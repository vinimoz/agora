(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode(`@charset "UTF-8";
.create-dialog {
  background-color: var(--color-main-background);
  padding: 8px 20px;
}
.create-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}
.agora-navigation__header {
  padding: 12px;
  border-bottom: 1px solid var(--color-border);
}
.agora-navigation__new-btn {
  width: 100%;
  justify-content: center;
}
.agora-navigation__section {
  margin-top: 12px;
}
.agora-navigation__section-title {
  font-size: 0.8rem;
  font-weight: 600;
  text-transform: uppercase;
  color: var(--color-text-lighter);
  margin: 0 12px 8px;
  letter-spacing: 0.5px;
}
.agora-navigation__group-item, .agora-navigation__filter-item {
  margin: 2px 8px;
  border-radius: 8px;
}
.agora-navigation__group-item:hover, .agora-navigation__filter-item:hover {
  background-color: var(--color-background-hover);
}
.agora-navigation__group-item.active, .agora-navigation__filter-item.active {
  background-color: var(--color-primary-light);
}
.agora-navigation__group-item.active .app-navigation-entry__title, .agora-navigation__filter-item.active .app-navigation-entry__title {
  font-weight: 600;
}
.agora-navigation__counter {
  font-weight: 600;
}
.agora-navigation__sub-list {
  margin-left: 12px;
  border-left: 1px solid var(--color-border);
}
.agora-navigation__empty {
  opacity: 0.7;
  font-style: italic;
}
.agora-navigation__view-all {
  color: var(--color-primary);
  font-weight: 500;
}
.agora-navigation__view-all:hover {
  color: var(--color-primary-text);
}
.agora-navigation__footer {
  border-top: 1px solid var(--color-border);
  padding: 8px 0;
}
.agora-navigation__footer-item {
  margin: 0 8px;
  border-radius: 8px;
}
.agora-navigation__footer-item:hover {
  background-color: var(--color-background-hover);
}
.app-agora .app-navigation__body {
  overflow: revert;
}
.app-agora .app-navigation-entry-icon, .app-agora .app-navigation-entry__title {
  transition: opacity 0.2s ease;
}
.app-agora .app-navigation-entry.active .app-navigation-entry-icon,
.app-agora .app-navigation-entry.active .app-navigation-entry__title {
  opacity: 1;
}
.closed .app-navigation-entry-icon,
.closed .app-navigation-entry__title {
  opacity: 0.6;
}
.app-navigation-entry-wrapper.force-not-active .app-navigation-entry.active {
  background-color: transparent !important;
}
.app-navigation-entry-wrapper.force-not-active .app-navigation-entry.active * {
  color: unset !important;
}.avatar-wrapper {
  position: relative;
  display: flex;
}
.avatar-wrapper .type-icon {
  position: absolute;
  background-size: 16px;
  top: -6px;
  inset-inline-start: -6px;
}
.user-item {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-around;
  padding: 4px;
  max-width: 100%;
}
.user-item.disabled {
  opacity: 0.6;
}
.hover-menu {
  position: absolute;
  top: 0;
  inset-inline-start: 0;
  opacity: 0;
}
.hover-menu:hover {
  opacity: 1;
}
.user-item__avatar .material-design-icon {
  background-color: var(--color-primary-element);
  border-radius: 50%;
  color: var(--color-primary-element-text);
}
.user-item__name {
  flex: 1;
  min-width: 50px;
  padding-inline-start: 8px;
  white-space: nowrap;
}
.user-item__name > div {
  overflow: hidden;
  text-overflow: ellipsis;
}
.user-item__name .description {
  color: var(--color-text-maxcontrast);
  font-size: 0.7em;
}
.condensed.user-item {
  flex-direction: column;
  justify-content: center;
  max-width: 70px;
}
.condensed .user-item__name {
  font-size: 0.7em;
  text-align: center;
  width: 70px;
  max-width: 70px;
  padding: 0 4px;
}.combo-title {
  margin-bottom: 16px;
}
.combo-table {
  display: flex;
  flex: 1;
}
.combo-table .spacer {
  flex: 1;
}
.combo-table .inquiry-group {
  display: flex;
  flex-direction: column;
}
.combo-table .participant,
.combo-table .inquiry-item {
  flex: 0 0 auto;
  height: 4.5em;
  line-height: 1.5em;
  padding: 4px;
  border-top: solid 1px var(--color-border-dark);
}
.combo-table .user-column {
  display: flex;
  flex-direction: column;
  overflow-x: scroll;
  margin-bottom: 4px;
}
.combo-table .user-column .participant {
  display: flex;
  max-width: 245px;
}
.combo-table .inquiry-grid {
  display: flex;
  flex: 1;
  overflow-x: scroll;
}
.combo-table .user-column::after,
.combo-table .inquiry-column::after {
  content: "";
  height: 8px;
}.material-design-icon.delete-icon, .material-design-icon.undo-icon {
  cursor: pointer;
}
.material-design-icon.delete-icon:hover {
  color: var(--color-error-hover);
}
.material-design-icon.arrow-u-left-top-icon {
  /* force the undo icon always to be visible */
  visibility: visible !important;
}
.section__optin a {
  text-decoration: underline;
}
.modal__registration {
  display: flex;
  flex-wrap: wrap;
  overflow: hidden;
}
.modal__registration > div {
  display: flex;
  flex-direction: column;
  flex: 1 auto;
  min-width: 140px;
  padding: 24px;
  border-top: 1px solid;
  border-inline-end: 1px solid;
  margin-top: -2px;
  margin-inline-end: -2px;
}
.modal__registration > div > button {
  margin: 8px 0;
}
.modal__registration .registration__login {
  flex: 1 180px;
}
.modal__registration .registration__registration {
  flex: 1 480px;
}
[class*=section__] {
  margin: 4px 0;
}
.modal__content .enter__name,
.modal__content .enter__email {
  margin-bottom: 12px;
}
.legal_links a {
  color: var(--color-text-maxcontrast);
  font-weight: bold;
  white-space: nowrap;
  padding: 10px;
  margin: -10px;
}
.legal_links a:hover, .legal_links a:active {
  color: var(--color-main-text);
}
.legal_links a:hover::after, .legal_links a:active::after {
  color: var(--color-text-maxcontrast);
}
.legal_links a:after {
  content: "Â·";
  padding: 0 4px;
}
.legal_links a:last-child:after {
  content: "";
}.modal-confirmation-result {
  padding: 24px;
}
.modal-confirmation-result ul {
  list-style: initial;
}
.modal-confirmation-result .sent-confirmations,
.modal-confirmation-result .error-confirmations {
  padding: 12px;
}.inquiry-item.list-view {
  display: flex;
  column-gap: 0.5rem;
  align-items: center;
  padding: 0.5rem;
  border-radius: 8px;
  border-bottom: 1px solid var(--color-border);
  margin-bottom: 0.25rem;
  transition: all 0.2s ease;
}
.inquiry-item.list-view:hover {
  background-color: var(--color-background-hover);
}
.inquiry-item.list-view.active {
  background-color: var(--color-primary-element-light);
}
.inquiry-item.list-view .item__type {
  flex: 0 0 2.5rem;
  display: flex;
  justify-content: center;
  align-items: center;
}
.inquiry-item.list-view .item__title {
  flex: 1;
  min-width: 0;
  overflow: hidden;
}
.inquiry-item.list-view .item__title .title_line,
.inquiry-item.list-view .item__title .description_line {
  display: flex;
  gap: 0.5rem;
  align-items: center;
}
.inquiry-item.list-view .item__title .title_line .title,
.inquiry-item.list-view .item__title .title_line .description,
.inquiry-item.list-view .item__title .description_line .title,
.inquiry-item.list-view .item__title .description_line .description {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.inquiry-item.list-view .item__title .title_line .title,
.inquiry-item.list-view .item__title .description_line .title {
  font-weight: 600;
  color: var(--color-main-text);
}
.inquiry-item.list-view .item__title .description_line {
  opacity: 0.7;
  font-size: 0.9rem;
  margin-top: 0.25rem;
}
.inquiry-item.list-view .item__title .description_line .description {
  flex: 1;
}
.inquiry-item.list-view .badges {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
  align-items: center;
  justify-content: flex-end;
}
.inquiry-item.list-view .badges .badge-bubble {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 4px 8px;
  font-size: 0.8rem;
  line-height: 1;
  min-height: 32px;
  min-width: 32px;
  transition: all 0.2s ease;
}
.inquiry-item.list-view .badges .badge-bubble.error {
  background-color: var(--color-error);
  color: white;
  border-color: var(--color-error);
}
.inquiry-item.list-view .badges .badge-bubble.warning {
  background-color: var(--color-warning);
  color: white;
  border-color: var(--color-warning);
}
.inquiry-item.list-view .badges .badge-bubble.success {
  background-color: var(--color-success);
  color: white;
  border-color: var(--color-success);
}
.inquiry-item.list-view .badges .badge-bubble.participated {
  background-color: var(--color-success);
  color: white;
  border-color: var(--color-success);
}
.inquiry-item.list-view .badges .badge-bubble .icon {
  margin-right: 0;
  display: flex;
  align-items: center;
}
.inquiry-item.list-view .badges .user-bubble__wrapper {
  line-height: normal;
  min-height: 1.6rem;
}
.inquiry-item.list-view .badges .user-bubble__wrapper.user-avatar {
  margin-left: -6px;
  margin-right: 2px;
}
.inquiry-item.list-view .actions {
  display: flex;
  flex: 0 0 auto;
  justify-content: center;
  align-items: center;
}
.inquiry-item.grid-view .grid-card {
  display: flex;
  flex-direction: column;
  height: 100%;
  padding: 12px;
  border: 1px solid var(--color-border);
  border-radius: 8px;
  background-color: var(--color-main-background);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
  transition: all 0.2s ease;
}
.inquiry-item.grid-view .grid-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.12);
  border-color: var(--color-primary-element);
}
.inquiry-item.grid-view .grid-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 12px;
  padding: 0 4px;
  min-height: 28px;
}
.inquiry-item.grid-view .grid-header .header-left {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
  flex: 1;
}
.inquiry-item.grid-view .grid-header .header-left .type-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-text-lighter);
  flex-shrink: 0;
}
.inquiry-item.grid-view .grid-header .header-left .status-badge {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 3px 8px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 600;
  white-space: nowrap;
  flex-shrink: 0;
}
.inquiry-item.grid-view .grid-header .header-left .status-badge.status--open {
  background-color: var(--color-success-light);
  color: var(--color-success);
}
.inquiry-item.grid-view .grid-header .header-left .status-badge.status--closed {
  background-color: var(--color-error-light);
  color: var(--color-error);
}
.inquiry-item.grid-view .grid-header .header-right {
  flex-shrink: 0;
  margin-left: 8px;
}
.inquiry-item.grid-view .grid-header .header-right .user-icon {
  width: 32px;
  height: 32px;
  flex-shrink: 0;
  margin-left: -8px;
}
.inquiry-item.grid-view .grid-content {
  flex: 1;
  margin-bottom: 12px;
  text-decoration: none;
  color: inherit;
}
.inquiry-item.grid-view .grid-content .grid-title {
  font-size: 15px;
  font-weight: 600;
  line-height: 1.4;
  margin: 0 0 8px 0;
  color: var(--color-main-text);
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.inquiry-item.grid-view .grid-content .grid-description {
  font-size: 13px;
  line-height: 1.5;
  color: var(--color-text-lighter);
  margin: 0;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
.inquiry-item.grid-view .grid-metadata {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-bottom: 12px;
  font-size: 12px;
  color: var(--color-text-maxcontrast);
}
.inquiry-item.grid-view .grid-metadata .metadata-item-time {
  margin-left: auto;
  display: flex;
  gap: 8px;
}
.inquiry-item.grid-view .grid-metadata .metadata-item {
  display: flex;
  align-items: center;
  gap: 4px;
  white-space: nowrap;
}
.inquiry-item.grid-view .grid-metadata .date-label {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 2px;
}
.inquiry-item.grid-view .grid-metadata .date-label .label-text {
  font-size: 10px;
  text-transform: lowercase;
  opacity: 0.8;
}
.inquiry-item.grid-view .grid-metadata .date-label .date-value {
  font-size: 11px;
  font-weight: 500;
}
.inquiry-item.grid-view .grid-actions {
  display: flex;
  justify-content: flex-end;
}
@media (max-width: 768px) {
.inquiry-item.grid-view .grid-card {
    padding: 10px;
}
.inquiry-item.grid-view .grid-header .header-left {
    gap: 4px;
}
.inquiry-item.grid-view .grid-header .header-left .status-badge {
    font-size: 10px;
    padding: 2px 6px;
}
.inquiry-item.grid-view .grid-header .header-right .user-icon {
    margin-left: -6px;
}
.inquiry-item.grid-view .grid-metadata {
    gap: 8px;
}
.inquiry-item.grid-view .grid-metadata .metadata-item {
    font-size: 11px;
}
}.inquiry-filters {
  margin-bottom: 10px;
  padding: 8px;
  background-color: var(--color-background-dark);
  border-radius: 12px;
  border: 1px solid var(--color-border);
}
.inquiry-filters .filters-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}
.inquiry-filters .filters-header .search-box.compact {
  position: relative;
  flex: 1;
  max-width: 300px;
}
.inquiry-filters .filters-header .search-box.compact .search-input {
  width: 100%;
  padding: 10px 12px 10px 36px;
  border: 1px solid var(--color-border);
  border-radius: 6px;
  font-size: 14px;
  background-color: var(--color-main-background);
  color: var(--color-main-text);
}
.inquiry-filters .filters-header .search-box.compact .search-input:focus {
  outline: none;
  border-color: var(--color-primary-element);
}
.inquiry-filters .filters-header .search-box.compact .search-icon {
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--color-text-lighter);
  font-size: 14px;
}
.inquiry-filters .filters-header .filters-toggle-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  background-color: var(--color-background-darker);
  border: 1px solid var(--color-border);
  border-radius: 6px;
  color: var(--color-text-lighter);
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}
.inquiry-filters .filters-header .filters-toggle-btn:hover {
  background-color: var(--color-background-hover);
  color: var(--color-main-text);
}
.inquiry-filters .filters-header .filters-toggle-btn.active {
  background-color: var(--color-primary-element);
  color: white;
  border-color: var(--color-primary-element);
}
.inquiry-filters .filters-header .filters-toggle-btn .filter-icon {
  font-size: 14px;
}
.inquiry-filters .filters-header .filters-toggle-btn .filter-count {
  background-color: var(--color-error);
  color: white;
  border-radius: 50%;
  width: 18px;
  height: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 11px;
  font-weight: 600;
}
.inquiry-filters .filters-header .filters-toggle-btn .toggle-arrow {
  margin-left: 4px;
  font-size: 12px;
}
.inquiry-filters .filters-header .reset-btn.compact {
  padding: 8px 12px;
  background-color: transparent;
  border: 1px solid var(--color-border);
  border-radius: 6px;
  color: var(--color-text-lighter);
  font-size: 13px;
  cursor: pointer;
}
.inquiry-filters .filters-header .reset-btn.compact:hover {
  background-color: var(--color-background-hover);
  color: var(--color-main-text);
}
.inquiry-filters .filters-expanded {
  margin-bottom: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--color-border-light);
}
.inquiry-filters .filters-expanded .filters-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
}
.inquiry-filters .filters-expanded .filters-grid .filter-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.inquiry-filters .filters-expanded .filters-grid .filter-group label {
  font-weight: 600;
  font-size: 12px;
  color: var(--color-text-lighter);
}
.inquiry-filters .filters-expanded .filters-grid .filter-group select {
  padding: 8px 10px;
  border: 1px solid var(--color-border);
  border-radius: 6px;
  background-color: var(--color-main-background);
  color: var(--color-main-text);
  font-size: 13px;
  cursor: pointer;
}
.inquiry-filters .filters-expanded .filters-grid .filter-group select:focus {
  outline: none;
  border-color: var(--color-primary-element);
}
.inquiry-filters .active-filters-summary {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 8px;
  padding-top: 16px;
  border-top: 1px solid var(--color-border-light);
}
.inquiry-filters .active-filters-summary .summary-label {
  font-weight: 600;
  font-size: 12px;
  color: var(--color-text-lighter);
}
.inquiry-filters .active-filters-summary .filter-tag {
  padding: 4px 8px;
  background-color: var(--color-primary-element);
  color: white;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 500;
}
@media (max-width: 1024px) {
.inquiry-filters .filters-header {
    flex-wrap: wrap;
}
.inquiry-filters .filters-header .search-box.compact {
    max-width: none;
    min-width: 200px;
}
.inquiry-filters .filters-expanded .filters-grid {
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
}
}
@media (max-width: 768px) {
.inquiry-filters {
    padding: 12px;
}
.inquiry-filters .filters-header {
    gap: 8px;
}
.inquiry-filters .filters-header .search-box.compact {
    min-width: 150px;
}
.inquiry-filters .filters-header .filters-toggle-btn {
    font-size: 12px;
    padding: 6px 10px;
}
.inquiry-filters .filters-header .reset-btn.compact {
    font-size: 12px;
    padding: 6px 10px;
}
.inquiry-filters .filters-expanded .filters-grid {
    grid-template-columns: 1fr;
    gap: 12px;
}
.inquiry-filters .active-filters-summary {
    flex-direction: column;
    align-items: flex-start;
    gap: 6px;
}
.inquiry-filters .active-filters-summary .summary-label {
    margin-bottom: 2px;
}
}
@media (max-width: 480px) {
.inquiry-filters .filters-header {
    flex-direction: column;
    align-items: stretch;
}
.inquiry-filters .filters-header .search-box.compact {
    max-width: none;
}
.inquiry-filters .filters-header .filters-toggle-btn,
  .inquiry-filters .filters-header .reset-btn.compact {
    justify-content: center;
}
}.multiselect {
  width: 100% !important;
  max-width: 100% !important;
  margin-top: 4px !important;
  margin-bottom: 4px !important;
}
.vs--single.vs--searching:not(.vs--open):not(.vs--loading) .vs__search {
  opacity: 1 !important;
}.inquiry-list .area__main {
  width: 100%;
}
.inquiry-list__container {
  width: 100%;
  padding-bottom: 14px;
  box-sizing: border-box;
}
.inquiry-list__list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}
.inquiry-list__grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  padding: 16px;
  width: 100%;
  box-sizing: border-box;
  align-items: stretch;
}
.inquiry-list__grid .inquiry-item {
  border: 1px solid var(--color-border);
  border-radius: 12px;
  padding: 10px;
  background-color: var(--color-main-background);
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
  transition: all 0.2s ease;
  height: 100%;
  min-height: 80px;
  display: flex;
  flex-direction: column;
}
.inquiry-list__grid .inquiry-item:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
}
.inquiry-list__grid .inquiry-item .inquiry-item__header {
  margin-bottom: 16px;
  flex-grow: 1;
}
.inquiry-list__grid .inquiry-item .inquiry-item__header .inquiry-item__title {
  font-size: 16px;
  font-weight: 600;
  line-height: 1.4;
  margin-bottom: 12px;
  color: var(--color-main-text);
  word-break: break-word;
}
.inquiry-list__grid .inquiry-item .inquiry-item__meta {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 16px;
  font-size: 13px;
  color: var(--color-text-lighter);
}
.inquiry-list__grid .inquiry-item .inquiry-item__meta .meta-item {
  display: flex;
  align-items: center;
  gap: 6px;
}
.inquiry-list__grid .inquiry-item .inquiry-item__meta .meta-item .material-design-icon {
  width: 16px;
  height: 16px;
  flex-shrink: 0;
}
.inquiry-list__grid .inquiry-item .inquiry-item__actions {
  margin-top: auto;
  padding-top: 16px;
  border-top: 1px solid var(--color-border-light);
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}
@media (max-width: 1400px) {
.inquiry-list__grid {
    grid-template-columns: repeat(3, 1fr);
}
}
@media (max-width: 1024px) {
.inquiry-list__grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 16px;
    padding: 12px;
}
}
@media (max-width: 768px) {
.inquiry-list__grid {
    grid-template-columns: 1fr;
    gap: 12px;
    padding: 8px;
}
.inquiry-list__grid .inquiry-item {
    padding: 16px;
    min-height: 160px;
}
}
.observer_section {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 20px 0;
  grid-column: 1/-1;
  width: 100%;
}
.clickable_load_more {
  cursor: pointer;
  font-weight: 600;
  text-align: center;
  padding: 20px;
  background-color: var(--color-background-dark);
  border-radius: 12px;
  margin: 0 16px;
  color: var(--color-text-lighter);
  transition: background-color 0.2s ease;
}
.clickable_load_more:hover {
  background-color: var(--color-background-darker);
  color: var(--color-main-text);
}
.app-content {
  width: 100%;
}
.app-content .app-content-wrapper {
  width: 100%;
  max-width: none;
}
@media (min-width: 1600px) {
.inquiry-list__grid {
    grid-template-columns: repeat(4, 1fr);
}
}.type-label {
  color: var(--color-primary);
  display: flex;
  font-size: 1rem;
  font-weight: 800;
}
.inquiry-info-line {
  display: flex;
  flex-wrap: wrap;
  opacity: 0.7;
  font-size: 1em;
  justify-content: space-between;
  align-items: center;
  width: 100%;
}
.inquiry-info-line .inquiry-type-status {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 4px;
  font-weight: bold;
}
.inquiry-info-line .inquiry-type-status .type-icon {
  margin-bottom: 4px;
}
.inquiry-info-line .inquiry-type-status .status-label {
  font-weight: 600;
  font-size: 0.9em;
  text-align: center;
}
.inquiry-info-line .inquiry-type-status .status-badge {
  display: flex;
  align-items: center;
  gap: 6px;
}
.inquiry-info-line .material-design-icon {
  padding: 0 2px;
}
.inquiry-info-line .subtexts-left {
  display: flex;
  align-items: center;
  gap: 8px;
}
.inquiry-info-line .subtexts-left .sub-text {
  display: flex;
  align-items: center;
  gap: 4px;
}
.inquiry-info-line > span:not(:last-child)::after {
  content: "|";
  padding: 0 2px;
}
.inquiry-info-line .closed .sub-text,
.inquiry-info-line .archived .sub-text {
  color: var(--color-error);
  font-weight: 700;
}
.inquiry-info-line .unpublished .sub-text,
.inquiry-info-line .open .sub-text {
  font-weight: 700;
}
.inquiry-info-line .closing .sub-text {
  color: var(--color-warning);
  font-weight: 700;
}
.inquiry-info-line .created .sub-text {
  color: var(--color-main-text);
}.inquiry-header-buttons {
  display: flex;
  flex: 0;
  justify-content: flex-end;
  align-self: flex-end;
  border-radius: var(--border-radius-pill);
}
.icon.icon-settings.active {
  display: block;
  width: 44px;
  height: 44px;
}
/* Container principal */
.editor-container[data-v-0d9f3682] {
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;
}
.editor-content[data-v-0d9f3682] {
  flex: 1;
  min-height: 300px;
  padding: 1rem;
  outline: none;
}
.editor-toolbar[data-v-0d9f3682] {
  padding: 0.5rem;
  background: #f5f5f5;
  border-bottom: 1px solid #ddd;
  display: flex;
  flex-wrap: wrap;
  gap: 0.25rem;
}
.editor-content-wrapper[data-v-0d9f3682] {
  flex: 1;
  overflow: auto;
  border: 1px solid #e2e8f0;
}
.tiptap-editor[data-v-0d9f3682] {
  height: 100%;
  width: 100%;
  min-height: 100%;
  display: block;
}
.tiptap-editor-content[data-v-0d9f3682] {
  height: 100% !important;
  width: 100% !important;
  padding: 1rem;
  outline: none;
}
.ProseMirror[data-v-0d9f3682] {
  height: 100% !important;
  min-height: 100% !important;
  padding: 1rem;
}
.ProseMirror-focused[data-v-0d9f3682] {
  outline: none;
}
.finalize-form-container[data-v-9e316df6] {
  padding: 10px;
  background: var(--color-main-background);
  border-radius: var(--border-radius-large);
}
.form-container[data-v-9e316df6] {
  flex-grow: 1;
  min-height: 200px;
  border: 1px solid #e2e8f0;
  border-radius: 0.5rem;
  background: var(--color-main-background);
  padding: 1rem;
  overflow: hidden;
}
.form-section.expanded .form-container[data-v-9e316df6] {
  height: 500px;
}
.form-section:not(.expanded) .form-container[data-v-9e316df6] {
  height: 300px;
}
.inline[data-v-9e316df6] {
  display: inline;
  margin: 0;
  padding: 0;
}
.top-block[data-v-9e316df6] {
  display: inline-block;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  gap: 1rem;
  background: var(--color-background-dark);
  border-radius: var(--border-radius-large);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}
.date-info[data-v-9e316df6] {
  display: flex;
  gap: 1.5rem;
  font-size: 0.85rem;
}
.date-item[data-v-9e316df6] {
  display: flex;
  align-items: center;
}
.date-label[data-v-9e316df6] {
  color: var(--color-primary);
  font-weight: 500;
  margin-right: 4px;
}
.date-value[data-v-9e316df6] {
  color: var(--color-text-lighter);
}
.action-buttons[data-v-9e316df6] {
  display: flex;
  gap: 0.5rem;
  align-items: center;
  justify-content: flex-start;
}
.action-buttons[data-v-9e316df6] > :last-child {
  margin-left: auto;
}
.save-button[data-v-9e316df6] {
  background-color: var(--color-primary);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: var(--border-radius);
  font-weight: 500;
}
.response-button[data-v-9e316df6] {
  background-color: var(--color-primary);
  border-radius: var(--border-radius);
  color: white;
  border: none;
  padding: 8px 16px;
  font-weight: 500;
}
.actions-menu[data-v-9e316df6] {
  margin-left: 10px;
}
.inquiry-form[data-v-9e316df6] {
  display: flex;
  flex-direction: column;
  gap: 2rem;
}
.form-section[data-v-9e316df6] {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 1.5rem;
  background: var(--color-background-dark);
  border-radius: var(--border-radius-large);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}
.title-section[data-v-9e316df6] {
  color: var(--color-primary);
  display: flex;
  font-size: 1rem;
  font-weight: 800;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  flex-grow: 1;
}
.title-content[data-v-9e316df6] {
  flex-grow: 1;
}
.title-content .form-input[data-v-9e316df6] {
  width: 100%;
  max-width: 500px;
}
.section-title[data-v-9e316df6] {
  color: var(--color-primary);
  display: flex;
  font-size: 1rem;
  font-weight: 800;
  display: inline-block;
  margin: 0;
  padding: 0;
  flex-wrap: wrap;
}
.section-header[data-v-9e316df6] {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  gap: 1rem;
}
.type-display[data-v-9e316df6] {
  display: flex;
  align-items: center;
  gap: 8px;
}
.type-icon[data-v-9e316df6] {
  width: 24px;
  height: 24px;
  color: var(--color-primary);
}
.type-label[data-v-9e316df6] {
  font-weight: 600;
  color: var(--color-primary);
  text-transform: capitalize;
}
.counters[data-v-9e316df6] {
  display: flex;
  gap: 1.5rem;
}
.counter-item[data-v-9e316df6] {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
}
.counter-item span[data-v-9e316df6] {
  font-weight: bold;
}
.form-row[data-v-9e316df6] {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}
.form-row.double-columns[data-v-9e316df6] {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
}
@media (max-width: 600px) {
.form-row.double-columns[data-v-9e316df6] {
    grid-template-columns: 1fr;
}
}
.form-field[data-v-9e316df6] {
  width: 100%;
}
.form-input[data-v-9e316df6] {
  width: 500px;
}
.readonly-value[data-v-9e316df6] {
  padding: 8px;
  background: var(--color-background-darker);
  border-radius: var(--border-radius);
  font-size: 0.9rem;
}

/* Select field adjustments */
.select-field[data-v-9e316df6] {
  width: 100%;
}
.select-field.narrow-select[data-v-9e316df6] {
  max-width: 200px;
}
.link-section[data-v-9e316df6] {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}
.link-button[data-v-9e316df6] {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  min-width: max-content;
  padding: 8px 12px;
}
.html-content[data-v-9e316df6] {
  padding: 16px;
  background: var(--color-background-darker);
  border-radius: var(--border-radius);
  border: 1px solid var(--color-border);
}
.debate-integration[data-v-9e316df6] {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
}
.integration-button[data-v-9e316df6] {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 8px 12px;
}
@media (max-width: 600px) {
.top-block[data-v-9e316df6] {
    flex-direction: column;
    align-items: stretch;
}
.date-info[data-v-9e316df6] {
    flex-direction: column;
    gap: 0.5rem;
}
.action-buttons[data-v-9e316df6] {
    justify-content: flex-end;
    width: 100%;
    margin-top: 10px;
}
.section-header[data-v-9e316df6] {
    flex-direction: column;
    align-items: flex-start;
}
.counters[data-v-9e316df6] {
    width: 100%;
    justify-content: space-between;
}
.link-section[data-v-9e316df6],
  .debate-integration[data-v-9e316df6] {
    flex-direction: column;
    align-items: stretch;
}
.link-button[data-v-9e316df6],
  .integration-button[data-v-9e316df6] {
    width: 100%;
}
.select-field.narrow-select[data-v-9e316df6] {
    max-width: 100%;
}
.loading-icon[data-v-9e316df6] {
    display: inline-block;
    animation: spin-9e316df6 1s linear infinite;
    margin-right: 8px;
}
@keyframes spin-9e316df6 {
from {
      transform: rotate(0deg);
}
to {
      transform: rotate(360deg);
}
}
}.transition-form-container[data-v-9857c039] {
  padding: 10px;
  background: var(--color-main-background);
  border-radius: var(--border-radius-large);
}
.loading-container[data-v-9857c039] {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 70vh;
}
.loading-container .loading-spinner[data-v-9857c039] {
  width: 50px;
  height: 50px;
  border: 5px solid var(--color-background-darker);
  border-top: 5px solid var(--color-primary);
  border-radius: 50%;
  animation: spin-9857c039 1s linear infinite;
  margin-bottom: 1rem;
}
.loading-container p[data-v-9857c039] {
  color: var(--color-text-lighter);
}

/* Transition effects */
.fade-enter-active[data-v-9857c039],
.fade-leave-active[data-v-9857c039] {
  transition: opacity 0.3s ease;
}
.fade-enter-from[data-v-9857c039],
.fade-leave-to[data-v-9857c039] {
  opacity: 0;
}
.list-move[data-v-9857c039],
.list-enter-active[data-v-9857c039],
.list-leave-active[data-v-9857c039] {
  transition: all 0.5s ease;
}
.list-enter-from[data-v-9857c039],
.list-leave-to[data-v-9857c039] {
  opacity: 0;
  transform: translateX(30px);
}
.list-leave-active[data-v-9857c039] {
  position: absolute;
}
.list-inner-move[data-v-9857c039] {
  transition: all 0.3s ease;
}
@keyframes spin-9857c039 {
0% {
    transform: rotate(0deg);
}
100% {
    transform: rotate(360deg);
}
}
.navigation-controls[data-v-9857c039] {
  display: flex;
  justify-content: flex-end;
  margin-bottom: 1.5rem;
}
.navigation-controls .back-button[data-v-9857c039],
.navigation-controls .home-button[data-v-9857c039] {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 8px 16px;
  background: var(--color-background-dark);
  border-radius: var(--border-radius);
}
.navigation-controls .back-button[data-v-9857c039]:hover,
.navigation-controls .home-button[data-v-9857c039]:hover {
  background: var(--color-primary-element-light);
}
.block-container[data-v-9857c039] {
  display: flex;
  flex-direction: column;
  gap: 1.2rem;
  margin-bottom: 2rem;
}
.block-container.parent-block[data-v-9857c039] {
  margin-bottom: 2rem;
}
.parent-block[data-v-9857c039] .inquiry-item.list-view {
  min-height: 180px !important;
  align-items: center;
}
.parent-block[data-v-9857c039] .inquiry-item.grid-view .grid-card {
  min-height: 250px !important;
}
.block-title[data-v-9857c039] {
  margin: 0;
  color: var(--color-primary);
  font-weight: 600;
  font-size: 1.3rem;
  text-align: center;
}
.divider[data-v-9857c039] {
  height: 2px;
  background: var(--color-border);
  width: 100%;
  margin: 0.5rem 0;
}
.children-blocks[data-v-9857c039] {
  display: flex;
  flex-direction: column;
  gap: 2rem;
  margin-bottom: 2rem;
}
.inquiry-list__grid[data-v-9857c039] {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  padding: 16px;
  width: 100%;
  box-sizing: border-box;
  align-items: stretch;
}
.inquiry-list__list[data-v-9857c039] {
  display: flex;
  flex-direction: column;
  gap: 12px;
  width: 100%;
}
.official-block[data-v-9857c039] {
  margin-top: 2rem;
  padding-top: 1rem;
  border-top: 2px solid var(--color-border);
}

/* Mobile styles */
@media (max-width: 768px) {
.transition-form-container[data-v-9857c039] {
    padding: 1rem;
}
.navigation-controls[data-v-9857c039] {
    position: sticky;
    top: 0;
    z-index: 100;
    background: var(--color-main-background);
    padding: 0.8rem 0.5rem;
    margin: -0.5rem -0.5rem 1rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}
.children-blocks[data-v-9857c039] {
    gap: 1.8rem;
}
.inquiry-list__grid[data-v-9857c039] {
    grid-template-columns: 1fr;
    gap: 16px;
    padding: 12px;
}
}
@media (max-width: 1024px) {
.inquiry-list__grid[data-v-9857c039] {
    grid-template-columns: repeat(2, 1fr);
}
}
@media (max-width: 1400px) {
.inquiry-list__grid[data-v-9857c039] {
    grid-template-columns: repeat(3, 1fr);
}
}
@media (min-width: 1600px) {
.inquiry-list__grid[data-v-9857c039] {
    grid-template-columns: repeat(4, 1fr);
}
}.optionAdd {
  display: flex;
}
.newOption {
  margin-inline-start: 40px;
  flex: 1;
}
.newOption:empty:before {
  color: grey;
}
.submit-option {
  width: 30px;
  background-color: transparent;
  border: none;
  opacity: 0.3;
  cursor: pointer;
}span[data-v-9dcb7d86]::after {
  content: " ";
}.inquiry-info-cards[data-v-e010057f] {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  justify-content: center;
}
.inquiry-info-cards[data-v-e010057f] > * {
  flex: 1;
}
.inquiry-info-cards .notecard[data-v-e010057f] {
  margin: unset;
  flex: 1 calc(var(--cap-width) / 2);
  max-width: var(--cap-width);
}.type-display {
  display: flex;
  align-items: center;
  gap: 8px;
}
.type-display .type-icon {
  flex-shrink: 0;
}
.type-display .type-label {
  font-weight: bold;
  text-transform: capitalize;
}
.header-left-content {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  padding-top: 8px;
  width: 100%;
}
.dates-container {
  display: flex;
  gap: 16px;
  align-items: center;
  flex-wrap: wrap;
  justify-content: flex-end;
}
@media (max-width: 1000px) {
.dates-container {
    gap: 8px;
}
.dates-container .metadata-item {
    font-size: 0.8em;
}
}
.header-right-content {
  display: flex;
  align-items: center;
  gap: 16px;
  flex-wrap: wrap;
  justify-content: flex-end;
}
.dates-container {
  display: flex;
  gap: 20px;
  align-items: center;
  justify-content: flex-end;
  flex-shrink: 0;
  margin-right: 16px;
}
.metadata-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.9em;
  color: var(--color-text-lighter);
  white-space: nowrap;
}
.date-label {
  white-space: nowrap;
}
.inquiry-list__list {
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: scroll;
  padding-bottom: 14px;
}
.observer_section {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 14px 0;
}
.clickable_load_more {
  cursor: pointer;
  font-weight: bold;
}
#expiring.closing {
  color: var(--color-warning);
  font-weight: bold;
}
#expiring.open {
  color: var(--color-text-lighter);
}.activity-item {
  display: flex;
  align-items: start;
  margin-bottom: 24px;
}
.activity-item__date {
  opacity: 0.5;
  font-size: 0.8em;
  text-align: end;
}
.activity-item__date::before {
  content: " ~ ";
}
.activity-item__content {
  margin-inline-start: 8px;
  flex: 1 1;
  padding-top: 2px;
}.sidebar-attachments[data-v-e8872216] {
  padding: var(--default-grid-baseline);
  height: 100%;
  display: flex;
  flex-direction: column;
  gap: var(--default-grid-baseline);
}
.sidebar-attachments .sidebar-header[data-v-e8872216] {
  margin-bottom: var(--default-grid-baseline);
  border-bottom: 1px solid var(--color-border);
  padding-bottom: var(--default-grid-baseline);
}
.sidebar-attachments .attachment-upload[data-v-e8872216] {
  margin-bottom: var(--default-grid-baseline);
}
.sidebar-attachments .attachment-upload .hidden[data-v-e8872216] {
  display: none;
}
.sidebar-attachments .attachments-list[data-v-e8872216] {
  flex-grow: 1;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: calc(var(--default-grid-baseline) / 2);
}
.sidebar-attachments .attachments-list .empty-state[data-v-e8872216] {
  text-align: center;
  color: var(--color-text-lighter);
  padding: calc(var(--default-grid-baseline) * 2);
}
.sidebar-attachments .attachments-list .attachment-item[data-v-e8872216] {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--default-grid-baseline);
}
.sidebar-attachments .attachments-list .attachment-item .attachment-info[data-v-e8872216] {
  display: flex;
  align-items: center;
  flex-grow: 1;
  min-width: 0;
  overflow: hidden;
}
.sidebar-attachments .attachments-list .attachment-item .attachment-name[data-v-e8872216] {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 70%;
}
.sidebar-attachments .attachments-list .attachment-item .file-icon[data-v-e8872216] {
  flex-shrink: 0;
  color: var(--color-text-lighter);
}
.sidebar-attachments .attachments-list .attachment-item .attachment-size[data-v-e8872216] {
  margin-left: auto;
  color: var(--color-text-lighter);
  font-size: 0.8em;
}.comment-add {
  margin-bottom: 24px;
  display: flex;
}
.comment-add .user-item {
  align-items: first baseline;
}
.comment-add .comment-add__input {
  margin-inline-start: 8px;
  flex: 1;
  align-items: center;
}.comment-item {
  display: flex;
  align-items: start;
  margin-bottom: 24px;
}
.comment-item__user {
  font-weight: 600;
  font-size: 0.9em;
}
.comment-item__date {
  opacity: 0.5;
  font-size: 0.8em;
  text-align: end;
}
.comment-item__date::before {
  content: " ~ ";
}
.comment-item__confidential {
  opacity: 0.5;
  font-size: 0.8em;
  text-align: end;
}
.comment-item__confidential::before {
  content: " (";
}
.comment-item__confidential::after {
  content: ") ";
}
.comment-item__content {
  margin-inline-start: 8px;
  flex: 1 1;
  padding-top: 2px;
}
.comment-item__content .material-design-icon {
  visibility: hidden;
}
.comment-item__content .comment-item__sub-comment {
  display: flex;
  align-items: center;
}
.comment-item__content .comment-item__sub-comment:hover {
  background: var(--color-background-hover);
}
.comment-item__content .comment-item__sub-comment:hover .material-design-icon {
  visibility: visible;
}
.comment-item__content .comment-item__sub-comment > span {
  hyphens: auto;
  flex: 1;
}
.comment-item__content .comment-item__sub-comment > span a {
  text-decoration-line: underline;
}
.comment-item__content .comment-item__sub-comment.deleted {
  opacity: 0.6;
}
.comment-item__content .comment-item__sub-comment.deleted > span::after {
  content: var(--content-deleted);
  font-weight: bold;
  color: var(--color-error-text);
}
.alternativestyle .comment-item {
  flex-direction: row-reverse;
}
.alternativestyle .comment-item.current-user {
  flex-direction: row;
}
.alternativestyle .comment-item__content {
  border: solid 1px var(--color-primary-element-light);
  border-radius: var(--border-radius-large);
  background-color: var(--color-primary-element-light);
  box-shadow: 2px 2px 6px var(--color-box-shadow);
  padding-inline-start: 8px;
  padding-bottom: 10px;
}
.alternativestyle .comment-item__content .comment-item__sub-comment {
  margin-inline-end: 4px;
}
.alternativestyle .comment-item__content .comment-item__sub-comment:hover {
  background: var(--color-primary-element-hover);
  color: var(--color-primary-element-light-hover);
  margin-inline-start: -4px;
  padding-inline-start: 4px;
  border-radius: var(--border-radius-large);
}.deleted .user-item .description {
  color: var(--color-error-text);
}
.inquiry-status {
  margin-inline-start: 8px;
  width: 32px;
}
.inquiry-status.support {
  color: var(--color-inquiries-foreground-yes);
}
.inquiry-status.support {
  color: var(--color-inquiries-foreground-no);
}.deleted .user-item .description {
  color: var(--color-error-text);
}
.support-status {
  margin-inline-start: 8px;
  width: 32px;
}
.support-status.supported {
  color: var(--color-inquiries-foreground-yes);
}
.support-status.unsupported {
  color: var(--color-inquiries-foreground-no);
}.shares-list.shared {
  border-top: 1px solid var(--color-border);
  padding-top: 24px;
  margin-top: 16px;
}.sidebar-share {
  display: flex;
  flex-direction: column;
}
.shares-list {
  display: flex;
  flex-flow: column;
  justify-content: flex-start;
  padding-top: 8px;
}
.shares-list > li {
  display: flex;
  align-items: stretch;
  margin: 4px 0;
}
.share-item {
  display: flex;
  flex: 1;
  align-items: center;
  max-width: 100%;
}
.share-item__description {
  flex: 1;
  min-width: 50px;
  color: var(--color-text-maxcontrast);
  padding-inline-start: 8px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}.markdown-description {
  overflow: auto;
}
.markdown-description * {
  margin: revert;
  font-size: revert;
  text-decoration: revert;
  list-style: inside;
}
.markdown-description table {
  border-spacing: 2px;
}
.markdown-description thead {
  background-color: var(--color-background-darker);
  color: var(--color-main-text);
}
.markdown-description td,
.markdown-description th {
  padding: 1px 4px;
}.shares-list.shared {
  border-top: 1px solid var(--color-border);
  padding-top: 24px;
  margin-top: 16px;
}.sidebar-share {
  display: flex;
  flex-direction: column;
}
.shares-list {
  display: flex;
  flex-flow: column;
  justify-content: flex-start;
  padding-top: 8px;
}
.shares-list > li {
  display: flex;
  align-items: stretch;
  margin: 4px 0;
}
.share-item {
  display: flex;
  flex: 1;
  align-items: center;
  max-width: 100%;
}
.share-item__description {
  flex: 1;
  min-width: 50px;
  color: var(--color-text-maxcontrast);
  padding-inline-start: 8px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.input-textarea[data-v-ac210d66] {
  width: 99%;
  resize: vertical;
}
.edit-inquiry-group {
  background-color: var(--color-main-background);
  padding: 8px 20px;
}
.edit-inquiry-group .create-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}
.edit-inquiry-group .input-textarea {
  width: 99%;
  resize: vertical;
}
.edit-inquiry-group .helper {
  min-height: 1.5rem;
  font-size: 0.8em;
  opacity: 0.8;
}/*!
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
.toastify.dialogs {
  min-width: 200px;
  background: none;
  background-color: var(--color-main-background);
  color: var(--color-main-text);
  box-shadow: 0 0 6px 0 var(--color-box-shadow);
  padding: 0 12px;
  margin-top: 45px;
  position: fixed;
  z-index: 10100;
  border-radius: var(--border-radius);
  display: flex;
  align-items: center;
  min-height: 50px;
}
.toastify.dialogs .toast-loader-container,
.toastify.dialogs .toast-undo-container {
  display: flex;
  align-items: center;
  width: 100%;
}
.toastify.dialogs .toast-undo-button,
.toastify.dialogs .toast-close {
  position: static;
  overflow: hidden;
  box-sizing: border-box;
  min-width: 44px;
  height: 100%;
  padding: 12px;
  white-space: nowrap;
  background-repeat: no-repeat;
  background-position: center;
  background-color: transparent;
  min-height: 0;
}
.toastify.dialogs .toast-undo-button.toast-close,
.toastify.dialogs .toast-close.toast-close {
  text-indent: 0;
  opacity: 0.4;
  border: none;
  min-height: 44px;
  margin-left: 10px;
  font-size: 0;
  /* dark theme overrides for Nextcloud 25 and later */
}
.toastify.dialogs .toast-undo-button.toast-close::before,
.toastify.dialogs .toast-close.toast-close::before {
  background-image: url("data:image/svg+xml,%3csvg%20viewBox='0%200%2016%2016'%20height='16'%20width='16'%20xmlns='http://www.w3.org/2000/svg'%20xml:space='preserve'%20style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2'%3e%3cpath%20d='M6.4%2019%205%2017.6l5.6-5.6L5%206.4%206.4%205l5.6%205.6L17.6%205%2019%206.4%2013.4%2012l5.6%205.6-1.4%201.4-5.6-5.6L6.4%2019Z'%20style='fill-rule:nonzero'%20transform='matrix(.85714%200%200%20.85714%20-2.286%20-2.286)'/%3e%3c/svg%3e");
  content: " ";
  filter: var(--background-invert-if-dark);
  display: inline-block;
  width: 16px;
  height: 16px;
}
.toastify.dialogs .toast-undo-button.toast-undo-button,
.toastify.dialogs .toast-close.toast-undo-button {
  margin: 3px;
  height: calc(100% - 2 * 3px);
  margin-left: 12px;
}
.toastify.dialogs .toast-undo-button:hover, .toastify.dialogs .toast-undo-button:focus, .toastify.dialogs .toast-undo-button:active,
.toastify.dialogs .toast-close:hover,
.toastify.dialogs .toast-close:focus,
.toastify.dialogs .toast-close:active {
  cursor: pointer;
  opacity: 1;
}
.toastify.dialogs.toastify-top {
  right: 10px;
}
.toastify.dialogs.toast-with-click {
  cursor: pointer;
}
.toastify.dialogs.toast-error {
  border-left: 3px solid var(--color-error);
}
.toastify.dialogs.toast-info {
  border-left: 3px solid var(--color-primary);
}
.toastify.dialogs.toast-warning {
  border-left: 3px solid var(--color-warning);
}
.toastify.dialogs.toast-success {
  border-left: 3px solid var(--color-success);
}
.toastify.dialogs.toast-undo {
  border-left: 3px solid var(--color-success);
}
.toastify.dialogs.toast-loading {
  border-left: 3px solid var(--color-primary);
}
.toastify.dialogs.toast-loading .toast-loader {
  display: inline-block;
  width: 20px;
  height: 20px;
  animation: rotate var(--animation-duration, 0.8s) linear infinite;
  margin-left: auto;
}

/* dark theme overrides for Nextcloud 24 and earlier */
.theme--dark .toastify.dialogs .toast-close {
  /* close icon style */
}
.theme--dark .toastify.dialogs .toast-close.toast-close::before {
  background-image: url("data:image/svg+xml,%3csvg%20viewBox='0%200%2016%2016'%20height='16'%20width='16'%20xmlns='http://www.w3.org/2000/svg'%20xml:space='preserve'%20style='fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2'%3e%3cpath%20d='M6.4%2019%205%2017.6l5.6-5.6L5%206.4%206.4%205l5.6%205.6L17.6%205%2019%206.4%2013.4%2012l5.6%205.6-1.4%201.4-5.6-5.6L6.4%2019Z'%20style='fill:%23fff;fill-rule:nonzero'%20transform='matrix(.85714%200%200%20.85714%20-2.286%20-2.286)'/%3e%3c/svg%3e");
}
.nc-generic-dialog .dialog__actions {
	justify-content: space-between;
	min-width: calc(100% - 12px);
}
/*!
 * SPDX-FileCopyrightText: 2023-2024 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * Icon styling of the file list row preview or fallback icon
 * (leading icon on the name row and header)
 */
._file-picker__file-icon_3v9zx_9 {
  position: relative;
  width: 32px;
  height: 32px;
  min-width: 32px;
  min-height: 32px;
  background-repeat: no-repeat;
  background-size: contain;
  display: flex;
  justify-content: center;
}

._file-picker__file-icon--primary_3v9zx_21 {
  color: var(--color-primary-element);
}

._file-picker__file-icon-overlay_3v9zx_25 {
  color: var(--color-primary-element-text);
  position: absolute;
  inset-block-start: 10px;
}/*!
 * SPDX-FileCopyrightText: 2023-2024 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
tr.file-picker__row[data-v-bfa2ae80] {
  height: var(--row-height, 50px);
}
tr.file-picker__row td[data-v-bfa2ae80] {
  cursor: pointer;
  overflow: hidden;
  text-overflow: ellipsis;
  border-bottom: none;
}
tr.file-picker__row td.row-checkbox[data-v-bfa2ae80] {
  padding: 0 2px;
}
tr.file-picker__row td[data-v-bfa2ae80]:not(.row-checkbox) {
  padding-inline: 14px 0;
}
tr.file-picker__row td.row-size[data-v-bfa2ae80] {
  text-align: end;
  padding-inline: 0 14px;
}
tr.file-picker__row td.row-name[data-v-bfa2ae80] {
  padding-inline: 2px 0;
}
.file-picker__row--selected[data-v-bfa2ae80] {
  background-color: var(--color-background-dark);
}
.file-picker__row[data-v-bfa2ae80]:hover {
  background-color: var(--color-background-hover);
}
.file-picker__name-container[data-v-bfa2ae80] {
  display: flex;
  justify-content: start;
  align-items: center;
  height: 100%;
}
.file-picker__file-name[data-v-bfa2ae80] {
  padding-inline-start: 6px;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
}
.file-picker__file-extension[data-v-bfa2ae80] {
  color: var(--color-text-maxcontrast);
  min-width: fit-content;
}/*!
 * SPDX-FileCopyrightText: 2023-2024 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
tr.file-picker__row[data-v-1f96131b] {
  height: var(--row-height, 50px);
}
tr.file-picker__row td[data-v-1f96131b] {
  cursor: pointer;
  overflow: hidden;
  text-overflow: ellipsis;
  border-bottom: none;
}
tr.file-picker__row td.row-checkbox[data-v-1f96131b] {
  padding: 0 2px;
}
tr.file-picker__row td[data-v-1f96131b]:not(.row-checkbox) {
  padding-inline: 14px 0;
}
tr.file-picker__row td.row-size[data-v-1f96131b] {
  text-align: end;
  padding-inline: 0 14px;
}
tr.file-picker__row td.row-name[data-v-1f96131b] {
  padding-inline: 2px 0;
}
@keyframes gradient-1f96131b {
0% {
    background-position: 0% 50%;
}
50% {
    background-position: 100% 50%;
}
100% {
    background-position: 0% 50%;
}
}
.loading-row .row-checkbox[data-v-1f96131b] {
  text-align: center !important;
}
.loading-row span[data-v-1f96131b] {
  display: inline-block;
  height: 24px;
  background: linear-gradient(to right, var(--color-background-darker), var(--color-text-maxcontrast), var(--color-background-darker));
  background-size: 600px 100%;
  border-radius: var(--border-radius);
  animation: gradient-1f96131b 12s ease infinite;
}
.loading-row .row-wrapper[data-v-1f96131b] {
  display: inline-flex;
  align-items: center;
}
.loading-row .row-checkbox span[data-v-1f96131b] {
  width: 24px;
}
.loading-row .row-name span[data-v-1f96131b]:last-of-type {
  margin-inline-start: 6px;
  width: 130px;
}
.loading-row .row-size span[data-v-1f96131b] {
  width: 80px;
}
.loading-row .row-modified span[data-v-1f96131b] {
  width: 90px;
}.file-picker__header-preview[data-v-149cddc3] {
  width: 22px;
  height: 32px;
  flex: 0 0 auto;
}
.file-picker__files[data-v-149cddc3] {
  margin: 2px;
  margin-inline-start: 12px;
  overflow: scroll auto;
}
.file-picker__files table[data-v-149cddc3] {
  width: 100%;
  max-height: 100%;
  table-layout: fixed;
}
.file-picker__files th[data-v-149cddc3] {
  position: sticky;
  z-index: 1;
  top: 0;
  background-color: var(--color-main-background);
  padding: 2px;
}
.file-picker__files th .header-wrapper[data-v-149cddc3] {
  display: flex;
}
.file-picker__files th.row-checkbox[data-v-149cddc3] {
  width: 44px;
}
.file-picker__files th.row-name[data-v-149cddc3] {
  width: 230px;
}
.file-picker__files th.row-size[data-v-149cddc3] {
  width: 100px;
}
.file-picker__files th.row-modified[data-v-149cddc3] {
  width: 120px;
}
.file-picker__files th[data-v-149cddc3]:not(.row-size) .button-vue__wrapper {
  justify-content: start;
  flex-direction: row-reverse;
}
.file-picker__files th[data-v-149cddc3]:not(.row-size) .button-vue {
  padding-inline: 16px 4px;
}
.file-picker__files th.row-size[data-v-149cddc3] .button-vue__wrapper {
  justify-content: end;
}
.file-picker__files th[data-v-149cddc3] .button-vue__wrapper {
  color: var(--color-text-maxcontrast);
}
.file-picker__files th[data-v-149cddc3] .button-vue__wrapper .button-vue__text {
  font-weight: normal;
}.file-picker__breadcrumbs[data-v-4e6fd4e4] {
  flex-grow: 0 !important;
}.file-picker__side[data-v-86223490] {
  display: flex;
  flex-direction: column;
  align-items: stretch;
  gap: 0.5rem;
  min-width: 200px;
  padding: 2px;
  margin-block-start: 7px;
  overflow: auto;
}
.file-picker__side[data-v-86223490] .button-vue__wrapper {
  justify-content: start;
}
.file-picker__filter-input[data-v-86223490] {
  margin-block: 7px;
  max-width: 260px;
}
@media (max-width: 736px) {
.file-picker__side[data-v-86223490] {
    flex-direction: row;
    min-width: unset;
}
}
@media (max-width: 512px) {
.file-picker__side[data-v-86223490] {
    flex-direction: row;
    min-width: unset;
}
.file-picker__filter-input[data-v-86223490] {
    max-width: unset;
}
}/* Ensure focus outline is visible */
.file-picker__navigation {
  padding-inline: 8px 2px;
}
.file-picker__navigation, .file-picker__navigation * {
  box-sizing: border-box;
}
.file-picker__navigation .v-select.select {
  min-width: 220px;
}
@media (min-width: 513px) and (max-width: 736px) {
.file-picker__navigation {
    gap: 11px;
}
}
@media (max-width: 512px) {
.file-picker__navigation {
    flex-direction: column-reverse !important;
}
}.file-picker__view[data-v-ce116f72] {
  height: 50px;
  display: flex;
  justify-content: start;
  align-items: center;
}
.file-picker__view h3[data-v-ce116f72] {
  font-weight: bold;
  height: fit-content;
  margin: 0;
}
.file-picker__main[data-v-ce116f72] {
  box-sizing: border-box;
  width: 100%;
  display: flex;
  flex-direction: column;
  min-height: 0;
  flex: 1;
  padding-inline: 2px;
}
.file-picker__main[data-v-ce116f72] * {
  box-sizing: border-box;
}
[data-v-ce116f72] .file-picker {
  height: min(80vh, 800px) !important;
}
@media (max-width: 512px) {
[data-v-ce116f72] .file-picker {
    height: calc(100% - 16px - var(--default-clickable-area)) !important;
}
}
[data-v-ce116f72] .file-picker__content {
  display: flex;
  flex-direction: column;
  overflow: hidden;
}.public-auth-prompt__text[data-v-f6ab8a31] {
  font-size: 1.25em;
  margin-block: 0 calc(3 * var(--default-grid-baseline));
}
.public-auth-prompt__header[data-v-f6ab8a31] {
  margin-block: 0 calc(3 * var(--default-grid-baseline));
}
.public-auth-prompt__header[data-v-f6ab8a31]:first-child {
  margin-top: 0;
}
.public-auth-prompt__input[data-v-f6ab8a31] {
  margin-block: calc(4 * var(--default-grid-baseline)) calc(2 * var(--default-grid-baseline));
}
/*!
 * SPDX-FileCopyrightText: 2020 RenÃ© Gieling <github@dartcafe.de>
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
:root {
  --color-inquiries-foreground-yes: var(--color-success);
  --color-inquiries-foreground-no: var(--color-error);
  --color-inquiries-foreground-maybe: var(--color-warning);
  --color-inquiries-background-yes: rgba(var(--color-success-rgb), 0.2);
  --color-inquiries-background-no: rgba(var(--color-error-rgb), 0.2);
  --color-inquiries-background-maybe: rgba(var(--color-warning-rgb), 0.1);
  --container-background-light: rgba(var(--color-info-rgb), 0.1);
  --cap-width: 49rem;
}
/*!
 * SPDX-FileCopyrightText: 2020 RenÃ© Gieling <github@dartcafe.de>
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
.avatardiv .material-design-icon {
  width: var(--size);
  height: var(--size);
}

.notecard h2 {
  margin-top: -6px;
}

.app-content {
  position: relative !important;
}

.app-sidebar {
  top: 0 !important;
}

.action-item.action-item--single.app-navigation-toggle.undefined.has-tooltip {
  top: 4px;
  margin-inline-end: -50px;
}

.app-sidebar-tabs {
  overflow-y: hidden;
}

.user-item > .checkbox-radio-switch-switch,
.user-item.add-public > .icon-add {
  margin-inline-end: 20px !important;
}

.inquiry-header-buttons .trigger {
  display: inline !important;
}

.modal-wrapper .modal-container {
  overflow: scroll !important;
}
/*!
 * SPDX-FileCopyrightText: 2020 RenÃ© Gieling <github@dartcafe.de>
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
@media print {
  #content-vue,
  .app-agora {
    padding-top: 0 !important;
  }
  .header_bar {
    margin-inline-start: 0 !important;
  }
  .inquiry-table__inquiries,
  .inquiry-table .inquiry-table__users {
    overflow-x: initial !important;
    min-width: initial !important;
  }
  .table-view .inquiry-table__inquiries,
  .table-view .inquiry-table .inquiry-table__users {
    max-width: 200px;
  }
  .app-content {
    background-color: transparent !important;
  }
  .app-content [class*=area__] {
    box-shadow: initial !important;
    margin: 0 !important;
  }
  footer,
  #header,
  #app-navigation-vue,
  #app-sidebar-vue,
  .counter.barStyle,
  .area__footer,
  .action-item,
  .header-actions,
  .app-navigation,
  .option-proposals,
  .inquiry-table__users .owner,
  .option-item-owner.owner,
  .app-sidebar {
    display: none !important;
  }
}
/*!
 * SPDX-FileCopyrightText: 2020 RenÃ© Gieling <github@dartcafe.de>
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
.transitions-active .list-enter-active,
.transitions-active .list-leave-active {
  transition: all 0.5s ease;
}
.transitions-active .list-enter-from,
.transitions-active .list-leave-to {
  opacity: 0;
}
.transitions-active .list-move {
  transition: transform 0.5s ease;
}

.v-enter-active,
.v-leave-active {
  transition: opacity 0.5s ease;
}

.v-enter-from,
.v-leave-to {
  opacity: 0;
}
/*!
 * SPDX-FileCopyrightText: 2020 RenÃ© Gieling <github@dartcafe.de>
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
.sticky-left {
  position: sticky;
  left: 0;
  z-index: 5;
}

.sticky-top {
  --shadow-height: 10px;
  position: sticky;
  top: 0;
  z-index: 4;
  padding-bottom: 0px;
  margin-bottom: var(--shadow-height);
}
.sticky-top::after {
  content: "";
  position: absolute;
  bottom: 0;
  left: -1px;
  right: 0;
  height: 0px;
  background: linear-gradient(to bottom, rgba(var(--color-box-shadow-rgb), 0.3), rgba(var(--color-box-shadow-rgb), 0));
  transition: all var(--animation-slow) linear, border 1ms;
}
.sticky-top.sticky-bottom-shadow {
  border-top: 0;
  padding-bottom: var(--shadow-height);
  margin-bottom: 0;
}
.sticky-top.sticky-bottom-shadow::after {
  height: var(--shadow-height);
}

.sticky-top.sticky-left {
  z-index: 6;
}.app-content {
  display: flex;
  flex-direction: column;
  padding: 0px 8px;
  row-gap: 8px;
}
.app-content .clamped {
  display: -webkit-box !important;
  -webkit-line-clamp: 2;
  line-clamp: 2;
  -webkit-box-orient: vertical;
  text-wrap: wrap;
  overflow: clip !important;
  text-overflow: ellipsis !important;
  padding: 0 !important;
}
.modal__content {
  padding: 14px;
  display: flex;
  flex-direction: column;
  color: var(--color-main-text);
}
.modal__buttons__spacer {
  flex: 1;
}
.modal__buttons {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  flex-wrap: wrap-reverse;
  align-items: center;
  margin-top: 36px;
}
.modal__buttons .left {
  display: flex;
  flex: 1;
  gap: 8px;
}
.modal__buttons .right {
  display: flex;
  flex: 0;
  justify-content: flex-end;
  gap: 8px;
}
.modal__buttons .button {
  margin-inline: 10px 0;
}
.modal__buttons__link {
  text-decoration: underline;
}`));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
const appName = "agora";
const appVersion = "1.0.0-rc5";
import { ar as h$1, B as defineStore, ba as Settings, a as _export_sfc, U as NcButton, V as resolveComponent, c as createElementBlock, o as openBlock, j as createVNode, g as withCtx, C as createTextVNode, t as toDisplayString, r as renderSlot, d as defineComponent, b as computed, bb as getCanonicalLocale, G as normalizeClass, b7 as NcActionButton, s as translate, _ as _export_sfc$1, f as createBlock, l as createCommentVNode, h as resolveDynamicComponent, k as createBaseVNode, i as mergeProps, P as ref, bc as NC_ACTIONS_IS_SEMANTIC_MENU, a2 as createElementId, bd as ActionGlobalMixin, Q as withDirectives, be as vModelRadio, bf as withKeys, ae as withModifiers, u as useModel, bg as userStatus, L as NcIconSvgWrapper, N as NcAvatar, p as normalizeStyle, m as mergeModels, e as watch, n as unref, $ as useTemplateRef, Z as useAttrs, aw as logger, a0 as mdiCheck, a1 as mdiAlertCircle, v as onMounted, bh as onBeforeUnmount, ab as NcLoadingIcon, S as vShow, bi as Teleport, bj as NcModal, bk as useRouter, M as Fragment$1, b4 as emit, O as renderList, bl as useRoute, aP as getCurrentUser, a5 as createSlots, bm as TransitionGroup, bn as translatePlural, E as _$2, x as normalizeProps, y as guardReactiveProps, F as DateTime, R as RouterLink, b6 as onUnmounted, T as vModelText, bo as vModelSelect, b8 as NcActions, b5 as shallowRef, bp as markRaw, bq as watchEffect, aK as nextTick, br as getCurrentInstance, bs as customRef, bt as global, bu as getAugmentedNamespace, au as process$1, aY as commonjsGlobal, bv as Buffer, X as getDefaultExportFromCjs, bw as toRaw, bx as subscribe, by as unsubscribe, af as Transition, bz as onBeforeRouteUpdate, bA as createRouter, bB as createWebHistory, z as createApp, A as pinia } from "./NcEmptyContent-q-geAf0w-DpSvTJqc.chunk.mjs";
import { b as useSessionStore, h as activity, l as lodashExports, o as options, L as Logger, i as inquiries, a as useInquiriesStore, p as publicInquiry, j as supports, k as InquiryGeneralIcons, I as InquiryTypesUI, n as useInquiryStore, q as showSuccess, s as showError, r as useInquiryGroupsStore, t as NavigationIcons, E as Event$1, S as StatusIcons, v as validators, w as NcEmptyContent, B as BadgeIcons, x as InquiryTypesUI$1, y as sortTitlesMapping, d as appSettings, z as showInfo, A as useSharesStore, C as moment, D as commonjsRequire, F as useCommentsStore, f as InquiryTypeValues, G as confirmAction, H as useOptionsStore, J as useAttachmentsStore, K as ShareIcons } from "./NcDashboardWidget-Wkx_9xKh-Bw6f1oJM.chunk.mjs";
import { u as usePreferencesStore, S as StyleSettings, F as FeatureSettings } from "./StyleSettings-Bl2d-fZa.chunk.mjs";
import { a as NcAppNavigationItem, S as Spinner, Q as QRCode, C as CheckIcon, I as InputDiv, P as PlusIcon, b as NcDialog, c as NcAppNavigation, d as NcAppContent, e as NcActionButtonGroup, f as NcActionInput, g as find$1, r as registerCustomProtocol, t as tokenize, h as reset, O as Options, i as NcAppSidebar, j as NcAppSettingsDialog, k as NcContent } from "./index-CZ70RVFy.chunk.mjs";
import { R as RadioGroupDiv, c as createPermissionContextForContent, a as ContentType, b as canSupport, d as canComment, e as canTransfer, f as canEdit, g as canDelete, h as canRestore, i as canArchive, j as canViewToggle, C as CardDiv } from "./markdown-BM-o38IH.chunk.mjs";
import { _ as _sfc_main$1S, a as NcSelect, N as NcCheckboxRadioSwitch, d as NcRichText } from "./NcRichText-G8kzsdwx-IKlnWRaR.chunk.mjs";
import { A as AgoraAppIcon } from "./AgoraAppIcon-CsAywkmy.chunk.mjs";
import { E as ExpirationIcon, N as NcUserBubble } from "./CalendarEnd-DiGIO2ac.chunk.mjs";
const setCookie = (cookieName, cookieValue = "", cookieExpiration = 360) => {
  const expirationTime = /* @__PURE__ */ new Date();
  expirationTime.setTime(expirationTime.getTime() + cookieExpiration);
  document.cookie = `${cookieName}=${cookieValue};expires=${expirationTime.toUTCString()};path=/`;
};
function findCookie(cookieName) {
  return document.cookie.split(";").find((cookie) => cookie.split("=")[0] === cookieName);
}
const getCookieValue = (cookieName) => {
  const cookie = findCookie(cookieName);
  if (cookie) {
    return cookie.split("=")[1];
  }
  return "";
};
const uniqueOptions = (options2) => options2.filter(
  (option2, index, array) => array.findIndex((compare) => compare.text === option2.text) === index
);
function groupSupports(inputArray) {
  const idToElement = inputArray.reduce(
    (idToSupportMap, item) => {
      idToSupportMap[item.id] = item;
      return idToSupportMap;
    },
    {}
  );
  const resultArray = inputArray.filter((support) => support.parent === 0).sort((a, b) => b.timestamp - a.timestamp).map((parentItem) => {
    const supports2 = getSupports(parentItem.id);
    const sortedSupports = supports2.sort((a, b) => {
      const supportA = idToElement[a.id];
      const supportB = idToElement[b.id];
      if (supportA && supportB) {
        if (supportA.timestamp !== supportB.timestamp) {
          return supportB.timestamp - supportA.timestamp;
        }
        return supportB.id - supportA.id;
      }
      return b.id - a.id;
    });
    return {
      ...parentItem,
      supports: sortedSupports
    };
  });
  function getSupports(parentId) {
    const supports2 = [];
    const stack = [parentId];
    while (stack.length > 0) {
      const currentId = stack.pop();
      if (currentId !== void 0) {
        const currentElement = idToElement[currentId];
        if (currentElement) {
          supports2.push({ ...currentElement });
          const childIds = inputArray.filter((item) => item.parent === currentId).map((item) => item.id);
          stack.push(...childIds);
        }
      }
    }
    return supports2;
  }
  return resultArray;
}
const SimpleLink = {
  props: {
    href: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: ""
    },
    target: {
      type: String,
      default: null
    }
  },
  setup(props2) {
    return () => h$1(
      "a",
      {
        href: props2.href,
        target: props2.target
      },
      props2.name
    );
  }
};
const GuestBubble = {
  props: {
    user: {
      type: String,
      default: ""
    },
    displayName: {
      type: String,
      default: ""
    }
  },
  setup(props2) {
    return () => h$1("span", props2.displayName);
  }
};
const useActivityStore = defineStore("activity", {
  state: () => ({
    activities: []
  }),
  actions: {
    async load() {
      const sessionStore = useSessionStore();
      try {
        const response = await activity.getActivities(sessionStore.currentInquiryId);
        this.activities = response.data.ocs.data;
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        this.$reset();
      }
    }
  },
  getters: {
    getActivitiesForInquiry(state) {
      const sessionStore = useSessionStore();
      return state.activities.filter(
        (activity2) => activity2.object_type === "inquiry" && activity2.object_id - sessionStore.currentInquiryId === 0
      );
    }
  }
});
const useComboStore = defineStore("combo", {
  state: () => ({
    id: 1,
    options: [],
    inquiries: [],
    participants: []
  }),
  getters: {
    inquiry: (state) => (inquiryId) => state.inquiries.find((inquiry) => inquiry.id === inquiryId),
    participantsInInquiry: (state) => (inquiryId) => state.participants.filter((participant) => participant.inquiryId === inquiryId),
    inquiryIsListed: (state) => (inquiryId) => !!state.inquiries.find((inquiry) => inquiry.id === inquiryId),
    inquiryCombo: (state) => state.inquiries.map((inquiry) => inquiry.id),
    optionBelongsToInquiry: (state) => (payload) => !!state.options.find(
      (option2) => option2.text === payload.text && option2.inquiryId === payload.inquiryId
    ),
    uniqueOptions: (state) => lodashExports.sortBy(uniqueOptions(state.options), "timestamp")
  },
  actions: {
    async add(inquiryId) {
      return Promise.all([this.addInquiry({ inquiryId }), this.addOptions({ inquiryId })]);
    },
    async remove(inquiryId) {
      return Promise.all([this.removeInquiry({ inquiryId }), this.removeOptions({ inquiryId })]);
    },
    removeInquiry(payload) {
      this.inquiries = this.inquiries.filter((inquiry) => inquiry.id !== payload.inquiryId);
    },
    removeOptions(payload) {
      this.options = this.options.filter((option2) => option2.inquiryId !== payload.inquiryId);
    },
    async verifyInquiriesFromSettings() {
      const preferencesStore = usePreferencesStore();
      preferencesStore.user.inquiryCombo.forEach((inquiryId) => {
        if (!this.inquiryCombo.includes(inquiryId)) {
          this.add(inquiryId);
        }
      });
    },
    async cleanUp() {
      const inquiriesStore = useInquiriesStore();
      this.inquiries.forEach((comboInquiry) => {
        if (inquiriesStore.inquiries.findIndex(
          (inquiry) => inquiry.id === comboInquiry.id && !inquiry.status.isArchived
        ) < 0) {
          this.removeInquiry({ inquiryId: comboInquiry.id });
        }
      });
    },
    async toggleInquiryItem(inquiryId) {
      if (this.inquiryIsListed(inquiryId)) {
        this.remove(inquiryId);
      } else {
        this.add(inquiryId);
      }
    },
    async addInquiry(payload) {
      try {
        const response = await inquiries.getInquiry(payload.inquiryId);
        this.inquiries.push(response.data.inquiry);
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        Logger.error("Error loading inquiry for combo", { error });
      }
    },
    async addOptions(payload) {
      try {
        const response = await options.getOptions(payload.inquiryId);
        this.options.push(...response.data.options);
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        Logger.error("Error loading options for combo", { error });
      }
    }
  }
});
const useSupportsStore = defineStore("supports", {
  state: () => ({
    supports: []
  }),
  getters: {
    count: (state) => state.supports.length,
    groupedSupports: (state) => groupSupports(state.supports)
  },
  actions: {
    async toggleSupport(inquiryId, userId, inquiryStore, inquiriesStore) {
      const inquiryInList = inquiriesStore.inquiries.find((i) => i.id === inquiryId);
      const inquiryInChilds = inquiryStore?.childs?.find((i) => i.id === inquiryId);
      const isCurrentInquiry = inquiryStore?.id === inquiryId;
      const sourceInquiry = inquiryInList || inquiryInChilds || (isCurrentInquiry ? inquiryStore : null);
      if (!sourceInquiry) {
        console.error("Inquiry not found in any store");
        return;
      }
      const oldState = sourceInquiry.currentUserStatus?.hasSupported ?? false;
      const oldCount = sourceInquiry.status?.countSupports ?? 0;
      if (inquiryInList) {
        inquiryInList.currentUserStatus.hasSupported = !oldState;
        inquiryInList.status.countSupports += oldState ? -1 : 1;
      }
      if (inquiryInChilds) {
        inquiryInChilds.currentUserStatus.hasSupported = !oldState;
        inquiryInChilds.status.countSupports += oldState ? -1 : 1;
      }
      if (isCurrentInquiry) {
        inquiryStore.currentUserStatus.hasSupported = !oldState;
        inquiryStore.status.countSupports += oldState ? -1 : 1;
      }
      const hasSupported = !oldState;
      try {
        if (hasSupported) {
          await supports.addSupport(inquiryId, userId);
        } else {
          await supports.removeSupport(inquiryId, userId);
        }
        return hasSupported;
      } catch (error) {
        if (inquiryInList) {
          inquiryInList.currentUserStatus.hasSupported = oldState;
          inquiryInList.status.countSupports = oldCount;
        }
        if (inquiryInChilds) {
          inquiryInChilds.currentUserStatus.hasSupported = oldState;
          inquiryInChilds.status.countSupports = oldCount;
        }
        if (isCurrentInquiry) {
          inquiryStore.currentUserStatus.hasSupported = oldState;
          inquiryStore.status.countSupports = oldCount;
        }
        throw error;
      }
    },
    async load() {
      const sessionStore = useSessionStore();
      try {
        const response = await (() => {
          if (sessionStore.route.name === "publicInquiry") {
            return publicInquiry.getSupports(sessionStore.route.params.token);
          }
          if (sessionStore.route.name === "inquiry") {
            return supports.getInquiryId(sessionStore.currentInquiryId);
          }
          return null;
        })();
        if (!response) {
          this.$reset();
          return;
        }
        this.supports = response.data.supports;
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        this.$reset();
      }
    },
    async add() {
      const sessionStore = useSessionStore();
      try {
        const response = await (() => {
          if (sessionStore.route.name === "publicInquiry") {
            return publicInquiry.addSupport(
              sessionStore.publicToken,
              sessionStore.currentInquiryId,
              sessionStore.currentUser.id
            );
          }
          if (sessionStore.route.name === "inquiry") {
            return supports.addSupport(
              sessionStore.currentInquiryId,
              sessionStore.currentUser.id
            );
          }
          return null;
        })();
        if (!response) {
          this.$reset();
          return;
        }
        this.load();
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        Logger.error("Error writing support", {
          error
        });
        throw error;
      }
    },
    async remove() {
      const sessionStore = useSessionStore();
      try {
        await (() => {
          if (sessionStore.route.name === "publicInquiry") {
            return publicInquiry.removeSupport(
              sessionStore.publicToken,
              sessionStore.currentInquiryId,
              sessionStore.currentUser.id
            );
          }
          return supports.removeSupport(
            sessionStore.currentInquiryId,
            sessionStore.currentUser.id
          );
        })();
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        Logger.error("Error deleting support", {
          error
        });
        throw error;
      }
    },
    /**
     * Restore support for an inquiry
     * @param inquiryId The inquiry ID to remove support from
     */
    async restore(payload) {
      const sessionStore = useSessionStore();
      try {
        const response = await (() => {
          if (sessionStore.route.name === "publicInquiry") {
            return publicInquiry.restoreSupport(sessionStore.publicToken, payload.support.id);
          }
          return supports.restoreSupport(payload.support.id);
        })();
        this.setItem({ support: response.data.support });
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        Logger.error("Error restoring support", {
          error,
          payload
        });
        throw error;
      }
    }
  }
});
async function loadContext(to2, cheapLoading = false, forceReload = false) {
  const sessionStore = useSessionStore();
  const preferencesStore = usePreferencesStore();
  const firstLoad = !sessionStore.isLoaded;
  await sessionStore.load(to2, cheapLoading, forceReload);
  if (firstLoad || !cheapLoading && forceReload) {
    Settings.defaultLocale = sessionStore.currentUser.localeCodeIntl || sessionStore.currentUser.languageCodeIntl;
    if (sessionStore.userStatus.isLoggedin) {
      await preferencesStore.load();
    }
  }
  Logger.info("Context loaded");
}
const _sfc_main$1R = {
  components: {
    NcButton
  },
  props: {
    buttonId: {
      type: String,
      required: false,
      default: ""
    },
    disabled: {
      type: Boolean,
      required: false,
      default: false
    },
    text: {
      type: String,
      required: true
    },
    /**
     * The color variant to use.
     * @default 'primary'
     */
    variant: {
      type: String,
      default: "primary",
      validator(value) {
        return ["primary", "secondary", "tertiary"].indexOf(value) !== -1;
      }
    }
  },
  emits: ["click"]
};
const _hoisted_1$1q = { class: "app-navigation-new" };
function _sfc_render$1N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcButton = resolveComponent("NcButton");
  return openBlock(), createElementBlock("div", _hoisted_1$1q, [
    createVNode(_component_NcButton, {
      id: $props.buttonId,
      disabled: $props.disabled,
      variant: $props.variant,
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
    }, {
      icon: withCtx(() => [
        renderSlot(_ctx.$slots, "icon", {}, void 0, true)
      ]),
      default: withCtx(() => [
        createTextVNode(" " + toDisplayString($props.text), 1)
      ]),
      _: 3
    }, 8, ["id", "disabled", "variant"])
  ]);
}
const NcAppNavigationNew = /* @__PURE__ */ _export_sfc(_sfc_main$1R, [["render", _sfc_render$1N], ["__scopeId", "data-v-08119e68"]]);
const _hoisted_1$1p = ["title"];
const _sfc_main$1Q = /* @__PURE__ */ defineComponent({
  __name: "NcCounterBubble",
  props: {
    count: {},
    active: { type: Boolean },
    type: { default: "" },
    raw: { type: Boolean }
  },
  setup(__props) {
    const props2 = __props;
    const humanizedCount = computed(() => {
      if (props2.raw) {
        return props2.count.toString();
      }
      const formatter = new Intl.NumberFormat(getCanonicalLocale(), {
        notation: "compact",
        compactDisplay: "short"
      });
      return formatter.format(props2.count);
    });
    const originalCountAsTitleIfNeeded = computed(() => {
      if (props2.raw) {
        return;
      }
      const countAsString = props2.count.toString();
      if (countAsString === humanizedCount.value) {
        return;
      }
      return countAsString;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["counter-bubble__counter", {
          active: _ctx.active,
          "counter-bubble__counter--highlighted": _ctx.type === "highlighted",
          "counter-bubble__counter--outlined": _ctx.type === "outlined"
        }]),
        title: originalCountAsTitleIfNeeded.value
      }, toDisplayString(humanizedCount.value), 11, _hoisted_1$1p);
    };
  }
});
const NcCounterBubble = /* @__PURE__ */ _export_sfc(_sfc_main$1Q, [["__scopeId", "data-v-5481b656"]]);
const _sfc_main$1P = /* @__PURE__ */ defineComponent({
  __name: "InquiryNavigationItems",
  props: {
    inquiry: { type: Object, required: true }
  },
  emits: ["cloneInquiry", "toggleArchive", "deleteInquiry"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const __returned__ = { emit: emit2, get t() {
      return translate;
    }, get NcActionButton() {
      return NcActionButton;
    }, get NcAppNavigationItem() {
      return NcAppNavigationItem;
    }, get InquiryTypesUI() {
      return InquiryTypesUI;
    }, get InquiryGeneralIcons() {
      return InquiryGeneralIcons;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$1o = { class: "type-icon" };
function _sfc_render$1M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcAppNavigationItem"], {
    name: $props.inquiry.title,
    to: $props.inquiry.permissions.view ? { name: "inquiry", params: { id: $props.inquiry.id } } : null,
    class: normalizeClass({ closed: $props.inquiry.status.isExpired })
  }, {
    icon: withCtx(() => [
      createBaseVNode("div", _hoisted_1$1o, [
        (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$props.inquiry.type].icon)))
      ])
    ]),
    actions: withCtx(() => [
      $props.inquiry.permissions.edit && !$props.inquiry.status.isArchived ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 0,
        name: $setup.t("agora", "Archive inquiry"),
        "aria-label": $setup.t("agora", "Archive inquiry"),
        onClick: _cache[0] || (_cache[0] = ($event) => $setup.emit("toggleArchive"))
      }, {
        icon: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.archive)))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"])) : createCommentVNode("v-if", true),
      $props.inquiry.permissions.edit && $props.inquiry.status.isArchived ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 1,
        name: $setup.t("agora", "Restore inquiry"),
        "aria-label": $setup.t("agora", "Restore inquiry"),
        onClick: _cache[1] || (_cache[1] = ($event) => $setup.emit("toggleArchive"))
      }, {
        icon: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.restore)))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"])) : createCommentVNode("v-if", true),
      $props.inquiry.permissions.edit ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 2,
        class: "danger",
        name: $setup.t("agora", "Delete inquiry"),
        "aria-label": $setup.t("agora", "Delete inquiry"),
        onClick: _cache[2] || (_cache[2] = ($event) => $setup.emit("deleteInquiry"))
      }, {
        icon: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.delete)))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"])) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  }, 8, ["name", "to", "class"]);
}
const InquiryNavigationItems = /* @__PURE__ */ _export_sfc$1(_sfc_main$1P, [["render", _sfc_render$1M], ["__file", "/var/www/nextcloud/apps/agora/src/components/Navigation/InquiryNavigationItems.vue"]]);
const _sfc_main$1O = {
  name: "BullhornIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$1n = ["aria-hidden", "aria-label"];
const _hoisted_2$Z = ["fill", "width", "height"];
const _hoisted_3$R = { d: "M12,8H4A2,2 0 0,0 2,10V14A2,2 0 0,0 4,16H5V20A1,1 0 0,0 6,21H8A1,1 0 0,0 9,20V16H12L17,20V4L12,8M21.5,12C21.5,13.71 20.54,15.26 19,16V8C20.53,8.75 21.5,10.3 21.5,12Z" };
const _hoisted_4$N = { key: 0 };
function _sfc_render$1L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon bullhorn-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$R, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$N,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$Z))
  ], 16, _hoisted_1$1n);
}
const SpeakerIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1O, [["render", _sfc_render$1L], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Bullhorn.vue"]]);
const _sfc_main$1N = {
  name: "InformationVariantIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$1m = ["aria-hidden", "aria-label"];
const _hoisted_2$Y = ["fill", "width", "height"];
const _hoisted_3$Q = { d: "M13.5,4A1.5,1.5 0 0,0 12,5.5A1.5,1.5 0 0,0 13.5,7A1.5,1.5 0 0,0 15,5.5A1.5,1.5 0 0,0 13.5,4M13.14,8.77C11.95,8.87 8.7,11.46 8.7,11.46C8.5,11.61 8.56,11.6 8.72,11.88C8.88,12.15 8.86,12.17 9.05,12.04C9.25,11.91 9.58,11.7 10.13,11.36C12.25,10 10.47,13.14 9.56,18.43C9.2,21.05 11.56,19.7 12.17,19.3C12.77,18.91 14.38,17.8 14.54,17.69C14.76,17.54 14.6,17.42 14.43,17.17C14.31,17 14.19,17.12 14.19,17.12C13.54,17.55 12.35,18.45 12.19,17.88C12,17.31 13.22,13.4 13.89,10.71C14,10.07 14.3,8.67 13.14,8.77Z" };
const _hoisted_4$M = { key: 0 };
function _sfc_render$1K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon information-variant-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$Q, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$M,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$Y))
  ], 16, _hoisted_1$1m);
}
const InformationIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1N, [["render", _sfc_render$1K], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/InformationVariant.vue"]]);
const _sfc_main$1M = /* @__PURE__ */ defineComponent({
  __name: "ConfigBox",
  props: {
    name: { type: String, required: true },
    info: { type: String, required: false, default: "" },
    indented: { type: Boolean, required: false, default: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = { InformationIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$1l = { class: "config-box" };
const _hoisted_2$X = { class: "config-box__header" };
const _hoisted_3$P = ["title"];
const _hoisted_4$L = { class: "config-box__container" };
function _sfc_render$1J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1l, [
    createBaseVNode("div", _hoisted_2$X, [
      renderSlot(_ctx.$slots, "icon"),
      createBaseVNode("div", {
        title: $props.info,
        class: normalizeClass(["config-box__title", { indented: $props.indented }])
      }, [
        createTextVNode(
          toDisplayString($props.name) + " ",
          1
          /* TEXT */
        ),
        $props.info ? (openBlock(), createBlock($setup["InformationIcon"], { key: 0 })) : createCommentVNode("v-if", true)
      ], 10, _hoisted_3$P),
      renderSlot(_ctx.$slots, "actions")
    ]),
    createBaseVNode("div", _hoisted_4$L, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
const ConfigBox = /* @__PURE__ */ _export_sfc$1(_sfc_main$1M, [["render", _sfc_render$1J], ["__file", "/var/www/nextcloud/apps/agora/src/components/Base/modules/ConfigBox.vue"]]);
const _sfc_main$1L = /* @__PURE__ */ defineComponent({
  __name: "HeaderBar",
  setup(__props, { expose: __expose }) {
    __expose();
    const clamped = ref(true);
    function toggleClamp() {
      clamped.value = !clamped.value;
    }
    const __returned__ = { clamped, toggleClamp };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$1k = { class: "header_bar" };
const _hoisted_2$W = { class: "header_bar_top" };
const _hoisted_3$O = { class: "bar_top_left" };
const _hoisted_4$K = { class: "bar_top_left_sub" };
const _hoisted_5$c = { class: "bar_top_right" };
const _hoisted_6$a = { class: "header_bar_bottom" };
function _sfc_render$1I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$1k, [
    createBaseVNode("div", _hoisted_2$W, [
      createBaseVNode("div", _hoisted_3$O, [
        createBaseVNode(
          "div",
          {
            class: normalizeClass(["header_avatar", { clamped: $setup.clamped }]),
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.toggleClamp())
          },
          [
            renderSlot(_ctx.$slots, "avatar")
          ],
          2
          /* CLASS */
        ),
        createBaseVNode("div", _hoisted_4$K, [
          renderSlot(_ctx.$slots, "sub")
        ])
      ]),
      createBaseVNode("div", _hoisted_5$c, [
        renderSlot(_ctx.$slots, "right")
      ])
    ]),
    createBaseVNode("div", _hoisted_6$a, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
const HeaderBar = /* @__PURE__ */ _export_sfc$1(_sfc_main$1L, [["render", _sfc_render$1I], ["__file", "/var/www/nextcloud/apps/agora/src/components/Base/modules/HeaderBar.vue"]]);
const _sfc_main$1K = /* @__PURE__ */ defineComponent({
  __name: "ThumbIcon",
  props: {
    title: { type: String, required: false, default: () => translate("agora", "Support status") },
    fillColor: { type: String, required: false, default: "#9ca3af" },
    size: { type: Number, required: false, default: 24 },
    supported: { type: Boolean, required: false, default: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = {};
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$1j = ["aria-hidden", "aria-label"];
const _hoisted_2$V = ["fill", "stroke", "width", "height"];
function _sfc_render$1H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    "aria-hidden": !$props.title,
    "aria-label": $props.title,
    class: "material-design-icon agora-thumb-icon",
    role: "img"
  }, [
    (openBlock(), createElementBlock("svg", {
      fill: $props.supported ? "#facc15" : $props.fillColor,
      stroke: $props.supported ? "#facc15" : $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24",
      xmlns: "http://www.w3.org/2000/svg"
    }, [..._cache[0] || (_cache[0] = [
      createBaseVNode(
        "path",
        { d: "M2 21h4V9H2v12zM22 10c0-1.1-.9-2-2-2h-5.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h7c.74 0 1.38-.4 1.73-1.03l3.58-6.49c.11-.19.18-.41.18-.65v-3.5l-.01-.01L22 10z" },
        null,
        -1
        /* CACHED */
      )
    ])], 8, _hoisted_2$V))
  ], 8, _hoisted_1$1j);
}
const ThumbIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1K, [["render", _sfc_render$1H], ["__scopeId", "data-v-24ed4f43"], ["__file", "/var/www/nextcloud/apps/agora/src/components/AppIcons/modules/ThumbIcon.vue"]]);
const _sfc_main$1J = {
  name: "NcActionCaption",
  inject: {
    isInSemanticMenu: {
      from: NC_ACTIONS_IS_SEMANTIC_MENU,
      default: false
    }
  },
  props: {
    /**
     * The caption's text
     */
    name: {
      type: String,
      required: true
    }
  }
};
const _hoisted_1$1i = ["role"];
function _sfc_render$1G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: "app-navigation-caption",
    role: $options.isInSemanticMenu && "presentation"
  }, toDisplayString($props.name), 9, _hoisted_1$1i);
}
const NcActionCaption = /* @__PURE__ */ _export_sfc(_sfc_main$1J, [["render", _sfc_render$1G], ["__scopeId", "data-v-1009e96c"]]);
const _sfc_main$1I = {
  name: "NcActionRadio",
  mixins: [ActionGlobalMixin],
  inject: {
    isInSemanticMenu: {
      from: NC_ACTIONS_IS_SEMANTIC_MENU,
      default: false
    }
  },
  props: {
    /**
     * id attribute of the radio element
     */
    id: {
      type: String,
      default: () => createElementId(),
      validator: (id) => id.trim() !== ""
    },
    /**
     * checked state of the radio element
     */
    modelValue: {
      type: [String, Number],
      default: ""
    },
    /**
     * Define if this radio is part of a set.
     * Checking the radio will disable all the
     * others with the same name.
     */
    name: {
      type: String,
      required: true
    },
    /**
     * value of the radio input
     */
    value: {
      type: [String, Number],
      default: ""
    },
    /**
     * disabled state of the radio element
     */
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "change",
    "update:modelValue"
  ],
  setup(props2) {
    return {
      model: useModel(props2, "modelValue")
    };
  },
  computed: {
    /**
     * determines if the action is focusable
     *
     * @return {boolean} is the action focusable ?
     */
    isFocusable() {
      return !this.disabled;
    },
    /**
     * aria-checked attribute for role="menuitemcheckbox"
     *
     * @return {'true'|'false'|undefined} aria-checked value if needed
     */
    ariaChecked() {
      if (this.isInSemanticMenu) {
        return this.modelValue === this.value ? "true" : "false";
      }
      return void 0;
    }
  },
  methods: {
    toggleInput() {
      this.$refs.label.click();
    },
    onChange(event) {
      this.$emit("change", event);
    }
  }
};
const _hoisted_1$1h = ["role"];
const _hoisted_2$U = ["aria-checked"];
const _hoisted_3$N = ["id", "disabled", "name", "value"];
const _hoisted_4$J = ["for"];
function _sfc_render$1F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["action", { "action--disabled": $props.disabled }]),
    role: $options.isInSemanticMenu && "presentation"
  }, [
    createBaseVNode("span", {
      class: "action-radio",
      role: "menuitemradio",
      "aria-checked": $options.ariaChecked
    }, [
      withDirectives(createBaseVNode("input", {
        id: $props.id,
        ref: "radio",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.model = $event),
        disabled: $props.disabled,
        name: $props.name,
        value: $props.value,
        class: normalizeClass([{ focusable: $options.isFocusable }, "radio action-radio__radio"]),
        type: "radio",
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.toggleInput && $options.toggleInput(...args), ["exact", "prevent"]), ["enter"])),
        onChange: _cache[2] || (_cache[2] = (...args) => $options.onChange && $options.onChange(...args))
      }, null, 42, _hoisted_3$N), [
        [vModelRadio, $setup.model]
      ]),
      createBaseVNode("label", {
        ref: "label",
        for: $props.id,
        class: "action-radio__label"
      }, toDisplayString(_ctx.text), 9, _hoisted_4$J),
      createCommentVNode("", true)
    ], 8, _hoisted_2$U)
  ], 10, _hoisted_1$1h);
}
const NcActionRadio = /* @__PURE__ */ _export_sfc(_sfc_main$1I, [["render", _sfc_render$1F], ["__scopeId", "data-v-4e9c727c"]]);
const _sfc_main$1H = {
  name: "NcActionSeparator"
};
const _hoisted_1$1g = {
  class: "action action-separator action--disabled",
  role: "separator"
};
function _sfc_render$1E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", _hoisted_1$1g);
}
const NcActionSeparator = /* @__PURE__ */ _export_sfc(_sfc_main$1H, [["render", _sfc_render$1E], ["__scopeId", "data-v-3e2324b7"]]);
const _hoisted_1$1f = { class: "app-navigation-spacer" };
const _sfc_main$1G = /* @__PURE__ */ defineComponent({
  __name: "NcAppNavigationSpacer",
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("li", _hoisted_1$1f);
    };
  }
});
const NcAppNavigationSpacer = /* @__PURE__ */ _export_sfc(_sfc_main$1G, [["__scopeId", "data-v-277fa710"]]);
const _sfc_main$1F = {
  name: "NcAppSettingsSection",
  inject: ["registerSection", "unregisterSection"],
  props: {
    name: {
      type: String,
      required: true
    },
    id: {
      type: String,
      required: true,
      validator(id) {
        return /^[a-z0-9\-_]+$/.test(id);
      }
    }
  },
  computed: {
    // generate an id for each settingssection based on the name without whitespaces
    htmlId() {
      return "settings-section_" + this.id;
    }
  },
  // Reactive changes for section navigation
  watch: {
    id(newId, oldId) {
      this.unregisterSection(oldId);
      this.registerSection(newId, this.name, this.$slots?.icon?.());
    },
    name(newName) {
      this.unregisterSection(this.id);
      this.registerSection(this.id, newName, this.$slots?.icon?.());
    }
  },
  mounted() {
    this.registerSection(this.id, this.name, this.$slots?.icon?.());
  },
  beforeUnmount() {
    this.unregisterSection(this.id);
  }
};
const _hoisted_1$1e = ["id", "aria-labelledby"];
const _hoisted_2$T = ["id"];
function _sfc_render$1D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("section", {
    id: $options.htmlId,
    "aria-labelledby": `${$options.htmlId}--label`,
    class: "app-settings-section"
  }, [
    createBaseVNode("h3", {
      id: `${$options.htmlId}--label`,
      class: "app-settings-section__name"
    }, toDisplayString($props.name), 9, _hoisted_2$T),
    renderSlot(_ctx.$slots, "default", {}, void 0, true),
    createCommentVNode("", true)
  ], 8, _hoisted_1$1e);
}
const NcAppSettingsSection = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["render", _sfc_render$1D], ["__scopeId", "data-v-ce8fac13"]]);
const _sfc_main$1E = {
  name: "NcAppSidebarTab",
  inject: ["registerTab", "unregisterTab", "getActiveTab", "isTablistShown"],
  props: {
    id: {
      type: String,
      required: true
    },
    /**
     * Tab name in navigation
     */
    name: {
      type: String,
      required: true
    },
    /**
     * Tab icon's html class in navigation. Used if #icon slot is not provided
     */
    icon: {
      type: String,
      default: ""
    },
    /**
     * Tab order in navigation. If not provided, name is used.
     */
    order: {
      type: Number,
      default: 0
    }
  },
  emits: [
    "bottomReached",
    "scroll"
  ],
  expose: ["id", "name", "icon", "order", "renderIcon"],
  computed: {
    /**
     * Is the current tab an active tab, that should be shown?
     *
     * @return {boolean}
     */
    isActive() {
      return this.getActiveTab() === this.id;
    }
  },
  created() {
    this.registerTab(this);
  },
  beforeUnmount() {
    this.unregisterTab(this.id);
  },
  methods: {
    onScroll(event) {
      if (this.$el.scrollHeight - this.$el.scrollTop === this.$el.clientHeight) {
        this.$emit("bottomReached", event);
      }
      this.$emit("scroll", event);
    },
    /**
     * Render tab's icon slot if any
     *
     * @return {import('vue').VNode[]}
     */
    renderIcon() {
      return this.$slots.icon?.();
    }
  }
};
const _hoisted_1$1d = ["id", "aria-hidden", "aria-label", "aria-labelledby", "tabindex", "role"];
const _hoisted_2$S = { class: "hidden-visually" };
function _sfc_render$1C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("section", {
    id: `tab-${$props.id}`,
    class: normalizeClass([{ "app-sidebar__tab--active": $options.isActive }, "app-sidebar__tab"]),
    "aria-hidden": !$options.isActive,
    "aria-label": $options.isTablistShown() ? void 0 : $props.name,
    "aria-labelledby": $options.isTablistShown() ? `tab-button-${$props.id}` : void 0,
    tabindex: $options.isTablistShown() ? 0 : -1,
    role: $options.isTablistShown() ? "tabpanel" : void 0,
    onScroll: _cache[0] || (_cache[0] = (...args) => $options.onScroll && $options.onScroll(...args))
  }, [
    createBaseVNode("h3", _hoisted_2$S, toDisplayString($props.name), 1),
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 42, _hoisted_1$1d);
}
const NcAppSidebarTab = /* @__PURE__ */ _export_sfc(_sfc_main$1E, [["render", _sfc_render$1C], ["__scopeId", "data-v-9d737d13"]]);
const margin = 8;
const defaultSize = 32;
const _sfc_main$1D = {
  name: "NcListItemIcon",
  components: {
    NcAvatar,
    NcHighlight: _sfc_main$1S,
    NcIconSvgWrapper
  },
  mixins: [
    userStatus
  ],
  props: {
    /**
     * Default first line text
     */
    name: {
      type: String,
      required: true
    },
    /**
     * Secondary optional line
     * Only visible on size of 32 and above
     */
    subname: {
      type: String,
      default: ""
    },
    /**
     * Icon class to be displayed at the end of the component
     */
    icon: {
      type: String,
      default: ""
    },
    /**
     * SVG icon to be displayed at the end of the component
     */
    iconSvg: {
      type: String,
      default: ""
    },
    /**
     * Descriptive name for the icon
     */
    iconName: {
      type: String,
      default: ""
    },
    /**
     * Search within the highlight of name/subname
     */
    search: {
      type: String,
      default: ""
    },
    /**
     * Set a size in px that will define the avatar height/width
     * and therefore, the height of the component
     */
    avatarSize: {
      type: Number,
      default: defaultSize
    },
    /**
     * Disable the margins of this component.
     * Useful for integration in `NcSelect` for example
     */
    noMargin: {
      type: Boolean,
      default: false
    },
    /**
     * See the [Avatar](#Avatar) displayName prop
     * Fallback to name
     */
    displayName: {
      type: String,
      default: null
    },
    /**
     * See the [Avatar](#Avatar) isNoUser prop
     * Enable/disable the UserStatus fetching
     */
    isNoUser: {
      type: Boolean,
      default: false
    },
    /**
     * Unique list item ID
     */
    id: {
      type: String,
      default: null
    }
  },
  setup() {
    return {
      margin,
      defaultSize
    };
  },
  computed: {
    hasIcon() {
      return this.icon !== "";
    },
    hasIconSvg() {
      return this.iconSvg !== "";
    },
    isValidSubname() {
      return this.subname?.trim?.() !== "";
    },
    isSizeBigEnough() {
      return this.avatarSize >= 26;
    },
    cssVars() {
      const margin2 = this.noMargin ? 0 : this.margin;
      return {
        "--height": this.avatarSize + 2 * margin2 + "px",
        "--margin": this.margin + "px"
      };
    },
    /**
     * Separates the search property into two parts, the first one is the search part on the name, the second on the subname.
     * @return {[string, string]}
     */
    searchParts() {
      const EMAIL_NOTATION = /^([^<]*)<([^>]+)>?$/;
      const match = this.search.match(EMAIL_NOTATION);
      if (this.isNoUser || !match) {
        return [this.search, this.search];
      }
      return [match[1].trim(), match[2]];
    }
  },
  beforeMount() {
    if (!this.isNoUser && !this.subname) {
      this.fetchUserStatus(this.user);
    }
  }
};
const _hoisted_1$1c = ["id"];
const _hoisted_2$R = { class: "option__details" };
const _hoisted_3$M = { key: 1 };
const _hoisted_4$I = ["aria-label"];
function _sfc_render$1B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcAvatar = resolveComponent("NcAvatar");
  const _component_NcHighlight = resolveComponent("NcHighlight");
  const _component_NcIconSvgWrapper = resolveComponent("NcIconSvgWrapper");
  return openBlock(), createElementBlock("span", {
    id: $props.id,
    class: normalizeClass(["option", { "option--compact": $props.avatarSize < $setup.defaultSize }]),
    style: normalizeStyle($options.cssVars)
  }, [
    createVNode(_component_NcAvatar, mergeProps(_ctx.$attrs, {
      "disable-menu": true,
      "disable-tooltip": true,
      "display-name": $props.displayName || $props.name,
      "is-no-user": $props.isNoUser,
      size: $props.avatarSize,
      class: "option__avatar"
    }), null, 16, ["display-name", "is-no-user", "size"]),
    createBaseVNode("div", _hoisted_2$R, [
      createVNode(_component_NcHighlight, {
        class: "option__lineone",
        text: $props.name,
        search: $options.searchParts[0]
      }, null, 8, ["text", "search"]),
      $options.isValidSubname && $options.isSizeBigEnough ? (openBlock(), createBlock(_component_NcHighlight, {
        key: 0,
        class: "option__linetwo",
        text: $props.subname,
        search: $options.searchParts[1]
      }, null, 8, ["text", "search"])) : _ctx.hasStatus ? (openBlock(), createElementBlock("span", _hoisted_3$M, [
        createBaseVNode("span", null, toDisplayString(_ctx.userStatus.icon), 1),
        createBaseVNode("span", null, toDisplayString(_ctx.userStatus.message), 1)
      ])) : createCommentVNode("", true)
    ]),
    renderSlot(_ctx.$slots, "default", {}, () => [
      $options.hasIconSvg ? (openBlock(), createBlock(_component_NcIconSvgWrapper, {
        key: 0,
        class: "option__icon",
        svg: $props.iconSvg,
        name: $props.iconName
      }, null, 8, ["svg", "name"])) : $options.hasIcon ? (openBlock(), createElementBlock("span", {
        key: 1,
        class: normalizeClass(["icon option__icon", $props.icon]),
        "aria-label": $props.iconName
      }, null, 10, _hoisted_4$I)) : createCommentVNode("", true)
    ], true)
  ], 14, _hoisted_1$1c);
}
const NcListItemIcon = /* @__PURE__ */ _export_sfc(_sfc_main$1D, [["render", _sfc_render$1B], ["__scopeId", "data-v-f5135913"]]);
const _sfc_main$1C = /* @__PURE__ */ defineComponent({
  __name: "NcSelectUsers",
  props: /* @__PURE__ */ mergeModels({
    ariaLabelClearSelected: {},
    ariaLabelListbox: {},
    ariaLabelDeselectOption: { type: Function },
    disabled: { type: Boolean },
    inputId: {},
    inputLabel: {},
    labelOutside: { type: Boolean },
    keepOpen: { type: Boolean },
    loading: { type: Boolean },
    multiple: { type: Boolean },
    noWrap: { type: Boolean },
    options: {},
    placeholder: {},
    required: { type: Boolean }
  }, {
    "modelValue": {},
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["search"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const modelValue = useModel(__props, "modelValue");
    const emit2 = __emit;
    const search = ref("");
    watch(search, () => emit2("search", search.value));
    const clickableArea = Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--default-clickable-area"));
    const gridBaseLine = Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--default-grid-baseline"));
    const avatarSize = clickableArea - 2 * gridBaseLine;
    function filterBy(option2, label, search2) {
      const EMAIL_NOTATION = /[^<]*<([^>]+)/;
      const match = search2.match(EMAIL_NOTATION);
      const subname = option2.subname?.toLocaleLowerCase() ?? "";
      return match && subname.indexOf(match[1].toLocaleLowerCase()) > -1 || `${label} ${option2.subname}`.toLocaleLowerCase().indexOf(search2.toLocaleLowerCase()) > -1;
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(NcSelect), mergeProps({
        modelValue: modelValue.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => modelValue.value = $event),
        class: "nc-select-users"
      }, _ctx.$props, {
        "filter-by": filterBy,
        label: "displayName",
        onSearch: _cache[1] || (_cache[1] = ($event) => search.value = $event)
      }), {
        option: withCtx((option2) => [
          createVNode(unref(NcListItemIcon), mergeProps(option2, {
            "avatar-size": 32,
            name: option2.displayName,
            search: search.value
          }), null, 16, ["name", "search"])
        ]),
        "selected-option": withCtx((selectedOption) => [
          createVNode(unref(NcListItemIcon), mergeProps(selectedOption, {
            "avatar-size": avatarSize,
            name: selectedOption.displayName,
            "no-margin": "",
            search: search.value
          }), null, 16, ["name", "search"])
        ]),
        _: 1
      }, 16, ["modelValue"]);
    };
  }
});
const NcSelectUsers = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["__scopeId", "data-v-085bfabd"]]);
const _hoisted_1$1b = { class: "textarea__main-wrapper" };
const _hoisted_2$Q = ["id", "aria-describedby", "disabled", "placeholder", "value"];
const _hoisted_3$L = ["for"];
const _hoisted_4$H = ["id"];
const _sfc_main$1B = /* @__PURE__ */ defineComponent({
  ...{ inheritAttrs: false },
  __name: "NcTextArea",
  props: /* @__PURE__ */ mergeModels({
    disabled: { type: Boolean },
    error: { type: Boolean },
    helperText: { default: void 0 },
    id: { default: () => createElementId() },
    inputClass: { default: "" },
    label: { default: void 0 },
    labelOutside: { type: Boolean },
    placeholder: { default: void 0 },
    resize: { default: "both" },
    success: { type: Boolean }
  }, {
    "modelValue": { required: true },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props, { expose: __expose }) {
    __expose({
      focus: focus2,
      select
    });
    const props2 = __props;
    const modelValue = useModel(__props, "modelValue");
    const textAreaElement = useTemplateRef("input");
    const attrs = useAttrs();
    watch(() => props2.labelOutside, () => {
      if (!props2.labelOutside && !props2.label) {
        logger.warn("[NcTextArea] You need to add a label to the NcInputField component. Either use the prop label or use an external one, as per the example in the documentation.");
      }
    });
    const ariaDescribedby = computed(() => {
      const ariaDescribedby2 = [];
      if (props2.helperText) {
        ariaDescribedby2.push(`${props2.id}-helper-text`);
      }
      if (typeof attrs["aria-describedby"] === "string") {
        ariaDescribedby2.push(attrs["aria-describedby"]);
      }
      return ariaDescribedby2.join(" ") || void 0;
    });
    function handleInput(event) {
      const { value } = event.target;
      modelValue.value = value;
    }
    function focus2(options2) {
      textAreaElement.value.focus(options2);
    }
    function select() {
      textAreaElement.value.select();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["textarea", [_ctx.$attrs.class, { "textarea--disabled": _ctx.disabled }]])
      }, [
        createBaseVNode("div", _hoisted_1$1b, [
          createBaseVNode("textarea", mergeProps({ ..._ctx.$attrs, class: void 0 }, {
            id: _ctx.id,
            ref: "input",
            "aria-describedby": ariaDescribedby.value,
            "aria-live": "polite",
            class: ["textarea__input", [
              _ctx.inputClass,
              {
                "textarea__input--label-outside": _ctx.labelOutside,
                "textarea__input--success": _ctx.success,
                "textarea__input--error": _ctx.error
              }
            ]],
            disabled: _ctx.disabled,
            placeholder: _ctx.placeholder,
            style: { resize: _ctx.resize },
            value: modelValue.value,
            onInput: handleInput
          }), null, 16, _hoisted_2$Q),
          !_ctx.labelOutside ? (openBlock(), createElementBlock("label", {
            key: 0,
            class: "textarea__label",
            for: _ctx.id
          }, toDisplayString(_ctx.label), 9, _hoisted_3$L)) : createCommentVNode("", true)
        ]),
        _ctx.helperText ? (openBlock(), createElementBlock("p", {
          key: 0,
          id: `${_ctx.id}-helper-text`,
          class: normalizeClass(["textarea__helper-text-message", {
            "textarea__helper-text-message--error": _ctx.error,
            "textarea__helper-text-message--success": _ctx.success
          }])
        }, [
          _ctx.success ? (openBlock(), createBlock(NcIconSvgWrapper, {
            key: 0,
            class: "textarea__helper-text-message__icon",
            path: unref(mdiCheck)
          }, null, 8, ["path"])) : _ctx.error ? (openBlock(), createBlock(NcIconSvgWrapper, {
            key: 1,
            class: "textarea__helper-text-message__icon",
            path: unref(mdiAlertCircle)
          }, null, 8, ["path"])) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.helperText), 1)
        ], 10, _hoisted_4$H)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
const NcTextArea = /* @__PURE__ */ _export_sfc(_sfc_main$1B, [["__scopeId", "data-v-58be798d"]]);
const _sfc_main$1A = /* @__PURE__ */ defineComponent({
  __name: "IntersectionObserver",
  props: /* @__PURE__ */ mergeModels({
    loading: { type: Boolean, required: false, default: false }
  }, {
    "modelValue": { type: Boolean },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["visible", "invisible"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const model = useModel(__props, "modelValue");
    const observer = ref(null);
    const observerTarget = ref(null);
    const emit2 = __emit;
    onMounted(() => {
      const observer2 = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            model.value = true;
            emit2("visible");
          } else {
            model.value = false;
            emit2("invisible");
          }
        });
      });
      observer2.observe(observerTarget.value);
    });
    onBeforeUnmount(() => {
      if (observer.value) {
        observer.value.disconnect();
      }
    });
    const __returned__ = { model, observer, observerTarget, emit: emit2, get NcLoadingIcon() {
      return NcLoadingIcon;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$1a = { ref: "observerTarget" };
function _sfc_render$1A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    _hoisted_1$1a,
    [
      $props.loading ? (openBlock(), createBlock($setup["NcLoadingIcon"], {
        key: 0,
        size: 15
      })) : renderSlot(_ctx.$slots, "default", {
        key: 1,
        inViewport: $setup.model
      })
    ],
    512
    /* NEED_PATCH */
  );
}
const IntersectionObserver$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1A, [["render", _sfc_render$1A], ["__file", "/var/www/nextcloud/apps/agora/src/components/Base/modules/IntersectionObserver.vue"]]);
const _sfc_main$1z = /* @__PURE__ */ defineComponent({
  __name: "LoadingOverlay",
  props: {
    show: { type: Boolean, required: true, default: false },
    name: { type: String, required: true, default: () => translate("agora", "Loading â¦") },
    loadingTexts: { type: [String, Array], required: false, default: "" },
    teleportTo: { type: String, required: false, default: "#content-vue" }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const description = ref(translate("agora", "Please waitâ¦"));
    const sequentialDescriptionOutput = () => {
      if (__props.loadingTexts instanceof String) {
        description.value = __props.loadingTexts;
        return;
      }
      if (__props.loadingTexts.length === 0) {
        description.value = "";
        return;
      }
      if (__props.loadingTexts.length === 1) {
        description.value = __props.loadingTexts[0];
        return;
      }
      let index = 0;
      const showDescription = () => {
        if (index < __props.loadingTexts.length) {
          if (__props.show === false) {
            return;
          }
          description.value = __props.loadingTexts[index];
          index = index + 1;
          const delay2 = 1500 + Math.floor(Math.random() * 1001) - 500;
          setTimeout(showDescription, delay2);
        } else {
          description.value = __props.loadingTexts[__props.loadingTexts.length - 1];
        }
      };
      showDescription();
    };
    watch(
      () => __props.show,
      (newValue) => {
        if (newValue === true && __props.loadingTexts.length > 0) {
          sequentialDescriptionOutput();
        }
      }
    );
    onMounted(() => {
      if (__props.show) {
        sequentialDescriptionOutput();
      }
    });
    const __returned__ = { description, sequentialDescriptionOutput, get Spinner() {
      return Spinner;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$19 = { class: "loading-overlay" };
const _hoisted_2$P = { class: "loading-overlay__inner" };
const _hoisted_3$K = { class: "loading-overlay__name" };
const _hoisted_4$G = { class: "loading-overlay__description" };
function _sfc_render$1z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Teleport, { to: $props.teleportTo }, [
    withDirectives(createBaseVNode(
      "div",
      _hoisted_1$19,
      [
        createBaseVNode("div", _hoisted_2$P, [
          createVNode($setup["Spinner"], {
            class: "loading-overlay__spinner",
            size: 70
          }),
          createBaseVNode(
            "span",
            _hoisted_3$K,
            toDisplayString($props.name),
            1
            /* TEXT */
          ),
          createBaseVNode(
            "p",
            _hoisted_4$G,
            toDisplayString($setup.description),
            1
            /* TEXT */
          )
        ])
      ],
      512
      /* NEED_PATCH */
    ), [
      [vShow, $props.show]
    ])
  ], 8, ["to"]);
}
const LoadingOverlay = /* @__PURE__ */ _export_sfc$1(_sfc_main$1z, [["render", _sfc_render$1z], ["__file", "/var/www/nextcloud/apps/agora/src/components/Base/modules/LoadingOverlay.vue"]]);
const _sfc_main$1y = /* @__PURE__ */ defineComponent({
  __name: "QrModal",
  props: {
    name: { type: String, required: false, default: "" },
    subTitle: { type: String, required: false, default: "" },
    description: { type: String, required: false, default: "" },
    encodeText: { type: String, required: true }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const qrUri = ref("");
    async function generateQr() {
      try {
        qrUri.value = await QRCode.toDataURL(__props.encodeText);
      } catch (e) {
        const error = e;
        Logger.error("Error on generating QR code", { error: error.message });
      }
    }
    onMounted(() => {
      generateQr();
    });
    const __returned__ = { qrUri, generateQr };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$18 = { class: "qr-code" };
const _hoisted_2$O = { class: "canvas" };
const _hoisted_3$J = ["src", "alt"];
const _hoisted_4$F = { class: "qr-url" };
function _sfc_render$1y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$18, [
    createBaseVNode(
      "h2",
      null,
      toDisplayString($props.name),
      1
      /* TEXT */
    ),
    renderSlot(_ctx.$slots, "description", {}, () => [
      createTextVNode(
        toDisplayString($props.description),
        1
        /* TEXT */
      )
    ]),
    createBaseVNode("div", _hoisted_2$O, [
      createBaseVNode("img", {
        src: $setup.qrUri,
        alt: $props.encodeText
      }, null, 8, _hoisted_3$J)
    ]),
    createBaseVNode(
      "h3",
      null,
      toDisplayString($props.subTitle),
      1
      /* TEXT */
    ),
    _cache[0] || (_cache[0] = createBaseVNode(
      "p",
      null,
      null,
      -1
      /* CACHED */
    )),
    createBaseVNode(
      "p",
      _hoisted_4$F,
      toDisplayString($props.encodeText),
      1
      /* TEXT */
    )
  ]);
}
const QrModal = /* @__PURE__ */ _export_sfc$1(_sfc_main$1y, [["render", _sfc_render$1y], ["__file", "/var/www/nextcloud/apps/agora/src/components/Base/modules/QrModal.vue"]]);
const _sfc_main$1x = /* @__PURE__ */ defineComponent({
  __name: "Collapsible",
  props: {
    initialState: { type: String, required: false, default: "max" },
    minHeight: { type: Number, required: false, default: 100 },
    noCollapse: { type: Boolean, required: true, default: false },
    maxHeightVh: { type: Number, required: false, default: 40 }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const slotWrapper = ref(null);
    const containerRef = ref(null);
    const contentHeight = ref(0);
    const height = ref(__props.minHeight);
    const maxHeight = computed(
      () => Math.min(contentHeight.value, window.innerHeight * (__props.maxHeightVh / 100))
    );
    const effectiveMinHeight = computed(() => Math.min(__props.minHeight, maxHeight.value));
    const isTransitioning = ref(false);
    const hasTopOverflow = ref(false);
    const hasBottomOverflow = ref(false);
    const drag = {
      startY: 0,
      startHeight: 0,
      isDragging: false,
      hasInitializedHeight: false
    };
    function getClientY(event) {
      return "touches" in event ? event.touches[0]?.clientY ?? 0 : event.clientY;
    }
    function startResize(event) {
      if (__props.noCollapse) return;
      drag.startY = getClientY(event);
      drag.startHeight = height.value;
      drag.isDragging = false;
      document.addEventListener("mousemove", onMove);
      document.addEventListener("touchmove", onMove);
      document.addEventListener("mouseup", stopResize);
      document.addEventListener("touchend", stopResize);
    }
    function onMove(event) {
      const y = getClientY(event);
      const dy = y - drag.startY;
      if (Math.abs(dy) > 3) drag.isDragging = true;
      let newHeight = drag.startHeight + dy;
      newHeight = Math.max(effectiveMinHeight.value, Math.min(maxHeight.value, newHeight));
      height.value = newHeight;
    }
    function stopResize() {
      if (__props.noCollapse) return;
      document.removeEventListener("mousemove", onMove);
      document.removeEventListener("touchmove", onMove);
      document.removeEventListener("mouseup", stopResize);
      document.removeEventListener("touchend", stopResize);
      if (drag.isDragging) {
        drag.isDragging = false;
      } else {
        requestAnimationFrame(() => {
          drag.isDragging = false;
          height.value = height.value > effectiveMinHeight.value + 10 ? effectiveMinHeight.value : maxHeight.value;
        });
      }
    }
    function updateOverflowIndicators() {
      const el = containerRef.value;
      if (!el) return;
      hasTopOverflow.value = el.scrollTop > 0;
      hasBottomOverflow.value = el.scrollTop + el.clientHeight < el.scrollHeight;
    }
    let observer = null;
    onMounted(() => {
      updateOverflowIndicators();
      containerRef.value?.addEventListener("scroll", updateOverflowIndicators);
      if (slotWrapper.value) {
        observer = new ResizeObserver(() => {
          if (!slotWrapper.value) return;
          if (__props.noCollapse) {
            contentHeight.value = slotWrapper.value.scrollHeight;
            height.value = maxHeight.value;
            return;
          }
          const scrollHeight = slotWrapper.value.scrollHeight;
          const previousMax = maxHeight.value;
          contentHeight.value = scrollHeight;
          const newMax = maxHeight.value;
          const wasAtMax = height.value === previousMax;
          if (wasAtMax && newMax > previousMax) {
            height.value = newMax;
          }
          if (height.value > newMax) {
            height.value = newMax;
          }
          if (!drag.hasInitializedHeight) {
            const target = __props.initialState === "min" ? effectiveMinHeight.value : newMax;
            drag.isDragging = true;
            height.value = target;
            drag.hasInitializedHeight = true;
            requestAnimationFrame(() => {
              drag.isDragging = false;
            });
          }
          updateOverflowIndicators();
        });
        observer.observe(slotWrapper.value);
      }
    });
    watch(height, () => {
      requestAnimationFrame(updateOverflowIndicators);
    });
    onBeforeUnmount(() => {
      observer?.disconnect();
      containerRef.value?.removeEventListener("scroll", updateOverflowIndicators);
    });
    const __returned__ = { slotWrapper, containerRef, contentHeight, height, maxHeight, effectiveMinHeight, isTransitioning, hasTopOverflow, hasBottomOverflow, drag, getClientY, startResize, onMove, stopResize, updateOverflowIndicators, get observer() {
      return observer;
    }, set observer(v) {
      observer = v;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$17 = { class: "collapsible" };
const _hoisted_2$N = {
  ref: "slotWrapper",
  class: "collapsible_content"
};
function _sfc_render$1x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$17, [
    createBaseVNode(
      "div",
      {
        class: normalizeClass([
          "collapsible_wrapper",
          {
            "has-top-shadow": $setup.hasTopOverflow,
            "has-bottom-shadow": $setup.hasBottomOverflow
          }
        ])
      },
      [
        createBaseVNode(
          "div",
          {
            ref: "containerRef",
            class: normalizeClass(["collapsible_container", { "no-transition": $setup.drag.isDragging }]),
            style: normalizeStyle({ height: $setup.height + "px" })
          },
          [
            createBaseVNode(
              "div",
              _hoisted_2$N,
              [
                renderSlot(_ctx.$slots, "default")
              ],
              512
              /* NEED_PATCH */
            )
          ],
          6
          /* CLASS, STYLE */
        )
      ],
      2
      /* CLASS */
    ),
    withDirectives(createBaseVNode(
      "div",
      {
        class: "resize-handle",
        style: normalizeStyle({ top: $setup.isTransitioning ? void 0 : $setup.height + "px" }),
        onTouchstart: withModifiers($setup.startResize, ["prevent"]),
        onMousedown: withModifiers($setup.startResize, ["prevent"])
      },
      null,
      36
      /* STYLE, NEED_HYDRATION */
    ), [
      [vShow, !$props.noCollapse && $setup.contentHeight >= $props.minHeight]
    ])
  ]);
}
const Collapsible = /* @__PURE__ */ _export_sfc$1(_sfc_main$1x, [["render", _sfc_render$1x], ["__file", "/var/www/nextcloud/apps/agora/src/components/Base/modules/Collapsible.vue"]]);
const _sfc_main$1w = /* @__PURE__ */ defineComponent({
  __name: "InquiryCreateDlg",
  emits: ["close", "added"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const emit2 = __emit;
    const inquiryTitle = ref("");
    const inquiryId = ref(null);
    const adding = ref(false);
    const inquiryType = ref("proposal");
    const inquiryTypeOptions = Object.entries(InquiryTypesUI).filter(([key]) => !["official", "suggestion"].includes(key)).map(([key, value]) => ({
      value: key,
      label: value.label
    }));
    const titleIsEmpty = computed(() => inquiryTitle.value === "");
    const disableAddButton = computed(() => titleIsEmpty.value || adding.value);
    async function addInquiry() {
      try {
        adding.value = true;
        const inquiry = await inquiryStore.add({
          type: inquiryType.value,
          title: inquiryTitle.value
        });
        if (inquiry) {
          inquiryId.value = inquiry.id;
          showSuccess(
            translate("agora", '"{inquiryTitle}" has been added', {
              inquiryTitle: inquiry.title
            })
          );
          emit2("added", {
            id: inquiry.id,
            title: inquiry.title
          });
          resetInquiry();
        }
      } catch {
        showError(
          translate("agora", 'Error while creating Inquiry "{inquiryTitle}"', {
            inquiryTitle: inquiryTitle.value
          })
        );
      } finally {
        adding.value = false;
      }
    }
    function resetInquiry() {
      inquiryId.value = null;
      inquiryTitle.value = "";
    }
    const __returned__ = { inquiryStore, emit: emit2, inquiryTitle, inquiryId, adding, inquiryType, inquiryTypeOptions, titleIsEmpty, disableAddButton, addInquiry, resetInquiry, get t() {
      return translate;
    }, get NcButton() {
      return NcButton;
    }, SpeakerIcon, CheckIcon, get ConfigBox() {
      return ConfigBox;
    }, get RadioGroupDiv() {
      return RadioGroupDiv;
    }, get InputDiv() {
      return InputDiv;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$16 = { class: "create-dialog" };
const _hoisted_2$M = { class: "create-buttons" };
function _sfc_render$1w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$16, [
    createVNode($setup["ConfigBox"], {
      name: $setup.t("agora", "Title")
    }, {
      icon: withCtx(() => [
        createVNode($setup["SpeakerIcon"])
      ]),
      default: withCtx(() => [
        createVNode($setup["InputDiv"], {
          modelValue: $setup.inquiryTitle,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inquiryTitle = $event),
          focus: "",
          type: "text",
          placeholder: $setup.t("agora", "Enter title"),
          "helper-text": $setup.t("agora", "Choose a meaningful title for your inquiry"),
          onSubmit: $setup.addInquiry
        }, null, 8, ["modelValue", "placeholder", "helper-text"])
      ]),
      _: 1
      /* STABLE */
    }, 8, ["name"]),
    createVNode($setup["ConfigBox"], {
      name: $setup.t("agora", "Inquiry type")
    }, {
      icon: withCtx(() => [
        createVNode($setup["CheckIcon"])
      ]),
      default: withCtx(() => [
        createVNode($setup["RadioGroupDiv"], {
          modelValue: $setup.inquiryType,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $setup.inquiryType = $event),
          options: $setup.inquiryTypeOptions
        }, null, 8, ["modelValue", "options"])
      ]),
      _: 1
      /* STABLE */
    }, 8, ["name"]),
    createBaseVNode("div", _hoisted_2$M, [
      createVNode($setup["NcButton"], {
        onClick: _cache[2] || (_cache[2] = ($event) => $setup.emit("close"))
      }, {
        default: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.t("agora", "Close")),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }),
      createVNode($setup["NcButton"], {
        disabled: $setup.disableAddButton,
        variant: "primary",
        onClick: $setup.addInquiry
      }, {
        default: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.t("agora", "Add")),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }, 8, ["disabled"])
    ])
  ]);
}
const InquiryCreateDlg = /* @__PURE__ */ _export_sfc$1(_sfc_main$1w, [["render", _sfc_render$1w], ["__file", "/var/www/nextcloud/apps/agora/src/components/Create/InquiryCreateDlg.vue"]]);
const _sfc_main$1v = /* @__PURE__ */ defineComponent({
  __name: "ButtonModal",
  props: /* @__PURE__ */ mergeModels({
    buttonVariant: { type: String, required: false, default: "primary" },
    buttonMode: { type: String, required: false, default: "native" },
    buttonCaption: { type: String, required: false, default: () => translate("agora", "Click") },
    modalSize: { type: String, required: false, default: "normal" },
    noClose: { type: Boolean, required: false, default: false }
  }, {
    "showModal": { type: Boolean, ...{ default: false } },
    "showModalModifiers": {}
  }),
  emits: ["update:showModal"],
  setup(__props, { expose: __expose }) {
    __expose();
    const showModal = useModel(__props, "showModal");
    const __returned__ = { showModal, get NcButton() {
      return NcButton;
    }, get NcModal() {
      return NcModal;
    }, get NcActionButton() {
      return NcActionButton;
    }, get NcAppNavigationNew() {
      return NcAppNavigationNew;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$15 = { class: "button-modal" };
function _sfc_render$1v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$15, [
    createCommentVNode(" The NcAppNavigationNew component is used to display a button in\n			the navigation bar (Edge case for ActionAddInquiry). "),
    $props.buttonMode === "navigation" ? (openBlock(), createBlock($setup["NcAppNavigationNew"], {
      key: 0,
      "button-class": "icon-add",
      text: $props.buttonCaption,
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.showModal = true)
    }, null, 8, ["text"])) : $props.buttonMode === "actionMenu" ? (openBlock(), createBlock($setup["NcActionButton"], {
      key: 1,
      "button-class": "icon-add",
      text: $props.buttonCaption,
      onClick: _cache[1] || (_cache[1] = ($event) => $setup.showModal = true)
    }, null, 8, ["text"])) : $props.buttonMode === "native" ? (openBlock(), createBlock($setup["NcButton"], {
      key: 2,
      variant: $props.buttonVariant,
      "aria-label": $props.buttonCaption,
      onClick: _cache[2] || (_cache[2] = ($event) => $setup.showModal = true)
    }, {
      icon: withCtx(() => [
        renderSlot(_ctx.$slots, "icon")
      ]),
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "caption", {}, () => [
          createTextVNode(
            toDisplayString($props.buttonCaption),
            1
            /* TEXT */
          )
        ])
      ]),
      _: 3
      /* FORWARDED */
    }, 8, ["variant", "aria-label"])) : createCommentVNode("v-if", true),
    createVNode($setup["NcModal"], {
      show: $setup.showModal,
      "onUpdate:show": _cache[3] || (_cache[3] = ($event) => $setup.showModal = $event),
      name: $props.buttonCaption,
      size: $props.modalSize,
      "no-close": $props.noClose,
      onClose: _cache[4] || (_cache[4] = ($event) => $setup.showModal = false)
    }, {
      default: withCtx(() => [
        createBaseVNode(
          "h2",
          null,
          toDisplayString($props.buttonCaption),
          1
          /* TEXT */
        ),
        renderSlot(_ctx.$slots, "modal-content")
      ]),
      _: 3
      /* FORWARDED */
    }, 8, ["show", "name", "size", "no-close"])
  ]);
}
const ButtonModal = /* @__PURE__ */ _export_sfc$1(_sfc_main$1v, [["render", _sfc_render$1v], ["__file", "/var/www/nextcloud/apps/agora/src/components/Base/modules/ButtonModal.vue"]]);
const _sfc_main$1u = /* @__PURE__ */ defineComponent({
  __name: "ActionAddInquiry",
  props: {
    caption: { type: String, required: false, default: () => translate("agora", "Add inquiry") },
    modalSize: { type: String, required: false, default: "normal" },
    buttonMode: { type: String, required: false, default: "native" }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const router2 = useRouter();
    const sessionStore = useSessionStore();
    const newInquiry = ref({
      id: 0,
      title: ""
    });
    const showModal = ref(false);
    function addedInquiry(payLoad) {
      newInquiry.value = payLoad;
      showModal.value = false;
      showConfirmationDialog.value = true;
    }
    const confirmationDialogMessage = computed(
      () => translate("agora", '"{inquiryTitle}" has been successfully created.', {
        inquiryTitle: newInquiry.value.title
      })
    );
    const confirmationDialogName = translate("agora", "Inquiry created");
    const showConfirmationDialog = ref(false);
    const confirmationDialogProps = {
      buttons: [
        {
          label: translate("agora", "Add another inquiry"),
          callback: () => {
            addAnotherInquiry();
          }
        },
        {
          label: translate("agora", "Open inquiry now"),
          variant: "primary",
          callback: () => {
            router2.push({
              name: "inquiry",
              params: { id: newInquiry.value.id }
            });
          }
        }
      ]
    };
    function addAnotherInquiry() {
      showModal.value = true;
      showConfirmationDialog.value = false;
    }
    const __returned__ = { router: router2, sessionStore, newInquiry, showModal, addedInquiry, confirmationDialogMessage, confirmationDialogName, showConfirmationDialog, confirmationDialogProps, addAnotherInquiry, get t() {
      return translate;
    }, ButtonModal, InquiryCreateDlg, PlusIcon, get NcDialog() {
      return NcDialog;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$1u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment$1,
    null,
    [
      $setup.sessionStore.appPermissions.inquiryCreation ? (openBlock(), createBlock($setup["ButtonModal"], {
        key: 0,
        "show-modal": $setup.showModal,
        "onUpdate:showModal": _cache[1] || (_cache[1] = ($event) => $setup.showModal = $event),
        "button-caption": $props.buttonMode === "navigation" ? $setup.t("agora", "New inquiry") : $props.caption,
        "modal-size": $props.modalSize,
        "button-mode": $props.buttonMode,
        "button-variant": "primary"
      }, {
        icon: withCtx(() => [
          createVNode($setup["PlusIcon"], {
            size: 20,
            decorative: ""
          })
        ]),
        "modal-content": withCtx(() => [
          createVNode($setup["InquiryCreateDlg"], {
            onAdded: $setup.addedInquiry,
            onClose: _cache[0] || (_cache[0] = ($event) => $setup.showModal = false)
          })
        ]),
        _: 1
        /* STABLE */
      }, 8, ["show-modal", "button-caption", "modal-size", "button-mode"])) : createCommentVNode("v-if", true),
      createVNode($setup["NcDialog"], mergeProps({
        open: $setup.showConfirmationDialog,
        "onUpdate:open": _cache[2] || (_cache[2] = ($event) => $setup.showConfirmationDialog = $event)
      }, $setup.confirmationDialogProps, {
        name: $setup.confirmationDialogName,
        message: $setup.confirmationDialogMessage
      }), null, 16, ["open", "name", "message"])
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
const ActionAddInquiry = /* @__PURE__ */ _export_sfc$1(_sfc_main$1u, [["render", _sfc_render$1u], ["__file", "/var/www/nextcloud/apps/agora/src/components/Actions/modules/ActionAddInquiry.vue"]]);
const iconSize = 20;
const _sfc_main$1t = /* @__PURE__ */ defineComponent({
  __name: "Navigation",
  setup(__props, { expose: __expose }) {
    __expose();
    const router2 = useRouter();
    const inquiriesStore = useInquiriesStore();
    const inquiryGroupsStore = useInquiryGroupsStore();
    const sessionStore = useSessionStore();
    const preferencesStore = usePreferencesStore();
    const icons = {
      relevant: {
        id: "relevant",
        iconComponent: NavigationIcons.relevant
      },
      my: {
        id: "my",
        iconComponent: NavigationIcons.myInquiries
      },
      private: {
        id: "private",
        iconComponent: NavigationIcons.private
      },
      participated: {
        id: "participated",
        iconComponent: NavigationIcons.participated
      },
      open: {
        id: "open",
        iconComponent: NavigationIcons.open
      },
      all: {
        id: "all",
        iconComponent: NavigationIcons.all
      },
      closed: {
        id: "closed",
        iconComponent: NavigationIcons.closed
      },
      archived: {
        id: "archived",
        iconComponent: NavigationIcons.archived
      },
      admin: {
        id: "admin",
        iconComponent: NavigationIcons.administration
      }
    };
    const createDlgToggle = ref(false);
    function getIconComponent(iconId) {
      return icons[iconId].iconComponent;
    }
    function toggleArchive(inquiryId) {
      try {
        inquiriesStore.toggleArchive({ inquiryId });
      } catch {
        showError(translate("agora", "Error archiving/restoring inquiry."));
      }
    }
    function deleteInquiry(inquiryId) {
      try {
        inquiriesStore.delete({ inquiryId });
      } catch {
        showError(translate("agora", "Error deleting inquiry."));
      }
    }
    function showSettings() {
      emit(Event$1.ShowSettings, null);
    }
    async function inquiryAdded(payLoad) {
      createDlgToggle.value = false;
      router2.push({
        name: "inquiry",
        params: { id: payLoad.id }
      });
    }
    onMounted(() => {
      inquiriesStore.load(false);
    });
    const __returned__ = { router: router2, inquiriesStore, inquiryGroupsStore, sessionStore, preferencesStore, iconSize, icons, createDlgToggle, getIconComponent, toggleArchive, deleteInquiry, showSettings, inquiryAdded, get t() {
      return translate;
    }, get NcAppNavigation() {
      return NcAppNavigation;
    }, get NcAppNavigationNew() {
      return NcAppNavigationNew;
    }, get NcAppNavigationItem() {
      return NcAppNavigationItem;
    }, get NcCounterBubble() {
      return NcCounterBubble;
    }, InquiryNavigationItems, get NavigationIcons() {
      return NavigationIcons;
    }, InquiryCreateDlg, ActionAddInquiry, get NcAppNavigationSpacer() {
      return NcAppNavigationSpacer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$14 = { class: "agora-navigation__header" };
const _hoisted_2$L = {
  key: 0,
  class: "agora-navigation__section"
};
const _hoisted_3$I = { class: "agora-navigation__section-title" };
const _hoisted_4$E = {
  key: 0,
  class: "agora-navigation__sub-list"
};
const _hoisted_5$b = { class: "agora-navigation__section" };
const _hoisted_6$9 = { class: "agora-navigation__section-title" };
const _hoisted_7$8 = {
  key: 0,
  class: "agora-navigation__sub-list"
};
const _hoisted_8$8 = { class: "agora-navigation__footer" };
function _sfc_render$1t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcAppNavigation"], { class: "agora-navigation" }, {
    list: withCtx(() => [
      createCommentVNode(" Groups Section "),
      $setup.inquiryGroupsStore.inquiryGroupsSorted.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_2$L, [
        createBaseVNode(
          "h3",
          _hoisted_3$I,
          toDisplayString($setup.t("agora", "Categories")),
          1
          /* TEXT */
        ),
        (openBlock(true), createElementBlock(
          Fragment$1,
          null,
          renderList($setup.inquiryGroupsStore.inquiryGroupsSorted, (inquiryGroup) => {
            return openBlock(), createBlock($setup["NcAppNavigationItem"], {
              key: inquiryGroup.id,
              name: inquiryGroup.name,
              title: inquiryGroup.titleExt,
              "allow-collapse": "",
              to: {
                name: "group",
                params: { slug: inquiryGroup.slug }
              },
              class: "agora-navigation__group-item",
              open: false
            }, {
              icon: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent($setup.NavigationIcons.group)))
              ]),
              counter: withCtx(() => [
                createVNode($setup["NcCounterBubble"], {
                  count: $setup.inquiryGroupsStore.countInquiriesInInquiryGroups[inquiryGroup.id],
                  class: "agora-navigation__counter"
                }, null, 8, ["count"])
              ]),
              default: withCtx(() => [
                $setup.sessionStore.appSettings.navigationInquiriesInList ? (openBlock(), createElementBlock("ul", _hoisted_4$E, [
                  (openBlock(true), createElementBlock(
                    Fragment$1,
                    null,
                    renderList($setup.inquiriesStore.groupList(inquiryGroup.inquiryIds), (inquiry) => {
                      return openBlock(), createBlock($setup["InquiryNavigationItems"], {
                        key: inquiry.id,
                        inquiry,
                        onToggleArchive: ($event) => $setup.toggleArchive(inquiry.id),
                        onDeleteInquiry: ($event) => $setup.deleteInquiry(inquiry.id)
                      }, null, 8, ["inquiry", "onToggleArchive", "onDeleteInquiry"]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  )),
                  $setup.inquiriesStore.groupList(inquiryGroup.inquiryIds).length === 0 ? (openBlock(), createBlock($setup["NcAppNavigationItem"], {
                    key: 0,
                    name: $setup.t("agora", "No inquiries found"),
                    class: "agora-navigation__empty"
                  }, null, 8, ["name"])) : createCommentVNode("v-if", true),
                  inquiryGroup.inquiryIds.length > $setup.inquiriesStore.meta.maxInquiriesInNavigation ? (openBlock(), createBlock($setup["NcAppNavigationItem"], {
                    key: 1,
                    class: "force-not-active",
                    to: {
                      name: "group",
                      params: { slug: inquiryGroup.slug }
                    },
                    name: $setup.t("agora", "View all")
                  }, {
                    icon: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent($setup.NavigationIcons.goTo)))
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["to", "name"])) : createCommentVNode("v-if", true)
                ])) : createCommentVNode("v-if", true)
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["name", "title", "to"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ])) : createCommentVNode("v-if", true),
      $setup.inquiryGroupsStore.inquiryGroups.length ? (openBlock(), createBlock($setup["NcAppNavigationSpacer"], { key: 1 })) : createCommentVNode("v-if", true),
      createCommentVNode(" Filters Section "),
      createBaseVNode("div", _hoisted_5$b, [
        createBaseVNode(
          "h3",
          _hoisted_6$9,
          toDisplayString($setup.t("agora", "Filters")),
          1
          /* TEXT */
        ),
        (openBlock(true), createElementBlock(
          Fragment$1,
          null,
          renderList($setup.inquiriesStore.navigationCategories, (inquiryCategory) => {
            return openBlock(), createBlock($setup["NcAppNavigationItem"], {
              key: inquiryCategory.id,
              name: inquiryCategory.title,
              title: inquiryCategory.titleExt,
              "allow-collapse": $setup.sessionStore.appSettings.navigationInquiriesInList,
              pinned: inquiryCategory.pinned,
              to: {
                name: "list",
                params: { type: inquiryCategory.id }
              },
              class: "agora-navigation__filter-item",
              open: false
            }, {
              icon: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent($setup.getIconComponent(inquiryCategory.id)), { size: $setup.iconSize }))
              ]),
              counter: withCtx(() => [
                createVNode($setup["NcCounterBubble"], {
                  count: $setup.inquiriesStore.inquiriesCount[inquiryCategory.id],
                  class: "agora-navigation__counter"
                }, null, 8, ["count"])
              ]),
              default: withCtx(() => [
                $setup.sessionStore.appSettings.navigationInquiriesInList ? (openBlock(), createElementBlock("ul", _hoisted_7$8, [
                  (openBlock(true), createElementBlock(
                    Fragment$1,
                    null,
                    renderList($setup.inquiriesStore.navigationList(inquiryCategory.id), (inquiry) => {
                      return openBlock(), createBlock($setup["InquiryNavigationItems"], {
                        key: inquiry.id,
                        inquiry,
                        onToggleArchive: ($event) => $setup.toggleArchive(inquiry.id),
                        onDeleteInquiry: ($event) => $setup.deleteInquiry(inquiry.id)
                      }, null, 8, ["inquiry", "onToggleArchive", "onDeleteInquiry"]);
                    }),
                    128
                    /* KEYED_FRAGMENT */
                  )),
                  $setup.inquiriesStore.navigationList(inquiryCategory.id).length === 0 ? (openBlock(), createBlock($setup["NcAppNavigationItem"], {
                    key: 0,
                    name: $setup.t("agora", "No inquiries found"),
                    class: "agora-navigation__empty"
                  }, null, 8, ["name"])) : createCommentVNode("v-if", true),
                  $setup.inquiriesStore.navigationList(inquiryCategory.id) > $setup.inquiriesStore.meta.maxInquiriesInNavigation ? (openBlock(), createBlock($setup["NcAppNavigationItem"], {
                    key: 1,
                    class: "force-not-active",
                    to: {
                      name: "list",
                      params: { type: inquiryCategory.id }
                    },
                    name: $setup.t("agora", "View all")
                  }, {
                    icon: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent($setup.NavigationIcons.goTo)))
                    ]),
                    _: 2
                    /* DYNAMIC */
                  }, 1032, ["to", "name"])) : createCommentVNode("v-if", true)
                ])) : createCommentVNode("v-if", true)
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["name", "title", "allow-collapse", "pinned", "to"]);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ])
    ]),
    footer: withCtx(() => [
      createBaseVNode("ul", _hoisted_8$8, [
        createVNode($setup["NcAppNavigationItem"], {
          name: $setup.t("agora", "Settings"),
          class: "agora-navigation__footer-item",
          onClick: _cache[2] || (_cache[2] = ($event) => $setup.showSettings())
        }, {
          icon: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent($setup.NavigationIcons.settings)))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"])
      ])
    ]),
    default: withCtx(() => [
      $setup.preferencesStore.useActionAddInquiryInNavigation && $setup.sessionStore.appPermissions.inquiryCreation ? (openBlock(), createBlock($setup["ActionAddInquiry"], {
        key: 0,
        "button-mode": "navigation"
      })) : createCommentVNode("v-if", true),
      createBaseVNode("div", _hoisted_1$14, [
        $setup.preferencesStore.useNcAppNavigationNew && $setup.sessionStore.appPermissions.inquiryCreation ? (openBlock(), createBlock($setup["NcAppNavigationNew"], {
          key: 0,
          text: $setup.t("agora", "New inquiry"),
          "button-class": "icon-add",
          class: "agora-navigation__new-btn",
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.createDlgToggle = !$setup.createDlgToggle)
        }, {
          icon: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent($setup.NavigationIcons.add)))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["text"])) : createCommentVNode("v-if", true)
      ]),
      withDirectives(createVNode(
        $setup["InquiryCreateDlg"],
        {
          onAdded: $setup.inquiryAdded,
          onClose: _cache[1] || (_cache[1] = ($event) => $setup.createDlgToggle = false)
        },
        null,
        512
        /* NEED_PATCH */
      ), [
        [vShow, $setup.createDlgToggle]
      ])
    ]),
    _: 1
    /* STABLE */
  });
}
const Navigation = /* @__PURE__ */ _export_sfc$1(_sfc_main$1t, [["render", _sfc_render$1t], ["__file", "/var/www/nextcloud/apps/agora/src/views/Navigation.vue"]]);
const _sfc_main$1s = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: true
  },
  __name: "UserItem",
  props: {
    disabled: { type: Boolean, required: false, default: false },
    deletedState: { type: Boolean, required: false, default: false },
    lockedState: { type: Boolean, required: false, default: false },
    hideNames: { type: Boolean, required: false, default: false },
    showEmail: { type: Boolean, required: false, default: false },
    disableMenu: { type: Boolean, required: false, default: true },
    disableTooltip: { type: Boolean, required: false, default: false },
    resolveInfo: { type: Boolean, required: false, default: false },
    description: { type: String, required: false },
    label: { type: String, required: false, default: "" },
    type: { type: String, required: false, default: "" },
    user: { type: Object, required: false, default: () => ({
      id: "",
      displayName: "",
      emailAddress: "",
      isNoUser: true,
      isAdmin: false,
      isOfficial: false,
      isModerator: false,
      type: "",
      subName: null,
      subtitle: null,
      desc: null,
      organisation: null,
      languageCode: "",
      localeCode: null,
      timeZone: null,
      categories: null
    }) },
    showTypeIcon: { type: Boolean, required: false, default: false },
    iconSize: { type: Number, required: false, default: 32 },
    mdIconSize: { type: Number, required: false, default: 20 },
    typeIconSize: { type: Number, required: false, default: 16 },
    hideStatus: { type: Boolean, required: false, default: false },
    condensed: { type: Boolean, required: false, default: false },
    delegatedFromGroup: { type: Boolean, required: false, default: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const route = useRoute();
    const isGuestComputed = computed(() => route.name === "publicInquiry" || __props.user.isNoUser);
    const avatarProps = computed(() => ({
      user: avatarUserId.value,
      showUserStatus: showUserStatusComputed.value,
      isGuest: isGuestComputed.value,
      displayName: labelComputed.value,
      size: __props.iconSize,
      disableTooltip: __props.disableTooltip,
      disableMenu: __props.disableMenu,
      isNoUser: __props.user.isNoUser
    }));
    const useIconSlot = computed(
      () => [
        "internalAccess",
        "addPublicLink",
        "public",
        "contactGroup",
        "group",
        "circle",
        "deleted",
        "anonymous"
      ].includes(typeComputed.value)
    );
    const typeComputed = computed(() => __props.user.type ?? __props.type);
    const descriptionComputed = computed(() => {
      if (__props.condensed) {
        return "";
      }
      if (__props.delegatedFromGroup) {
        return translate("agora", "Inquiry group access");
      }
      if (__props.deletedState) {
        return translate("agora", "(deleted)");
      }
      if (__props.lockedState) {
        return translate("agora", "(locked)");
      }
      if (__props.description !== "") {
        return __props.description;
      }
      if (typeComputed.value === "public") {
        return publicShareDescription;
      }
      if (typeComputed.value === "deleted") {
        return translate("agora", "The participant got removed from this inquiry");
      }
      if (typeComputed.value === "admin") {
        return translate("agora", "Administrative rights granted");
      }
      if (typeComputed.value === "anonymous") {
        return translate("agora", "Anonymized participant");
      }
      return emailAddressComputed;
    });
    const labelComputed = computed(() => {
      if (__props.label !== "") {
        return __props.label;
      }
      if (typeComputed.value === "public") {
        return publicShareLabel.value;
      }
      if (typeComputed.value === "deleted") {
        return translate("agora", "Deleted participant");
      }
      return __props.user.displayName ?? __props.user.id;
    });
    const avatarUserId = computed(() => {
      if (isGuestComputed.value) {
        return __props.user.displayName;
      }
      return __props.user.id;
    });
    const publicShareDescription = computed(() => {
      if (__props.label === "") {
        return translate("agora", "Token: {token}", { token: __props.user.id });
      }
      return translate("agora", "Public link: {token}", { token: __props.user.id });
    });
    const publicShareLabel = computed(() => {
      if (__props.label === "") {
        return translate("agora", "Public link");
      }
      return __props.label;
    });
    const emailAddressComputed = computed(() => {
      if (__props.resolveInfo && (typeComputed.value === "contactGroup" || typeComputed.value === "circle")) {
        return translate("agora", "Resolve this group first!");
      }
      if (__props.showEmail && __props.user.emailAddress !== __props.user.displayName && (typeComputed.value === "external" || typeComputed.value === "email")) {
        return __props.user.emailAddress;
      }
      return "";
    });
    const showUserStatusComputed = computed(() => __props.hideStatus && Boolean(getCurrentUser()));
    function showMenu() {
      return true;
    }
    const __returned__ = { route, isGuestComputed, avatarProps, useIconSlot, typeComputed, descriptionComputed, labelComputed, avatarUserId, publicShareDescription, publicShareLabel, emailAddressComputed, showUserStatusComputed, showMenu, get StatusIcons() {
      return StatusIcons;
    }, get NcAvatar() {
      return NcAvatar;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$13 = { class: "avatar-wrapper" };
const _hoisted_2$K = {
  key: 0,
  class: "hover-menu"
};
const _hoisted_3$H = {
  key: 0,
  class: "user-item__name"
};
const _hoisted_4$D = { class: "name" };
const _hoisted_5$a = { class: "description" };
function _sfc_render$1s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass([
        "user-item",
        $setup.typeComputed,
        {
          disabled: $props.disabled,
          condensed: $props.condensed
        }
      ])
    },
    [
      createBaseVNode("div", _hoisted_1$13, [
        createVNode(
          $setup["NcAvatar"],
          mergeProps($setup.avatarProps, {
            class: "user-item__avatar",
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.showMenu())
          }),
          createSlots({
            _: 2
            /* DYNAMIC */
          }, [
            $setup.useIconSlot ? {
              name: "icon",
              fn: withCtx(() => [
                $setup.typeComputed === "public" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.LinkIcon), {
                  key: 0,
                  size: $props.mdIconSize
                }, null, 8, ["size"])) : createCommentVNode("v-if", true),
                $setup.typeComputed === "addPublicLink" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.LinkIcon), {
                  key: 1,
                  size: $props.mdIconSize
                }, null, 8, ["size"])) : createCommentVNode("v-if", true),
                $setup.typeComputed === "anonymous" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.AnonymousIcon), {
                  key: 2,
                  size: $props.mdIconSize
                }, null, 8, ["size"])) : createCommentVNode("v-if", true),
                $setup.typeComputed === "internalAccess" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.LinkIcon), {
                  key: 3,
                  size: $props.mdIconSize
                }, null, 8, ["size"])) : createCommentVNode("v-if", true),
                $setup.typeComputed === "contactGroup" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.ContactGroupIcon), {
                  key: 4,
                  size: $props.mdIconSize
                }, null, 8, ["size"])) : createCommentVNode("v-if", true),
                $setup.typeComputed === "group" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.AccountMultiple), {
                  key: 5,
                  size: $props.mdIconSize
                }, null, 8, ["size"])) : createCommentVNode("v-if", true),
                $setup.typeComputed === "circle" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.CircleIcon), {
                  key: 6,
                  size: $props.mdIconSize
                }, null, 8, ["size"])) : createCommentVNode("v-if", true),
                $setup.typeComputed === "deleted" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.DeletedUserIcon), {
                  key: 7,
                  size: $props.mdIconSize
                }, null, 8, ["size"])) : createCommentVNode("v-if", true)
              ]),
              key: "0"
            } : void 0
          ]),
          1040
          /* FULL_PROPS, DYNAMIC_SLOTS */
        ),
        _ctx.$slots.menu ? (openBlock(), createElementBlock("div", _hoisted_2$K, [
          renderSlot(_ctx.$slots, "menu")
        ])) : createCommentVNode("v-if", true),
        $props.showTypeIcon && $setup.typeComputed === "admin" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.AdminIcon), {
          key: 1,
          size: $props.typeIconSize,
          class: "type-icon"
        }, null, 8, ["size"])) : $props.showTypeIcon && $setup.typeComputed === "contact" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.ContactIcon), {
          key: 2,
          size: $props.typeIconSize,
          class: "type-icon"
        }, null, 8, ["size"])) : $props.showTypeIcon && $setup.typeComputed === "email" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.EmailIcon), {
          key: 3,
          size: $props.typeIconSize,
          class: "type-icon"
        }, null, 8, ["size"])) : $props.showTypeIcon && $setup.typeComputed === "external" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.ShareIcon), {
          key: 4,
          size: $props.typeIconSize,
          class: "type-icon"
        }, null, 8, ["size"])) : $props.showTypeIcon && $props.delegatedFromGroup ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.InquiryGroupIcon), {
          key: 5,
          size: $props.typeIconSize,
          class: "type-icon"
        }, null, 8, ["size"])) : createCommentVNode("v-if", true)
      ]),
      renderSlot(_ctx.$slots, "status"),
      !$props.hideNames ? (openBlock(), createElementBlock("div", _hoisted_3$H, [
        createBaseVNode(
          "div",
          _hoisted_4$D,
          toDisplayString($setup.labelComputed),
          1
          /* TEXT */
        ),
        createBaseVNode(
          "div",
          _hoisted_5$a,
          toDisplayString($setup.descriptionComputed),
          1
          /* TEXT */
        )
      ])) : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default")
    ],
    2
    /* CLASS */
  );
}
const UserItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$1s, [["render", _sfc_render$1s], ["__file", "/var/www/nextcloud/apps/agora/src/components/User/UserItem.vue"]]);
const _sfc_main$1r = /* @__PURE__ */ defineComponent({
  __name: "ComboTable",
  props: {
    viewMode: { type: String, required: true }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const comboStore = useComboStore();
    const __returned__ = { comboStore, UserItem };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$12 = { class: "user-column" };
const _hoisted_2$J = ["title"];
function _sfc_render$1r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["combo-table", $props.viewMode])
    },
    [
      createBaseVNode("div", _hoisted_1$12, [
        _cache[0] || (_cache[0] = createBaseVNode(
          "div",
          { class: "spacer" },
          null,
          -1
          /* CACHED */
        )),
        (openBlock(true), createElementBlock(
          Fragment$1,
          null,
          renderList($setup.comboStore.inquiries, (inquiry) => {
            return openBlock(), createElementBlock("div", {
              key: inquiry.id,
              title: inquiry.title,
              class: "inquiry-group"
            }, [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.comboStore.participantsInInquiry(inquiry.id), (participant) => {
                  return openBlock(), createElementBlock("div", {
                    key: `${participant.user.id}_${participant.inquiryId}`,
                    class: "participant"
                  }, [
                    createVNode(
                      $setup["UserItem"],
                      mergeProps({ ref_for: true }, participant, { condensed: "" }),
                      null,
                      16
                      /* FULL_PROPS */
                    )
                  ]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ], 8, _hoisted_2$J);
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ]),
      createVNode(TransitionGroup, {
        name: "list",
        tag: "div",
        class: "inquiry-grid"
      }, {
        default: withCtx(() => [
          createCommentVNode('	<InquiryColumn\n				v-for="option in comboStore.uniqueOptions"\n				:key="option.id"\n				:option="option" />')
        ]),
        _: 1
        /* STABLE */
      })
    ],
    2
    /* CLASS */
  );
}
const ComboTable = /* @__PURE__ */ _export_sfc$1(_sfc_main$1r, [["render", _sfc_render$1r], ["__file", "/var/www/nextcloud/apps/agora/src/components/Combo/ComboTable.vue"]]);
const _sfc_main$1q = {
  name: "DeleteIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$11 = ["aria-hidden", "aria-label"];
const _hoisted_2$I = ["fill", "width", "height"];
const _hoisted_3$G = { d: "M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" };
const _hoisted_4$C = { key: 0 };
function _sfc_render$1q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon delete-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$G, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$C,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$I))
  ], 16, _hoisted_1$11);
}
const DeleteIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1q, [["render", _sfc_render$1q], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Delete.vue"]]);
const _sfc_main$1p = {
  name: "RecycleIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$10 = ["aria-hidden", "aria-label"];
const _hoisted_2$H = ["fill", "width", "height"];
const _hoisted_3$F = { d: "M21.82,15.42L19.32,19.75C18.83,20.61 17.92,21.06 17,21H15V23L12.5,18.5L15,14V16H17.82L15.6,12.15L19.93,9.65L21.73,12.77C22.25,13.54 22.32,14.57 21.82,15.42M9.21,3.06H14.21C15.19,3.06 16.04,3.63 16.45,4.45L17.45,6.19L19.18,5.19L16.54,9.6L11.39,9.69L13.12,8.69L11.71,6.24L9.5,10.09L5.16,7.59L6.96,4.47C7.37,3.64 8.22,3.06 9.21,3.06M5.05,19.76L2.55,15.43C2.06,14.58 2.13,13.56 2.64,12.79L3.64,11.06L1.91,10.06L7.05,10.14L9.7,14.56L7.97,13.56L6.56,16H11V21H7.4C6.47,21.07 5.55,20.61 5.05,19.76Z" };
const _hoisted_4$B = { key: 0 };
function _sfc_render$1p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon recycle-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$F, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$B,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$H))
  ], 16, _hoisted_1$10);
}
const RestoreIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1p, [["render", _sfc_render$1p], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Recycle.vue"]]);
const _sfc_main$1o = {
  name: "LockIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$$ = ["aria-hidden", "aria-label"];
const _hoisted_2$G = ["fill", "width", "height"];
const _hoisted_3$E = { d: "M12,17A2,2 0 0,0 14,15C14,13.89 13.1,13 12,13A2,2 0 0,0 10,15A2,2 0 0,0 12,17M18,8A2,2 0 0,1 20,10V20A2,2 0 0,1 18,22H6A2,2 0 0,1 4,20V10C4,8.89 4.9,8 6,8H7V6A5,5 0 0,1 12,1A5,5 0 0,1 17,6V8H18M12,3A3,3 0 0,0 9,6V8H15V6A3,3 0 0,0 12,3Z" };
const _hoisted_4$A = { key: 0 };
function _sfc_render$1o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon lock-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$E, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$A,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$G))
  ], 16, _hoisted_1$$);
}
const LockedIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1o, [["render", _sfc_render$1o], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Lock.vue"]]);
const _sfc_main$1n = {
  name: "ArrowULeftTopIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$_ = ["aria-hidden", "aria-label"];
const _hoisted_2$F = ["fill", "width", "height"];
const _hoisted_3$D = { d: "M20 13.5C20 17.09 17.09 20 13.5 20H6V18H13.5C16 18 18 16 18 13.5S16 9 13.5 9H7.83L10.91 12.09L9.5 13.5L4 8L9.5 2.5L10.92 3.91L7.83 7H13.5C17.09 7 20 9.91 20 13.5Z" };
const _hoisted_4$z = { key: 0 };
function _sfc_render$1n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon arrow-u-left-top-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$D, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$z,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$F))
  ], 16, _hoisted_1$_);
}
const UndoIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1n, [["render", _sfc_render$1n], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/ArrowULeftTop.vue"]]);
const _sfc_main$1m = /* @__PURE__ */ defineComponent({
  __name: "ActionDelete",
  props: {
    timeout: { type: Number, required: false, default: 4 },
    name: { type: String, required: false, default: () => translate("agora", "Delete") },
    iconSize: { type: Number, required: false, default: 20 },
    restore: { type: Boolean, required: false, default: false },
    lock: { type: Boolean, required: false, default: false }
  },
  emits: ["delete", "restore"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const deleteInterval = ref(null);
    const deleteTimeout = ref(null);
    const countdown = ref(4);
    const countdownTitle = computed(
      () => translatePlural(
        "inquiries",
        "Deleting in {countdown} second",
        "Deleting in {countdown} seconds",
        countdown.value,
        { countdown: countdown.value }
      )
    );
    const computedTitle = computed(() => deleteTimeout.value ? countdownTitle.value : __props.name);
    const emit2 = __emit;
    function deleteItem() {
      if (__props.timeout === 0) {
        emit2("delete");
        return;
      }
      countdown.value = __props.timeout;
      deleteInterval.value = setInterval(() => {
        countdown.value -= 1;
        if (countdown.value < 0) {
          countdown.value = 0;
        }
      }, 1e3);
      deleteTimeout.value = setTimeout(() => {
        emit2("delete");
        deleteTimeout.value = null;
        deleteInterval.value = null;
        countdown.value = __props.timeout;
      }, __props.timeout * 1e3);
    }
    function cancelDelete() {
      clearTimeout(deleteTimeout.value);
      clearInterval(deleteInterval.value);
      deleteTimeout.value = null;
      deleteInterval.value = null;
      countdown.value = __props.timeout;
    }
    function restoreItem() {
      clearTimeout(deleteTimeout.value);
      clearInterval(deleteInterval.value);
      deleteTimeout.value = null;
      deleteInterval.value = null;
      emit2("restore");
    }
    const __returned__ = { deleteInterval, deleteTimeout, countdown, countdownTitle, computedTitle, emit: emit2, deleteItem, cancelDelete, restoreItem, get NcButton() {
      return NcButton;
    }, DeleteIcon, RestoreIcon, LockIcon: LockedIcon, UndoIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$Z = { class: "" };
function _sfc_render$1m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$Z, [
    createVNode($setup["NcButton"], {
      name: $setup.computedTitle,
      variant: "tertiary",
      "aria-label": $setup.computedTitle
    }, {
      icon: withCtx(() => [
        $props.restore ? (openBlock(), createBlock($setup["RestoreIcon"], {
          key: 0,
          size: $props.iconSize,
          onClick: _cache[0] || (_cache[0] = ($event) => $setup.restoreItem())
        }, null, 8, ["size"])) : $setup.deleteTimeout ? (openBlock(), createBlock($setup["UndoIcon"], {
          key: 1,
          size: $props.iconSize,
          onClick: _cache[1] || (_cache[1] = ($event) => $setup.cancelDelete())
        }, null, 8, ["size"])) : $props.lock ? (openBlock(), createBlock($setup["LockIcon"], {
          key: 2,
          size: $props.iconSize,
          onClick: _cache[2] || (_cache[2] = ($event) => $setup.deleteItem())
        }, null, 8, ["size"])) : (openBlock(), createBlock($setup["DeleteIcon"], {
          key: 3,
          size: $props.iconSize,
          onClick: _cache[3] || (_cache[3] = ($event) => $setup.deleteItem())
        }, null, 8, ["size"]))
      ]),
      _: 1
      /* STABLE */
    }, 8, ["name", "aria-label"])
  ]);
}
const ActionDelete = /* @__PURE__ */ _export_sfc$1(_sfc_main$1m, [["render", _sfc_render$1m], ["__file", "/var/www/nextcloud/apps/agora/src/components/Actions/modules/ActionDelete.vue"]]);
const _sfc_main$1l = /* @__PURE__ */ defineComponent({
  __name: "ActionDeleteOrphanedInquiries",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiriesStore = useInquiriesStore();
    const caption = translate("agora", "Delete orphaned");
    const __returned__ = { inquiriesStore, caption, get NcButton() {
      return NcButton;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$Y = { class: "action toggle-sidebar" };
function _sfc_render$1l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$Y, [
    createVNode($setup["NcButton"], {
      variant: "primary",
      "aria-label": $setup.caption,
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.inquiriesStore.removeOrphanedInquiries())
    }, {
      default: withCtx(() => [
        createTextVNode(
          toDisplayString($setup.caption),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    }, 8, ["aria-label"])
  ]);
}
const ActionDeleteOrphanedInquiries = /* @__PURE__ */ _export_sfc$1(_sfc_main$1l, [["render", _sfc_render$1l], ["__file", "/var/www/nextcloud/apps/agora/src/components/Actions/modules/ActionDeleteOrphanedInquiries.vue"]]);
const _sfc_main$1k = /* @__PURE__ */ defineComponent({
  __name: "ActionOpenSharesSidebar",
  setup(__props, { expose: __expose }) {
    __expose();
    const caption = translate("agora", "Edit access");
    function clickAction() {
      emit(Event$1.SidebarToggle, {
        open: true,
        activeTab: "sharing"
      });
    }
    const __returned__ = { caption, clickAction, get NcButton() {
      return NcButton;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$X = { class: "action toggle-sidebar" };
function _sfc_render$1k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$X, [
    createVNode($setup["NcButton"], {
      variant: "primary",
      "aria-label": $setup.caption,
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.clickAction())
    }, {
      default: withCtx(() => [
        createTextVNode(
          toDisplayString($setup.caption),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    }, 8, ["aria-label"])
  ]);
}
const ActionOpenSharesSidebar = /* @__PURE__ */ _export_sfc$1(_sfc_main$1k, [["render", _sfc_render$1k], ["__file", "/var/www/nextcloud/apps/agora/src/components/Actions/modules/ActionOpenSharesSidebar.vue"]]);
const COOKIE_LIFETIME = 30;
const _sfc_main$1j = /* @__PURE__ */ defineComponent({
  __name: "PublicRegisterModal",
  emits: ["close"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const route = useRoute();
    const router2 = useRouter();
    const emit2 = __emit;
    const sessionStore = useSessionStore();
    const inquiryStore = useInquiryStore();
    const checkStatus = ref({
      email: "empty",
      userName: "empty"
    });
    const sendRegistration = ref(false);
    const userName = ref("");
    const emailAddress = ref("");
    const saveCookie = ref(true);
    const registrationIsValid = computed(
      () => checkStatus.value.userName === "valid" && (checkStatus.value.email === "valid" || emailAddress.value.length === 0 && sessionStore.share.publicInquiryEmail !== "mandatory")
    );
    const disableSubmit = computed(
      () => !registrationIsValid.value || checkStatus.value.userName === "checking" || sendRegistration.value
    );
    const emailGeneratedStatus = computed(
      () => checkStatus.value.email === "empty" ? sessionStore.share.publicInquiryEmail : checkStatus.value.email
    );
    const offerCookies = computed(() => sessionStore.share.type === "public");
    const loginLink = computed(() => {
      const redirectUrl = router2.resolve({
        name: "publicInquiry",
        params: { token: route.params.token }
      }).href;
      return `${_$2("/login")}?redirect_url=${redirectUrl}`;
    });
    const userNameHint = computed(() => {
      if (checkStatus.value.userName === "checking") {
        return translate("agora", "Checking name â¦");
      }
      if (checkStatus.value.userName === "empty") {
        return translate("agora", "A name is required.");
      }
      if (checkStatus.value.userName === "invalid") {
        return translate("agora", "The name {username} is invalid or reserved.", {
          username: userName.value
        });
      }
      return "";
    });
    const emailAddressHint = computed(() => {
      if (emailGeneratedStatus.value === "checking") {
        return translate("agora", "Checking email address â¦");
      }
      if (emailGeneratedStatus.value === "mandatory") {
        return translate("agora", "An email address is required.");
      }
      if (emailGeneratedStatus.value === "invalid") {
        return translate("agora", "Invalid email address.");
      }
      if (sessionStore.share.type === "public") {
        if (emailGeneratedStatus.value === "valid") {
          return translate("inquiries", 'You will receive your personal link after clicking "OK".');
        }
        return translate("inquiries", "Enter your email address to get your personal access link.");
      }
      return "";
    });
    onMounted(() => {
      if (route.name === "publicInquiry" && route.query.name) {
        userName.value = route.query.name.toString();
      } else {
        userName.value = sessionStore.currentUser.displayName;
      }
      if (route.name === "publicInquiry" && route.query.email) {
        emailAddress.value = route.query.email.toString();
      } else {
        emailAddress.value = sessionStore.currentUser.emailAddress;
      }
    });
    function routeToPersonalShare(token2) {
      if (route.params.token === token2) {
        inquiryStore.load();
        closeModal();
      } else {
        router2.push({
          name: "publicInquiry",
          params: { token: token2 },
          replace: true
        });
        closeModal();
      }
    }
    function updateCookie(value) {
      const cookieExpiration = COOKIE_LIFETIME * 24 * 60 * 1e3;
      setCookie(route.params.token.toString(), value, cookieExpiration);
    }
    function closeModal() {
      emit2("close");
    }
    function login() {
      window.location.assign(`${window.location.protocol}//${window.location.host}${loginLink.value}`);
    }
    const validatePublicUsername = lodashExports.debounce(async function() {
      if (userName.value.length < 1) {
        checkStatus.value.userName = "empty";
        return;
      }
      checkStatus.value.userName = "checking";
      try {
        await validators.validateName(route.params.token, userName.value);
        checkStatus.value.userName = "valid";
      } catch (error) {
        if (error.code === "ERR_CANCELED") {
          return;
        }
        if (error.code === "ERR_BAD_REQUEST") {
          checkStatus.value.userName = "invalid";
          return;
        }
        throw error;
      }
    }, 500);
    const validateEmailAddress = lodashExports.debounce(async function() {
      if (emailAddress.value.length < 1) {
        checkStatus.value.email = "empty";
        return;
      }
      checkStatus.value.email = "checking";
      try {
        await validators.validateEmailAddress(emailAddress.value);
        checkStatus.value.email = "valid";
      } catch (error) {
        if (error.code === "ERR_CANCELED") {
          return;
        }
        if (error.code === "ERR_BAD_REQUEST") {
          checkStatus.value.email = "invalid";
          return;
        }
        throw error;
      }
    }, 500);
    async function submitRegistration() {
      if (!registrationIsValid.value || sendRegistration.value) {
        return;
      }
      sendRegistration.value = true;
      try {
        const response = await publicInquiry.register(
          route.params.token,
          userName.value,
          emailAddress.value
        );
        if (saveCookie.value && route.name === "publicInquiry") {
          updateCookie(response.data.share.token);
        }
        routeToPersonalShare(response.data.share.token);
        if (sessionStore.currentUser.emailAddress && !sessionStore.share.invitationSent) {
          showError(
            translate("agora", "Email could not be sent to {emailAddress}", {
              emailAddress: sessionStore.currentUser.emailAddress
            })
          );
        }
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        showError(translate("agora", "Error registering to inquiry", { error }));
        throw error;
      } finally {
        sendRegistration.value = false;
      }
    }
    const __returned__ = { route, router: router2, emit: emit2, sessionStore, inquiryStore, COOKIE_LIFETIME, checkStatus, sendRegistration, userName, emailAddress, saveCookie, registrationIsValid, disableSubmit, emailGeneratedStatus, offerCookies, loginLink, userNameHint, emailAddressHint, routeToPersonalShare, updateCookie, closeModal, login, validatePublicUsername, validateEmailAddress, submitRegistration, get t() {
      return translate;
    }, get NcCheckboxRadioSwitch() {
      return NcCheckboxRadioSwitch;
    }, get NcButton() {
      return NcButton;
    }, get InputDiv() {
      return InputDiv;
    }, get SimpleLink() {
      return SimpleLink;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$W = { class: "modal__content" };
const _hoisted_2$E = { class: "modal__registration" };
const _hoisted_3$C = { class: "registration__registration" };
const _hoisted_4$y = { class: "modal__buttons" };
const _hoisted_5$9 = { class: "left" };
const _hoisted_6$8 = { class: "legal_links" };
const _hoisted_7$7 = { class: "right" };
const _hoisted_8$7 = {
  key: 0,
  class: "registration__login"
};
function _sfc_render$1j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$W, [
    createBaseVNode("div", _hoisted_2$E, [
      createBaseVNode("div", _hoisted_3$C, [
        createBaseVNode(
          "h2",
          null,
          toDisplayString($setup.t("agora", "Guest participants")),
          1
          /* TEXT */
        ),
        createVNode($setup["InputDiv"], {
          modelValue: $setup.userName,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.userName = $event),
          class: "section__username",
          "signaling-class": $setup.checkStatus.userName,
          placeholder: $setup.t("agora", "Enter your name or a nickname"),
          "helper-text": $setup.userNameHint,
          focus: "",
          onInput: _cache[1] || (_cache[1] = ($event) => $setup.validatePublicUsername()),
          onSubmit: _cache[2] || (_cache[2] = ($event) => $setup.submitRegistration())
        }, null, 8, ["modelValue", "signaling-class", "placeholder", "helper-text"]),
        $setup.sessionStore.share.publicInquiryEmail !== "disabled" ? (openBlock(), createBlock($setup["InputDiv"], {
          key: 0,
          modelValue: $setup.emailAddress,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.emailAddress = $event),
          class: "section__email",
          "signaling-class": $setup.checkStatus.email,
          placeholder: $setup.sessionStore.share.publicInquiryEmail === "mandatory" ? $setup.t("agora", "Email address (mandatory)") : $setup.t("agora", "Email address (optional)"),
          "helper-text": $setup.emailAddressHint,
          type: "email",
          inputmode: "email",
          onInput: _cache[4] || (_cache[4] = ($event) => $setup.validateEmailAddress()),
          onSubmit: _cache[5] || (_cache[5] = ($event) => $setup.submitRegistration())
        }, null, 8, ["modelValue", "signaling-class", "placeholder", "helper-text"])) : createCommentVNode("v-if", true),
        $setup.offerCookies ? (openBlock(), createBlock($setup["NcCheckboxRadioSwitch"], {
          key: 1,
          modelValue: $setup.saveCookie,
          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $setup.saveCookie = $event)
        }, {
          default: withCtx(() => [
            createTextVNode(
              toDisplayString($setup.t("agora", "Remember me for 30 days")),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        }, 8, ["modelValue"])) : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_4$y, [
          createBaseVNode("div", _hoisted_5$9, [
            createBaseVNode("div", _hoisted_6$8, [
              $setup.sessionStore.appSettings.finalImprintUrl ? (openBlock(), createBlock($setup["SimpleLink"], {
                key: 0,
                href: $setup.sessionStore.appSettings.finalImprintUrl,
                target: "_blank",
                name: $setup.t("agora", "Legal Notice")
              }, null, 8, ["href", "name"])) : createCommentVNode("v-if", true),
              $setup.sessionStore.appSettings.finalPrivacyUrl ? (openBlock(), createBlock($setup["SimpleLink"], {
                key: 1,
                href: $setup.sessionStore.appSettings.finalPrivacyUrl,
                target: "_blank",
                name: $setup.t("agora", "Privacy policy")
              }, null, 8, ["href", "name"])) : createCommentVNode("v-if", true)
            ])
          ]),
          createBaseVNode("div", _hoisted_7$7, [
            createVNode($setup["NcButton"], { onClick: $setup.closeModal }, {
              default: withCtx(() => [
                createTextVNode(
                  toDisplayString($setup.t("agora", "Cancel")),
                  1
                  /* TEXT */
                )
              ]),
              _: 1
              /* STABLE */
            }),
            createVNode($setup["NcButton"], {
              variant: "primary",
              disabled: $setup.disableSubmit,
              onClick: _cache[7] || (_cache[7] = ($event) => $setup.submitRegistration())
            }, {
              default: withCtx(() => [
                createTextVNode(
                  toDisplayString($setup.t("agora", "OK")),
                  1
                  /* TEXT */
                )
              ]),
              _: 1
              /* STABLE */
            }, 8, ["disabled"])
          ])
        ])
      ]),
      $setup.sessionStore.appSettings.showLogin ? (openBlock(), createElementBlock("div", _hoisted_8$7, [
        createBaseVNode(
          "h2",
          null,
          toDisplayString($setup.t("agora", "Registered accounts")),
          1
          /* TEXT */
        ),
        createVNode($setup["NcButton"], {
          wide: "",
          onClick: _cache[8] || (_cache[8] = ($event) => $setup.login())
        }, {
          default: withCtx(() => [
            createTextVNode(
              toDisplayString($setup.t("agora", "Login")),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        }),
        createBaseVNode(
          "div",
          null,
          toDisplayString($setup.t("inquiries", "You can also log in and participate with your regular account.")),
          1
          /* TEXT */
        ),
        createBaseVNode(
          "div",
          null,
          toDisplayString($setup.t("agora", "Otherwise participate as a guest participant.")),
          1
          /* TEXT */
        )
      ])) : createCommentVNode("v-if", true)
    ])
  ]);
}
const PublicRegisterModal = /* @__PURE__ */ _export_sfc$1(_sfc_main$1j, [["render", _sfc_render$1j], ["__file", "/var/www/nextcloud/apps/agora/src/components/Public/PublicRegisterModal.vue"]]);
const registerModalSize = "large";
const _sfc_main$1i = /* @__PURE__ */ defineComponent({
  __name: "ActionRegister",
  setup(__props, { expose: __expose }) {
    __expose();
    const caption = translate("agora", "Register");
    const showRegistration = ref(false);
    const __returned__ = { caption, showRegistration, registerModalSize, get NcButton() {
      return NcButton;
    }, get NcModal() {
      return NcModal;
    }, PublicRegisterModal };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$V = { class: "action toggle-sidebar" };
function _sfc_render$1i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$V, [
    createVNode($setup["NcButton"], {
      variant: "primary",
      "aria-label": $setup.caption,
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.showRegistration = true)
    }, {
      default: withCtx(() => [
        createTextVNode(
          toDisplayString($setup.caption),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    }, 8, ["aria-label"]),
    createVNode($setup["NcModal"], {
      show: $setup.showRegistration,
      "onUpdate:show": _cache[2] || (_cache[2] = ($event) => $setup.showRegistration = $event),
      name: $setup.caption,
      size: $setup.registerModalSize,
      "close-on-click-outside": "",
      onClose: _cache[3] || (_cache[3] = ($event) => $setup.showRegistration = false)
    }, {
      default: withCtx(() => [
        createVNode($setup["PublicRegisterModal"], {
          onClose: _cache[1] || (_cache[1] = ($event) => $setup.showRegistration = false)
        })
      ]),
      _: 1
      /* STABLE */
    }, 8, ["show", "name"])
  ]);
}
const ActionRegister = /* @__PURE__ */ _export_sfc$1(_sfc_main$1i, [["render", _sfc_render$1i], ["__file", "/var/www/nextcloud/apps/agora/src/components/Actions/modules/ActionRegister.vue"]]);
const _sfc_main$1h = {
  name: "EmailCheckIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$U = ["aria-hidden", "aria-label"];
const _hoisted_2$D = ["fill", "width", "height"];
const _hoisted_3$B = { d: "M13 19C13 15.69 15.69 13 19 13C20.1 13 21.12 13.3 22 13.81V6C22 4.89 21.1 4 20 4H4C2.89 4 2 4.89 2 6V18C2 19.11 2.9 20 4 20H13.09C13.04 19.67 13 19.34 13 19M4 8V6L12 11L20 6V8L12 13L4 8M17.75 22.16L15 19.16L16.16 18L17.75 19.59L21.34 16L22.5 17.41L17.75 22.16" };
const _hoisted_4$x = { key: 0 };
function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon email-check-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$B, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$x,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$D))
  ], 16, _hoisted_1$U);
}
const EmailCheckIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1h, [["render", _sfc_render$1h], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/EmailCheck.vue"]]);
const _sfc_main$1g = /* @__PURE__ */ defineComponent({
  __name: "ActionSendConfirmed",
  emits: ["success", "error"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const route = useRoute();
    const showModal = ref(false);
    const sendButtonCaption = ref(translate("agora", "Send confirmation mails"));
    const confirmations = ref({
      sentMails: [],
      abortedMails: [],
      countSentMails: 0,
      countAbortedMails: 0
    });
    const disableButton = ref(false);
    const sentStatus = ref("");
    const emit2 = __emit;
    async function clickAction() {
      if (sentStatus.value === "success") {
        showModal.value = true;
        return;
      }
      try {
        disableButton.value = true;
        const result2 = await inquiries.sendConfirmation(parseInt(route.params.id));
        confirmations.value = result2.data.confirmations;
        showModal.value = true;
        sendButtonCaption.value = translate("agora", "See result");
        sentStatus.value = "success";
        emit2("success");
      } catch (error) {
        Logger.error("Error on sending confirmation mails", { error });
        sentStatus.value = "error";
        emit2("error");
      } finally {
        disableButton.value = false;
      }
    }
    const __returned__ = { route, showModal, sendButtonCaption, confirmations, disableButton, sentStatus, emit: emit2, clickAction, get t() {
      return translate;
    }, get n() {
      return translatePlural;
    }, get NcModal() {
      return NcModal;
    }, get NcButton() {
      return NcButton;
    }, EmailCheckIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$T = { class: "action send-confirmations" };
const _hoisted_2$C = { class: "modal-confirmation-result" };
const _hoisted_3$A = {
  key: 0,
  class: "sent-confirmations"
};
const _hoisted_4$w = {
  key: 1,
  class: "error-confirmations"
};
function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$T, [
    createVNode($setup["NcButton"], {
      variant: "primary",
      "aria-label": $setup.sendButtonCaption,
      disabled: $setup.disableButton,
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.clickAction())
    }, {
      icon: withCtx(() => [
        createVNode($setup["EmailCheckIcon"])
      ]),
      default: withCtx(() => [
        createTextVNode(
          " " + toDisplayString($setup.sendButtonCaption),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    }, 8, ["aria-label", "disabled"]),
    createVNode($setup["NcModal"], {
      show: $setup.showModal,
      "onUpdate:show": _cache[1] || (_cache[1] = ($event) => $setup.showModal = $event),
      "no-close": "",
      name: $setup.t("agora", "Result of sent confirmation mails"),
      size: "small"
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_2$C, [
          $setup.confirmations?.countSentMails > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$A, [
            createBaseVNode(
              "h2",
              null,
              toDisplayString($setup.n(
                "agora",
                "%n confirmation has been sent",
                "%n confirmations have been sent",
                $setup.confirmations.countSentMails
              )),
              1
              /* TEXT */
            ),
            createBaseVNode("ul", null, [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.confirmations.sentMails, (item) => {
                  return openBlock(), createElementBlock(
                    "li",
                    {
                      key: item.displayName
                    },
                    toDisplayString(item.displayName) + " <" + toDisplayString(item.emailAddress) + "> ",
                    1
                    /* TEXT */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])
          ])) : createCommentVNode("v-if", true),
          $setup.confirmations?.countAbortedMails > 0 ? (openBlock(), createElementBlock("div", _hoisted_4$w, [
            createBaseVNode(
              "h2",
              null,
              toDisplayString($setup.n(
                "agora",
                "%n confirmation could not be sent",
                "%n confirmations could not be sent:",
                $setup.confirmations.countAbortedMails
              )),
              1
              /* TEXT */
            ),
            createBaseVNode("ul", null, [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.confirmations.abortedMails, (item) => {
                  return openBlock(), createElementBlock(
                    "li",
                    {
                      key: item.displayName
                    },
                    toDisplayString(item.displayName) + " (" + toDisplayString(item.reason === "InvalidMail" ? $setup.t("agora", "No valid email address") : $setup.t("agora", "Unknown error")) + ") ",
                    1
                    /* TEXT */
                  );
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ])
          ])) : createCommentVNode("v-if", true)
        ])
      ]),
      _: 1
      /* STABLE */
    }, 8, ["show", "name"])
  ]);
}
const ActionSendConfirmed = /* @__PURE__ */ _export_sfc$1(_sfc_main$1g, [["render", _sfc_render$1g], ["__file", "/var/www/nextcloud/apps/agora/src/components/Actions/modules/ActionSendConfirmed.vue"]]);
const _sfc_main$1f = {
  name: "TextAccountIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$S = ["aria-hidden", "aria-label"];
const _hoisted_2$B = ["fill", "width", "height"];
const _hoisted_3$z = { d: "M21 5V7H3V5H21M3 17H12V15H3V17M3 12H21V10H3V12M18 14C19.11 14 20 14.9 20 16S19.11 18 18 18 16 17.11 16 16 16.9 14 18 14M14 22V21C14 19.9 15.79 19 18 19S22 19.9 22 21V22H14Z" };
const _hoisted_4$v = { key: 0 };
function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon text-account-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$z, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$v,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$B))
  ], 16, _hoisted_1$S);
}
const SidebarIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1f, [["render", _sfc_render$1f], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/TextAccount.vue"]]);
const _sfc_main$1e = /* @__PURE__ */ defineComponent({
  __name: "ActionToggleSidebar",
  setup(__props, { expose: __expose }) {
    __expose();
    const caption = translate("agora", "Toggle sidebar");
    function clickAction() {
      emit(Event$1.SidebarToggle, null);
    }
    const __returned__ = { caption, clickAction, get NcButton() {
      return NcButton;
    }, SidebarIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$R = { class: "action toggle-sidebar" };
function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$R, [
    createVNode($setup["NcButton"], {
      variant: "tertiary",
      title: $setup.caption,
      "aria-label": $setup.caption,
      onClick: _cache[0] || (_cache[0] = ($event) => $setup.clickAction())
    }, {
      icon: withCtx(() => [
        createVNode($setup["SidebarIcon"])
      ]),
      _: 1
      /* STABLE */
    }, 8, ["title", "aria-label"])
  ]);
}
const ActionToggleSidebar = /* @__PURE__ */ _export_sfc$1(_sfc_main$1e, [["render", _sfc_render$1e], ["__file", "/var/www/nextcloud/apps/agora/src/components/Actions/modules/ActionToggleSidebar.vue"]]);
const _sfc_main$1d = /* @__PURE__ */ defineComponent({
  __name: "Combo",
  setup(__props, { expose: __expose }) {
    __expose();
    const comboStore = useComboStore();
    const isLoading = ref(false);
    const title = translate("agora", "Combined inquiries");
    const description = translate("agora", "Combine multiple date inquiries in a single view");
    onMounted(() => {
      comboStore.verifyInquiriesFromSettings();
    });
    const __returned__ = { comboStore, isLoading, title, description, get t() {
      return translate;
    }, get NcAppContent() {
      return NcAppContent;
    }, get NcEmptyContent() {
      return NcEmptyContent;
    }, ComboTable, LoadingOverlay, get ActionToggleSidebar() {
      return ActionToggleSidebar;
    }, get HeaderBar() {
      return HeaderBar;
    }, get AgoraAppIcon() {
      return AgoraAppIcon;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$Q = { class: "inquiry-header-buttons" };
const _hoisted_2$A = { class: "area__main" };
function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcAppContent"], null, {
    default: withCtx(() => [
      createVNode($setup["HeaderBar"], null, {
        title: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.title),
            1
            /* TEXT */
          )
        ]),
        right: withCtx(() => [
          createBaseVNode("div", _hoisted_1$Q, [
            createVNode($setup["ActionToggleSidebar"])
          ])
        ]),
        default: withCtx(() => [
          createTextVNode(
            " " + toDisplayString($setup.description),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }),
      createBaseVNode("div", _hoisted_2$A, [
        withDirectives(createVNode(
          $setup["ComboTable"],
          null,
          null,
          512
          /* NEED_PATCH */
        ), [
          [vShow, $setup.comboStore.inquiries.length]
        ]),
        !$setup.comboStore.inquiries.length ? (openBlock(), createBlock($setup["NcEmptyContent"], {
          key: 0,
          name: $setup.t("agora", "No inquiries selected"),
          description: $setup.t("agora", "Select inquiries by clicking on them in the right sidebar!")
        }, {
          icon: withCtx(() => [
            createVNode($setup["AgoraAppIcon"])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name", "description"])) : createCommentVNode("v-if", true)
      ]),
      $setup.isLoading ? (openBlock(), createBlock($setup["LoadingOverlay"], { key: 0 })) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  });
}
const Combo = /* @__PURE__ */ _export_sfc$1(_sfc_main$1d, [["render", _sfc_render$1d], ["__file", "/var/www/nextcloud/apps/agora/src/views/Combo.vue"]]);
const _sfc_main$1c = {
  name: "CancelIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$P = ["aria-hidden", "aria-label"];
const _hoisted_2$z = ["fill", "width", "height"];
const _hoisted_3$y = { d: "M12 2C17.5 2 22 6.5 22 12S17.5 22 12 22 2 17.5 2 12 6.5 2 12 2M12 4C10.1 4 8.4 4.6 7.1 5.7L18.3 16.9C19.3 15.5 20 13.8 20 12C20 7.6 16.4 4 12 4M16.9 18.3L5.7 7.1C4.6 8.4 4 10.1 4 12C4 16.4 7.6 20 12 20C13.9 20 15.6 19.4 16.9 18.3Z" };
const _hoisted_4$u = { key: 0 };
function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon cancel-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$y, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$u,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$z))
  ], 16, _hoisted_1$P);
}
const CancelIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$1c, [["render", _sfc_render$1c], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Cancel.vue"]]);
const _sfc_main$1b = /* @__PURE__ */ defineComponent({
  __name: "Forbidden",
  setup(__props, { expose: __expose }) {
    __expose();
    const emptyContentProps = {
      name: translate("agora", "403 - You are not allowed to access this inquiry"),
      description: translate("agora", "Contact the owner, if you think that this is wrong.")
    };
    const __returned__ = { emptyContentProps, get NcAppContent() {
      return NcAppContent;
    }, get NcEmptyContent() {
      return NcEmptyContent;
    }, CancelIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcAppContent"], null, {
    default: withCtx(() => [
      createVNode(
        $setup["NcEmptyContent"],
        normalizeProps(guardReactiveProps($setup.emptyContentProps)),
        {
          icon: withCtx(() => [
            createVNode($setup["CancelIcon"])
          ]),
          _: 1
          /* STABLE */
        },
        16
        /* FULL_PROPS */
      )
    ]),
    _: 1
    /* STABLE */
  });
}
const Forbidden = /* @__PURE__ */ _export_sfc$1(_sfc_main$1b, [["render", _sfc_render$1b], ["__file", "/var/www/nextcloud/apps/agora/src/views/Forbidden.vue"]]);
const _sfc_main$1a = /* @__PURE__ */ defineComponent({
  __name: "InquiryItem",
  props: {
    inquiry: { type: Object, required: true },
    noLink: { type: Boolean, required: false, default: false },
    gridView: { type: Boolean, required: false, default: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const inquiriesStore = useInquiriesStore();
    const preferencesStore = usePreferencesStore();
    const sessionStore = useSessionStore();
    const supportsStore = useSupportsStore();
    const context2 = computed(
      () => createPermissionContextForContent(
        ContentType.Inquiry,
        __props.inquiry.owner.id,
        __props.inquiry.configuration.access === "public",
        __props.inquiry.status.isLocked,
        __props.inquiry.status.isExpired,
        __props.inquiry.status.deletionDate > 0,
        __props.inquiry.status.isArchived,
        __props.inquiry.inquiryGroups.length > 0,
        __props.inquiry.inquiryGroups,
        __props.inquiry.type
      )
    );
    const onToggleSupport = async () => {
      supportsStore.toggleSupport(__props.inquiry.id, sessionStore.currentUser.id, inquiryStore, inquiriesStore);
      if (__props.inquiry.currentUserStatus.hasSupported) {
        showSuccess(translate("agora", "Inquiry supported, thanks for her !"), { timeout: 2e3 });
      } else {
        showSuccess(translate("agora", "Inquiry support removed !"), { timeout: 2e3 });
      }
    };
    function htmlToFirstLine(html2) {
      const tempDiv = document.createElement("div");
      tempDiv.innerHTML = html2;
      let text = tempDiv.textContent || tempDiv.innerText || "";
      text = text.replace(/\s+/g, " ").trim();
      const firstLine = text.split(/\r?\n/)[0];
      return firstLine;
    }
    const closeToClosing = computed(
      () => !__props.inquiry.status.isExpired && __props.inquiry.configuration.expire && DateTime.fromMillis(__props.inquiry.configuration.expire * 1e3).diffNow("hours").hours < 36
    );
    const timeExpirationRelative = computed(() => {
      if (__props.inquiry.configuration.expire) {
        return DateTime.fromMillis(__props.inquiry.configuration.expire * 1e3).toRelative();
      }
      return translate("agora", "never");
    });
    const expiryClass = computed(() => {
      if (__props.inquiry.status.isExpired) {
        return "error";
      }
      if (__props.inquiry.configuration.expire && closeToClosing.value) {
        return "warning";
      }
      if (__props.inquiry.configuration.expire && !__props.inquiry.status.isExpired) {
        return "success";
      }
      return "success";
    });
    const timeCreatedRelative = computed(
      () => DateTime.fromMillis(__props.inquiry.status.created * 1e3).toRelative()
    );
    const safeDescription = computed(() => {
      if (preferencesStore.user.verboseInquiriesList) {
        if (__props.inquiry.description) {
          return htmlToFirstLine(__props.inquiry.description);
        }
        return translate("agora", "No description provided");
      }
      if (__props.inquiry.status.isArchived) {
        return translate("agora", "Archived {relativeTime}", {
          relativeTime: DateTime.fromMillis(__props.inquiry.status.archivedDate * 1e3).toRelative()
        });
      }
      return translate("agora", "Started {relativeTime} from {ownerName}", {
        ownerName: __props.inquiry.owner.displayName,
        relativeTime: timeCreatedRelative.value
      });
    });
    const formatDate = (timestamp) => DateTime.fromMillis(timestamp * 1e3).toLocaleString(DateTime.DATE_SHORT);
    const moderationStatus = computed(
      () => __props.inquiry.moderationStatus || inquiryStore.getInquiryModerationStatus?.(__props.inquiry.id)
    );
    const moderationStatusIcon = computed(() => {
      const statusItem = sessionStore.appSettings.moderationStatusTab.find(
        (item) => item.inquiryType === __props.inquiry.type && item.statusKey === __props.inquiry.moderationStatus
      );
      if (!statusItem) {
        return StatusIcons.Draft;
      }
      return StatusIcons[statusItem.icon] || StatusIcons.Draft;
    });
    const moderationStatusLabel = computed(() => {
      const statusItem = sessionStore.appSettings.moderationStatusTab.find(
        (item) => item.inquiryType === __props.inquiry.type && item.statusKey === __props.inquiry.moderationStatus
      );
      if (!statusItem) {
        return "Draft";
      }
      return statusItem.label || "Draft";
    });
    const moderationStatusInfo = computed(() => {
      if (!moderationStatus.value || !sessionStore.appSettings?.moderationStatusTab) {
        return null;
      }
      return sessionStore.appSettings.moderationStatusTab.find(
        (status) => status.status_key === moderationStatus.value
      );
    });
    const __returned__ = { inquiryStore, inquiriesStore, preferencesStore, sessionStore, supportsStore, context: context2, onToggleSupport, htmlToFirstLine, closeToClosing, timeExpirationRelative, expiryClass, timeCreatedRelative, safeDescription, formatDate, moderationStatus, moderationStatusIcon, moderationStatusLabel, moderationStatusInfo, get RouterLink() {
      return RouterLink;
    }, get t() {
      return translate;
    }, get NcAvatar() {
      return NcAvatar;
    }, get ThumbIcon() {
      return ThumbIcon;
    }, get canComment() {
      return canComment;
    }, get canSupport() {
      return canSupport;
    }, get InquiryTypesUI() {
      return InquiryTypesUI$1;
    }, get BadgeIcons() {
      return BadgeIcons;
    }, get StatusIcons() {
      return StatusIcons;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$O = ["title"];
const _hoisted_2$y = ["title"];
const _hoisted_3$x = { class: "description_line" };
const _hoisted_4$t = { class: "description" };
const _hoisted_5$8 = { class: "title_line" };
const _hoisted_6$7 = { class: "title" };
const _hoisted_7$6 = { class: "description_line" };
const _hoisted_8$6 = { class: "description" };
const _hoisted_9$5 = { class: "badges" };
const _hoisted_10$4 = {
  key: 0,
  class: "item__type"
};
const _hoisted_11$4 = { key: 1 };
const _hoisted_12$3 = ["title"];
const _hoisted_13$3 = ["title"];
const _hoisted_14$3 = ["title"];
const _hoisted_15$3 = ["title"];
const _hoisted_16$2 = ["title"];
const _hoisted_17$2 = ["title"];
const _hoisted_18$2 = ["title"];
const _hoisted_19$2 = ["title"];
const _hoisted_20$2 = ["title"];
const _hoisted_21$2 = ["title"];
const _hoisted_22$2 = { class: "actions" };
const _hoisted_23$2 = {
  key: 1,
  class: "grid-card"
};
const _hoisted_24$2 = { class: "grid-header" };
const _hoisted_25$2 = { class: "header-left" };
const _hoisted_26$2 = { class: "type-icon" };
const _hoisted_27$1 = { key: 0 };
const _hoisted_28$1 = ["title"];
const _hoisted_29$1 = ["title"];
const _hoisted_30$1 = ["title"];
const _hoisted_31$1 = ["title"];
const _hoisted_32$1 = ["title"];
const _hoisted_33$1 = { class: "header-right" };
const _hoisted_34$1 = { class: "grid-title" };
const _hoisted_35$1 = { class: "grid-description" };
const _hoisted_36$1 = {
  key: 1,
  class: "grid-content"
};
const _hoisted_37$1 = { class: "grid-title" };
const _hoisted_38$1 = { class: "grid-description" };
const _hoisted_39 = { class: "grid-metadata" };
const _hoisted_40 = ["title"];
const _hoisted_41 = ["title"];
const _hoisted_42 = ["title"];
const _hoisted_43 = { class: "metadata-item-time" };
const _hoisted_44 = ["title"];
const _hoisted_45 = { class: "date-label" };
const _hoisted_46 = { class: "date-value" };
const _hoisted_47 = ["title"];
const _hoisted_48 = { class: "date-label" };
const _hoisted_49 = { class: "date-value" };
const _hoisted_50 = { class: "grid-actions" };
function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["inquiry-item", { "grid-view": $props.gridView, "list-view": !$props.gridView }])
    },
    [
      createCommentVNode(" Mode liste "),
      !$props.gridView ? (openBlock(), createElementBlock(
        Fragment$1,
        { key: 0 },
        [
          createBaseVNode("div", {
            class: "item__type",
            title: $props.inquiry.type
          }, [
            (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$props.inquiry.type].icon), {
              title: $setup.InquiryTypesUI[$props.inquiry.type].label
            }, null, 8, ["title"]))
          ], 8, _hoisted_1$O),
          $props.noLink ? (openBlock(), createElementBlock(
            "div",
            {
              key: 0,
              class: normalizeClass(["item__title", { closed: $props.inquiry.status.isExpired }])
            },
            [
              createBaseVNode("div", {
                class: "title",
                title: $props.inquiry.title
              }, toDisplayString($props.inquiry.title), 9, _hoisted_2$y),
              createBaseVNode("div", _hoisted_3$x, [
                (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.Lock), { size: 16 })),
                createBaseVNode(
                  "div",
                  _hoisted_4$t,
                  toDisplayString($setup.t("agora", "No access to this inquiry of {ownerName}.", {
                    ownerName: $props.inquiry.owner.displayName
                  })),
                  1
                  /* TEXT */
                )
              ])
            ],
            2
            /* CLASS */
          )) : (openBlock(), createBlock($setup["RouterLink"], {
            key: 1,
            class: normalizeClass(["item__title", {
              closed: $props.inquiry.status.isExpired,
              active: $props.inquiry.id === $setup.inquiryStore.id
            }]),
            title: $props.inquiry.description,
            to: {
              name: "inquiry",
              params: { id: $props.inquiry.id }
            }
          }, {
            default: withCtx(() => [
              createBaseVNode("div", _hoisted_5$8, [
                createBaseVNode(
                  "span",
                  _hoisted_6$7,
                  toDisplayString($props.inquiry.title),
                  1
                  /* TEXT */
                )
              ]),
              createBaseVNode("div", _hoisted_7$6, [
                !$setup.preferencesStore.user.verboseInquiriesList && $props.inquiry.status.isArchived ? (openBlock(), createBlock(resolveDynamicComponent($setup.BadgeIcons.archived), {
                  key: 0,
                  title: $setup.t("agora", "Archived inquiry"),
                  size: 16
                }, null, 8, ["title"])) : !$setup.preferencesStore.user.verboseInquiriesList && $props.inquiry.configuration.access === "open" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.LockOpen), {
                  key: 1,
                  title: $setup.t("agora", "Openly accessible inquiry"),
                  size: 16
                }, null, 8, ["title"])) : !$setup.preferencesStore.user.verboseInquiriesList && $props.inquiry.configuration.access === "private" ? (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.Lock), {
                  key: 2,
                  title: $setup.t("agora", "Private inquiry"),
                  size: 16
                }, null, 8, ["title"])) : createCommentVNode("v-if", true),
                createBaseVNode(
                  "span",
                  _hoisted_8$6,
                  toDisplayString($setup.safeDescription),
                  1
                  /* TEXT */
                )
              ])
            ]),
            _: 1
            /* STABLE */
          }, 8, ["title", "to", "class"])),
          createBaseVNode("div", _hoisted_9$5, [
            $props.inquiry.parentId !== 0 ? (openBlock(), createElementBlock("div", _hoisted_10$4, [
              createVNode($setup["RouterLink"], {
                class: "underline",
                to: `/inquiry/${$props.inquiry.parentId}`
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.LinkIcon), {
                    size: 20,
                    title: `id:inquiry.parentId`
                  }))
                ]),
                _: 1
                /* STABLE */
              }, 8, ["to"])
            ])) : createCommentVNode("v-if", true),
            $props.inquiry.type !== "official" ? (openBlock(), createElementBlock("div", _hoisted_11$4, [
              $setup.moderationStatusInfo ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "badge-bubble status--moderation",
                title: $setup.moderationStatusInfo.description || $setup.moderationStatusInfo.label
              }, [
                $setup.moderationStatusInfo.icon ? (openBlock(), createBlock(resolveDynamicComponent($setup.moderationStatusIcon), {
                  key: 0,
                  size: 12,
                  class: "icon"
                })) : createCommentVNode("v-if", true),
                createCommentVNode(" {{ inquiry.moderationStatus }}</span> ")
              ], 8, _hoisted_12$3)) : $props.inquiry.moderationStatus ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "badge-bubble status--moderation",
                title: $setup.moderationStatusLabel
              }, [
                (openBlock(), createBlock(resolveDynamicComponent($setup.moderationStatusIcon), {
                  size: 12,
                  class: "icon"
                }))
              ], 8, _hoisted_13$3)) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true),
            $setup.canComment($setup.context) ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: "badge-bubble",
              title: $setup.t("agora", "{count} comments", {
                count: $props.inquiry.status.countComments || 0
              })
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.ForumOutline), {
                size: 12,
                class: "icon"
              })),
              createBaseVNode(
                "span",
                null,
                toDisplayString($props.inquiry.status.countComments || 0),
                1
                /* TEXT */
              )
            ], 8, _hoisted_14$3)) : createCommentVNode("v-if", true),
            $setup.canSupport($setup.context) ? (openBlock(), createElementBlock("div", {
              key: 3,
              class: "badge-bubble",
              title: $setup.t("agora", "{count} supports", {
                count: $props.inquiry.status.countSupports || 0
              }),
              onClick: $setup.onToggleSupport
            }, [
              createVNode($setup["ThumbIcon"], {
                supported: $props.inquiry.currentUserStatus.hasSupported,
                size: 22
              }, null, 8, ["supported"]),
              createBaseVNode(
                "span",
                null,
                toDisplayString($props.inquiry.status.countSupports || 0),
                1
                /* TEXT */
              )
            ], 8, _hoisted_15$3)) : createCommentVNode("v-if", true),
            $props.inquiry.type !== "official" && $setup.preferencesStore.user.verboseInquiriesList ? (openBlock(), createElementBlock("div", {
              key: 4,
              class: "badge-bubble",
              title: $setup.t("agora", "{count} participants", {
                count: $props.inquiry.status.countParticipants
              })
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.BadgeIcons.participated), {
                size: 16,
                class: "icon"
              })),
              createBaseVNode(
                "span",
                null,
                toDisplayString($props.inquiry.status.countParticipants),
                1
                /* TEXT */
              )
            ], 8, _hoisted_16$2)) : createCommentVNode("v-if", true),
            $setup.preferencesStore.user.verboseInquiriesList && !$props.inquiry.status.isArchived && $props.inquiry.configuration.access === "private" ? (openBlock(), createElementBlock("div", {
              key: 5,
              class: "badge-bubble",
              title: $setup.t("agora", "Private inquiry, only invited participants have access")
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.Lock), {
                size: 16,
                class: "icon"
              }))
            ], 8, _hoisted_17$2)) : createCommentVNode("v-if", true),
            $setup.preferencesStore.user.verboseInquiriesList && !$props.inquiry.status.isArchived && $props.inquiry.configuration.access === "open" ? (openBlock(), createElementBlock("div", {
              key: 6,
              class: "badge-bubble",
              title: $setup.t("agora", "Open inquiry, accessible to all users of this instance")
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.LockOpen), {
                size: 16,
                class: "icon"
              }))
            ], 8, _hoisted_18$2)) : createCommentVNode("v-if", true),
            $setup.preferencesStore.user.verboseInquiriesList && $props.inquiry.status.isArchived ? (openBlock(), createElementBlock("div", {
              key: 7,
              class: "badge-bubble",
              title: $setup.t("agora", "Archived inquiry")
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.BadgeIcons.archived), {
                size: 16,
                class: "icon"
              }))
            ], 8, _hoisted_19$2)) : createCommentVNode("v-if", true),
            $setup.preferencesStore.user.verboseInquiriesList && $props.inquiry.countParticipants ? (openBlock(), createElementBlock("div", {
              key: 8,
              class: "badge-bubble participated",
              title: $setup.t("agora", "This inquiry get participation")
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.AccountCheck), {
                size: 16,
                class: "icon"
              }))
            ], 8, _hoisted_20$2)) : createCommentVNode("v-if", true),
            $setup.preferencesStore.user.verboseInquiriesList ? (openBlock(), createBlock($setup["NcAvatar"], {
              key: 9,
              user: $props.inquiry.owner.id,
              class: "user-avatar",
              style: { marginLeft: "-8px", marginRight: "4px" },
              "show-name": false,
              size: 32
            }, null, 8, ["user"])) : createCommentVNode("v-if", true),
            $props.inquiry.configuration.expire ? (openBlock(), createElementBlock("div", {
              key: 10,
              class: normalizeClass(["badge-bubble", $setup.expiryClass]),
              title: $setup.t("agora", "Expiration")
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($props.inquiry.status.isExpired ? $setup.BadgeIcons.closed : $setup.BadgeIcons.expiration), {
                size: 16,
                class: "icon"
              })),
              createBaseVNode(
                "span",
                null,
                toDisplayString($setup.timeExpirationRelative),
                1
                /* TEXT */
              )
            ], 10, _hoisted_21$2)) : createCommentVNode("v-if", true)
          ]),
          createBaseVNode("div", _hoisted_22$2, [
            renderSlot(_ctx.$slots, "actions")
          ])
        ],
        64
        /* STABLE_FRAGMENT */
      )) : (openBlock(), createElementBlock("div", _hoisted_23$2, [
        createBaseVNode("div", _hoisted_24$2, [
          createBaseVNode("div", _hoisted_25$2, [
            createBaseVNode("div", _hoisted_26$2, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$props.inquiry.type].icon), {
                title: $setup.InquiryTypesUI[$props.inquiry.type].label,
                size: 18
              }, null, 8, ["title"]))
            ]),
            $props.inquiry.type !== "official" ? (openBlock(), createElementBlock("div", _hoisted_27$1, [
              $setup.moderationStatusInfo ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "status-badge status--moderation",
                title: $setup.moderationStatusInfo.description || $setup.moderationStatusInfo.label
              }, [
                $setup.moderationStatusInfo.icon ? (openBlock(), createBlock(resolveDynamicComponent($setup.moderationStatusIcon), {
                  key: 0,
                  size: 12
                })) : createCommentVNode("v-if", true),
                createCommentVNode(" {{ inquiry.moderationStatus }}</span> ")
              ], 8, _hoisted_28$1)) : $props.inquiry.moderationStatus ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "status-badge status--moderation",
                title: $setup.moderationStatusLabel
              }, [
                (openBlock(), createBlock(resolveDynamicComponent($setup.moderationStatusIcon), { size: 12 })),
                createCommentVNode(" {{ inquiry.moderationStatus }}</span> ")
              ], 8, _hoisted_29$1)) : createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true),
            $setup.preferencesStore.user.verboseInquiriesList && !$props.inquiry.status.isArchived && $props.inquiry.configuration.access === "private" ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "badge-bubble",
              title: $setup.t("agora", "Private inquiry, only invited participants have access")
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.Lock), {
                size: 16,
                class: "icon"
              }))
            ], 8, _hoisted_30$1)) : createCommentVNode("v-if", true),
            $setup.preferencesStore.user.verboseInquiriesList && !$props.inquiry.status.isArchived && $props.inquiry.configuration.access === "open" ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: "badge-bubble",
              title: $setup.t("agora", "Open inquiry, accessible to all users of this instance")
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.LockOpen), {
                size: 16,
                class: "icon"
              }))
            ], 8, _hoisted_31$1)) : createCommentVNode("v-if", true),
            $setup.preferencesStore.user.verboseInquiriesList && $props.inquiry.status.isArchived ? (openBlock(), createElementBlock("div", {
              key: 3,
              class: "badge-bubble",
              title: $setup.t("agora", "Archived inquiry")
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.BadgeIcons.archived), {
                size: 16,
                class: "icon"
              }))
            ], 8, _hoisted_32$1)) : createCommentVNode("v-if", true)
          ]),
          createBaseVNode("div", _hoisted_33$1, [
            createVNode($setup["NcAvatar"], {
              user: $props.inquiry.owner.id,
              size: 32,
              class: "user-icon",
              style: { marginLeft: "-8px" }
            }, null, 8, ["user"])
          ])
        ]),
        !$props.noLink ? (openBlock(), createBlock($setup["RouterLink"], {
          key: 0,
          class: "grid-content",
          title: $props.inquiry.description,
          to: {
            name: "inquiry",
            params: { id: $props.inquiry.id }
          }
        }, {
          default: withCtx(() => [
            createBaseVNode(
              "h3",
              _hoisted_34$1,
              toDisplayString($props.inquiry.title),
              1
              /* TEXT */
            ),
            createBaseVNode(
              "p",
              _hoisted_35$1,
              toDisplayString($setup.safeDescription),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        }, 8, ["title", "to"])) : (openBlock(), createElementBlock("div", _hoisted_36$1, [
          createBaseVNode(
            "h3",
            _hoisted_37$1,
            toDisplayString($props.inquiry.title),
            1
            /* TEXT */
          ),
          createBaseVNode(
            "p",
            _hoisted_38$1,
            toDisplayString($setup.t("agora", "No access to this inquiry of {ownerName}.", {
              ownerName: $props.inquiry.owner.displayName
            })),
            1
            /* TEXT */
          )
        ])),
        createBaseVNode("div", _hoisted_39, [
          $props.inquiry.type !== "official" && $props.inquiry.status.countParticipants > 0 ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "metadata-item",
            title: $setup.t("agora", "{count} participants", {
              count: $props.inquiry.status.countParticipants
            })
          }, [
            (openBlock(), createBlock(resolveDynamicComponent($setup.BadgeIcons.participated), { size: 16 })),
            createBaseVNode(
              "span",
              null,
              toDisplayString($props.inquiry.status.countParticipants),
              1
              /* TEXT */
            )
          ], 8, _hoisted_40)) : createCommentVNode("v-if", true),
          $setup.canComment($setup.context) ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "metadata-item",
            title: $setup.t("agora", "{count} comments", {
              count: $props.inquiry.status.countComments || 0
            })
          }, [
            (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.ForumOutline), { size: 16 })),
            createBaseVNode(
              "span",
              null,
              toDisplayString($props.inquiry.status.countComments || 0),
              1
              /* TEXT */
            )
          ], 8, _hoisted_41)) : createCommentVNode("v-if", true),
          $setup.canSupport($setup.context) ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: "metadata-item",
            title: $setup.t("agora", "{count} supports", {
              count: $props.inquiry.status.countSupports || 0
            }),
            onClick: $setup.onToggleSupport
          }, [
            createVNode($setup["ThumbIcon"], {
              supported: $props.inquiry.currentUserStatus.hasSupported,
              size: 22
            }, null, 8, ["supported"]),
            createBaseVNode(
              "span",
              null,
              toDisplayString($props.inquiry.status.countSupports || 0),
              1
              /* TEXT */
            )
          ], 8, _hoisted_42)) : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_43, [
            createBaseVNode("div", {
              class: "metadata-item",
              title: $setup.t("agora", "Created on {date}", {
                date: $setup.formatDate($props.inquiry.status.created)
              })
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.Calendar), { size: 16 })),
              createBaseVNode("span", _hoisted_45, [
                createBaseVNode(
                  "span",
                  _hoisted_46,
                  toDisplayString($setup.formatDate($props.inquiry.status.created)),
                  1
                  /* TEXT */
                )
              ])
            ], 8, _hoisted_44),
            $props.inquiry.status.lastInteraction ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "metadata-item",
              title: $setup.t("agora", "Last interaction on {date}", {
                date: $setup.formatDate($props.inquiry.status.lastInteraction)
              })
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.Updated), { size: 16 })),
              createBaseVNode("span", _hoisted_48, [
                createBaseVNode(
                  "span",
                  _hoisted_49,
                  toDisplayString($setup.formatDate($props.inquiry.status.lastInteraction)),
                  1
                  /* TEXT */
                )
              ])
            ], 8, _hoisted_47)) : createCommentVNode("v-if", true)
          ])
        ]),
        createBaseVNode("div", _hoisted_50, [
          renderSlot(_ctx.$slots, "actions")
        ])
      ]))
    ],
    2
    /* CLASS */
  );
}
const InquiryItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$1a, [["render", _sfc_render$1a], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/InquiryItem.vue"]]);
const _sfc_main$19 = /* @__PURE__ */ defineComponent({
  __name: "InquiryFilter",
  setup(__props, { expose: __expose }) {
    __expose();
    const sessionStore = useSessionStore();
    const inquiriesStore = useInquiriesStore();
    const selectedType = ref("all");
    const selectedCategory = ref("all");
    const selectedLocation = ref("all");
    const hasComments = ref(null);
    const hasSupports = ref(null);
    const searchQuery = ref("");
    const isFiltersOpen = ref(false);
    const filterOptions = computed(() => ({
      types: [
        { value: "all", label: translate("agora", "All types") },
        { value: "proposal", label: translate("agora", "Proposals") },
        { value: "debate", label: translate("agora", "Debates") },
        { value: "petition", label: translate("agora", "Petitions") },
        { value: "project", label: translate("agora", "Projects") },
        { value: "grievance", label: translate("agora", "Grievances") },
        { value: "suggestion", label: translate("agora", "Suggestions") },
        { value: "official", label: translate("agora", "Official") }
      ],
      categories: [
        { value: "all", label: translate("agora", "All categories") },
        ...sessionStore.appSettings.categoryTab?.map((cat) => ({
          value: cat.id,
          label: cat.name
        })) || []
      ],
      locations: [
        { value: "all", label: translate("agora", "All locations") },
        ...sessionStore.appSettings.locationTab?.map((loc) => ({
          value: loc.id,
          label: loc.name
        })) || []
      ],
      participation: [
        { value: null, label: translate("agora", "Any comments") },
        { value: true, label: translate("agora", "With comments") },
        { value: false, label: translate("agora", "Without comments") }
      ],
      support: [
        { value: null, label: translate("agora", "Any supports") },
        { value: true, label: translate("agora", "With supports") },
        { value: false, label: translate("agora", "Without supports") }
      ]
    }));
    const applyFilters = () => {
      if (!inquiriesStore) {
        console.error("Inquiries store not initialized");
        return;
      }
      inquiriesStore.setFilters({
        type: selectedType.value === "all" ? void 0 : selectedType.value,
        categoryId: selectedCategory.value === "all" ? void 0 : selectedCategory.value,
        locationId: selectedLocation.value === "all" ? void 0 : selectedLocation.value,
        hasComments: hasComments.value,
        hasSupports: hasSupports.value,
        search: searchQuery.value.trim() || void 0
      });
    };
    const resetFilters = () => {
      selectedType.value = "all";
      selectedCategory.value = "all";
      selectedLocation.value = "all";
      hasComments.value = null;
      hasSupports.value = null;
      searchQuery.value = "";
      inquiriesStore.resetFilters();
    };
    const activeFiltersCount = computed(() => {
      let count = 0;
      if (selectedType.value !== "all") count += 1;
      if (selectedCategory.value !== "all") count += 1;
      if (selectedLocation.value !== "all") count += 1;
      if (hasComments.value !== null) count += 1;
      if (hasSupports.value !== null) count += 1;
      if (searchQuery.value.trim()) count += 1;
      return count;
    });
    onUnmounted(() => {
      inquiriesStore.resetFilters();
    });
    const __returned__ = { sessionStore, inquiriesStore, selectedType, selectedCategory, selectedLocation, hasComments, hasSupports, searchQuery, isFiltersOpen, filterOptions, applyFilters, resetFilters, activeFiltersCount, get t() {
      return translate;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$N = { class: "inquiry-filters" };
const _hoisted_2$x = { class: "filters-header" };
const _hoisted_3$w = { class: "search-box compact" };
const _hoisted_4$s = ["placeholder"];
const _hoisted_5$7 = {
  key: 0,
  class: "filter-count"
};
const _hoisted_6$6 = { class: "toggle-arrow" };
const _hoisted_7$5 = {
  key: 0,
  class: "filters-expanded"
};
const _hoisted_8$5 = { class: "filters-grid" };
const _hoisted_9$4 = { class: "filter-group" };
const _hoisted_10$3 = ["value"];
const _hoisted_11$3 = {
  key: 0,
  class: "filter-group"
};
const _hoisted_12$2 = ["value"];
const _hoisted_13$2 = {
  key: 1,
  class: "filter-group"
};
const _hoisted_14$2 = ["value"];
const _hoisted_15$2 = { class: "filter-group" };
const _hoisted_16$1 = ["value"];
const _hoisted_17$1 = { class: "filter-group" };
const _hoisted_18$1 = ["value"];
const _hoisted_19$1 = {
  key: 1,
  class: "active-filters-summary"
};
const _hoisted_20$1 = { class: "summary-label" };
const _hoisted_21$1 = {
  key: 0,
  class: "filter-tag"
};
const _hoisted_22$1 = {
  key: 1,
  class: "filter-tag"
};
const _hoisted_23$1 = {
  key: 2,
  class: "filter-tag"
};
const _hoisted_24$1 = {
  key: 3,
  class: "filter-tag"
};
const _hoisted_25$1 = {
  key: 4,
  class: "filter-tag"
};
const _hoisted_26$1 = {
  key: 5,
  class: "filter-tag"
};
function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$N, [
    createBaseVNode("div", _hoisted_2$x, [
      createBaseVNode("div", _hoisted_3$w, [
        withDirectives(createBaseVNode("input", {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.searchQuery = $event),
          type: "text",
          placeholder: $setup.t("agora", "Search inquiries..."),
          class: "search-input",
          onInput: $setup.applyFilters
        }, null, 40, _hoisted_4$s), [
          [vModelText, $setup.searchQuery]
        ]),
        _cache[7] || (_cache[7] = createBaseVNode(
          "span",
          { class: "search-icon" },
          "ð",
          -1
          /* CACHED */
        ))
      ]),
      createBaseVNode(
        "button",
        {
          class: normalizeClass(["filters-toggle-btn", { active: $setup.isFiltersOpen }]),
          onClick: _cache[1] || (_cache[1] = ($event) => $setup.isFiltersOpen = !$setup.isFiltersOpen)
        },
        [
          _cache[8] || (_cache[8] = createBaseVNode(
            "span",
            { class: "filter-icon" },
            "âï¸",
            -1
            /* CACHED */
          )),
          createTextVNode(
            " " + toDisplayString($setup.t("agora", "Filters")) + " ",
            1
            /* TEXT */
          ),
          $setup.activeFiltersCount > 0 ? (openBlock(), createElementBlock(
            "span",
            _hoisted_5$7,
            toDisplayString($setup.activeFiltersCount),
            1
            /* TEXT */
          )) : createCommentVNode("v-if", true),
          createBaseVNode(
            "span",
            _hoisted_6$6,
            toDisplayString($setup.isFiltersOpen ? "â²" : "â¼"),
            1
            /* TEXT */
          )
        ],
        2
        /* CLASS */
      ),
      $setup.activeFiltersCount > 0 ? (openBlock(), createElementBlock(
        "button",
        {
          key: 0,
          class: "reset-btn compact",
          onClick: $setup.resetFilters
        },
        toDisplayString($setup.t("agora", "Clear all")),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true)
    ]),
    $setup.isFiltersOpen ? (openBlock(), createElementBlock("div", _hoisted_7$5, [
      createBaseVNode("div", _hoisted_8$5, [
        createCommentVNode(" Filtre par type "),
        createBaseVNode("div", _hoisted_9$4, [
          createBaseVNode(
            "label",
            null,
            toDisplayString($setup.t("agora", "Type")),
            1
            /* TEXT */
          ),
          withDirectives(createBaseVNode(
            "select",
            {
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.selectedType = $event),
              onChange: $setup.applyFilters
            },
            [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.filterOptions.types, (option2) => {
                  return openBlock(), createElementBlock("option", {
                    key: option2.value,
                    value: option2.value
                  }, toDisplayString(option2.label), 9, _hoisted_10$3);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ],
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vModelSelect, $setup.selectedType]
          ])
        ]),
        $setup.filterOptions.categories.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_11$3, [
          createBaseVNode(
            "label",
            null,
            toDisplayString($setup.t("agora", "Category")),
            1
            /* TEXT */
          ),
          withDirectives(createBaseVNode(
            "select",
            {
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.selectedCategory = $event),
              onChange: $setup.applyFilters
            },
            [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.filterOptions.categories, (option2) => {
                  return openBlock(), createElementBlock("option", {
                    key: option2.value,
                    value: option2.value
                  }, toDisplayString(option2.label), 9, _hoisted_12$2);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ],
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vModelSelect, $setup.selectedCategory]
          ])
        ])) : createCommentVNode("v-if", true),
        $setup.filterOptions.locations.length > 1 ? (openBlock(), createElementBlock("div", _hoisted_13$2, [
          createBaseVNode(
            "label",
            null,
            toDisplayString($setup.t("agora", "Location")),
            1
            /* TEXT */
          ),
          withDirectives(createBaseVNode(
            "select",
            {
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $setup.selectedLocation = $event),
              onChange: $setup.applyFilters
            },
            [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.filterOptions.locations, (option2) => {
                  return openBlock(), createElementBlock("option", {
                    key: option2.value,
                    value: option2.value
                  }, toDisplayString(option2.label), 9, _hoisted_14$2);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ],
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vModelSelect, $setup.selectedLocation]
          ])
        ])) : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_15$2, [
          createBaseVNode(
            "label",
            null,
            toDisplayString($setup.t("agora", "Comments")),
            1
            /* TEXT */
          ),
          withDirectives(createBaseVNode(
            "select",
            {
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $setup.hasComments = $event),
              onChange: $setup.applyFilters
            },
            [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.filterOptions.participation, (option2) => {
                  return openBlock(), createElementBlock("option", {
                    key: String(option2.value),
                    value: option2.value
                  }, toDisplayString(option2.label), 9, _hoisted_16$1);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ],
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vModelSelect, $setup.hasComments]
          ])
        ]),
        createBaseVNode("div", _hoisted_17$1, [
          createBaseVNode(
            "label",
            null,
            toDisplayString($setup.t("agora", "Supports")),
            1
            /* TEXT */
          ),
          withDirectives(createBaseVNode(
            "select",
            {
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $setup.hasSupports = $event),
              onChange: $setup.applyFilters
            },
            [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.filterOptions.support, (option2) => {
                  return openBlock(), createElementBlock("option", {
                    key: String(option2.value),
                    value: option2.value
                  }, toDisplayString(option2.label), 9, _hoisted_18$1);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ],
            544
            /* NEED_HYDRATION, NEED_PATCH */
          ), [
            [vModelSelect, $setup.hasSupports]
          ])
        ])
      ])
    ])) : createCommentVNode("v-if", true),
    $setup.activeFiltersCount > 0 ? (openBlock(), createElementBlock("div", _hoisted_19$1, [
      createBaseVNode(
        "span",
        _hoisted_20$1,
        toDisplayString($setup.t("agora", "Active:")),
        1
        /* TEXT */
      ),
      $setup.selectedType !== "all" ? (openBlock(), createElementBlock(
        "span",
        _hoisted_21$1,
        toDisplayString($setup.filterOptions.types.find((t) => t.value === $setup.selectedType)?.label),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      $setup.selectedCategory !== "all" ? (openBlock(), createElementBlock(
        "span",
        _hoisted_22$1,
        toDisplayString($setup.filterOptions.categories.find((c) => c.value === $setup.selectedCategory)?.label),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      $setup.selectedLocation !== "all" ? (openBlock(), createElementBlock(
        "span",
        _hoisted_23$1,
        toDisplayString($setup.filterOptions.locations.find((l) => l.value === $setup.selectedLocation)?.label),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      $setup.hasComments !== null ? (openBlock(), createElementBlock(
        "span",
        _hoisted_24$1,
        toDisplayString($setup.filterOptions.participation.find((p) => p.value === $setup.hasComments)?.label),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      $setup.hasSupports !== null ? (openBlock(), createElementBlock(
        "span",
        _hoisted_25$1,
        toDisplayString($setup.filterOptions.support.find((s) => s.value === $setup.hasSupports)?.label),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      $setup.searchQuery ? (openBlock(), createElementBlock(
        "span",
        _hoisted_26$1,
        ' "' + toDisplayString($setup.searchQuery) + '" ',
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true)
    ])) : createCommentVNode("v-if", true)
  ]);
}
const InquiryFilter = /* @__PURE__ */ _export_sfc$1(_sfc_main$19, [["render", _sfc_render$19], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/InquiryFilter.vue"]]);
const _sfc_main$18 = {
  name: "SortAscendingIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$M = ["aria-hidden", "aria-label"];
const _hoisted_2$w = ["fill", "width", "height"];
const _hoisted_3$v = { d: "M19 17H22L18 21L14 17H17V3H19M2 17H12V19H2M6 5V7H2V5M2 11H9V13H2V11Z" };
const _hoisted_4$r = { key: 0 };
function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon sort-ascending-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$v, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$r,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$w))
  ], 16, _hoisted_1$M);
}
const SortAscendingIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$18, [["render", _sfc_render$18], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/SortAscending.vue"]]);
const _sfc_main$17 = {
  name: "CommentIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$L = ["aria-hidden", "aria-label"];
const _hoisted_2$v = ["fill", "width", "height"];
const _hoisted_3$u = { d: "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9Z" };
const _hoisted_4$q = { key: 0 };
function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon comment-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$u, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$q,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$v))
  ], 16, _hoisted_1$L);
}
const CommentIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$17, [["render", _sfc_render$17], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Comment.vue"]]);
const _sfc_main$16 = {
  name: "SortDescendingIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$K = ["aria-hidden", "aria-label"];
const _hoisted_2$u = ["fill", "width", "height"];
const _hoisted_3$t = { d: "M19 7H22L18 3L14 7H17V21H19M2 17H12V19H2M6 5V7H2V5M2 11H9V13H2V11Z" };
const _hoisted_4$p = { key: 0 };
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon sort-descending-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$t, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$p,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$u))
  ], 16, _hoisted_1$K);
}
const SortDescendingIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$16, [["render", _sfc_render$16], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/SortDescending.vue"]]);
const _sfc_main$15 = {
  name: "AlphabeticalIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$J = ["aria-hidden", "aria-label"];
const _hoisted_2$t = ["fill", "width", "height"];
const _hoisted_3$s = { d: "M6,11A2,2 0 0,1 8,13V17H4A2,2 0 0,1 2,15V13A2,2 0 0,1 4,11H6M4,13V15H6V13H4M20,13V15H22V17H20A2,2 0 0,1 18,15V13A2,2 0 0,1 20,11H22V13H20M12,7V11H14A2,2 0 0,1 16,13V15A2,2 0 0,1 14,17H12A2,2 0 0,1 10,15V7H12M12,15H14V13H12V15Z" };
const _hoisted_4$o = { key: 0 };
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon alphabetical-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$s, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$o,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$t))
  ], 16, _hoisted_1$J);
}
const AlphabeticalIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$15, [["render", _sfc_render$15], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Alphabetical.vue"]]);
const _sfc_main$14 = {
  name: "GestureDoubleTapIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$I = ["aria-hidden", "aria-label"];
const _hoisted_2$s = ["fill", "width", "height"];
const _hoisted_3$r = { d: "M10,9A1,1 0 0,1 11,8A1,1 0 0,1 12,9V13.47L13.21,13.6L18.15,15.79C18.68,16.03 19,16.56 19,17.14V21.5C18.97,22.32 18.32,22.97 17.5,23H11C10.62,23 10.26,22.85 10,22.57L5.1,18.37L5.84,17.6C6.03,17.39 6.3,17.28 6.58,17.28H6.8L10,19V9M11,5A4,4 0 0,1 15,9C15,10.5 14.2,11.77 13,12.46V11.24C13.61,10.69 14,9.89 14,9A3,3 0 0,0 11,6A3,3 0 0,0 8,9C8,9.89 8.39,10.69 9,11.24V12.46C7.8,11.77 7,10.5 7,9A4,4 0 0,1 11,5M11,3A6,6 0 0,1 17,9C17,10.7 16.29,12.23 15.16,13.33L14.16,12.88C15.28,11.96 16,10.56 16,9A5,5 0 0,0 11,4A5,5 0 0,0 6,9C6,11.05 7.23,12.81 9,13.58V14.66C6.67,13.83 5,11.61 5,9A6,6 0 0,1 11,3Z" };
const _hoisted_4$n = { key: 0 };
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon gesture-double-tap-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$r, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$n,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$s))
  ], 16, _hoisted_1$I);
}
const GestureDoubleTapIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$14, [["render", _sfc_render$14], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/GestureDoubleTap.vue"]]);
const _sfc_main$13 = {
  name: "ClockPlusOutlineIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$H = ["aria-hidden", "aria-label"];
const _hoisted_2$r = ["fill", "width", "height"];
const _hoisted_3$q = { d: "M14.47 15.08L11 13V7H12.5V12.25L15.58 14.08C15.17 14.36 14.79 14.7 14.47 15.08M13.08 19.92C12.72 19.97 12.37 20 12 20C7.58 20 4 16.42 4 12S7.58 4 12 4 20 7.58 20 12C20 12.37 19.97 12.72 19.92 13.08C20.61 13.18 21.25 13.4 21.84 13.72C21.94 13.16 22 12.59 22 12C22 6.5 17.5 2 12 2S2 6.5 2 12C2 17.5 6.47 22 12 22C12.59 22 13.16 21.94 13.72 21.84C13.4 21.25 13.18 20.61 13.08 19.92M18 15V18H15V20H18V23H20V20H23V18H20V15H18Z" };
const _hoisted_4$m = { key: 0 };
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon clock-plus-outline-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$q, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$m,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$r))
  ], 16, _hoisted_1$H);
}
const CreationIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$13, [["render", _sfc_render$13], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/ClockPlusOutline.vue"]]);
const _sfc_main$12 = {
  name: "AccountCircleOutlineIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$G = ["aria-hidden", "aria-label"];
const _hoisted_2$q = ["fill", "width", "height"];
const _hoisted_3$p = { d: "M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7.07,18.28C7.5,17.38 10.12,16.5 12,16.5C13.88,16.5 16.5,17.38 16.93,18.28C15.57,19.36 13.86,20 12,20C10.14,20 8.43,19.36 7.07,18.28M18.36,16.83C16.93,15.09 13.46,14.5 12,14.5C10.54,14.5 7.07,15.09 5.64,16.83C4.62,15.5 4,13.82 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,13.82 19.38,15.5 18.36,16.83M12,6C10.06,6 8.5,7.56 8.5,9.5C8.5,11.44 10.06,13 12,13C13.94,13 15.5,11.44 15.5,9.5C15.5,7.56 13.94,6 12,6M12,11A1.5,1.5 0 0,1 10.5,9.5A1.5,1.5 0 0,1 12,8A1.5,1.5 0 0,1 13.5,9.5A1.5,1.5 0 0,1 12,11Z" };
const _hoisted_4$l = { key: 0 };
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon account-circle-outline-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$p, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$l,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$q))
  ], 16, _hoisted_1$G);
}
const AccountCircleOutlineIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$12, [["render", _sfc_render$12], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/AccountCircleOutline.vue"]]);
const _sfc_main$11 = {
  name: "TargetIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$F = ["aria-hidden", "aria-label"];
const _hoisted_2$p = ["fill", "width", "height"];
const _hoisted_3$o = { d: "M11,2V4.07C7.38,4.53 4.53,7.38 4.07,11H2V13H4.07C4.53,16.62 7.38,19.47 11,19.93V22H13V19.93C16.62,19.47 19.47,16.62 19.93,13H22V11H19.93C19.47,7.38 16.62,4.53 13,4.07V2M11,6.08V8H13V6.09C15.5,6.5 17.5,8.5 17.92,11H16V13H17.91C17.5,15.5 15.5,17.5 13,17.92V16H11V17.91C8.5,17.5 6.5,15.5 6.08,13H8V11H6.09C6.5,8.5 8.5,6.5 11,6.08M12,11A1,1 0 0,0 11,12A1,1 0 0,0 12,13A1,1 0 0,0 13,12A1,1 0 0,0 12,11Z" };
const _hoisted_4$k = { key: 0 };
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon target-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$o, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$k,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$p))
  ], 16, _hoisted_1$F);
}
const TypeIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$11, [["render", _sfc_render$11], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Target.vue"]]);
const _sfc_main$10 = /* @__PURE__ */ defineComponent({
  __name: "InquiryListSort",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiriesStore = useInquiriesStore();
    const sortDirection = computed({
      get() {
        return inquiriesStore.sort.reverse ? "desc" : "asc";
      },
      set(direction) {
        if (direction === "asc") {
          inquiriesStore.sort.reverse = false;
        } else {
          inquiriesStore.sort.reverse = true;
        }
      }
    });
    function setSort(sort) {
      if (sort.by !== void 0) {
        inquiriesStore.sort.by = sort.by;
      }
      if (sort.reverse !== void 0) {
        inquiriesStore.sort.reverse = sort.reverse;
      }
    }
    const __returned__ = { inquiriesStore, sortDirection, setSort, get t() {
      return translate;
    }, get sortTitlesMapping() {
      return sortTitlesMapping;
    }, get NcActions() {
      return NcActions;
    }, get NcActionButton() {
      return NcActionButton;
    }, get NcActionSeparator() {
      return NcActionSeparator;
    }, SortAscendingIcon, CommentIcon, get ThumbIcon() {
      return ThumbIcon;
    }, SortDescendingIcon, AlphabeticalIcon, GestureDoubleTapIcon, CreationIcon, ExpirationIcon, AccountCircleOutlineIcon, TypeIcon, get NcActionButtonGroup() {
      return NcActionButtonGroup;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcActions"], {
    primary: "",
    "menu-name": $setup.sortTitlesMapping[$setup.inquiriesStore.sort.by]
  }, {
    icon: withCtx(() => [
      $setup.inquiriesStore.sort.reverse ? (openBlock(), createBlock($setup["SortDescendingIcon"], {
        key: 0,
        size: 20,
        decorative: ""
      })) : (openBlock(), createBlock($setup["SortAscendingIcon"], {
        key: 1,
        size: 20,
        decorative: ""
      }))
    ]),
    default: withCtx(() => [
      createVNode($setup["NcActionButton"], {
        name: $setup.sortTitlesMapping["title"],
        "aria-label": $setup.t("agora", "Sort by title"),
        onClick: _cache[0] || (_cache[0] = ($event) => $setup.setSort({ by: "title" }))
      }, {
        icon: withCtx(() => [
          createVNode($setup["AlphabeticalIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"]),
      createVNode($setup["NcActionButton"], {
        name: $setup.sortTitlesMapping["type"],
        "aria-label": $setup.t("agora", "Sort by type"),
        onClick: _cache[1] || (_cache[1] = ($event) => $setup.setSort({ by: "type" }))
      }, {
        icon: withCtx(() => [
          createVNode($setup["TypeIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"]),
      createVNode($setup["NcActionButton"], {
        name: $setup.sortTitlesMapping["countComments"],
        "aria-label": $setup.t("agora", "Sort by comments"),
        onClick: _cache[2] || (_cache[2] = ($event) => $setup.setSort({ by: "countComments" }))
      }, {
        icon: withCtx(() => [
          createVNode($setup["CommentIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"]),
      createVNode($setup["NcActionButton"], {
        name: $setup.sortTitlesMapping["countSupports"],
        "aria-label": $setup.t("agora", "Sort by supports"),
        onClick: _cache[3] || (_cache[3] = ($event) => $setup.setSort({ by: "type" }))
      }, {
        icon: withCtx(() => [
          createVNode($setup["ThumbIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"]),
      createVNode($setup["NcActionButton"], {
        name: $setup.sortTitlesMapping["interaction"],
        "aria-label": $setup.t("agora", "Sort by last interaction"),
        onClick: _cache[4] || (_cache[4] = ($event) => $setup.setSort({ by: "interaction" }))
      }, {
        icon: withCtx(() => [
          createVNode($setup["GestureDoubleTapIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"]),
      createVNode($setup["NcActionButton"], {
        name: $setup.sortTitlesMapping["created"],
        "aria-label": $setup.t("agora", "Sort by creation date"),
        onClick: _cache[5] || (_cache[5] = ($event) => $setup.setSort({ by: "created" }))
      }, {
        icon: withCtx(() => [
          createVNode($setup["CreationIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"]),
      createVNode($setup["NcActionButton"], {
        name: $setup.sortTitlesMapping["expire"],
        "aria-label": $setup.t("agora", "Sort by expiration date"),
        onClick: _cache[6] || (_cache[6] = ($event) => $setup.setSort({ by: "expire" }))
      }, {
        icon: withCtx(() => [
          createVNode($setup["ExpirationIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"]),
      createVNode($setup["NcActionButton"], {
        name: $setup.sortTitlesMapping["owner"],
        "aria-label": $setup.t("agora", "Sort by owner name"),
        onClick: _cache[7] || (_cache[7] = ($event) => $setup.setSort({ by: "owner" }))
      }, {
        icon: withCtx(() => [
          createVNode($setup["AccountCircleOutlineIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label"]),
      createVNode($setup["NcActionSeparator"]),
      createVNode($setup["NcActionButtonGroup"], {
        name: $setup.t("agora", "Direction")
      }, {
        default: withCtx(() => [
          createVNode($setup["NcActionButton"], {
            modelValue: $setup.sortDirection,
            "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $setup.sortDirection = $event),
            value: "desc",
            type: "radio",
            "aria-label": $setup.t("agora", "Descending")
          }, {
            icon: withCtx(() => [
              createVNode($setup["SortDescendingIcon"])
            ]),
            _: 1
            /* STABLE */
          }, 8, ["modelValue", "aria-label"]),
          createVNode($setup["NcActionButton"], {
            modelValue: $setup.sortDirection,
            "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $setup.sortDirection = $event),
            value: "asc",
            type: "radio",
            "aria-label": $setup.t("agora", "Ascending")
          }, {
            icon: withCtx(() => [
              createVNode($setup["SortAscendingIcon"])
            ]),
            _: 1
            /* STABLE */
          }, 8, ["modelValue", "aria-label"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name"])
    ]),
    _: 1
    /* STABLE */
  }, 8, ["menu-name"]);
}
const InquiryListSort = /* @__PURE__ */ _export_sfc$1(_sfc_main$10, [["render", _sfc_render$10], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/InquiryListSort.vue"]]);
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "DeleteInquiryDialog",
  props: /* @__PURE__ */ mergeModels({
    inquiry: { type: Object, required: true }
  }, {
    "modelValue": { type: Boolean, ...{ required: true } },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["deleted"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const model = useModel(__props, "modelValue");
    const emit2 = __emit;
    const inquiriesStore = useInquiriesStore();
    const sessionStore = useSessionStore();
    const adminAccess = computed(() => !__props.inquiry.permissions.view && sessionStore.currentUser.isAdmin);
    function dialogOK() {
      try {
        inquiriesStore.delete({ inquiryId: __props.inquiry.id });
        emit2("deleted");
      } catch {
        showError(translate("agora", "Error deleting inquiry."));
      }
    }
    const dialogText = adminAccess.value ? translate("inquiries", "This will finally delete the inquiry and {username} will get notified.", {
      username: __props.inquiry.owner.displayName
    }) : translate("agora", "This will finally delete the inquiry.");
    const dialogProps = {
      name: translate("agora", "Delete inquiry"),
      noClose: true,
      closeOnClickOutside: true,
      buttons: [
        { label: translate("agora", "Cancel") },
        {
          label: translate("agora", "OK"),
          variant: "primary",
          callback: () => {
            dialogOK();
          }
        }
      ]
    };
    const __returned__ = { model, emit: emit2, inquiriesStore, sessionStore, adminAccess, dialogOK, dialogText, dialogProps, get NcDialog() {
      return NcDialog;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcDialog"], mergeProps({
    open: $setup.model,
    "onUpdate:open": _cache[0] || (_cache[0] = ($event) => $setup.model = $event)
  }, $setup.dialogProps), {
    default: withCtx(() => [
      createBaseVNode(
        "span",
        null,
        toDisplayString($setup.dialogText),
        1
        /* TEXT */
      )
    ]),
    _: 1
    /* STABLE */
  }, 16, ["open"]);
}
const DeleteInquiryDialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["render", _sfc_render$$], ["__file", "/var/www/nextcloud/apps/agora/src/components/Modals/DeleteInquiryDialog.vue"]]);
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "UserSearch",
  props: /* @__PURE__ */ mergeModels({
    placeholder: { type: String, required: false, default: () => translate("agora", "Type to start searching â¦") },
    ariaLabel: { type: String, required: false, default: () => translate("agora", "Select users") },
    searchTypes: { type: Array, required: false, default: () => [99] },
    closeOnSelect: { type: Boolean, required: false, default: false }
  }, {
    "modelValue": { type: null },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["userSelected"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const model = useModel(__props, "modelValue");
    const users = ref([]);
    const isLoading = ref(false);
    const loadUsersAsync = lodashExports.debounce(async function(query) {
      if (!query) {
        users.value = [];
        return;
      }
      isLoading.value = true;
      try {
        const response = await appSettings.getUsers(query, __props.searchTypes);
        users.value = response.data.siteusers;
        isLoading.value = false;
      } catch (error) {
        if (error?.code === "ERR_CANCELED") {
          return;
        }
        Logger.error("Error loading users", { error });
        isLoading.value = false;
      }
    }, 250);
    async function optionSelected(user) {
      emit2("userSelected", user);
    }
    const selectProps = {
      ariaLabelCombobox: __props.ariaLabel,
      multiple: false,
      userSelect: true,
      tagWidth: 80,
      loading: isLoading.value,
      filterable: false,
      searchable: true,
      placeholder: __props.placeholder,
      closeOnSelect: __props.closeOnSelect,
      dropdownShouldOpen: () => users.value.length > 0,
      label: "displayName"
    };
    const __returned__ = { emit: emit2, model, users, isLoading, loadUsersAsync, optionSelected, selectProps, get NcSelectUsers() {
      return NcSelectUsers;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$E = {
  key: 0,
  class: "multiselect__single"
};
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcSelectUsers"], mergeProps({
    id: "ajax",
    modelValue: $setup.model,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.model = $event)
  }, $setup.selectProps, {
    options: $setup.users,
    "onOption:selected": $setup.optionSelected,
    onSearch: $setup.loadUsersAsync
  }), {
    selection: withCtx(({ values: values2, isOpen }) => [
      values2.length && !isOpen ? (openBlock(), createElementBlock(
        "span",
        _hoisted_1$E,
        toDisplayString(values2.length) + " users selected ",
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  }, 16, ["modelValue", "options", "onSearch"]);
}
const UserSearch = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["render", _sfc_render$_], ["__file", "/var/www/nextcloud/apps/agora/src/components/User/UserSearch.vue"]]);
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "TransferInquiryDialog",
  props: /* @__PURE__ */ mergeModels({
    inquiry: { type: Object, required: true }
  }, {
    "modelValue": { type: Boolean, ...{ required: true } },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["accessDenied"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const model = useModel(__props, "modelValue");
    const inquiriesStore = useInquiriesStore();
    const inquiryStore = useInquiryStore();
    const newUser = ref(void 0);
    async function dialogOK() {
      try {
        await inquiriesStore.changeOwner({
          inquiryId: __props.inquiry.id,
          userId: newUser.value ? newUser.value.id : ""
        });
        showSuccess(
          translate("agora", "Transfered inquiry to {user}.", {
            user: newUser.value ? newUser.value.displayName : ""
          })
        );
      } catch {
        showError(translate("agora", "Error transfering inquiry."));
      } finally {
        try {
          await inquiryStore.load();
        } catch {
          emit2("accessDenied");
        }
      }
    }
    const dialogText = computed(() => {
      if (__props.inquiry.currentUserStatus.isOwner) {
        if (!newUser.value) {
          return translate(
            "inquiries",
            "Transfering a inquiry to another user may result in loss of access to this inquiry."
          );
        }
        return translate(
          "inquiries",
          "Transfering a inquiry to {user} may result in loss of access to this inquiry.",
          {
            user: newUser.value.displayName
          }
        );
      }
      if (!newUser.value) {
        return translate(
          "inquiries",
          "You are not the owner of this inquiry. {owner} will get informed about this action.",
          {
            owner: __props.inquiry.owner.displayName
          }
        );
      }
      return translate(
        "inquiries",
        "You are not the owner of this inquiry. {owner} will get informed about the transfer to {newUser}.",
        {
          owner: __props.inquiry.owner.displayName,
          newUser: newUser.value.displayName
        }
      );
    });
    const dialogProps = computed(() => ({
      name: translate("agora", "Transfer inquiry"),
      noClose: true,
      closeOnClickOutside: true,
      buttons: [
        { label: translate("agora", "Cancel") },
        {
          label: translate("agora", "OK"),
          variant: "primary",
          disabled: !newUser.value,
          callback: () => {
            dialogOK();
          }
        }
      ]
    }));
    const __returned__ = { emit: emit2, model, inquiriesStore, inquiryStore, newUser, dialogOK, dialogText, dialogProps, get t() {
      return translate;
    }, get NcDialog() {
      return NcDialog;
    }, UserSearch };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcDialog"], mergeProps({
    open: $setup.model,
    "onUpdate:open": _cache[2] || (_cache[2] = ($event) => $setup.model = $event)
  }, $setup.dialogProps), {
    default: withCtx(() => [
      createVNode($setup["UserSearch"], {
        modelValue: $setup.newUser,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.newUser = $event),
        "search-types": [0],
        "input-label": $setup.t("agora", "Select the user to transfer the ownership to"),
        "user-select": "",
        "close-on-select": "",
        onUserSelected: _cache[1] || (_cache[1] = (user) => $setup.newUser = user)
      }, null, 8, ["modelValue", "input-label"]),
      createBaseVNode(
        "span",
        null,
        toDisplayString($setup.dialogText),
        1
        /* TEXT */
      )
    ]),
    _: 1
    /* STABLE */
  }, 16, ["open"]);
}
const TransferInquiryDialog = /* @__PURE__ */ _export_sfc$1(_sfc_main$Z, [["render", _sfc_render$Z], ["__file", "/var/www/nextcloud/apps/agora/src/components/Modals/TransferInquiryDialog.vue"]]);
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "InquiryItemActions",
  props: {
    inquiry: { type: Object, required: true }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const route = useRoute();
    const inquiriesStore = useInquiriesStore();
    const inquiryGroupsStore = useInquiryGroupsStore();
    const sessionStore = useSessionStore();
    const showDeleteDialog = ref(false);
    const showTransferDialog = ref(false);
    const subMenu = ref(null);
    const newGroupTitle = ref("");
    const context2 = computed(
      () => createPermissionContextForContent(
        ContentType.Inquiry,
        __props.inquiry.owner.id,
        __props.inquiry.configuration.access === "public",
        __props.inquiry.status.isLocked,
        __props.inquiry.status.isExpired,
        __props.inquiry.status.deletionDate > 0,
        __props.inquiry.status.isArchived,
        __props.inquiry.inquiryGroups.length > 0,
        __props.inquiry.inquiryGroups,
        __props.inquiry.type
      )
    );
    async function toggleSubMenu(action = null) {
      subMenu.value = subMenu.value === action ? null : action;
    }
    async function removeInquiryFromGroup(inquiryId, inquiryGroupId) {
      subMenu.value = null;
      try {
        await inquiryGroupsStore.removeInquiryFromGroup({
          inquiryId,
          inquiryGroupId
        });
        if (!inquiryGroupsStore.currentInquiryGroup) {
          showInfo(translate("agora", "The inquiry group was deleted by removing the last member."));
          if (route.name === "group") {
            router.push({ name: "root" });
          }
        }
      } catch {
        showError(translate("agora", "Error removing inquiry from group."));
      }
    }
    async function addInquiryToInquiryGroup(inquiryId, inquiryGroupId) {
      subMenu.value = null;
      inquiryGroupsStore.addInquiryToInquiryGroup({
        inquiryId,
        inquiryGroupId
      });
    }
    async function addInquiryToNewInquiryGroup(inquiryId) {
      if (!newGroupTitle.value.trim()) {
        return;
      }
      try {
        await inquiryGroupsStore.addInquiryToInquiryGroup({
          inquiryId,
          groupTitle: newGroupTitle.value.trim()
        });
        newGroupTitle.value = "";
        subMenu.value = null;
      } catch {
        showError(translate("agora", "Error creating new inquiry group."));
      }
    }
    async function toggleArchive() {
      try {
        await inquiriesStore.toggleArchive({ inquiryId: __props.inquiry.id });
      } catch {
        showError(translate("agora", "Error archiving/restoring inquiry."));
      }
    }
    const __returned__ = { route, inquiriesStore, inquiryGroupsStore, sessionStore, showDeleteDialog, showTransferDialog, subMenu, newGroupTitle, context: context2, toggleSubMenu, removeInquiryFromGroup, addInquiryToInquiryGroup, addInquiryToNewInquiryGroup, toggleArchive, get NcActionInput() {
      return NcActionInput;
    }, get t() {
      return translate;
    }, get InquiryGeneralIcons() {
      return InquiryGeneralIcons;
    }, get NcActions() {
      return NcActions;
    }, get NcActionButton() {
      return NcActionButton;
    }, DeleteInquiryDialog, TransferInquiryDialog, get canArchive() {
      return canArchive;
    }, get canRestore() {
      return canRestore;
    }, get canDelete() {
      return canDelete;
    }, get canEdit() {
      return canEdit;
    }, get canTransfer() {
      return canTransfer;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment$1,
    null,
    [
      createVNode($setup["NcActions"], { "force-menu": "" }, {
        default: withCtx(() => [
          $setup.subMenu ? (openBlock(), createBlock($setup["NcActionButton"], {
            key: 0,
            "aria-label": $setup.t("agora", "Back"),
            name: $setup.t("agora", "Back"),
            onClick: _cache[0] || (_cache[0] = ($event) => $setup.subMenu = null)
          }, {
            icon: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.back), { size: 16 }))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["aria-label", "name"])) : (openBlock(), createElementBlock(
            Fragment$1,
            { key: 1 },
            [
              withDirectives(createVNode($setup["NcActionButton"], {
                name: $setup.t("agora", "Archive inquiry"),
                "aria-label": $setup.t("agora", "Archive inquiry"),
                "close-after-click": "",
                onClick: _cache[1] || (_cache[1] = ($event) => $setup.toggleArchive())
              }, {
                icon: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.archive), { size: 24 }))
                ]),
                _: 1
                /* STABLE */
              }, 8, ["name", "aria-label"]), [
                [vShow, $setup.canArchive($setup.context)]
              ]),
              withDirectives(createVNode($setup["NcActionButton"], {
                name: $setup.t("agora", "Restore inquiry"),
                "aria-label": $setup.t("agora", "Restore inquiry"),
                "close-after-click": "",
                onClick: _cache[2] || (_cache[2] = ($event) => $setup.toggleArchive())
              }, {
                icon: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.restore), { size: 24 }))
                ]),
                _: 1
                /* STABLE */
              }, 8, ["name", "aria-label"]), [
                [vShow, $setup.canRestore($setup.context)]
              ]),
              withDirectives(createVNode($setup["NcActionButton"], {
                class: "danger",
                name: $setup.t("agora", "Delete inquiry"),
                "aria-label": $setup.t("agora", "Delete inquiry"),
                "close-after-click": "",
                onClick: _cache[3] || (_cache[3] = ($event) => $setup.showDeleteDialog = true)
              }, {
                icon: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.delete), { size: 24 }))
                ]),
                _: 1
                /* STABLE */
              }, 8, ["name", "aria-label"]), [
                [vShow, $setup.canDelete($setup.context)]
              ]),
              withDirectives(createVNode($setup["NcActionButton"], {
                class: "danger",
                name: $setup.t("agora", "Transfer inquiry ownership"),
                "aria-label": $setup.t("agora", "Transfer inquiry ownership"),
                "close-after-click": "",
                onClick: _cache[4] || (_cache[4] = ($event) => $setup.showTransferDialog = true)
              }, {
                icon: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.transfer), { size: 24 }))
                ]),
                _: 1
                /* STABLE */
              }, 8, ["name", "aria-label"]), [
                [vShow, $setup.canTransfer($setup.context)]
              ]),
              withDirectives(createVNode(
                $setup["NcActionButton"],
                {
                  "is-menu": "",
                  name: "Add to group",
                  onClick: _cache[5] || (_cache[5] = ($event) => $setup.toggleSubMenu("addToGroup"))
                },
                {
                  icon: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.plus), { size: 16 }))
                  ]),
                  _: 1
                  /* STABLE */
                },
                512
                /* NEED_PATCH */
              ), [
                [vShow, $setup.canEdit($setup.context)]
              ]),
              withDirectives(createVNode(
                $setup["NcActionButton"],
                {
                  "is-menu": "",
                  name: "Remove from group",
                  onClick: _cache[6] || (_cache[6] = ($event) => $setup.toggleSubMenu("removeFromGroup"))
                },
                {
                  icon: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.minus), { size: 16 }))
                  ]),
                  _: 1
                  /* STABLE */
                },
                512
                /* NEED_PATCH */
              ), [
                [vShow, $props.inquiry.permissions.edit && $props.inquiry.inquiryGroups.length > 0]
              ])
            ],
            64
            /* STABLE_FRAGMENT */
          )),
          $setup.subMenu === "addToGroup" ? (openBlock(), createElementBlock(
            Fragment$1,
            { key: 2 },
            [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.inquiryGroupsStore.addableInquiryGroups($props.inquiry.id), (inquiryGroup) => {
                  return openBlock(), createBlock($setup["NcActionButton"], {
                    key: `add-${inquiryGroup.id}`,
                    name: inquiryGroup.name,
                    onClick: ($event) => $setup.addInquiryToInquiryGroup($props.inquiry.id, inquiryGroup.id)
                  }, null, 8, ["name", "onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              )),
              $setup.sessionStore.appPermissions.inquiryCreation ? (openBlock(), createBlock($setup["NcActionInput"], {
                key: 0,
                modelValue: $setup.newGroupTitle,
                "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $setup.newGroupTitle = $event),
                name: $setup.t("agora", "Create new group"),
                "aria-label": $setup.t("agora", "Create new group"),
                placeholder: $setup.t("agora", "New group name"),
                onSubmit: _cache[8] || (_cache[8] = ($event) => $setup.addInquiryToNewInquiryGroup($props.inquiry.id))
              }, null, 8, ["modelValue", "name", "aria-label", "placeholder"])) : createCommentVNode("v-if", true)
            ],
            64
            /* STABLE_FRAGMENT */
          )) : createCommentVNode("v-if", true),
          $setup.subMenu === "removeFromGroup" ? (openBlock(true), createElementBlock(
            Fragment$1,
            { key: 3 },
            renderList($props.inquiry.inquiryGroups, (inquiryGroupId) => {
              return openBlock(), createBlock($setup["NcActionButton"], {
                key: `remove-${inquiryGroupId}`,
                name: $setup.inquiryGroupsStore.getInquiryGroupName(inquiryGroupId),
                onClick: ($event) => $setup.removeInquiryFromGroup($props.inquiry.id, inquiryGroupId)
              }, null, 8, ["name", "onClick"]);
            }),
            128
            /* KEYED_FRAGMENT */
          )) : createCommentVNode("v-if", true)
        ]),
        _: 1
        /* STABLE */
      }),
      createVNode($setup["TransferInquiryDialog"], {
        modelValue: $setup.showTransferDialog,
        "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $setup.showTransferDialog = $event),
        inquiry: $props.inquiry,
        onClose: _cache[10] || (_cache[10] = ($event) => $setup.showTransferDialog = false)
      }, null, 8, ["modelValue", "inquiry"]),
      createVNode($setup["DeleteInquiryDialog"], {
        modelValue: $setup.showDeleteDialog,
        "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => $setup.showDeleteDialog = $event),
        inquiry: $props.inquiry,
        onClose: _cache[12] || (_cache[12] = ($event) => $setup.showDeleteDialog = false)
      }, null, 8, ["modelValue", "inquiry"])
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
const InquiryItemActions = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["render", _sfc_render$Y], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/InquiryItemActions.vue"]]);
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "InquiryList",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiriesStore = useInquiriesStore();
    const inquiryGroupsStore = useInquiryGroupsStore();
    const preferencesStore = usePreferencesStore();
    const sessionStore = useSessionStore();
    const route = useRoute();
    const title = computed(() => {
      if (route.name === "group") {
        return inquiryGroupsStore.currentInquiryGroup?.titleExt || inquiryGroupsStore.currentInquiryGroup?.name || "";
      }
      return inquiriesStore.categories[route.params.type].titleExt;
    });
    const showMore = computed(
      () => inquiriesStore.chunkedList.length < inquiriesStore.inquiriesFilteredSorted.length && inquiriesStore.meta.status !== "loading"
    );
    const countLoadedInquiries = computed(
      () => Math.min(inquiriesStore.chunkedList.length, inquiriesStore.inquiriesFilteredSorted.length)
    );
    const infoLoaded = computed(
      () => translatePlural(
        "agora",
        "{loadedInquiries} of {countInquiries} inquiry loaded.",
        "{loadedInquiries} of {countInquiries} inquiries loaded.",
        inquiriesStore.inquiriesFilteredSorted.length,
        {
          loadedInquiries: countLoadedInquiries.value,
          countInquiries: inquiriesStore.inquiriesFilteredSorted.length
        }
      )
    );
    const description = computed(() => {
      if (route.name === "group") {
        return inquiryGroupsStore.currentInquiryGroup?.description || "";
      }
      return inquiriesStore.categories[route.params.type].description;
    });
    const emptyInquiryListnoInquiries = computed(
      () => inquiriesStore.inquiriesFilteredSorted.length < 1
    );
    const isGridView = computed(() => preferencesStore.user.defaultViewInquiry === "table-view");
    const loadingOverlayProps = {
      name: translate("agora", "Loading overviewâ¦"),
      teleportTo: "#content-vue",
      loadingTexts: [
        translate("agora", "Fetching inquiriesâ¦"),
        translate("agora", "Checking accessâ¦"),
        translate("agora", "Almost readyâ¦"),
        translate("agora", "Do not go awayâ¦"),
        translate("agora", "Please be patientâ¦")
      ]
    };
    const emptyContentProps = computed(() => ({
      name: translate("agora", "No inquiries found for this category"),
      description: translate("agora", "Add one or change category!")
    }));
    async function loadMore() {
      try {
        inquiriesStore.addChunk();
      } catch {
        showError(translate("agora", "Error loading more inquiries"));
      }
    }
    onMounted(() => {
      inquiriesStore.load(false);
    });
    const __returned__ = { inquiriesStore, inquiryGroupsStore, preferencesStore, sessionStore, route, title, showMore, countLoadedInquiries, infoLoaded, description, emptyInquiryListnoInquiries, isGridView, loadingOverlayProps, emptyContentProps, loadMore, get t() {
      return translate;
    }, get NcAppContent() {
      return NcAppContent;
    }, get NcEmptyContent() {
      return NcEmptyContent;
    }, get HeaderBar() {
      return HeaderBar;
    }, get IntersectionObserver() {
      return IntersectionObserver$1;
    }, get AgoraAppIcon() {
      return AgoraAppIcon;
    }, InquiryItem, InquiryFilter, InquiryListSort, InquiryItemActions, ActionAddInquiry, ActionToggleSidebar, LoadingOverlay };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$D = { class: "area__main" };
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcAppContent"], { class: "inquiry-list" }, {
    default: withCtx(() => [
      createVNode($setup["HeaderBar"], null, {
        title: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.title),
            1
            /* TEXT */
          )
        ]),
        right: withCtx(() => [
          $setup.preferencesStore.user.useNewInquiryInInquiryist ? (openBlock(), createBlock($setup["ActionAddInquiry"], { key: 0 })) : createCommentVNode("v-if", true),
          createVNode($setup["InquiryListSort"]),
          $setup.inquiryGroupsStore.currentInquiryGroup?.owner.id === $setup.sessionStore.currentUser.id ? (openBlock(), createBlock($setup["ActionToggleSidebar"], { key: 1 })) : createCommentVNode("v-if", true)
        ]),
        default: withCtx(() => [
          createTextVNode(
            " " + toDisplayString($setup.description) + " ",
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }),
      createVNode($setup["InquiryFilter"]),
      createBaseVNode("div", _hoisted_1$D, [
        !$setup.emptyInquiryListnoInquiries ? (openBlock(), createBlock(TransitionGroup, {
          key: 0,
          tag: "div",
          name: "list",
          class: normalizeClass([
            "inquiry-list__container",
            $setup.isGridView ? "inquiry-list__grid" : "inquiry-list__list"
          ])
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(
              Fragment$1,
              null,
              renderList($setup.inquiriesStore.chunkedList, (inquiry) => {
                return openBlock(), createBlock($setup["InquiryItem"], {
                  key: inquiry.id,
                  inquiry,
                  "grid-view": $setup.isGridView
                }, {
                  actions: withCtx(() => [
                    inquiry.permissions.edit || $setup.sessionStore.appPermissions.inquiryCreation ? (openBlock(), createBlock($setup["InquiryItemActions"], {
                      key: `actions-${inquiry.id}`,
                      inquiry
                    }, null, 8, ["inquiry"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                  /* DYNAMIC */
                }, 1032, ["inquiry", "grid-view"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        }, 8, ["class"])) : createCommentVNode("v-if", true),
        $setup.showMore ? (openBlock(), createBlock($setup["IntersectionObserver"], {
          key: "observer",
          class: "observer_section",
          onVisible: $setup.loadMore
        }, {
          default: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: "clickable_load_more",
                onClick: $setup.loadMore
              },
              toDisplayString($setup.infoLoaded) + " " + toDisplayString($setup.t("agora", "Click here to load more")),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        })) : createCommentVNode("v-if", true),
        $setup.emptyInquiryListnoInquiries ? (openBlock(), createBlock(
          $setup["NcEmptyContent"],
          normalizeProps(mergeProps({ key: 2 }, $setup.emptyContentProps)),
          {
            icon: withCtx(() => [
              createVNode($setup["AgoraAppIcon"])
            ]),
            _: 1
            /* STABLE */
          },
          16
          /* FULL_PROPS */
        )) : createCommentVNode("v-if", true)
      ]),
      createVNode($setup["LoadingOverlay"], mergeProps({
        show: $setup.inquiriesStore.meta.status === "loading"
      }, $setup.loadingOverlayProps), null, 16, ["show"])
    ]),
    _: 1
    /* STABLE */
  });
}
const List = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["render", _sfc_render$X], ["__file", "/var/www/nextcloud/apps/agora/src/views/InquiryList.vue"]]);
const _sfc_main$W = {
  name: "MagnifyIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$C = ["aria-hidden", "aria-label"];
const _hoisted_2$o = ["fill", "width", "height"];
const _hoisted_3$n = { d: "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" };
const _hoisted_4$j = { key: 0 };
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon magnify-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$n, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$j,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$o))
  ], 16, _hoisted_1$C);
}
const SearchIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$W, [["render", _sfc_render$W], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Magnify.vue"]]);
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  __name: "NotFound",
  setup(__props, { expose: __expose }) {
    __expose();
    const emptyContentProps = {
      name: translate("agora", "404 - inquiry not found"),
      description: translate("agora", "Enter a inquiry or start a new one.")
    };
    const __returned__ = { emptyContentProps, get NcAppContent() {
      return NcAppContent;
    }, get NcEmptyContent() {
      return NcEmptyContent;
    }, SearchIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcAppContent"], null, {
    default: withCtx(() => [
      createVNode(
        $setup["NcEmptyContent"],
        normalizeProps(guardReactiveProps($setup.emptyContentProps)),
        {
          icon: withCtx(() => [
            createVNode($setup["SearchIcon"])
          ]),
          _: 1
          /* STABLE */
        },
        16
        /* FULL_PROPS */
      )
    ]),
    _: 1
    /* STABLE */
  });
}
const NotFound = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["render", _sfc_render$V], ["__file", "/var/www/nextcloud/apps/agora/src/views/NotFound.vue"]]);
//! moment.js
//! version : 2.30.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray$1(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject$1(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k;
    for (k in obj) {
      if (hasOwnProp(obj, k)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined$1(input) {
  return input === void 0;
}
function isNumber$2(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate$1(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map$2(arr, fn) {
  var res = [], i, arrLen = arr.length;
  for (i = 0; i < arrLen; ++i) {
    res.push(fn(arr[i], i));
  }
  return res;
}
function extend$1(a, b) {
  for (var i in b) {
    if (hasOwnProp(b, i)) {
      a[i] = b[i];
    }
  }
  if (hasOwnProp(b, "toString")) {
    a.toString = b.toString;
  }
  if (hasOwnProp(b, "valueOf")) {
    a.valueOf = b.valueOf;
  }
  return a;
}
function createUTC(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m) {
  if (m._pf == null) {
    m._pf = defaultParsingFlags();
  }
  return m._pf;
}
var some$2;
if (Array.prototype.some) {
  some$2 = Array.prototype.some;
} else {
  some$2 = function(fun) {
    var t = Object(this), len = t.length >>> 0, i;
    for (i = 0; i < len; i++) {
      if (i in t && fun.call(this, t[i], i, t)) {
        return true;
      }
    }
    return false;
  };
}
function isValid(m) {
  var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
  if (isNowValid) {
    flags = getParsingFlags(m);
    parsedParts = some$2.call(flags.parsedDateParts, function(i) {
      return i != null;
    });
    isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
  }
  if (Object.isFrozen == null || !Object.isFrozen(m)) {
    m._isValid = isNowValid;
  } else {
    return isNowValid;
  }
  return m._isValid;
}
function createInvalid(flags) {
  var m = createUTC(NaN);
  if (flags != null) {
    extend$1(getParsingFlags(m), flags);
  } else {
    getParsingFlags(m).userInvalidated = true;
  }
  return m;
}
var momentProperties = hooks.momentProperties = [], updateInProgress = false;
function copyConfig(to2, from3) {
  var i, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined$1(from3._isAMomentObject)) {
    to2._isAMomentObject = from3._isAMomentObject;
  }
  if (!isUndefined$1(from3._i)) {
    to2._i = from3._i;
  }
  if (!isUndefined$1(from3._f)) {
    to2._f = from3._f;
  }
  if (!isUndefined$1(from3._l)) {
    to2._l = from3._l;
  }
  if (!isUndefined$1(from3._strict)) {
    to2._strict = from3._strict;
  }
  if (!isUndefined$1(from3._tzm)) {
    to2._tzm = from3._tzm;
  }
  if (!isUndefined$1(from3._isUTC)) {
    to2._isUTC = from3._isUTC;
  }
  if (!isUndefined$1(from3._offset)) {
    to2._offset = from3._offset;
  }
  if (!isUndefined$1(from3._pf)) {
    to2._pf = getParsingFlags(from3);
  }
  if (!isUndefined$1(from3._locale)) {
    to2._locale = from3._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i = 0; i < momentPropertiesLen; i++) {
      prop = momentProperties[i];
      val = from3[prop];
      if (!isUndefined$1(val)) {
        to2[prop] = val;
      }
    }
  }
  return to2;
}
function Moment(config) {
  copyConfig(this, config);
  this._d = new Date(config._d != null ? config._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = /* @__PURE__ */ new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn) {
  var firstTime = true;
  return extend$1(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i, key, argLen = arguments.length;
      for (i = 0; i < argLen; i++) {
        arg = "";
        if (typeof arguments[i] === "object") {
          arg += "\n[" + i + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn.apply(this, arguments);
  }, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name, msg);
  }
  if (!deprecations[name]) {
    warn(msg);
    deprecations[name] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction$3(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config) {
  var prop, i;
  for (i in config) {
    if (hasOwnProp(config, i)) {
      prop = config[i];
      if (isFunction$3(prop)) {
        this[i] = prop;
      } else {
        this["_" + i] = prop;
      }
    }
  }
  this._config = config;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend$1({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject$1(parentConfig[prop]) && isObject$1(childConfig[prop])) {
        res[prop] = {};
        extend$1(res[prop], parentConfig[prop]);
        extend$1(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$1(parentConfig[prop])) {
      res[prop] = extend$1({}, res[prop]);
    }
  }
  return res;
}
function Locale(config) {
  if (config != null) {
    this.set(config);
  }
}
var keys$2;
if (Object.keys) {
  keys$2 = Object.keys;
} else {
  keys$2 = function(obj) {
    var i, res = [];
    for (i in obj) {
      if (hasOwnProp(obj, i)) {
        res.push(i);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now2) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction$3(output) ? output.call(mom, now2) : output;
}
function zeroFill(number, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format2) {
  var array = format2.match(formattingTokens), i, length;
  for (i = 0, length = array.length; i < length; i++) {
    if (formatTokenFunctions[array[i]]) {
      array[i] = formatTokenFunctions[array[i]];
    } else {
      array[i] = removeFormattingTokens(array[i]);
    }
  }
  return function(mom) {
    var output = "", i2;
    for (i2 = 0; i2 < length; i2++) {
      output += isFunction$3(array[i2]) ? array[i2].call(mom, format2) : array[i2];
    }
    return output;
  };
}
function formatMoment(m, format2) {
  if (!m.isValid()) {
    return m.localeData().invalidDate();
  }
  format2 = expandFormat(format2, m.localeData());
  formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
  return formatFunctions[format2](m);
}
function expandFormat(format2, locale2) {
  var i = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i >= 0 && localFormattingTokens.test(format2)) {
    format2 = format2.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i -= 1;
  }
  return format2;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format2 || !formatUpper) {
    return format2;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number) {
  return this._ordinal.replace("%d", number);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number, withoutSuffix, string, isFuture) {
  var output = this._relativeTime[string];
  return isFunction$3(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
}
function pastFuture(diff2, output) {
  var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
  return isFunction$3(format2) ? format2(output) : format2.replace(/%s/i, output);
}
var aliases = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function getPrioritizedUnits(unitsObj) {
  var units = [], u;
  for (u in unitsObj) {
    if (hasOwnProp(unitsObj, u)) {
      units.push({ unit: u, priority: priorities[u] });
    }
  }
  units.sort(function(a, b) {
    return a.priority - b.priority;
  });
  return units;
}
var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction$3(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config._strict, config._locale);
}
function unescapeFormat(s) {
  return regexEscape(
    s.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
      }
    )
  );
}
function regexEscape(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function absFloor(number) {
  if (number < 0) {
    return Math.ceil(number) || 0;
  } else {
    return Math.floor(number);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
var tokens = {};
function addParseToken(token2, callback) {
  var i, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber$2(callback)) {
    func = function(input, array) {
      array[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i = 0; i < tokenLen; i++) {
    tokens[token2[i]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array, config, token3) {
    config._w = config._w || {};
    callback(input, config._w, config, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config._a, config, token2);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
addFormatToken("Y", 0, 0, function() {
  var y = this.year();
  return y <= 9999 ? zeroFill(y, 4) : "+" + y;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match2);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array) {
  array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array) {
  array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array) {
  array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get$1(this, unit);
    }
  };
}
function get$1(mom, unit) {
  if (!mom.isValid()) {
    return NaN;
  }
  var d = mom._d, isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
    case "Seconds":
      return isUTC ? d.getUTCSeconds() : d.getSeconds();
    case "Minutes":
      return isUTC ? d.getUTCMinutes() : d.getMinutes();
    case "Hours":
      return isUTC ? d.getUTCHours() : d.getHours();
    case "Date":
      return isUTC ? d.getUTCDate() : d.getDate();
    case "Day":
      return isUTC ? d.getUTCDay() : d.getDay();
    case "Month":
      return isUTC ? d.getUTCMonth() : d.getMonth();
    case "FullYear":
      return isUTC ? d.getUTCFullYear() : d.getFullYear();
    default:
      return NaN;
  }
}
function set$1(mom, unit, value) {
  var d, isUTC, year, month, date;
  if (!mom.isValid() || isNaN(value)) {
    return;
  }
  d = mom._d;
  isUTC = mom._isUTC;
  switch (unit) {
    case "Milliseconds":
      return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
    case "Seconds":
      return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
    case "Minutes":
      return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
    case "Hours":
      return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
    case "Date":
      return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
    // case 'Day': // Not real
    //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
    // case 'Month': // Not used because we need to pass two variables
    //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
    case "FullYear":
      break;
    // See below ...
    default:
      return;
  }
  year = value;
  month = mom.month();
  date = mom.date();
  date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
  void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction$3(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
    for (i = 0; i < prioritizedLen; i++) {
      this[prioritized[i].unit](units[prioritized[i].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction$3(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
function mod(n, x) {
  return (n % x + x) % x;
}
var indexOf$1;
if (Array.prototype.indexOf) {
  indexOf$1 = Array.prototype.indexOf;
} else {
  indexOf$1 = function(o) {
    var i;
    for (i = 0; i < this.length; ++i) {
      if (this[i] === o) {
        return i;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format2) {
  return this.localeData().monthsShort(this, format2);
});
addFormatToken("MMMM", 0, 0, function(format2) {
  return this.localeData().months(this, format2);
});
addRegexToken("M", match1to2, match1to2NoLeadingZero);
addRegexToken("MM", match1to2, match2);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array) {
  array[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
  var month = config._locale.monthsParse(input, token2, config._strict);
  if (month != null) {
    array[MONTH] = month;
  } else {
    getParsingFlags(config).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
function localeMonths(m, format2) {
  if (!m) {
    return isArray$1(this._months) ? this._months : this._months["standalone"];
  }
  return isArray$1(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
}
function localeMonthsShort(m, format2) {
  if (!m) {
    return isArray$1(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray$1(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
}
function handleStrictParse(monthName, format2, strict) {
  var i, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i = 0; i < 12; ++i) {
      mom = createUTC([2e3, i]);
      this._shortMonthsParse[i] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "MMM") {
      ii = indexOf$1.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf$1.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "MMM") {
      ii = indexOf$1.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf$1.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf$1.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf$1.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format2, strict) {
  var i, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format2, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    if (strict && !this._longMonthsParse[i]) {
      this._longMonthsParse[i] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
      return i;
    } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
      return i;
    } else if (!strict && this._monthsParse[i].test(monthName)) {
      return i;
    }
  }
}
function setMonth(mom, value) {
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber$2(value)) {
        return mom;
      }
    }
  }
  var month = value, date = mom.date();
  date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
  void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get$1(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
  for (i = 0; i < 12; i++) {
    mom = createUTC([2e3, i]);
    shortP = regexEscape(this.monthsShort(mom, ""));
    longP = regexEscape(this.months(mom, ""));
    shortPieces.push(shortP);
    longPieces.push(longP);
    mixedPieces.push(longP);
    mixedPieces.push(shortP);
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
function createDate(y, m, d, h2, M, s, ms) {
  var date;
  if (y < 100 && y >= 0) {
    date = new Date(y + 400, m, d, h2, M, s, ms);
    if (isFinite(date.getFullYear())) {
      date.setFullYear(y);
    }
  } else {
    date = new Date(y, m, d, h2, M, s, ms);
  }
  return date;
}
function createUTCDate(y) {
  var date, args;
  if (y < 100 && y >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y + 400;
    date = new Date(Date.UTC.apply(null, args));
    if (isFinite(date.getUTCFullYear())) {
      date.setUTCFullYear(y);
    }
  } else {
    date = new Date(Date.UTC.apply(null, arguments));
  }
  return date;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addRegexToken("w", match1to2, match1to2NoLeadingZero);
addRegexToken("ww", match1to2, match2);
addRegexToken("W", match1to2, match1to2NoLeadingZero);
addRegexToken("WW", match1to2, match2);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format2) {
  return this.localeData().weekdaysMin(this, format2);
});
addFormatToken("ddd", 0, 0, function(format2) {
  return this.localeData().weekdaysShort(this, format2);
});
addFormatToken("dddd", 0, 0, function(format2) {
  return this.localeData().weekdays(this, format2);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
  var weekday = config._locale.weekdaysParse(input, token2, config._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n) {
  return ws.slice(n, 7).concat(ws.slice(0, n));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m, format2) {
  var weekdays = isArray$1(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
  return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
}
function localeWeekdaysShort(m) {
  return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m) {
  return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format2, strict) {
  var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i = 0; i < 7; ++i) {
      mom = createUTC([2e3, 1]).day(i);
      this._minWeekdaysParse[i] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format2 === "dddd") {
      ii = indexOf$1.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf$1.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf$1.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format2 === "dddd") {
      ii = indexOf$1.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf$1.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf$1.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format2 === "ddd") {
      ii = indexOf$1.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf$1.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf$1.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf$1.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf$1.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf$1.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format2, strict) {
  var i, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format2, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    if (strict && !this._fullWeekdaysParse[i]) {
      this._fullWeekdaysParse[i] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
      return i;
    } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
      return i;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = get$1(this, "Day");
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a, b) {
    return b.length - a.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
  for (i = 0; i < 7; i++) {
    mom = createUTC([2e3, 1]).day(i);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2, match1to2HasZero);
addRegexToken("h", match1to2, match1to2NoLeadingZero);
addRegexToken("k", match1to2, match1to2NoLeadingZero);
addRegexToken("HH", match1to2, match2);
addRegexToken("hh", match1to2, match2);
addRegexToken("kk", match1to2, match2);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array, config) {
  var kInput = toInt(input);
  array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array, config) {
  config._isPm = config._locale.isPM(input);
  config._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array, config) {
  array[HOUR] = toInt(input);
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config).bigHour = true;
});
addParseToken("hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config).bigHour = true;
});
addParseToken("Hmm", function(input, array, config) {
  var pos = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos));
  array[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array, config) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array[HOUR] = toInt(input.substr(0, pos1));
  array[MINUTE] = toInt(input.substr(pos1, 2));
  array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {}, localeFamilies = {}, globalLocale;
function commonPrefix(arr1, arr2) {
  var i, minl = Math.min(arr1.length, arr2.length);
  for (i = 0; i < minl; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return i;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names) {
  var i = 0, j, next, locale2, split2;
  while (i < names.length) {
    split2 = normalizeLocale(names[i]).split("-");
    j = split2.length;
    next = normalizeLocale(names[i + 1]);
    next = next ? next.split("-") : null;
    while (j > 0) {
      locale2 = loadLocale(split2.slice(0, j).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j && commonPrefix(split2, next) >= j - 1) {
        break;
      }
      j--;
    }
    i++;
  }
  return globalLocale;
}
function isLocaleNameSane(name) {
  return !!(name && name.match("^[^/\\\\]*$"));
}
function loadLocale(name) {
  var oldLocale = null, aliasedRequire;
  if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = require;
      aliasedRequire("./locale/" + name);
      getSetGlobalLocale(oldLocale);
    } catch (e) {
      locales[name] = null;
    }
  }
  return locales[name];
}
function getSetGlobalLocale(key, values2) {
  var data;
  if (key) {
    if (isUndefined$1(values2)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values2);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name, config) {
  if (config !== null) {
    var locale2, parentConfig = baseConfig;
    config.abbr = name;
    if (locales[name] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name]._config;
    } else if (config.parentLocale != null) {
      if (locales[config.parentLocale] != null) {
        parentConfig = locales[config.parentLocale]._config;
      } else {
        locale2 = loadLocale(config.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config.parentLocale]) {
            localeFamilies[config.parentLocale] = [];
          }
          localeFamilies[config.parentLocale].push({
            name,
            config
          });
          return null;
        }
      }
    }
    locales[name] = new Locale(mergeConfigs(parentConfig, config));
    if (localeFamilies[name]) {
      localeFamilies[name].forEach(function(x) {
        defineLocale(x.name, x.config);
      });
    }
    getSetGlobalLocale(name);
    return locales[name];
  } else {
    delete locales[name];
    return null;
  }
}
function updateLocale(name, config) {
  if (config != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name] != null && locales[name].parentLocale != null) {
      locales[name].set(mergeConfigs(locales[name]._config, config));
    } else {
      tmpLocale = loadLocale(name);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config = mergeConfigs(parentConfig, config);
      if (tmpLocale == null) {
        config.abbr = name;
      }
      locale2 = new Locale(config);
      locale2.parentLocale = locales[name];
      locales[name] = locale2;
    }
    getSetGlobalLocale(name);
  } else {
    if (locales[name] != null) {
      if (locales[name].parentLocale != null) {
        locales[name] = locales[name].parentLocale;
        if (name === getSetGlobalLocale()) {
          getSetGlobalLocale(name);
        }
      } else if (locales[name] != null) {
        delete locales[name];
      }
    }
  }
  return locales[name];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray$1(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys$2(locales);
}
function checkOverflow(m) {
  var overflow, a = m._a;
  if (a && getParsingFlags(m).overflow === -2) {
    overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m).overflow = overflow;
  }
  return m;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
], isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config) {
  var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match) {
    getParsingFlags(config).iso = true;
    for (i = 0, l = isoDatesLen; i < l; i++) {
      if (isoDates[i][1].exec(match[1])) {
        dateFormat = isoDates[i][0];
        allowTime = isoDates[i][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config._isValid = false;
      return;
    }
    if (match[3]) {
      for (i = 0, l = isoTimesLen; i < l; i++) {
        if (isoTimes[i][1].exec(match[3])) {
          timeFormat = (match[2] || " ") + isoTimes[i][0];
          break;
        }
      }
      if (timeFormat == null) {
        config._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config._isValid = false;
      return;
    }
    if (match[4]) {
      if (tzRegex.exec(match[4])) {
        tzFormat = "Z";
      } else {
        config._isValid = false;
        return;
      }
    }
    config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config);
  } else {
    config._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result2 = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result2.push(parseInt(secondStr, 10));
  }
  return result2;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s) {
  return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config).weekdayMismatch = true;
      config._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
    return h2 * 60 + m;
  }
}
function configFromRFC2822(config) {
  var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
  if (match) {
    parsedArray = extractFromRFC2822Strings(
      match[4],
      match[3],
      match[2],
      match[5],
      match[6],
      match[7]
    );
    if (!checkWeekday(match[1], parsedArray, config)) {
      return;
    }
    config._a = parsedArray;
    config._tzm = calculateOffset(match[8], match[9], match[10]);
    config._d = createUTCDate.apply(null, config._a);
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    getParsingFlags(config).rfc2822 = true;
  } else {
    config._isValid = false;
  }
}
function configFromString(config) {
  var matched = aspNetJsonRegex.exec(config._i);
  if (matched !== null) {
    config._d = /* @__PURE__ */ new Date(+matched[1]);
    return;
  }
  configFromISO(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  configFromRFC2822(config);
  if (config._isValid === false) {
    delete config._isValid;
  } else {
    return;
  }
  if (config._strict) {
    config._isValid = false;
  } else {
    hooks.createFromInputFallback(config);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config) {
    config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
  }
);
function defaults$1(a, b, c) {
  if (a != null) {
    return a;
  }
  if (b != null) {
    return b;
  }
  return c;
}
function currentDateArray(config) {
  var nowValue = new Date(hooks.now());
  if (config._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config) {
  var i, date, input = [], currentDate, expectedWeekday, yearToUse;
  if (config._d) {
    return;
  }
  currentDate = currentDateArray(config);
  if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config);
  }
  if (config._dayOfYear != null) {
    yearToUse = defaults$1(config._a[YEAR], currentDate[YEAR]);
    if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
      getParsingFlags(config)._overflowDayOfYear = true;
    }
    date = createUTCDate(yearToUse, 0, config._dayOfYear);
    config._a[MONTH] = date.getUTCMonth();
    config._a[DATE] = date.getUTCDate();
  }
  for (i = 0; i < 3 && config._a[i] == null; ++i) {
    config._a[i] = input[i] = currentDate[i];
  }
  for (; i < 7; i++) {
    config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
  }
  if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
    config._nextDay = true;
    config._a[HOUR] = 0;
  }
  config._d = (config._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
  if (config._tzm != null) {
    config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
  }
  if (config._nextDay) {
    config._a[HOUR] = 24;
  }
  if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
    getParsingFlags(config).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config) {
  var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w = config._w;
  if (w.GG != null || w.W != null || w.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults$1(
      w.GG,
      config._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults$1(w.W, 1);
    weekday = defaults$1(w.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config._locale._week.dow;
    doy = config._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults$1(w.gg, config._a[YEAR], curWeek.year);
    week = defaults$1(w.w, curWeek.week);
    if (w.d != null) {
      weekday = w.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w.e != null) {
      weekday = w.e + dow;
      if (w.e < 0 || w.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config._a[YEAR] = temp.year;
    config._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config) {
  if (config._f === hooks.ISO_8601) {
    configFromISO(config);
    return;
  }
  if (config._f === hooks.RFC_2822) {
    configFromRFC2822(config);
    return;
  }
  config._a = [];
  getParsingFlags(config).empty = true;
  var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i = 0; i < tokenLen; i++) {
    token2 = tokens2[i];
    parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
    if (parsedInput) {
      skipped = string.substr(0, string.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config).unusedInput.push(skipped);
      }
      string = string.slice(
        string.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config).empty = false;
      } else {
        getParsingFlags(config).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config);
    } else if (config._strict && !parsedInput) {
      getParsingFlags(config).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
  if (string.length > 0) {
    getParsingFlags(config).unusedInput.push(string);
  }
  if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
    getParsingFlags(config).bigHour = void 0;
  }
  getParsingFlags(config).parsedDateParts = config._a.slice(0);
  getParsingFlags(config).meridiem = config._meridiem;
  config._a[HOUR] = meridiemFixWrap(
    config._locale,
    config._a[HOUR],
    config._meridiem
  );
  era = getParsingFlags(config).era;
  if (era !== null) {
    config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
  }
  configFromArray(config);
  checkOverflow(config);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config) {
  var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
  if (configfLen === 0) {
    getParsingFlags(config).invalidFormat = true;
    config._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (i = 0; i < configfLen; i++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config);
    if (config._useUTC != null) {
      tempConfig._useUTC = config._useUTC;
    }
    tempConfig._f = config._f[i];
    configFromStringAndFormat(tempConfig);
    if (isValid(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend$1(config, bestMoment || tempConfig);
}
function configFromObject(config) {
  if (config._d) {
    return;
  }
  var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
  config._a = map$2(
    [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config);
}
function createFromConfig(config) {
  var res = new Moment(checkOverflow(prepareConfig(config)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config) {
  var input = config._i, format2 = config._f;
  config._locale = config._locale || getLocale(config._l);
  if (input === null || format2 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config._i = input = config._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate$1(input)) {
    config._d = input;
  } else if (isArray$1(format2)) {
    configFromStringAndArray(config);
  } else if (format2) {
    configFromStringAndFormat(config);
  } else {
    configFromInput(config);
  }
  if (!isValid(config)) {
    config._d = null;
  }
  return config;
}
function configFromInput(config) {
  var input = config._i;
  if (isUndefined$1(input)) {
    config._d = new Date(hooks.now());
  } else if (isDate$1(input)) {
    config._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config);
  } else if (isArray$1(input)) {
    config._a = map$2(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config);
  } else if (isObject$1(input)) {
    configFromObject(config);
  } else if (isNumber$2(input)) {
    config._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config);
  }
}
function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
  var c = {};
  if (format2 === true || format2 === false) {
    strict = format2;
    format2 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject$1(input) && isObjectEmpty(input) || isArray$1(input) && input.length === 0) {
    input = void 0;
  }
  c._isAMomentObject = true;
  c._useUTC = c._isUTC = isUTC;
  c._l = locale2;
  c._i = input;
  c._f = format2;
  c._strict = strict;
  return createFromConfig(c);
}
function createLocal(input, format2, locale2, strict) {
  return createLocalOrUTC(input, format2, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
), prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn, moments) {
  var res, i;
  if (moments.length === 1 && isArray$1(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i = 1; i < moments.length; ++i) {
    if (!moments[i].isValid() || moments[i][fn](res)) {
      res = moments[i];
    }
  }
  return res;
}
function min$1() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max$1() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now$1 = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m) {
  var key, unitHasDecimal = false, i, orderLen = ordering.length;
  for (key in m) {
    if (hasOwnProp(m, key) && !(indexOf$1.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
      return false;
    }
  }
  for (i = 0; i < orderLen; ++i) {
    if (m[ordering[i]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number) {
  if (number < 0) {
    return Math.round(-1 * number) * -1;
  } else {
    return Math.round(number);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
  for (i = 0; i < len; i++) {
    if (toInt(array1[i]) !== toInt(array2[i])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset2 = this.utcOffset(), sign2 = "+";
    if (offset2 < 0) {
      offset2 = -offset2;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
  });
}
offset("Z", ":");
offset("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher2, string) {
  var matches2 = (string || "").match(matcher2), chunk2, parts, minutes2;
  if (matches2 === null) {
    return null;
  }
  chunk2 = matches2[matches2.length - 1] || [];
  parts = (chunk2 + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff2;
  if (model._isUTC) {
    res = model.clone();
    diff2 = (isMoment(input) || isDate$1(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff2);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m) {
  return -Math.round(m._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset2 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset2 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset2, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset2 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined$1(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c = {}, other;
  copyConfig(c, this);
  c = prepareConfig(c);
  if (c._a) {
    other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
    this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber$2(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match = aspNetRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match[DATE]) * sign2,
      h: toInt(match[HOUR]) * sign2,
      m: toInt(match[MINUTE]) * sign2,
      s: toInt(match[SECOND]) * sign2,
      ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match = isoRegex.exec(input)) {
    sign2 = match[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match[2], sign2),
      M: parseIso(match[3], sign2),
      w: parseIso(match[4], sign2),
      d: parseIso(match[5], sign2),
      h: parseIso(match[6], sign2),
      m: parseIso(match[7], sign2),
      s: parseIso(match[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base2, other) {
  var res = {};
  res.months = other.month() - base2.month() + (other.year() - base2.year()) * 12;
  if (base2.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base2.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base2, other) {
  var res;
  if (!(base2.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base2);
  if (base2.isBefore(other)) {
    res = positiveMomentsDifference(base2, other);
  } else {
    res = positiveMomentsDifference(other, base2);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name,
        "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get$1(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get$1(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
function isString$1(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate$1(input) || isString$1(input) || isNumber$2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject$1(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i, property2, propertyLen = properties.length;
  for (i = 0; i < propertyLen; i += 1) {
    property2 = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray$1(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber$2(item) && isString$1(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject$1(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i, property2;
  for (i = 0; i < properties.length; i += 1) {
    property2 = properties[i];
    propertyTest = propertyTest || hasOwnProp(input, property2);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now2) {
  var diff2 = myMoment.diff(now2, "days", true);
  return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction$3(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
  return this.format(
    output || this.localeData().calendar(format2, this, createLocal(now2))
  );
}
function clone$1() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from3, to2, units, inclusivity) {
  var localFrom = isMoment(from3) ? from3 : createLocal(from3), localTo = isMoment(to2) ? to2 : createLocal(to2);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    // 1000
    case "minute":
      output = (this - that) / 6e4;
      break;
    // 1000 * 60
    case "hour":
      output = (this - that) / 36e5;
      break;
    // 1000 * 60 * 60
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    // 1000 * 60 * 60 * 24, negate dst
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    // 1000 * 60 * 60 * 24 * 7, negate dst
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a, b) {
  if (a.date() < b.date()) {
    return -monthDiff(b, a);
  }
  var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b - anchor < 0) {
    anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString$1() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
  if (m.year() < 0 || m.year() > 9999) {
    return formatMoment(
      m,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction$3(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
    }
  }
  return formatMoment(
    m,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix, year, datetime, suffix;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix = zone + '[")]';
  return this.format(prefix + year + datetime + suffix);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from$1(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return new Date(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return new Date(y, m, d).valueOf();
  }
}
function utcStartOfDate(y, m, d) {
  if (y < 100 && y >= 0) {
    return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y, m, d);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray$1() {
  var m = this;
  return [
    m.year(),
    m.month(),
    m.date(),
    m.hour(),
    m.minute(),
    m.second(),
    m.millisecond()
  ];
}
function toObject() {
  var m = this;
  return {
    years: m.year(),
    months: m.month(),
    date: m.date(),
    hours: m.hours(),
    minutes: m.minutes(),
    seconds: m.seconds(),
    milliseconds: m.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid(this);
}
function parsingFlags() {
  return extend$1({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array, config, token2) {
    var era = config._locale.erasParse(input, token2, config._strict);
    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array, config, token2) {
  var match;
  if (config._locale._eraYearOrdinalRegex) {
    match = input.match(config._locale._eraYearOrdinalRegex);
  }
  if (config._locale.eraYearOrdinalParse) {
    array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
  } else {
    array[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m, format2) {
  var i, l, date, eras = this._eras || getLocale("en")._eras;
  for (i = 0, l = eras.length; i < l; ++i) {
    switch (typeof eras[i].since) {
      case "string":
        date = hooks(eras[i].since).startOf("day");
        eras[i].since = date.valueOf();
        break;
    }
    switch (typeof eras[i].until) {
      case "undefined":
        eras[i].until = Infinity;
        break;
      case "string":
        date = hooks(eras[i].until).startOf("day").valueOf();
        eras[i].until = date.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format2, strict) {
  var i, l, eras = this.eras(), name, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i = 0, l = eras.length; i < l; ++i) {
    name = eras[i].name.toUpperCase();
    abbr = eras[i].abbr.toUpperCase();
    narrow = eras[i].narrow.toUpperCase();
    if (strict) {
      switch (format2) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i];
          }
          break;
        case "NNNN":
          if (name === eraName) {
            return eras[i];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i];
          }
          break;
      }
    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].name;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].narrow;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i, l, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until) {
      return eras[i].abbr;
    }
    if (eras[i].until <= val && val <= eras[i].since) {
      return eras[i].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i, l, dir, val, eras = this.localeData().eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    dir = eras[i].since <= eras[i].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
      return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
  for (i = 0, l = eras.length; i < l; ++i) {
    erasName = regexEscape(eras[i].name);
    erasAbbr = regexEscape(eras[i].abbr);
    erasNarrow = regexEscape(eras[i].narrow);
    namePieces.push(erasName);
    abbrPieces.push(erasAbbr);
    narrowPieces.push(erasNarrow);
    mixedPieces.push(erasName);
    mixedPieces.push(erasAbbr);
    mixedPieces.push(erasNarrow);
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter) {
  addFormatToken(0, [token2, token2.length], 0, getter);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match2);
addRegexToken("gg", match1to2, match2);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date.getUTCFullYear());
  this.month(date.getUTCMonth());
  this.date(date.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addRegexToken("Q", match1);
addParseToken("Q", function(input, array) {
  array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addRegexToken("D", match1to2, match1to2NoLeadingZero);
addRegexToken("DD", match1to2, match2);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array) {
  array[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array, config) {
  config._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addRegexToken("m", match1to2, match1to2HasZero);
addRegexToken("mm", match1to2, match2);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addRegexToken("s", match1to2, match1to2HasZero);
addRegexToken("ss", match1to2, match2);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match2);
addRegexToken("SSS", match1to3, match3);
var token, getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
  array[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add;
proto.calendar = calendar$1;
proto.clone = clone$1;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from$1;
proto.fromNow = fromNow;
proto.to = to;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract;
proto.toArray = toArray$1;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString$1;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string) {
  return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1$1(format2, index, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index);
  return locale2[field](utc, format2);
}
function listMonthsImpl(format2, index, field) {
  if (isNumber$2(format2)) {
    index = format2;
    format2 = void 0;
  }
  format2 = format2 || "";
  if (index != null) {
    return get$1$1(format2, index, field, "month");
  }
  var i, out = [];
  for (i = 0; i < 12; i++) {
    out[i] = get$1$1(format2, i, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format2, index, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber$2(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  } else {
    format2 = localeSorted;
    index = format2;
    localeSorted = false;
    if (isNumber$2(format2)) {
      index = format2;
      format2 = void 0;
    }
    format2 = format2 || "";
  }
  var locale2 = getLocale(), shift2 = localeSorted ? locale2._week.dow : 0, i, out = [];
  if (index != null) {
    return get$1$1(format2, (index + shift2) % 7, field, "day");
  }
  for (i = 0; i < 7; i++) {
    out[i] = get$1$1(format2, (i + shift2) % 7, field, "day");
  }
  return out;
}
function listMonths(format2, index) {
  return listMonthsImpl(format2, index, "months");
}
function listMonthsShort(format2, index) {
  return listMonthsImpl(format2, index, "monthsShort");
}
function listWeekdays(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
}
function listWeekdaysShort(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format2, index) {
  return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number) {
    var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
    return number + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number) {
  if (number < 0) {
    return Math.floor(number);
  } else {
    return Math.ceil(number);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      // Math.floor prevents floating point math errors here
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
function clone$1$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name) {
  return function() {
    return this.isValid() ? this._data[name] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round = Math.round, thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a[2] = withoutSuffix;
  a[3] = +posNegDuration > 0;
  a[4] = locale2;
  return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round;
  }
  if (typeof roundingFunction === "function") {
    round = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x) {
  return (x > 0) - (x < 0) || +x;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array, config) {
  config._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array, config) {
  config._d = new Date(toInt(input));
});
//! moment.js
hooks.version = "2.30.1";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min$1;
hooks.max = max$1;
hooks.now = now$1;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate$1;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  __name: "InquiryInfoLine",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const sessionStore = useSessionStore();
    const sharesStore = useSharesStore();
    const availableStatuses = computed(
      () => sessionStore.appSettings.moderationStatusTab.filter((status) => status.inquiryType === inquiryStore.type).sort((a, b) => a.order - b.order)
    );
    const currentStatus = computed(
      () => availableStatuses.value.find(
        (status) => status.statusKey === inquiryStore.moderationStatus
      ) || [
        {
          statusKey: "draft",
          label: "Draft",
          icon: "Draft",
          inquiryType: inquiryStore.type,
          order: 0
        }
      ]
    );
    const selectedStatusKey = ref(currentStatus.value?.statusKey);
    const currentStatusLabel = computed(() => currentStatus.value?.label || "Draft");
    const currentStatusIcon = computed(() => StatusIcons[currentStatus.value?.icon]);
    const onStatusChange = async () => {
      try {
        await inquiryStore.setModerationStatus(selectedStatusKey.value);
        showSuccess(" Moderator status of this inquiry has been updated !");
      } catch (error) {
        console.error("Failed to update status:", error);
        selectedStatusKey.value = currentStatus.value.statusKey;
      }
    };
    const isNoAccessSet = computed(
      () => inquiryStore.configuration.access === "private" && !sharesStore.hasShares && inquiryStore.permissions.edit
    );
    const subTexts = computed(() => {
      const subTexts2 = [];
      if (inquiryStore.status.isArchived) {
        subTexts2.push({
          id: "deleted",
          text: translate("agora", "Archived"),
          class: "archived",
          iconComponent: InquiryGeneralIcons.archived
        });
        return subTexts2;
      }
      if (isNoAccessSet.value) {
        subTexts2.push({
          id: "no-access",
          text: [translate("agora", "Unpublished")].join(". "),
          class: "unpublished",
          iconComponent: InquiryGeneralIcons.unpublished
        });
        return subTexts2;
      }
      if (inquiryStore.configuration.access === "private") {
        subTexts2.push({
          id: inquiryStore.configuration.access,
          text: translate("agora", "A private inquiry from {name}", {
            name: inquiryStore.owner.displayName
          }),
          class: "",
          iconComponent: InquiryGeneralIcons.private
        });
      } else {
        subTexts2.push({
          id: inquiryStore.configuration.access,
          text: translate("agora", "An openly accessible inquiry from {name}", {
            name: inquiryStore.owner.displayName
          }),
          class: "",
          iconComponent: InquiryGeneralIcons.open
        });
      }
      if (inquiryStore.isClosed) {
        subTexts2.push({
          id: "closed",
          text: timeExpirationRelative.value,
          class: "closed",
          iconComponent: InquiryGeneralIcons.closed
        });
        return subTexts2;
      }
      if (subTexts2.length < 2) {
        subTexts2.push({
          id: "created",
          text: dateCreatedRelative.value,
          class: "created",
          iconComponent: InquiryGeneralIcons.creation
        });
      }
      return subTexts2;
    });
    const dateCreatedRelative = computed(() => moment.unix(inquiryStore.status.created).fromNow());
    const timeExpirationRelative = computed(() => {
      if (inquiryStore.configuration.expire) {
        return moment.unix(inquiryStore.configuration.expire).fromNow();
      }
      return translate("agora", "never");
    });
    const __returned__ = { inquiryStore, sessionStore, sharesStore, availableStatuses, currentStatus, selectedStatusKey, currentStatusLabel, currentStatusIcon, onStatusChange, isNoAccessSet, subTexts, dateCreatedRelative, timeExpirationRelative, get t() {
      return translate;
    }, get InquiryTypesUI() {
      return InquiryTypesUI$1;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$B = { class: "inquiry-info-line" };
const _hoisted_2$n = { class: "subtexts-left" };
const _hoisted_3$m = { class: "type-label" };
const _hoisted_4$i = { class: "sub-text" };
const _hoisted_5$6 = {
  key: 0,
  class: "inquiry-type-status"
};
const _hoisted_6$5 = { class: "status-badge" };
const _hoisted_7$4 = { class: "status-prefix" };
const _hoisted_8$4 = ["value"];
const _hoisted_9$3 = { class: "status-label" };
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$B, [
    createBaseVNode("div", _hoisted_2$n, [
      $setup.inquiryStore.type && $setup.InquiryTypesUI[$setup.inquiryStore.type]?.icon ? (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$setup.inquiryStore.type]?.icon), {
        key: 0,
        size: 20
      })) : createCommentVNode("v-if", true),
      createBaseVNode(
        "span",
        _hoisted_3$m,
        toDisplayString($setup.InquiryTypesUI[$setup.inquiryStore.type]?.label || $setup.inquiryStore.type),
        1
        /* TEXT */
      ),
      (openBlock(true), createElementBlock(
        Fragment$1,
        null,
        renderList($setup.subTexts, (subText) => {
          return openBlock(), createElementBlock(
            "span",
            {
              key: subText.id,
              class: normalizeClass(["sub-text", subText.class])
            },
            [
              (openBlock(), createBlock(resolveDynamicComponent(subText.iconComponent), { size: 16 })),
              createBaseVNode(
                "span",
                _hoisted_4$i,
                toDisplayString(subText.text),
                1
                /* TEXT */
              )
            ],
            2
            /* CLASS */
          );
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]),
    $setup.inquiryStore.type !== "official" ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
      createBaseVNode("div", _hoisted_6$5, [
        createBaseVNode(
          "span",
          _hoisted_7$4,
          toDisplayString($setup.t("agora", "Moderation status is:")),
          1
          /* TEXT */
        ),
        $setup.sessionStore.currentUser.isModerator ? withDirectives((openBlock(), createElementBlock(
          "select",
          {
            key: 0,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.selectedStatusKey = $event),
            onChange: $setup.onStatusChange
          },
          [
            (openBlock(true), createElementBlock(
              Fragment$1,
              null,
              renderList($setup.availableStatuses, (status) => {
                return openBlock(), createElementBlock("option", {
                  key: status.statusKey,
                  value: status.statusKey
                }, toDisplayString($setup.t("agora", status.label)), 9, _hoisted_8$4);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ],
          544
          /* NEED_HYDRATION, NEED_PATCH */
        )), [
          [vModelSelect, $setup.selectedStatusKey]
        ]) : (openBlock(), createElementBlock(
          Fragment$1,
          { key: 1 },
          [
            (openBlock(), createBlock(resolveDynamicComponent($setup.currentStatusIcon), { size: 20 })),
            createBaseVNode(
              "span",
              _hoisted_9$3,
              toDisplayString($setup.t("agora", $setup.currentStatusLabel)),
              1
              /* TEXT */
            )
          ],
          64
          /* STABLE_FRAGMENT */
        ))
      ])
    ])) : createCommentVNode("v-if", true)
  ]);
}
const InquiryInfoLine = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["render", _sfc_render$U], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/InquiryInfoLine.vue"]]);
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  __name: "InquiryHeaderButtons",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const sessionStore = useSessionStore();
    onBeforeUnmount(() => {
      inquiryStore.$reset();
    });
    const __returned__ = { inquiryStore, sessionStore, get ActionToggleSidebar() {
      return ActionToggleSidebar;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$A = { class: "inquiry-header-buttons" };
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$A, [
    $setup.inquiryStore.permissions.edit || $setup.sessionStore.appSettings.inquiryTypeRights[$setup.inquiryStore.type].inquiryComment ? (openBlock(), createBlock($setup["ActionToggleSidebar"], { key: 0 })) : createCommentVNode("v-if", true)
  ]);
}
const InquiryHeaderButtons = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["render", _sfc_render$T], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/InquiryHeaderButtons.vue"]]);
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string) â ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) â OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) â OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) â OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) â OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) â OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without2 = this.remove(key), content = without2.content.slice();
    var found2 = without2.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) â OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size) return this;
    return new OrderedMap(map3.content.concat(this.subtract(map3).content));
  },
  // :: (union<Object, OrderedMap>) â OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size) return this;
    return new OrderedMap(this.subtract(map3).content.concat(map3.content));
  },
  // :: (union<Object, OrderedMap>) â OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map3) {
    var result2 = this;
    map3 = OrderedMap.from(map3);
    for (var i = 0; i < map3.content.length; i += 2)
      result2 = result2.remove(map3.content[i]);
    return result2;
  },
  // :: () â Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result2 = {};
    this.forEach(function(key, value) {
      result2[key] = value;
    });
    return result2;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
function findDiffStart(a, b, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount)
      return a.childCount == b.childCount ? null : pos;
    let childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j = 0; childA.text[j] == childB.text[j]; j++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (let iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size2;
    posB -= size2;
  }
}
class Fragment {
  /**
  @internal
  */
  constructor(content, size2) {
    this.content = content;
    this.size = size2 || 0;
    if (size2 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from3, to2, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to2; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from3 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from3 - start), Math.min(child.content.size, to2 - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from3, to2, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from3, to2, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from3, pos) - pos, to2 - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last2 = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last2.isText && last2.sameMarkup(first2)) {
      content[content.length - 1] = last2.withText(last2.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from3, to2 = this.size) {
    if (from3 == 0 && to2 == this.size)
      return this;
    let result2 = [], size2 = 0;
    if (to2 > from3)
      for (let i = 0, pos = 0; pos < to2; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from3) {
          if (pos < from3 || end > to2) {
            if (child.isText)
              child = child.cut(Math.max(0, from3 - pos), Math.min(child.text.length, to2 - pos));
            else
              child = child.cut(Math.max(0, from3 - pos - 1), Math.min(child.content.size, to2 - pos - 1));
          }
          result2.push(child);
          size2 += child.nodeSize;
        }
        pos = end;
      }
    return new Fragment(result2, size2);
  }
  /**
  @internal
  */
  cutByIndex(from3, to2) {
    if (from3 == to2)
      return Fragment.empty;
    if (from3 == 0 && to2 == this.content.length)
      return this;
    return new Fragment(this.content.slice(from3, to2));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index, node) {
    let current = this.content[index];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size2 = this.size + node.nodeSize - current.nodeSize;
    copy2[index] = node;
    return new Fragment(copy2, size2);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index) {
    let found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content[index] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return Fragment.empty;
    let joined, size2 = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size2 += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array, size2);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes2) {
    if (!nodes2)
      return Fragment.empty;
    if (nodes2 instanceof Fragment)
      return nodes2;
    if (Array.isArray(nodes2))
      return this.fromArray(nodes2);
    if (nodes2.attrs)
      return new Fragment([nodes2], nodes2.nodeSize);
    throw new RangeError("Can not convert " + nodes2 + " to a Fragment" + (nodes2.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index, offset2) {
  found.index = index;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b) {
  if (a === b)
    return true;
  if (!(a && typeof a == "object") || !(b && typeof b == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b) != array)
    return false;
  if (array) {
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b) || !compareDeep(a[p], b[p]))
        return false;
    for (let p in b)
      if (!(p in a))
        return false;
  }
  return true;
}
let Mark$1 = class Mark {
  /**
  @internal
  */
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set2) {
    let copy2, placed = false;
    for (let i = 0; i < set2.length; i++) {
      let other = set2[i];
      if (this.eq(other))
        return set2;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set2.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set2;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set2.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set2.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set2) {
    for (let i = 0; i < set2.length; i++)
      if (this.eq(set2[i]))
        return set2.slice(0, i).concat(set2.slice(i + 1));
    return set2;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set2) {
    for (let i = 0; i < set2.length; i++)
      if (this.eq(set2[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type.create(json.attrs);
    type.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b) {
    if (a == b)
      return true;
    if (a.length != b.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark.none;
    if (marks instanceof Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b) => a.type.rank - b.type.rank);
    return copy2;
  }
};
Mark$1.none = [];
class ReplaceError extends Error {
}
class Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmentâi.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from3, to2) {
    return new Slice(removeRange(this.content, from3 + this.openStart, to2 + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from3, to2) {
  let { index, offset: offset2 } = content.findIndex(from3), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to2);
  if (offset2 == from3 || child.isText) {
    if (offsetTo != to2 && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from3).append(content.cut(to2));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from3 - offset2 - 1, to2 - offset2 - 1)));
}
function insertInto(content, dist2, insert, parent) {
  let { index, offset: offset2 } = content.findIndex(dist2), child = content.maybeChild(index);
  if (offset2 == dist2 || child.isText) {
    if (parent && !parent.canReplace(index, index, insert))
      return null;
    return content.cut(0, dist2).append(insert).append(content.cut(dist2));
  }
  let inner = insertInto(child.content, dist2 - offset2 - 1, insert, child);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice3) {
  if (slice3.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice3.openStart != $to.depth - slice3.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice3, 0);
}
function replaceOuter($from, $to, slice3, depth) {
  let index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice3.openStart) {
    let inner = replaceOuter($from, $to, slice3, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice3.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice3.openStart && !slice3.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice3.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice3, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable$1($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last2 = target.length - 1;
  if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))
    target[last2] = child.withText(target[last2].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable$1($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice3, $along) {
  let extra = $along.depth - slice3.openStart, parent = $along.node(extra);
  let node = parent.copy(slice3.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice3.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice3.openEnd - extra)
  };
}
class ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parentâtext nodes are âflatâ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark$1.none;
    if (this.textOffset)
      return parent.child(index).marks;
    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after2 = this.parent.maybeChild(this.index());
    if (!after2 || !after2.isInline)
      return null;
    let marks = after2.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
      if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
        return new NodeRange(this, other, d);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc2; ; ) {
      let { index, offset: offset2 } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node, index, start + offset2);
      if (!rem)
        break;
      node = node.child(index);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset2 + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc2, pos) {
    let cache = resolveCache.get(doc2);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc2, cache = new ResolveCache());
    }
    let result2 = cache.elts[cache.i] = ResolvedPos.resolve(doc2, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result2;
  }
}
class ResolveCache {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
}
const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
class NodeRange {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
class Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks = Mark$1.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index) {
    return this.content.child(index);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content.maybeChild(index);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from3, to2, f, startPos = 0) {
    this.content.nodesBetween(from3, to2, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(from3, to2, blockSeparator, leafText) {
    return this.content.textBetween(from3, to2, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from3, to2 = this.content.size) {
    if (from3 == 0 && to2 == this.content.size)
      return this;
    return this.copy(this.content.cut(from3, to2));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from3, to2 = this.content.size, includeParents = false) {
    if (from3 == to2)
      return Slice.empty;
    let $from = this.resolve(from3), $to = this.resolve(to2);
    let depth = includeParents ? 0 : $from.sharedDepth(to2);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from3, to2, slice3) {
    return replace(this.resolve(from3), this.resolve(to2), slice3);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index, offset: offset2 } = node.content.findIndex(pos);
      node = node.maybeChild(index);
      if (!node)
        return null;
      if (offset2 == pos || node.isText)
        return node;
      pos -= offset2 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index), index, offset: offset2 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index), index, offset: offset2 };
    let node = this.content.child(index - 1);
    return { node, index: index - 1, offset: offset2 - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from3, to2, type) {
    let found2 = false;
    if (to2 > from3)
      this.nodesBetween(from3, to2, (node) => {
        if (type.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from3, to2, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from3).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to2);
    if (!two || !two.validEnd)
      return false;
    for (let i = start; i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from3, to2, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from3).matchType(type);
    let end = start && start.matchFragment(this.content, to2);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark$1.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark$1.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
}
Node.prototype.text = void 0;
class TextNode extends Node {
  /**
  @internal
  */
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from3, to2) {
    return this.text.slice(from3, to2);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from3 = 0, to2 = this.text.length) {
    if (from3 == 0 && to2 == this.text.length)
      return this;
    return this.withText(this.text.slice(from3, to2));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
}
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
class ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type } = this.next[i];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j = 0; j < other.next.length; j++)
        if (this.next[i].type == other.next[j].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after2, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types) {
      let finished = match.matchFragment(after2, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed2 = this.computeWrapping(target);
    this.wrapCache.push(target, computed2);
    return computed2;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result2 = [];
        for (let obj = current; obj.type; obj = obj.via)
          result2.push(obj.type);
        return result2.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type, next } = match.next[i];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_âth outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m) {
      seen.push(m);
      for (let i = 0; i < m.next.length; i++)
        if (seen.indexOf(m.next[i].next) == -1)
          scan(m.next[i].next);
    }
    scan(this);
    return seen.map((m, i) => {
      let out = i + (m.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m.next.length; i2++)
        out += (i2 ? ", " : "") + m.next[i2].type.name + "->" + seen.indexOf(m.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result2 = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.isInGroup(name))
      result2.push(type2);
  }
  if (result2.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result2;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from3, to2, term) {
    let edge2 = { term, to: to2 };
    nfa2[from3].push(edge2);
    return edge2;
  }
  function connect(edges, to2) {
    edges.forEach((edge2) => edge2.to = to2);
  }
  function compile(expr2, from3) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from3)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from3);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from3 = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from3, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from3), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from3)].concat(compile(expr2.expr, from3));
    } else if (expr2.type == "range") {
      let cur = from3;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from3, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node) {
  let result2 = [];
  scan(node);
  return result2.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result2.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to: to2 } = edges[i];
      if (!term && result2.indexOf(to2) == -1)
        scan(to2);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to: to2 }) => {
        if (!term)
          return;
        let set2;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set2 = out[i][1];
        nullFrom(nfa2, to2).forEach((node2) => {
          if (!set2)
            out.push([term, set2 = []]);
          if (set2.indexOf(node2) == -1)
            set2.push(node2);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state = work[i], dead = !state.validEnd, nodes2 = [];
    for (let j = 0; j < state.next.length; j++) {
      let { type, next } = state.next[j];
      nodes2.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes2.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values2, type, name) {
  for (let name2 in values2)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values2[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result2 = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result2[name] = new Attribute(typeName, name, attrs[name]);
  return result2;
}
let NodeType$1 = class NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group2) {
    return this.groups.indexOf(group2) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before2 = this.contentMatch.fillBefore(content);
      if (!before2)
        return null;
      content = before2.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after2 = matched && matched.fillBefore(Fragment.empty, true);
    if (!after2)
      return null;
    return new Node(this, attrs, content.append(after2), Mark$1.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result2 = this.contentMatch.matchFragment(content);
    if (!result2 || !result2.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
  }
  /**
  @internal
  */
  static compile(nodes2, schema) {
    let result2 = /* @__PURE__ */ Object.create(null);
    nodes2.forEach((name, spec) => result2[name] = new NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result2[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result2.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _2 in result2.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result2;
  }
};
function validateType(typeName, attrName, type) {
  let types = type.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
class Attribute {
  constructor(typeName, attrName, options2) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options2, "default");
    this.default = options2.default;
    this.validate = typeof options2.validate == "string" ? validateType(typeName, attrName, options2.validate) : options2.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark$1(this, defaults2) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark$1(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result2 = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result2[name] = new MarkType(name, rank++, schema, spec));
    return result2;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set2) {
    for (var i = 0; i < set2.length; i++)
      if (set2[i].type == this) {
        set2 = set2.slice(0, i).concat(set2.slice(i + 1));
        i--;
      }
    return set2;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set2) {
    for (let i = 0; i < set2.length; i++)
      if (set2[i].type == this)
        return set2[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
class Schema {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      if (type.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type.isInline || !type.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type;
      }
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = (json) => Node.fromJSON(this, json);
    this.markFromJSON = (json) => Mark$1.fromJSON(this, json);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType$1))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text, Mark$1.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
}
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
class DOMParser {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules2) {
    this.schema = schema;
    this.rules = rules2;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules2.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom2, options2 = {}) {
    let context2 = new ParseContext(this, options2, false);
    context2.addAll(dom2, Mark$1.none, options2.from, options2.to);
    return context2.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom2, options2 = {}) {
    let context2 = new ParseContext(this, options2, true);
    context2.addAll(dom2, Mark$1.none, options2.from, options2.to);
    return Slice.maxOpen(context2.finish());
  }
  /**
  @internal
  */
  matchTag(dom2, context2, after2) {
    for (let i = after2 ? this.tags.indexOf(after2) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom2, rule.tag) && (rule.namespace === void 0 || dom2.namespaceURI == rule.namespace) && (!rule.context || context2.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result2 = rule.getAttrs(dom2);
          if (result2 === false)
            continue;
          rule.attrs = result2 || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context2, after2) {
    for (let i = after2 ? this.styles.indexOf(after2) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context2.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result2 = rule.getAttrs(value);
        if (result2 === false)
          continue;
        rule.attrs = result2 || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result2 = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result2.length; i++) {
        let next = result2[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result2.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules2 = schema.marks[name].spec.parseDOM;
      if (rules2)
        rules2.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules2 = schema.nodes[name].spec.parseDOM;
      if (rules2)
        rules2.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result2;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
  }
}
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type, attrs, marks, solid, match, options2) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options2;
    this.content = [];
    this.activeMarks = Mark$1.none;
    this.match = match || (options2 & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap2;
        if (wrap2 = start.findWrapping(node.type)) {
          this.match = start;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last2 = this.content[this.content.length - 1], m;
      if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
        let text = last2;
        if (last2.text.length == m[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser2, options2, isOpen) {
    this.parser = parser2;
    this.options = options2;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options2.topNode, topContext;
    let topOptions = wsOptionsFor(null, options2.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, true, options2.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark$1.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser2.schema.topNodeType, null, Mark$1.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options2.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom2, marks) {
    if (dom2.nodeType == 3)
      this.addTextNode(dom2, marks);
    else if (dom2.nodeType == 1)
      this.addElement(dom2, marks);
  }
  addTextNode(dom2, marks) {
    let value = dom2.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top.inlineContext(dom2) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom2.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom2);
    } else {
      this.findInside(dom2);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom2, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom2.tagName == "PRE" || /pre/.test(dom2.style && dom2.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom2.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom2);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom2) || (ruleID = this.parser.matchTag(dom2, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom2);
      this.ignoreFallback(dom2, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom2 = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom2.firstChild) {
        this.leafFallback(dom2, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom2, marks);
      if (innerMarks)
        this.addAll(dom2, innerMarks);
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom2, marks);
      if (innerMarks)
        this.addElementByRule(dom2, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom2, marks) {
    if (dom2.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom2.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom2, marks) {
    if (dom2.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom2, marks) {
    let styles = dom2.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after2 = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after2);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m) => !rule.clearMark(m));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after2 = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom2, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom2.nodeName == "BR")) {
        this.leafFallback(dom2, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom2);
    } else if (continueAfter) {
      this.addElement(dom2, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom2);
      rule.getContent(dom2, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
    } else {
      let contentDOM = dom2;
      if (typeof rule.contentElement == "string")
        contentDOM = dom2.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom2);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom2, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom2, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom2 = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom2 != end; dom2 = dom2.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom2, marks);
    }
    this.findAtPoint(parent, index);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks, cautious) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node.type);
      let nodeMarks = Mark$1.none;
      for (let m of innerMarks.concat(node.marks))
        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))
          nodeMarks = m.addToSet(nodeMarks);
      top.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type);
    let options2 = wsOptionsFor(type, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options2 |= OPT_OPEN_LEFT;
    let applyMarks = Mark$1.none;
    marks = marks.filter((m) => {
      if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {
        applyMarks = m.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options2));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to2) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to2) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j = content.length - 1; j >= 0; j--)
        pos += content[j].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before2) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before2 ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context2) {
    if (context2.indexOf("|") > -1)
      return context2.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context2.split("/");
    let option2 = this.options.context;
    let useRoot = !this.isOpen && (!option2 || option2.parent.type == this.nodes[0].type);
    let minDepth = -(option2 ? option2.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option2 && depth >= minDepth ? option2.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d = $context.depth; d >= 0; d--) {
        let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
}
function normalizeList(dom2) {
  for (let child = dom2.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom2, selector) {
  return (dom2.matches || dom2.msMatchesSelector || dom2.webkitMatchesSelector || dom2.mozMatchesSelector).call(dom2, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes2 = nodeType.schema.nodes;
  for (let name in nodes2) {
    let parent = nodes2[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type, next } = match.edge(i);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
class DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes2, marks) {
    this.nodes = nodes2;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options2 = {}, target) {
    if (!target)
      target = doc$1(options2).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add2 = node.marks[rendered++];
          let markDOM = this.serializeMark(add2, node.isInline, options2);
          if (markDOM) {
            active.push([add2, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options2));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options2) {
    let { dom: dom2, contentDOM } = renderSpec(doc$1(options2), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options2, contentDOM);
    }
    return dom2;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options2 = {}) {
    let dom2 = this.serializeNodeInner(node, options2);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options2);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom2);
        dom2 = wrap2.dom;
      }
    }
    return dom2;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options2 = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc$1(options2), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc2, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result2 = gatherToDOM(schema.nodes);
    if (!result2.text)
      result2.text = (node) => node.text;
    return result2;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result2 = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result2[name] = toDOM;
  }
  return result2;
}
function doc$1(options2) {
  return options2.document || window.document;
}
const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result2 = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result2)
            result2 = [];
          result2.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result2;
}
function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc2.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom2 = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom2.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else if (name == "style" && dom2.style)
          dom2.style.cssText = attrs[name];
        else
          dom2.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: dom2, contentDOM: dom2 };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
      dom2.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom: dom2, contentDOM };
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index, offset2) {
  return index + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff2 = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index; i++)
        diff2 += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff2 + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff2 = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff2 : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result2 = start + diff2 + (side < 0 ? 0 : newSize);
        if (simple)
          return result2;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del |= DEL_SIDE;
        return new MapResult(result2, del, recover);
      }
      diff2 += newSize - oldSize;
    }
    return simple ? pos + diff2 : new MapResult(pos + diff2, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff2 = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff2 : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index * 3)
        return true;
      diff2 += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff2 = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff2 : 0), newStart = start + (this.inverted ? 0 : diff2);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff2 += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from3 = 0, to2 = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from3;
    this.to = to2;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from3 = 0, to2 = this.maps.length) {
    return new Mapping(this._maps, this.mirror, from3, to2);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map3, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map3);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map3 = this._maps[i], result2 = map3.mapResult(pos, assoc);
      if (result2.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result2.recover);
          continue;
        }
      }
      delInfo |= result2.delInfo;
      pos = result2.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc2, from3, to2, slice3) {
    try {
      return StepResult.ok(doc2.replace(from3, to2, slice3));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from3, to2, mark) {
    super();
    this.from = from3;
    this.to = to2;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice3 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice3);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from3 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
    if (from3.deleted && to2.deleted || from3.pos >= to2.pos)
      return null;
    return new AddMarkStep(from3.pos, to2.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from3, to2, mark) {
    super();
    this.from = from3;
    this.to = to2;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice3 = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice3);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from3 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
    if (from3.deleted && to2.deleted || from3.pos >= to2.pos)
      return null;
    return new RemoveMarkStep(from3.pos, to2.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`âthe depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from3, to2, slice3, structure = false) {
    super();
    this.from = from3;
    this.to = to2;
    this.slice = slice3;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from3 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
    if (from3.deletedAcross && to2.deletedAcross)
      return null;
    return new ReplaceStep(from3.pos, Math.max(from3.pos, to2.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice3 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice3, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice3 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice3, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from3, to2, gapFrom, gapTo, slice3, insert, structure = false) {
    super();
    this.from = from3;
    this.to = to2;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice3;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from3 = mapping.mapResult(this.from, 1), to2 = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from3.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to2.pos : mapping.map(this.gapTo, 1);
    if (from3.deletedAcross && to2.deletedAcross || gapFrom < from3.pos || gapTo > to2.pos)
      return null;
    return new ReplaceAroundStep(from3.pos, to2.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from3, to2) {
  let $from = doc2.resolve(from3), dist2 = to2 - from3, depth = $from.depth;
  while (dist2 > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist2--;
  }
  if (dist2 > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist2 > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist2--;
    }
  }
  return false;
}
function addMark(tr, from3, to2, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from3, to2, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from3), end = Math.min(pos + node.nodeSize, to2);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from3, to2, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from3, to2, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set2 = node.marks, found2;
      while (found2 = mark.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(found2);
        set2 = found2.removeFromSet(set2);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to2);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j = 0; j < matched.length; j++) {
          let m = matched[j];
          if (m.step == step - 1 && style2.eq(matched[j].style))
            found2 = m;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from3), to: end, step });
        }
      }
    }
  });
  matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j = 0; j < child.marks.length; j++)
        if (!parentType.allowsMarkType(child.marks[j].type))
          tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m, newline = /\r?\n|\r/g, slice3;
        while (m = newline.exec(child.text)) {
          if (!slice3)
            slice3 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice3));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr.step(replSteps[i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range2) {
  let parent = range2.parent;
  let content = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
  for (let depth = range2.depth; ; --depth) {
    let node = range2.$from.node(depth);
    let index = range2.$from.index(depth), endIndex = range2.$to.indexAfter(depth);
    if (depth < range2.depth && node.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
      break;
  }
  return null;
}
function lift$2(tr, range2, target) {
  let { $from, $to, depth } = range2;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before2 = Fragment.empty, openStart = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before2 = Fragment.from($from.node(d).copy(before2));
      openStart++;
    } else {
      start--;
    }
  let after2 = Fragment.empty, openEnd = 0;
  for (let d = depth, splitting = false; d > target; d--)
    if (splitting || $to.after(d + 1) < $to.end(d)) {
      splitting = true;
      after2 = Fragment.from($to.node(d).copy(after2));
      openEnd++;
    } else {
      end++;
    }
  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before2.append(after2), openStart, openEnd), before2.size - openStart, true));
}
function findWrapping(range2, nodeType, attrs = null, innerRange = range2) {
  let around = findWrappingOutside(range2, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range2, type) {
  let { parent, startIndex, endIndex } = range2;
  let around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range2, type) {
  let { parent, startIndex, endIndex } = range2;
  let inner = parent.child(startIndex);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap$1(tr, range2, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start = range2.start, end = range2.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr, from3, to2, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from3, to2, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      let convertNewlines = null;
      if (type.schema.linebreakReplacement) {
        let pre = type.whitespace == "pre", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr, node, pos, mapFrom);
      clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr, node, pos, mapFrom) {
  node.forEach((child, offset2) => {
    if (child.isText) {
      let m, newline = /\r?\n|\r/g;
      while (m = newline.exec(child.text)) {
        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset2 + m.index);
        tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr, node, pos, mapFrom) {
  node.forEach((child, offset2) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset2);
      tr.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc2, pos, type) {
  let $pos = doc2.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
function setNodeMarkup(tr, pos, type, attrs, marks) {
  let node = tr.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type)
    type = node.type;
  let newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    let node = $pos.node(d), index2 = $pos.index(d);
    if (node.type.spec.isolating)
      return false;
    let rest2 = node.content.cutByIndex(index2, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest2 = rest2.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after2 = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index2 + 1, node.childCount) || !after2.type.validContent(rest2))
      return false;
  }
  let index = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before2 = Fragment.empty, after2 = Fragment.empty;
  for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before2 = Fragment.from($pos.node(d).copy(before2));
    let typeAfter = typesAfter && typesAfter[i];
    after2 = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after2) : $pos.node(d).copy(after2));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before2.append(after2), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b) {
  if (!b.content.size)
    a.type.compatibleContent(b.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0; i < b.childCount; i++) {
    let child = b.child(i);
    let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable(a, b) {
  return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d = $pos.depth; ; d--) {
    let before2, after2, index = $pos.index(d);
    if (d == $pos.depth) {
      before2 = $pos.nodeBefore;
      after2 = $pos.nodeAfter;
    } else if (dir > 0) {
      before2 = $pos.node(d + 1);
      index++;
      after2 = $pos.node(d).maybeChild(index);
    } else {
      before2 = $pos.node(d).maybeChild(index - 1);
      after2 = $pos.node(d + 1);
    }
    if (before2 && !before2.isTextblock && joinable(before2, after2) && $pos.node(d).canReplace(index, index + 1))
      return pos;
    if (d == 0)
      break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function join$1(tr, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr.doc.type.schema;
  let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr.steps.length;
  if (convertNewlines === false) {
    let $after = tr.doc.resolve(pos + depth);
    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr.doc.resolve(start);
    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
  }
  return tr;
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.before(d + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d = $pos.depth - 1; d >= 0; d--) {
      let index = $pos.indexAfter(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType))
        return $pos.after(d + 1);
      if (index < $pos.node(d).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice3) {
  let $pos = doc2.resolve(pos);
  if (!slice3.content.size)
    return pos;
  let content = slice3.content;
  for (let i = 0; i < slice3.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice3.openStart == 0 && slice3.size ? 2 : 1); pass++) {
    for (let d = $pos.depth; d >= 0; d--) {
      let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from3, to2 = from3, slice3 = Slice.empty) {
  if (from3 == to2 && !slice3.size)
    return null;
  let $from = doc2.resolve(from3), $to = doc2.resolve(to2);
  if (fitsTrivially($from, $to, slice3))
    return new ReplaceStep(from3, to2, slice3);
  return new Fitter($from, $to, slice3).fit();
}
function fitsTrivially($from, $to, slice3) {
  return !slice3.openStart && !slice3.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice3.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice3 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice3, placedSize);
    if (slice3.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice3);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d) {
        startDepth = d;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice3 = this.unplaced, fragment = parent ? parent.content : slice3.content;
    let openStart = slice3.openStart - sliceDepth;
    let taken = 0, add2 = [];
    let { match, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add2.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice3.content.size - slice3.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add2.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice3.content, sliceDepth, taken), slice3.openStart, slice3.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice3.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice3.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after2 = this.$to.after(depth);
    while (depth > 1 && after2 == this.$to.end(--depth))
      ++after2;
    return after2;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match, type } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type, match, dropInner);
      if (!fit)
        continue;
      for (let d = i - 1; d >= 0; d--) {
        let { match: match5, type: type2 } = this.frontier[d];
        let matches2 = contentAfterFits($to, d, type2, match5, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d = close2.depth + 1; d <= $to.depth; d++) {
      let node = $to.node(d), add2 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
      this.openFrontierNode(node.type, node.attrs, add2);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add2 = open.match.fillBefore(Fragment.empty, true);
    if (add2.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add2);
  }
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (let i = start; i < fragment.childCount; i++)
    if (!type.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr, from3, to2, slice3) {
  if (!slice3.size)
    return tr.deleteRange(from3, to2);
  let $from = tr.doc.resolve(from3), $to = tr.doc.resolve(to2);
  if (fitsTrivially($from, $to, slice3))
    return tr.step(new ReplaceStep(from3, to2, slice3));
  let targetDepths = coveredDepths($from, tr.doc.resolve(to2));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    let spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d) > -1)
      preferredTarget = d;
    else if ($from.before(d) == pos)
      targetDepths.splice(1, 0, -d);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice3.openStart;
  for (let content = slice3.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice3.openStart)
      break;
    content = node.content;
  }
  for (let d = preferredDepth - 1; d >= 0; d--) {
    let leftNode = leftNodes[d], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j = slice3.openStart; j >= 0; j--) {
    let openDepth = (j + preferredDepth + 1) % (slice3.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to2, new Slice(closeFragment(slice3.content, 0, slice3.openStart, openDepth), openDepth, slice3.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr.replace(from3, to2, slice3);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from3 = $from.before(depth);
    to2 = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from3, to2, node) {
  if (!node.isInline && from3 == to2 && tr.doc.resolve(from3).parent.content.size) {
    let point = insertPoint(tr.doc, from3, node.type);
    if (point != null)
      from3 = to2 = point;
  }
  tr.replaceRange(from3, to2, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange$1(tr, from3, to2) {
  let $from = tr.doc.resolve(from3), $to = tr.doc.resolve(to2);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last2 = i == covered.length - 1;
    if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from3 - $from.start(d) == $from.depth - d && to2 > $from.end(d) && $to.end(d) - to2 != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))
      return tr.delete($from.before(d), to2);
  }
  tr.delete(from3, to2);
}
function coveredDepths($from, $to) {
  let result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d = minDepth; d >= 0; d--) {
    let start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
      break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
      result2.push(d);
  }
  return result2;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc2.attrs)
      attrs[name] = doc2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(json.attr, json.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result2 = this.maybeStep(step);
    if (result2.failed)
      throw new TransformError(result2.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result2 = step.apply(this.doc);
    if (!result2.failed)
      this.addStep(step, result2.doc);
    return result2;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from3, to2 = from3, slice3 = Slice.empty) {
    let step = replaceStep(this.doc, from3, to2, slice3);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from3, to2, content) {
    return this.replace(from3, to2, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from3, to2) {
    return this.replace(from3, to2, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from3, to2, slice3) {
    replaceRange(this, from3, to2, slice3);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from3, to2, node) {
    replaceRangeWith(this, from3, to2, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from3, to2) {
    deleteRange$1(this, from3, to2);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range2, target) {
    lift$2(this, range2, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join$1(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range2, wrappers) {
    wrap$1(this, range2, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from3, to2 = from3, type, attrs = null) {
    setBlockType$1(this, from3, to2, type, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node = this.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark$1) {
      if (mark.isInSet(node.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set2 = node.marks, found2, steps = [];
      while (found2 = mark.isInSet(set2)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set2 = found2.removeFromSet(set2);
      }
      for (let i = steps.length - 1; i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from3, to2, mark) {
    addMark(this, from3, to2, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from3, to2, mark) {
    removeMark(this, from3, to2, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr, node) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from3 = mapping.map($from.pos), to2 = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from3, to2);
      } else {
        tr.replaceRangeWith(from3, to2, node);
        selectionToInsertionEnd$1(tr, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc2, from3) {
    return new NodeSelection(doc2.resolve(from3));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node, pos, index, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$1(tr, startLen, bias) {
  let last2 = tr.steps.length - 1;
  if (last2 < startLen)
    return;
  let step = tr.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map3 = tr.mapping.maps[last2], end;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform {
  /**
  @internal
  */
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice3) {
    this.selection.replace(this, slice3);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from3, to2) {
    let schema = this.doc.type.schema;
    if (from3 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to2 == null)
        to2 = from3;
      to2 = to2 == null ? from3 : to2;
      if (!text)
        return this.deleteRange(from3, to2);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from3);
        marks = to2 == from3 ? $from.marks() : $from.marksAcross(this.doc.resolve(to2));
      }
      this.replaceRangeWith(from3, to2, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _2 in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind$2(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind$2(desc.init, self2);
    this.apply = bind$2(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
class Configuration {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
}
class EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  /**
  @internal
  */
  filterTransaction(tr, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j = 0; j < this.config.plugins.length; j++)
                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result2.storedMarks = this.storedMarks.map((m) => m.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result2[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result2;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
}
const keys$1 = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys$1)
    return name + "$" + ++keys$1[name];
  keys$1[name] = 0;
  return name + "$";
}
class PluginKey {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state) {
    return state[this.key];
  }
}
const domIndex = function(node) {
  for (var index = 0; ; index++) {
    node = node.previousSibling;
    if (!node)
      return index;
  }
};
const parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node, from3, to2) {
  let range2 = reusedRange || (reusedRange = document.createRange());
  range2.setEnd(node, to2 == null ? node.nodeValue.length : to2);
  range2.setStart(node, from3 || 0);
  return range2;
};
const clearReusedRange = function() {
  reusedRange = null;
};
const isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  var _a;
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)
          off += dir;
        else
          return false;
      } else {
        node = child;
        off = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2];
      offset2 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom2) {
  let desc;
  for (let cur = dom2; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom2 || desc.contentDOM == dom2);
}
const selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y) {
  if (doc2.caretPositionFromPoint) {
    try {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_2) {
    }
  }
  if (doc2.caretRangeFromPoint) {
    let range2 = doc2.caretRangeFromPoint(x, y);
    if (range2)
      return { node: range2.startContainer, offset: Math.min(nodeSize(range2.startContainer), range2.startOffset) };
  }
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome$1 = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const windows$1 = nav ? /Win/.test(nav.platform) : false;
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  let vp = doc2.defaultView && doc2.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom2 = view.root.elementFromPoint(x, y);
    if (!dom2 || dom2 == view.dom || !view.dom.contains(dom2))
      continue;
    let localRect = dom2.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom2;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom2) {
  let stack = [], doc2 = dom2.ownerDocument;
  for (let cur = dom2; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom2 == doc2)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom: dom2, top, left } = stack[i];
    if (dom2.scrollTop != top + dTop)
      dom2.scrollTop = top + dTop;
    if (dom2.scrollLeft != left)
      dom2.scrollLeft = left;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom2) {
  if (dom2.setActive)
    return dom2.setActive();
  if (preventScrollSupported)
    return dom2.focus(preventScrollSupported);
  let stored = scrollStack(dom2);
  dom2.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range2 = document.createRange();
  for (let i = 0; i < len; i++) {
    range2.setEnd(node, i + 1);
    range2.setStart(node, i);
    let rect = singleRect(range2, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom2, coords) {
  let parent = dom2.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom2.getBoundingClientRect().left)
    return parent;
  return dom2;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before2 = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before2 ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node, offset2 = 0;
  let caret = caretFromPoint(doc2, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from3 = offset2, to2 = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to2++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from3--;
        takeSide = 1;
      } else if (side < 0) {
        from3--;
      } else {
        to2++;
      }
      return flattenV(singleRect(textRange(node, from3, to2), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before2 = node.childNodes[offset2 - 1];
      if (before2.nodeType == 1)
        return flattenH(before2.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after2 = node.childNodes[offset2];
      if (after2.nodeType == 1)
        return flattenH(after2.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before2 = node.childNodes[offset2 - 1];
    let target = before2.nodeType == 3 ? textRange(before2, nodeSize(before2) - (supportEmptyRange ? 0 : 1)) : before2.nodeType == 1 && (before2.nodeName != "BR" || !before2.nextSibling) ? before2 : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node)) {
    let after2 = node.childNodes[offset2];
    while (after2.pmViewDesc && after2.pmViewDesc.ignoreForCoords)
      after2 = after2.nextSibling;
    let target = !after2 ? null : after2.nodeType == 3 ? textRange(after2, 0, supportEmptyRange ? 0 : 1) : after2.nodeType == 1 ? after2 : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0)
    return rect;
  let x = left ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top) {
  if (rect.height == 0)
    return rect;
  let y = top ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom2 } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom2, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom2 = nearest.contentDOM || nearest.dom;
        break;
      }
      dom2 = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom2.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result2 = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_2) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result2;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom2, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom2;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom2.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size2 = 0;
    for (let i = 0; i < this.children.length; i++)
      size2 += this.children[i].size;
    return size2;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom2, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom2.nodeType == 1 ? dom2 : dom2.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom2 == this.contentDOM) {
          domBefore = dom2.childNodes[offset2 - 1];
        } else {
          while (dom2.parentNode != this.contentDOM)
            dom2 = dom2.parentNode;
          domBefore = dom2.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom2 == this.contentDOM) {
          domAfter = dom2.childNodes[offset2];
        } else {
          while (dom2.parentNode != this.contentDOM)
            dom2 = dom2.parentNode;
          domAfter = dom2.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom2 == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom2.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search = dom2; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom2.childNodes.length)
        for (let search = dom2; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom2, onlyNodes = false) {
    for (let first2 = true, cur = dom2; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom2.nodeType == 1 ? dom2 : dom2.parentNode) : nodeDOM == dom2))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom2) {
    let desc = dom2.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom2, offset2, bias) {
    for (let scan = dom2; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom2, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (offset2 == pos && end != offset2) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end = curPos + child.size;
      if (end > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter2 = true;
      for (; ; i--, enter2 = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter2 && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter2 = true;
      for (; ; i++, enter2 = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter2 && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from3, to2, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from3, to: to2, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (fromOffset == -1 && from3 <= end) {
        let childBase = offset2 + child.border;
        if (from3 >= childBase && to2 <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from3, to2, childBase);
        from3 = offset2;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from3 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end > to2 || i == this.children.length - 1)) {
        to2 = end;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to2 += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end;
    }
    return { node: this.contentDOM, from: from3, to: to2, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from3 = Math.min(anchor, head), to2 = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (from3 > offset2 && to2 < end)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, view, force);
      offset2 = end;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after2; scan; scan = scan.parentNode) {
            if (after2 = scan.nextSibling) {
              if (after2.nodeName == "BR")
                anchorDOM = headDOM = { node: after2.parentNode, offset: domIndex(after2) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after2 = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after2 && after2.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_2) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range2 = document.createRange();
      range2.setEnd(headDOM.node, headDOM.offset);
      range2.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range2);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from3, to2) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end = offset2 + child.size;
      if (offset2 == end ? from3 <= end && to2 >= offset2 : from3 < end && to2 > offset2) {
        let startInside = offset2 + child.border, endInside = end - child.border;
        if (from3 >= startInside && to2 <= endInside) {
          this.dirty = from3 == offset2 || to2 == end ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from3 == startInside && to2 == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from3 - startInside, to2 - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom2 = widget.type.toDOM;
    if (typeof dom2 == "function")
      dom2 = dom2(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom2.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom2);
        dom2 = wrap2;
      }
      dom2.contentEditable = "false";
      dom2.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom2, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom2, textDOM, text) {
    super(parent, [], dom2, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom2, offset2) {
    if (dom2 != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom2, contentDOM, spec) {
    super(parent, [], dom2, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from3, to2) {
    super.markDirty(from3, to2);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from3, to2, view) {
    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes2 = this.children, size2 = this.size;
    if (to2 < size2)
      nodes2 = replaceNodes(nodes2, to2, size2, view);
    if (from3 > 0)
      nodes2 = replaceNodes(nodes2, 0, from3, view);
    for (let i = 0; i < nodes2.length; i++)
      nodes2[i].parent = copy2;
    copy2.children = nodes2;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom2, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom2, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom2 = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom2)
        dom2 = document.createTextNode(node.text);
      else if (dom2.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom2) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom: dom2, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom2.nodeName != "BR") {
      if (!dom2.hasAttribute("contenteditable"))
        dom2.contentEditable = "false";
      if (node.type.spec.draggable)
        dom2.draggable = true;
    }
    let nodeDOM = dom2;
    dom2 = applyOuterDeco(dom2, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom2, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom2, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom2, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark$1.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from3, to: to2 } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from3 < pos || to2 > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from3 - pos, to2 - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom2, view) {
  applyOuterDeco(dom2, outerDeco, doc2);
  let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom2, dom2, dom2, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom2, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom2, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom2, offset2, bias) {
    if (dom2 == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom2, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from3, to2, view) {
    let node = this.node.cut(from3, to2), dom2 = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom2, dom2, view);
  }
  markDirty(from3, to2) {
    super.markDirty(from3, to2);
    if (this.dom != this.nodeDOM && (from3 == 0 || to2 == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom2, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom2, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result2 = this.spec.update(node, outerDeco, innerDeco);
      if (result2)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result2;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom2 = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom2) {
        dom2 = rm(dom2);
        written = true;
      }
      dom2 = dom2.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom2);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom2 ? dom2.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom2 = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom2) {
    dom2 = rm(dom2);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result2.push(top = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result2.length == 1)
        result2.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top.class = (top.class ? top.class + " " : "") + val;
      else if (name == "style")
        top.style = (top.style ? top.style + ";" : "") + val;
      else if (name != "nodeName")
        top[name] = val;
    }
  }
  return result2;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom2, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom2.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom2.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom2.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom2.classList.add(curList[i]);
    if (dom2.classList.length == 0)
      dom2.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom2.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom2.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom2, deco, node) {
  return patchOuterDeco(dom2, dom2, noDeco, computeOuterDeco(deco, node, dom2.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom2) {
  let next = dom2.nextSibling;
  dom2.parentNode.removeChild(dom2);
  return next;
}
class ViewTreeUpdater {
  constructor(top, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start, end) {
    if (start == end)
      return;
    for (let i = start; i < end; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start, end - start);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index) {
    let found2 = -1, targetDesc;
    if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index, view) {
    let child = this.top.children[index];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome$1) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom2 = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom2.className = "ProseMirror-separator";
        dom2.alt = "";
      }
      if (nodeName == "BR")
        dom2.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom2, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches2.push(desc);
  }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index;
    if (restNode) {
      index = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index);
    offset2 = end;
  }
}
function iosHacks(dom2) {
  if (dom2.nodeName == "UL" || dom2.nodeName == "OL") {
    let oldCSS = dom2.style.cssText;
    dom2.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom2).listStyle;
    dom2.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from3, to2) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to2; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from3) {
      if (pos >= to2 && str.slice(to2 - text.length - childStart, to2 - childStart) == text)
        return to2 - text.length;
      let found2 = childStart < to2 ? str.lastIndexOf(text, to2 - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from3)
        return childStart + found2;
      if (from3 == to2 && str.length >= to2 + text.length - childStart && str.slice(to2 - childStart, to2 - childStart + text.length) == text)
        return to2;
    }
  }
  return -1;
}
function replaceNodes(nodes2, from3, to2, view, replacement) {
  let result2 = [];
  for (let i = 0, off = 0; i < nodes2.length; i++) {
    let child = nodes2[i], start = off, end = off += child.size;
    if (start >= to2 || end <= from3) {
      result2.push(child);
    } else {
      if (start < from3)
        result2.push(child.slice(0, from3 - start, view));
      if (replacement) {
        result2.push(replacement);
        replacement = void 0;
      }
      if (end > to2)
        result2.push(child.slice(to2 - start, child.size, view));
    }
  }
  return result2;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range2 = domSel.getRangeAt(i);
        min2 = Math.min(min2, view.docView.posFromDOM(range2.startContainer, range2.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range2.endContainer, range2.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc2.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc2.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome$1) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome$1 && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after2 = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before2 = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after2 && after2.contentEditable == "false")
    return setEditable(after2);
  if ((!after2 || after2.contentEditable == "false") && (!before2 || before2.contentEditable == "false")) {
    if (after2)
      return setEditable(after2);
    else if (before2)
      return setEditable(before2);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range2 = document.createRange();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range2.setStart(node.parentNode, domIndex(node) + 1);
  else
    range2.setStart(node, 0);
  range2.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range2);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom2, dir) {
  let desc = dom2.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom2.nextSibling || dom2.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before2 = node.childNodes[offset2 - 1];
        if (isIgnorable(before2, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before2.nodeType == 3) {
          node = before2;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after2 = node.childNodes[offset2];
      if (isIgnorable(after2, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom2) {
  let desc = dom2.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before2, after2;
    if (after2 = textNodeAfter(node, offset2)) {
      node = after2;
      offset2 = 0;
    } else if (before2 = textNodeBefore(node, offset2)) {
      node = before2;
      offset2 = before2.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range2 = document.createRange();
    range2.setEnd(node, offset2);
    range2.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range2);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome$1 || windows$1) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before2 = view.coordsAtPos(pos - 1);
      let mid = (before2.top + before2.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before2.left - coords.left) > 1)
        return before2.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after2 = view.coordsAtPos(pos + 1);
      let mid = (after2.top + after2.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after2.left - coords.left) > 1)
        return after2.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed2 = getComputedStyle(view.dom).direction;
  return computed2 == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result2 = "";
  if (event.ctrlKey)
    result2 += "c";
  if (event.metaKey)
    result2 += "m";
  if (event.altKey)
    result2 += "a";
  if (event.shiftKey)
    result2 += "s";
  return result2;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac$2 && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac$2 && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac$2 && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac$2 && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac$2 && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac$2 && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac$2 ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice3) {
  view.someProp("transformCopied", (f) => {
    slice3 = f(slice3, view);
  });
  let context2 = [], { content, openStart, openEnd } = slice3;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context2.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context2)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice3, view)) || slice3.content.textBetween(0, slice3.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice3 };
}
function parseFromClipboard(view, text, html2, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom2, slice3;
  if (!html2 && !text)
    return null;
  let asText = text && (plainText || inCode || !html2);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice3 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom2 = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom2.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html2 = f(html2, view);
    });
    dom2 = readHTML(html2);
    if (webkit)
      restoreReplacedSpaces(dom2);
  }
  let contextNode = dom2 && dom2.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom2.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom2 = child;
    }
  if (!slice3) {
    let parser2 = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice3 = parser2.parseSlice(dom2, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom3) {
        if (dom3.nodeName == "BR" && !dom3.nextSibling && dom3.parentNode && !inlineParents.test(dom3.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice3 = addContext(closeSlice(slice3, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice3 = Slice.maxOpen(normalizeSiblings(slice3.content, $context), true);
    if (slice3.openStart || slice3.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice3.content.firstChild; openStart < slice3.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice3.content.lastChild; openEnd < slice3.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice3 = closeSlice(slice3, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice3 = f(slice3, view);
  });
  return slice3;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result2 = [];
    fragment.forEach((node) => {
      if (!result2)
        return;
      let wrap2 = match.findWrapping(node.type), inLast;
      if (!wrap2)
        return result2 = null;
      if (inLast = result2.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length)
          result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap2);
        result2.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result2)
      return Fragment.from(result2);
  }
  return fragment;
}
function withWrappers(node, wrap2, from3 = 0) {
  for (let i = wrap2.length - 1; i >= from3; i--)
    node = wrap2[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap2, lastWrap, node, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from3, to2, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to2 - 1)
    inner = closeRange(inner, side, from3, to2, depth + 1, openEnd);
  if (depth >= from3)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice3, openStart, openEnd) {
  if (openStart < slice3.openStart)
    slice3 = new Slice(closeRange(slice3.content, -1, openStart, slice3.openStart, 0, slice3.openEnd), openStart, slice3.openEnd);
  if (openEnd < slice3.openEnd)
    slice3 = new Slice(closeRange(slice3.content, 1, openEnd, slice3.openEnd, 0, 0), slice3.openStart, openEnd);
  return slice3;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
let _policy = null;
function maybeWrapTrusted(html2) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html2;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html2);
}
function readHTML(html2) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html2);
  if (metas)
    html2 = html2.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html2 = wrap2.map((n) => "<" + n + ">").join("") + html2 + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html2);
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom2) {
  let nodes2 = dom2.querySelectorAll(chrome$1 ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes2.length; i++) {
    let node = nodes2[i];
    if (node.childNodes.length == 1 && node.textContent == "Â " && node.parentNode)
      node.parentNode.replaceChild(dom2.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice3, context2) {
  if (!slice3.size)
    return slice3;
  let schema = slice3.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context2);
  } catch (e) {
    return slice3;
  }
  let { content, openStart, openEnd } = slice3;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
const handlers = {};
const editHandlers = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome$1 && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view.input.lastIOSEnter = now2;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now2) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr = view.state.tr.setSelection(selection);
  tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos));
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt));
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick$1(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size));
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size));
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc2, nodePos));
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome$1 && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)));
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before2 = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before2)
            break;
          if (before2.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before2, before2.nodeValue.length);
            break;
          } else {
            node = before2;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay2) {
  clearTimeout(view.input.composingTimeout);
  if (delay2 > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay2);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom2) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom2);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range2 = document.createRange();
  range2.selectNodeContents(dom2);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range2);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut2 = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice3 = sel.content(), { dom: dom2, text } = serializeForClipboard(view, slice3);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom2.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom2);
  }
  if (cut2)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice3) {
  return slice3.openStart == 0 && slice3.openEnd == 0 && slice3.content.childCount == 1 ? slice3.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html2, preferPlain, event) {
  let slice3 = parseFromClipboard(view, text, html2, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice3 || Slice.empty)))
    return true;
  if (!slice3)
    return false;
  let singleNode = sliceSingleNode(slice3);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice3);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText$1(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris2 = clipboardData.getData("text/uri-list");
  return uris2 ? uris2.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText$1(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging {
  constructor(slice3, move, node) {
    this.slice = slice3;
    this.move = move;
    this.node = node;
  }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom: dom2, text, slice: slice3 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome$1 || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom2.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice3, dragMoves(view, event), node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_2, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice3 = dragging && dragging.slice;
  if (slice3) {
    view.someProp("transformPasted", (f) => {
      slice3 = f(slice3, view);
    });
  } else {
    slice3 = parseFromClipboard(view, getText$1(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice3 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice3)
    return;
  event.preventDefault();
  let insertPos = slice3 ? dropPoint(view.state.doc, $mouse.pos, slice3) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr);
    else
      tr.deleteSelection();
  }
  let pos = tr.mapping.map(insertPos);
  let isNode = slice3.openStart == 0 && slice3.openEnd == 0 && slice3.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode)
    tr.replaceRangeWith(pos, pos, slice3.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice3);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode && NodeSelection.isSelectable(slice3.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice3.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome$1 && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
}
class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from3 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to2 = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from3 >= to2 ? null : new Decoration(from3, to2, this);
  }
  valid(_2, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType2 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from3 = mapping.mapResult(span.from + oldOffset, 1);
    if (from3.deleted)
      return null;
    let to2 = mapping.mapResult(span.to + oldOffset, -1);
    if (to2.deleted || to2.pos <= from3.pos)
      return null;
    return new Decoration(from3.pos - offset2, to2.pos - offset2, this);
  }
  valid(node, span) {
    let { index, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  /**
  @internal
  */
  constructor(from3, to2, type) {
    this.from = from3;
    this.to = to2;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from3, to2) {
    return new Decoration(from3, to2, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from3, to2, attrs, spec) {
    return new Decoration(from3, to2, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from3, to2, attrs, spec) {
    return new Decoration(from3, to2, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start, end, predicate) {
    let result2 = [];
    this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result2, 0, predicate);
    return result2;
  }
  findInner(start, end, result2, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
        result2.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end && this.children[i + 1] > start) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start - childOff, end - childOff, result2, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc2, options2) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options2 || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset2, oldOffset, options2) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options2.onRemove)
        options2.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options2);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from3 = children[i] + offset2, to2 = children[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from3 && span.to < to2) {
            decorations[j] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from3 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset2, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start = offset2 + 1, end = start + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
        let from3 = Math.max(start, dec.from) - start, to2 = Math.min(end, dec.to) - start;
        if (from3 < to2)
          (local || (local = [])).push(dec.copy(from3, to2));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result2 = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result2.push(this.local[i]);
    }
    return result2;
  }
  forEachSet(f) {
    f(this);
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result2 = this.members[i].forChild(offset2, child);
      if (result2 == empty)
        continue;
      if (result2 instanceof DecorationGroup)
        found2 = found2.concat(result2.members);
      else
        found2.push(result2);
    }
    return DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result2, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result2) {
        result2 = locals;
      } else {
        if (sorted) {
          result2 = result2.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result2.push(locals[j]);
      }
    }
    return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options2) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end = children[i2 + 1];
        if (end < 0 || oldStart > end + baseOffset - moved)
          continue;
        let start = children[i2] + baseOffset - moved;
        if (oldEnd >= start) {
          children[i2 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from3 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from3 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to2 = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to2 - offset2;
      let { index, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from3 + 1, oldChildren[i] + oldOffset + 1, options2);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options2);
    let built = buildTree(decorations, node, 0, options2);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from3 = built.children[i];
      while (j < children.length && children[j] < from3)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result2 = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result2.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options2) {
  function gather(set2, oldOffset2) {
    for (let i = 0; i < set2.local.length; i++) {
      let mapped = set2.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options2.onRemove)
        options2.onRemove(set2.local[i].spec);
    }
    for (let i = 0; i < set2.children.length; i += 3)
      gather(set2.children[i + 2], set2.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end = offset2 + node.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result2 = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result2.push(array[i]);
  return result2;
}
function buildTree(spans, node, offset2, options2) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options2);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options2.onRemove)
        options2.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result2 = f(view.state);
    if (result2 && result2 != empty)
      found2.push(result2);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie$1 && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from3 = -1, to2 = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result2 = this.registerMutation(mutations[i], added);
        if (result2) {
          from3 = from3 < 0 ? result2.from : Math.min(result2.from, from3);
          to2 = to2 < 0 ? result2.to : Math.max(result2.to, to2);
          if (result2.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from3 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from3 > -1 || newSel) {
      if (from3 > -1) {
        view.docView.markDirty(from3, to2);
        checkCSS(view);
      }
      this.handleDOMChange(from3, to2, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from3 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to2 = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from3, to: to2 };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range2) {
  let anchorNode = range2.startContainer, anchorOffset = range2.startOffset;
  let focusNode = range2.endContainer, focusOffset = range2.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range2 = selection.getComposedRanges(view.root)[0];
    if (range2)
      return rangeToSelectionRange(view, range2);
  }
  let found2;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from3, to: to2 } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome$1 && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser2 = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from3);
  let sel = null, doc2 = parser2.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from3, head: head + from3 };
  }
  return { doc: doc2, sel, from: from3, to: to2 };
}
function ruleFromNode(dom2) {
  let desc = dom2.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom2.nodeName == "BR" && dom2.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom2.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom2.parentNode.lastChild == dom2 || safari && /^(tr|table)$/i.test(dom2.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom2.nodeName == "IMG" && dom2.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from3, to2, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from3 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome$1 && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr.setMeta("pointer", true);
      else if (origin == "key")
        tr.scrollIntoView();
      if (compositionID)
        tr.setMeta("composition", compositionID);
      view.dispatch(tr);
    }
    return;
  }
  let $before = view.state.doc.resolve(from3);
  let shared = $before.sharedDepth(to2);
  from3 = $before.before(shared + 1);
  to2 = view.state.doc.resolve(to2).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from3, to2);
  let doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr.setMeta("composition", compositionID);
          view.dispatch(tr);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " Â ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome$1)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome$1 && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr.doc, parse.sel);
      if (sel2 && !(chrome$1 && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
        tr.setSelection(sel2);
    }
    if (compositionID)
      tr.setMeta("composition", compositionID);
    return tr.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      if (marks)
        tr.ensureMarks(marks);
      view.dispatch(tr);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start, end, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start);
  if (!$newStart.parent.isTextblock) {
    let after2 = $start.nodeAfter;
    return after2 != null && end == start + after2.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start = a.findDiffStart(b, pos);
  if (start == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move;
    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))
      start += move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return { start, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
class EditorView {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props2) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props2;
    this.state = props2.state;
    this.directPlugins = props2.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from3, to2, typeOver, added) => readDOMChange(this, from3, to2, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props2) {
    if (props2.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props2;
    if (props2.plugins) {
      props2.plugins.forEach(checkStateComponent);
      this.directPlugins = props2.plugins;
    }
    this.updateStateInner(props2.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props2) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props2)
      updated[name] = props2[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome$1) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome$1 ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie$1) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesâfor example when interpreting an event
  targetâyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html2, event) {
    return doPaste(this, "", html2, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice3) {
    return serializeForClipboard(this, slice3);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
EditorView.prototype.dispatch = function(tr) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr);
  else
    this.updateState(this.state.apply(tr));
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom2 = document.createElement("img");
    dom2.className = "ProseMirror-separator";
    dom2.setAttribute("mark-placeholder", "true");
    dom2.setAttribute("alt", "");
    view.cursorWrapper = { dom: dom2, deco: Decoration.widget(view.state.selection.from, dom2, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result2 = /* @__PURE__ */ Object.create(null);
  function add2(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result2, prop))
        result2[prop] = obj[prop];
  }
  view.someProp("nodeViews", add2);
  view.someProp("markViews", add2);
  return result2;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _2 in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
function keyName(event) {
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
const windows = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName$1(name) {
  let parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space")
    result2 = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod2 = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod2))
      meta = true;
    else if (/^a(lt)?$/i.test(mod2))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod2))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod2))
      shift2 = true;
    else if (/^mod$/i.test(mod2)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod2);
  }
  if (alt)
    result2 = "Alt-" + result2;
  if (ctrl)
    result2 = "Ctrl-" + result2;
  if (meta)
    result2 = "Meta-" + result2;
  if (shift2)
    result2 = "Shift-" + result2;
  return result2;
}
function normalize(map3) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map3)
    copy2[normalizeKeyName$1(prop)] = map3[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map3 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map3[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map3[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map3[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
const deleteSelection$1 = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
const joinBackward$1 = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range2, target).scrollIntoView());
    return true;
  }
  let before2 = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before2, "end") || NodeSelection.isSelectable(before2))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(before2, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before2.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before2.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
const joinTextblockBackward$1 = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
const joinTextblockForward$1 = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  let before2 = $cut.nodeBefore, beforeText = before2, beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating)
      return false;
    let child = beforeText.lastChild;
    if (!child)
      return false;
    beforeText = child;
  }
  let after2 = $cut.nodeAfter, afterText = after2, afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating)
      return false;
    let child = afterText.firstChild;
    if (!child)
      return false;
    afterText = child;
  }
  let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);
  if (!step || step.from != beforePos || step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)
    return false;
  if (dispatch) {
    let tr = state.tr.step(step);
    tr.setSelection(TextSelection.create(tr.doc, beforePos));
    dispatch(tr.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$1 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
const joinForward$1 = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after2 = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after2, "start") || NodeSelection.isSelectable(after2))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after2, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after2.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$1 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const joinUp$1 = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr = state.tr.join(point);
    if (nodeSel)
      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const joinDown$1 = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
const lift$1 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range2 = $from.blockRange($to), target = range2 && liftTarget(range2);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range2, target).scrollIntoView());
  return true;
};
const newlineInCode$1 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt$1(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
const exitCode$1 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after2 = $head.indexAfter(-1), type = defaultBlockAt$1(above.contentMatchAt(after2));
  if (!type || !above.canReplaceWith(after2, after2, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const createParagraphNear$1 = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt$1($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$1 = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before2 = $cursor.before();
    if (canSplit(state.doc, before2)) {
      if (dispatch)
        dispatch(state.tr.split(before2).scrollIntoView());
      return true;
    }
  }
  let range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range2, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt$1($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        types.unshift(atEnd && deflt ? { type: deflt } : null);
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr.deleteSelection();
    let splitPos = tr.mapping.map($from.pos);
    let can = canSplit(tr.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
const splitBlock$1 = splitBlockAs();
const selectParentNode$1 = (state, dispatch) => {
  let { $from, to: to2 } = state.selection, pos;
  let same = $from.sharedDepth(to2);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before2 = $pos.nodeBefore, after2 = $pos.nodeAfter, index = $pos.index();
  if (!before2 || !after2 || !before2.type.compatibleContent(after2.type))
    return false;
  if (!before2.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before2.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after2.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let before2 = $cut.nodeBefore, after2 = $cut.nodeAfter, conn, match;
  let isolated = before2.type.spec.isolating || after2.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before2.contentMatchAt(before2.childCount)).findWrapping(after2.type)) && match.matchType(conn[0] || after2.type).validEnd) {
    if (dispatch) {
      let end = $cut.pos + after2.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before2.copy(wrap2));
      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr.doc.resolve(end + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before2.type && canJoin(tr.doc, $joinAt.pos))
        tr.join($joinAt.pos);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = after2.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range2 = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range2 && liftTarget(range2);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range2, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after2, "start", true) && textblockAt(before2, "end")) {
    let at = before2, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after2, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end = Fragment.from(wrap2[i].copy(end));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after2.nodeSize, $cut.pos + afterDepth, $cut.pos + after2.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$1 = selectTextblockSide(-1);
const selectTextblockEnd$1 = selectTextblockSide(1);
function wrapIn$1(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range2 = $from.blockRange($to), wrapping = range2 && findWrapping(range2, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range2, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from3 }, $to: { pos: to2 } } = state.selection.ranges[i];
      state.doc.nodesBetween(from3, to2, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from3 }, $to: { pos: to2 } } = state.selection.ranges[i];
        tr.setBlockType(from3, to2, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands.length; i++)
      if (commands[i](state, dispatch, view))
        return true;
    return false;
  };
}
chainCommands(deleteSelection$1, joinBackward$1, selectNodeBackward$1);
chainCommands(deleteSelection$1, joinForward$1, selectNodeForward$1);
({
  "Enter": chainCommands(newlineInCode$1, createParagraphNear$1, liftEmptyBlock$1, splitBlock$1)
});
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
function wrapInList$1(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range2 = $from.blockRange($to);
    if (!range2)
      return false;
    let tr = dispatch ? state.tr : null;
    if (!wrapRangeInList(tr, range2, listType, attrs))
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr, range2, listType, attrs = null) {
  let doJoin = false, outerRange = range2, doc2 = range2.$from.doc;
  if (range2.depth >= 2 && range2.$from.node(range2.depth - 1).type.compatibleContent(listType) && range2.startIndex == 0) {
    if (range2.$from.index(range2.depth - 1) == 0)
      return false;
    let $insert = doc2.resolve(range2.start - 2);
    outerRange = new NodeRange($insert, $insert, range2.depth);
    if (range2.endIndex < range2.parent.childCount)
      range2 = new NodeRange(range2.$from, doc2.resolve(range2.$to.end(range2.depth)), range2.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs, range2);
  if (!wrap2)
    return false;
  if (tr)
    doWrapInList(tr, range2, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr, range2, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr.step(new ReplaceAroundStep(range2.start - (joinBefore ? 2 : 0), range2.end, range2.start, range2.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range2.start + wrappers.length - (joinBefore ? 2 : 0), parent = range2.parent;
  for (let i = range2.startIndex, e = range2.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr;
}
function liftListItem$1(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range2 = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range2)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range2.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range2);
    else
      return liftOutOfList(state, dispatch, range2);
  };
}
function liftToOuterList(state, dispatch, itemType, range2) {
  let tr = state.tr, end = range2.end, endOfList = range2.$to.end(range2.depth);
  if (end < endOfList) {
    tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range2.parent.copy())), 1, 0), 1, true));
    range2 = new NodeRange(tr.doc.resolve(range2.$from.pos), tr.doc.resolve(endOfList), range2.depth);
  }
  const target = liftTarget(range2);
  if (target == null)
    return false;
  tr.lift(range2, target);
  let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);
  if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr.join($after.pos);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range2) {
  let tr = state.tr, list = range2.parent;
  for (let pos = range2.end, i = range2.endIndex - 1, e = range2.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range2.start), item = $start.nodeAfter;
  if (tr.mapping.map(range2.end) != range2.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range2.startIndex == 0, atEnd = range2.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start = $start.pos, end = start + item.nodeSize;
  tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem$1(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range2 = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range2)
      return false;
    let startIndex = range2.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range2.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice3 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before2 = range2.start, after2 = range2.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before2 - (nestedBefore ? 3 : 1), after2, before2, after2, slice3, 1, true)).scrollIntoView());
    }
    return true;
  };
}
var __defProp$1 = Object.defineProperty;
var __export$1 = (target, all) => {
  for (var name in all)
    __defProp$1(target, name, { get: all[name], enumerable: true });
};
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc2 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
var CommandManager = class {
  constructor(props2) {
    this.editor = props2.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props2.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr } = state;
    const props2 = this.buildProps(tr);
    return Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        const method2 = (...args) => {
          const callback = command2(...args)(props2);
          if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
            view.dispatch(tr);
          }
          return callback;
        };
        return [name, method2];
      })
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr = startTr || state.tr;
    const run3 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain2 = {
      ...Object.fromEntries(
        Object.entries(rawCommands).map(([name, command2]) => {
          const chainedCommand = (...args) => {
            const props2 = this.buildProps(tr, shouldDispatch);
            const callback = command2(...args)(props2);
            callbacks.push(callback);
            return chain2;
          };
          return [name, chainedCommand];
        })
      ),
      run: run3
    };
    return chain2;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr = startTr || state.tr;
    const props2 = this.buildProps(tr, dispatch);
    const formattedCommands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props2, dispatch: void 0 })];
      })
    );
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr, dispatch)
    };
  }
  buildProps(tr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const props2 = {
      tr,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr, shouldDispatch),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props2)];
          })
        );
      }
    };
    return props2;
  }
};
var EventEmitter = class {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  once(event, fn) {
    const onceFn = (...args) => {
      this.off(event, onceFn);
      fn.apply(this, args);
    };
    return this.on(event, onceFn);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
};
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
var removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  if (typeof window === "undefined") {
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  }
  const wrappedValue = `<body>${value}</body>`;
  const html2 = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html2);
}
function createNodeFromContent(content, schema, options2) {
  if (content instanceof Node || content instanceof Fragment) {
    return content;
  }
  options2 = {
    slice: true,
    parseOptions: {},
    ...options2
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options2.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options2.errorOnInvalidContent) {
        throw new Error("[tiptap error]: Invalid JSON content", { cause: error });
      }
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options2);
    }
  }
  if (isTextContent) {
    if (options2.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options2.slice) {
        DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options2.parseOptions);
      } else {
        DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options2.parseOptions);
      }
      if (options2.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser2 = DOMParser.fromSchema(schema);
    if (options2.slice) {
      return parser2.parseSlice(elementFromString(content), options2.parseOptions).content;
    }
    return parser2.parse(elementFromString(content), options2.parseOptions);
  }
  return createNodeFromContent("", schema, options2);
}
function createDocument(content, schema, parseOptions = {}, options2 = {}) {
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions,
    errorOnInvalidContent: options2.errorOnInvalidContent
  });
}
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i += 1) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node, range2, predicate) {
  const nodesWithPos = [];
  node.nodesBetween(range2.from, range2.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i = $pos.depth; i > 0; i -= 1) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getExtensionField(extension, field, context2) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context2);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context2,
      parent: extension.parent ? getExtensionField(extension.parent, field, context2) : null
    });
    return value;
  }
  return extension.config[field];
}
function flattenExtensions(extensions) {
  return extensions.map((extension) => {
    const context2 = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addExtensions = getExtensionField(extension, "addExtensions", context2);
    if (addExtensions) {
      return [extension, ...flattenExtensions(addExtensions())];
    }
    return extension;
  }).flat(10);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function isFunction$2(value) {
  return typeof value === "function";
}
function callOrReturn(value, context2 = void 0, ...props2) {
  if (isFunction$2(value)) {
    if (context2) {
      return value.bind(context2)(...props2);
    }
    return value(...props2);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function splitExtensions(extensions) {
  const baseExtensions = extensions.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions.filter((extension) => extension.type === "node");
  const markExtensions = extensions.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    validate: void 0,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach((extension) => {
    const context2 = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      extensions: nodeAndMarkExtensions
    };
    const addGlobalAttributes = getExtensionField(
      extension,
      "addGlobalAttributes",
      context2
    );
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context2 = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(
      extension,
      "addAttributes",
      context2
    );
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof (mergedAttr == null ? void 0 : mergedAttr.default) === "function") {
        mergedAttr.default = mergedAttr.default();
      }
      if ((mergedAttr == null ? void 0 : mergedAttr.isRequired) && (mergedAttr == null ? void 0 : mergedAttr.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function mergeAttributes(...objects) {
  return objects.filter((item) => !!item).reduce((items, item) => {
    const mergedAttributes = { ...items };
    Object.entries(item).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        const valueClasses = value ? String(value).split(" ") : [];
        const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
        const insertClasses = valueClasses.filter((valueClass) => !existingClasses.includes(valueClass));
        mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
      } else if (key === "style") {
        const newStyles = value ? value.split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(";").map((style2) => style2.trim()).filter(Boolean) : [];
        const styleMap2 = /* @__PURE__ */ new Map();
        existingStyles.forEach((style2) => {
          const [property2, val] = style2.split(":").map((part) => part.trim());
          styleMap2.set(property2, val);
        });
        newStyles.forEach((style2) => {
          const [property2, val] = style2.split(":").map((part) => part.trim());
          styleMap2.set(property2, val);
        });
        mergedAttributes[key] = Array.from(styleMap2.entries()).map(([property2, val]) => `${property2}: ${val}`).join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((attribute) => attribute.type === nodeOrMark.type.name).filter((item) => item.attribute.rendered).map((item) => {
    if (!item.attribute.renderHTML) {
      return {
        [item.name]: nodeOrMark.attrs[item.name]
      };
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if ("style" in parseRule) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item) => {
        const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(data).filter(([key, value]) => {
      if (key === "attrs" && isEmptyObject(value)) {
        return false;
      }
      return value !== null && value !== void 0;
    })
  );
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) == null ? void 0 : _a.name;
  const nodes2 = Object.fromEntries(
    nodeExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context2 = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraNodeFields = extensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionField(e, "extendNodeSchema", context2);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraNodeFields,
        content: callOrReturn(getExtensionField(extension, "content", context2)),
        marks: callOrReturn(getExtensionField(extension, "marks", context2)),
        group: callOrReturn(getExtensionField(extension, "group", context2)),
        inline: callOrReturn(getExtensionField(extension, "inline", context2)),
        atom: callOrReturn(getExtensionField(extension, "atom", context2)),
        selectable: callOrReturn(getExtensionField(extension, "selectable", context2)),
        draggable: callOrReturn(getExtensionField(extension, "draggable", context2)),
        code: callOrReturn(getExtensionField(extension, "code", context2)),
        whitespace: callOrReturn(getExtensionField(extension, "whitespace", context2)),
        linebreakReplacement: callOrReturn(
          getExtensionField(extension, "linebreakReplacement", context2)
        ),
        defining: callOrReturn(getExtensionField(extension, "defining", context2)),
        isolating: callOrReturn(getExtensionField(extension, "isolating", context2)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a2, _b;
            return [
              extensionAttribute.name,
              { default: (_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context2));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context2);
      if (renderHTML) {
        schema.toDOM = (node) => renderHTML({
          node,
          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
        });
      }
      const renderText = getExtensionField(extension, "renderText", context2);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    })
  );
  const marks = Object.fromEntries(
    markExtensions.map((extension) => {
      const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
      const context2 = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const extraMarkFields = extensions.reduce((fields, e) => {
        const extendMarkSchema = getExtensionField(e, "extendMarkSchema", context2);
        return {
          ...fields,
          ...extendMarkSchema ? extendMarkSchema(extension) : {}
        };
      }, {});
      const schema = cleanUpSchemaItem({
        ...extraMarkFields,
        inclusive: callOrReturn(getExtensionField(extension, "inclusive", context2)),
        excludes: callOrReturn(getExtensionField(extension, "excludes", context2)),
        group: callOrReturn(getExtensionField(extension, "group", context2)),
        spanning: callOrReturn(getExtensionField(extension, "spanning", context2)),
        code: callOrReturn(getExtensionField(extension, "code", context2)),
        attrs: Object.fromEntries(
          extensionAttributes.map((extensionAttribute) => {
            var _a2, _b;
            return [
              extensionAttribute.name,
              { default: (_a2 = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _a2.default, validate: (_b = extensionAttribute == null ? void 0 : extensionAttribute.attribute) == null ? void 0 : _b.validate }
            ];
          })
        )
      });
      const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context2));
      if (parseHTML) {
        schema.parseDOM = parseHTML.map(
          (parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes)
        );
      }
      const renderHTML = getExtensionField(extension, "renderHTML", context2);
      if (renderHTML) {
        schema.toDOM = (mark) => renderHTML({
          mark,
          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    })
  );
  return new Schema({
    topNode,
    nodes: nodes2,
    marks
  });
}
function findDuplicates(items) {
  const filtered = items.filter((el, index) => items.indexOf(el) !== index);
  return Array.from(new Set(filtered));
}
function sortExtensions(extensions) {
  const defaultPriority = 100;
  return extensions.sort((a, b) => {
    const priorityA = getExtensionField(a, "priority") || defaultPriority;
    const priorityB = getExtensionField(b, "priority") || defaultPriority;
    if (priorityA > priorityB) {
      return -1;
    }
    if (priorityA < priorityB) {
      return 1;
    }
    return 0;
  });
}
function resolveExtensions(extensions) {
  const resolvedExtensions = sortExtensions(flattenExtensions(extensions));
  const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
  if (duplicatedNames.length) {
    console.warn(
      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item) => `'${item}'`).join(", ")}]. This can lead to issues.`
    );
  }
  return resolvedExtensions;
}
function getTextBetween(startNode, range2, options2) {
  const { from: from3, to: to2 } = range2;
  const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
  let text = "";
  startNode.nodesBetween(from3, to2, (node, pos, parent, index) => {
    var _a;
    if (node.isBlock && pos > from3) {
      text += blockSeparator;
    }
    const textSerializer = textSerializers == null ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (parent) {
        text += textSerializer({
          node,
          pos,
          parent,
          index,
          range: range2
        });
      }
      return false;
    }
    if (node.isText) {
      text += (_a = node == null ? void 0 : node.text) == null ? void 0 : _a.slice(Math.max(from3, pos) - pos, to2 - pos);
    }
  });
  return text;
}
function getText(node, options2) {
  const range2 = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range2, options2);
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(
    Object.entries(schema.nodes).filter(([, node]) => node.spec.toText).map(([name, node]) => [name, node.spec.toText])
  );
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from3, to: to2, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from3, to2, (node) => {
      marks.push(...node.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from3, to: to2 } = state.selection;
  const nodes2 = [];
  state.doc.nodesBetween(from3, to2, (node2) => {
    nodes2.push(node2);
  });
  const node = nodes2.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node) {
    return {};
  }
  return { ...node.attrs };
}
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item) => {
    const key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index) => {
    const rest2 = uniqueChanges.filter((_2, i) => i !== index);
    return !rest2.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from3, to: to2 } = steps[index];
      if (from3 === void 0 || to2 === void 0) {
        return;
      }
      ranges.push({ from: from3, to: to2 });
    } else {
      stepMap.forEach((from3, to2) => {
        ranges.push({ from: from3, to: to2 });
      });
    }
    ranges.forEach(({ from: from3, to: to2 }) => {
      const newStart = mapping.slice(index).map(from3, -1);
      const newEnd = mapping.slice(index).map(to2);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function isRegExp$1(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
function objectIncludes(object1, object2, options2 = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options2.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp$1(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item) => {
    return item.type === type && objectIncludes(
      // Only check equality for the attributes that are provided
      Object.fromEntries(Object.keys(attributes).map((k) => [k, item.attrs[k]])),
      attributes
    );
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes) {
  var _a;
  if (!$pos || !type) {
    return;
  }
  let start = $pos.parent.childAfter($pos.parentOffset);
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node || !start.node.marks.some((mark2) => mark2.type === type)) {
    return;
  }
  attributes = attributes || ((_a = start.node.marks[0]) == null ? void 0 : _a.attrs);
  const mark = findMarkInSet([...start.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarksBetween(from3, to2, doc2) {
  const marks = [];
  if (from3 === to2) {
    doc2.resolve(from3).marks().forEach((mark) => {
      const $pos = doc2.resolve(from3);
      const range2 = getMarkRange($pos, mark.type);
      if (!range2) {
        return;
      }
      marks.push({
        mark,
        ...range2
      });
    });
  } else {
    doc2.nodesBetween(from3, to2, (node, pos) => {
      if (!node || (node == null ? void 0 : node.nodeSize) === void 0) {
        return;
      }
      marks.push(
        ...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        }))
      );
    });
  }
  return marks;
}
var getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {
  const $pos = state.doc.resolve(pos);
  let currentDepth = maxDepth;
  let node = null;
  while (currentDepth > 0 && node === null) {
    const currentNode = $pos.node(currentDepth);
    if ((currentNode == null ? void 0 : currentNode.type.name) === typeOrName) {
      node = currentNode;
    } else {
      currentDepth -= 1;
    }
  }
  return [node, currentDepth];
};
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(
    Object.entries(attributes).filter(([name]) => {
      const extensionAttribute = extensionAttributes.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttribute) {
        return false;
      }
      return extensionAttribute.attribute.keepOnSplit;
    })
  );
}
var getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {
    var _a, _b;
    const chunk2 = ((_b = (_a = node.type.spec).toText) == null ? void 0 : _b.call(_a, {
      node,
      pos,
      parent,
      index
    })) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk2 : chunk2.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from3 = $from.pos;
    const to2 = $to.pos;
    state.doc.nodesBetween(from3, to2, (node, pos) => {
      if (!node.isText && !node.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from3, pos);
      const relativeTo = Math.min(to2, pos + node.nodeSize);
      const range22 = relativeTo - relativeFrom;
      selectionRange += range22;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range2 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range2 >= selectionRange;
}
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from3, to: to2, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from3, to2, (node, pos) => {
    if (node.isText) {
      return;
    }
    const relativeFrom = Math.max(from3, pos);
    const relativeTo = Math.min(to2, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to2 - from3;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range2 = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range2 >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
var isAtEndOfNode = (state, nodeType) => {
  const { $from, $to, $anchor } = state.selection;
  if (nodeType) {
    const parentNode2 = findParentNode((node) => node.type.name === nodeType)(state.selection);
    if (!parentNode2) {
      return false;
    }
    const $parentPos = state.doc.resolve(parentNode2.pos + 1);
    if ($anchor.pos + 1 === $parentPos.end()) {
      return true;
    }
    return false;
  }
  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
var isAtStartOfNode = (state) => {
  const { $from, $to } = state.selection;
  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
function isList(name, extensions) {
  const { nodeExtensions } = splitExtensions(extensions);
  const extension = nodeExtensions.find((item) => item.name === name);
  if (!extension) {
    return false;
  }
  const context2 = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group2 = callOrReturn(getExtensionField(extension, "group", context2));
  if (typeof group2 !== "string") {
    return false;
  }
  return group2.split(" ").includes("list");
}
function isNodeEmpty(node, {
  checkChildren = true,
  ignoreWhitespace = false
} = {}) {
  var _a;
  if (ignoreWhitespace) {
    if (node.type.name === "hardBreak") {
      return true;
    }
    if (node.isText) {
      return /^\s*$/m.test((_a = node.text) != null ? _a : "");
    }
  }
  if (node.isText) {
    return !node.text;
  }
  if (node.isAtom || node.isLeaf) {
    return false;
  }
  if (node.content.childCount === 0) {
    return true;
  }
  if (checkChildren) {
    let isContentEmpty = true;
    node.content.forEach((childNode) => {
      if (isContentEmpty === false) {
        return;
      }
      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {
        isContentEmpty = false;
      }
    });
    return isContentEmpty;
  }
  return false;
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc2, position = null) {
  if (!position) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position === "start" || position === true) {
    return selectionAtStart;
  }
  if (position === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function selectionToInsertionEnd(tr, startLen, bias) {
  const last2 = tr.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  const step = tr.steps[last2];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map3 = tr.mapping.maps[last2];
  let end = 0;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end === 0) {
      end = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
var InputRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var inputRuleMatcherHandler = (text, find2) => {
  if (isRegExp$1(find2)) {
    return find2.exec(text);
  }
  const inputRuleMatch = find2(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result2 = [inputRuleMatch.text];
  result2.index = inputRuleMatch.index;
  result2.input = text;
  result2.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result2.push(inputRuleMatch.replaceWith);
  }
  return result2;
};
function run(config) {
  var _a;
  const { editor, from: from3, to: to2, text, rules: rules2, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from3);
  if (
    // check for code node
    $from.parent.type.spec.code || // check for code mark
    !!((_a = $from.nodeBefore || $from.nodeAfter) == null ? void 0 : _a.marks.find((mark) => mark.type.spec.code))
  ) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules2.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr
    });
    const range2 = {
      from: from3 - (match[0].length - text.length),
      to: to2
    };
    const { commands, chain: chain2, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range: range2,
      match,
      commands,
      chain: chain2,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from: from3,
      to: to2,
      text
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props2) {
  const { editor, rules: rules2 } = props2;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr, prev, state) {
        const stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text === "string") {
              text = text;
            } else {
              text = getHTMLFromFragment(Fragment.from(text), state.schema);
            }
            const { from: from3 } = simulatedInputMeta;
            const to2 = from3 + text.length;
            run({
              editor,
              from: from3,
              to: to2,
              text,
              rules: rules2,
              plugin
            });
          });
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from3, to2, text) {
        return run({
          editor,
          from: from3,
          to: to2,
          text,
          rules: rules2,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules: rules2,
                plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules: rules2,
            plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key]) && isPlainObject(target[key])) {
        output[key] = mergeDeep(target[key], source[key]);
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
var Extendable = class {
  constructor(config = {}) {
    this.type = "extendable";
    this.parent = null;
    this.child = null;
    this.name = "";
    this.config = {
      name: this.name
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
  }
  get options() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...callOrReturn(
        getExtensionField(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(options2 = {}) {
    const extension = this.extend({
      ...this.config,
      addOptions: () => {
        return mergeDeep(this.options, options2);
      }
    });
    extension.name = this.name;
    extension.parent = this.parent;
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new this.constructor({ ...this.config, ...extendedConfig });
    extension.parent = this;
    this.child = extension;
    extension.name = "name" in extendedConfig ? extendedConfig.name : extension.parent.name;
    return extension;
  }
};
var Mark2 = class _Mark extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Mark(resolvedConfig);
  }
  static handleExit({ editor, mark }) {
    const { tr } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m) => (m == null ? void 0 : m.type.name) === mark.name);
      if (removeMark2) {
        tr.removeStoredMark(removeMark2);
      }
      tr.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr);
      return true;
    }
    return false;
  }
  configure(options2) {
    return super.configure(options2);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
function isNumber$1(value) {
  return typeof value === "number";
}
var PasteRule = class {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
};
var pasteRuleMatcherHandler = (text, find2, event) => {
  if (isRegExp$1(find2)) {
    return [...text.matchAll(find2)];
  }
  const matches2 = find2(text, event);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result2 = [pasteRuleMatch.text];
    result2.index = pasteRuleMatch.index;
    result2.input = text;
    result2.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result2.push(pasteRuleMatch.replaceWith);
    }
    return result2;
  });
};
function run2(config) {
  const { editor, state, from: from3, to: to2, rule, pasteEvent, dropEvent } = config;
  const { commands, chain: chain2, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from3, to2, (node, pos) => {
    var _a, _b, _c, _d, _e;
    if (((_b = (_a = node.type) == null ? void 0 : _a.spec) == null ? void 0 : _b.code) || !(node.isText || node.isTextblock || node.isInline)) {
      return;
    }
    const contentSize = (_e = (_d = (_c = node.content) == null ? void 0 : _c.size) != null ? _d : node.nodeSize) != null ? _e : 0;
    const resolvedFrom = Math.max(from3, pos);
    const resolvedTo = Math.min(to2, pos + contentSize);
    if (resolvedFrom >= resolvedTo) {
      return;
    }
    const textToMatch = node.isText ? node.text || "" : node.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "ï¿¼");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches2.forEach((match) => {
      if (match.index === void 0) {
        return;
      }
      const start = resolvedFrom + match.index + 1;
      const end = start + match[0].length;
      const range2 = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      const handler = rule.handler({
        state,
        range: range2,
        match,
        commands,
        chain: chain2,
        can,
        pasteEvent,
        dropEvent
      });
      handlers2.push(handler);
    });
  });
  const success = handlers2.every((handler) => handler !== null);
  return success;
}
var tiptapDragFromOtherEditor = null;
var createClipboardPasteEvent = (text) => {
  var _a;
  const event = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  (_a = event.clipboardData) == null ? void 0 : _a.setData("text/html", text);
  return event;
};
function pasteRulesPlugin(props2) {
  const { editor, rules: rules2 } = props2;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  let pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
  let dropEvent;
  try {
    dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
  } catch {
    dropEvent = null;
  }
  const processEvent = ({
    state,
    from: from3,
    to: to2,
    rule,
    pasteEvt
  }) => {
    const tr = state.tr;
    const chainableState = createChainableState({
      state,
      transaction: tr
    });
    const handler = run2({
      editor,
      state: chainableState,
      from: Math.max(from3 - 1, 0),
      to: to2.b - 1,
      rule,
      pasteEvent: pasteEvt,
      dropEvent
    });
    if (!handler || !tr.steps.length) {
      return;
    }
    try {
      dropEvent = typeof DragEvent !== "undefined" ? new DragEvent("drop") : null;
    } catch {
      dropEvent = null;
    }
    pasteEvent = typeof ClipboardEvent !== "undefined" ? new ClipboardEvent("paste") : null;
    return tr;
  };
  const plugins = rules2.map((rule) => {
    return new Plugin({
      // we register a global drag handler to track the current drag source element
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) == null ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
          if (dragSourceElement) {
            tiptapDragFromOtherEditor = editor;
          }
        };
        const handleDragend = () => {
          if (tiptapDragFromOtherEditor) {
            tiptapDragFromOtherEditor = null;
          }
        };
        window.addEventListener("dragstart", handleDragstart);
        window.addEventListener("dragend", handleDragend);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
            window.removeEventListener("dragend", handleDragend);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view, event) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            if (!isDroppedFromProseMirror) {
              const dragFromOtherEditor = tiptapDragFromOtherEditor;
              if (dragFromOtherEditor == null ? void 0 : dragFromOtherEditor.isEditable) {
                setTimeout(() => {
                  const selection = dragFromOtherEditor.state.selection;
                  if (selection) {
                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });
                  }
                }, 10);
              }
            }
            return false;
          },
          paste: (_view, event) => {
            var _a;
            const html2 = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/html");
            pasteEvent = event;
            isPastedFromProseMirror = !!(html2 == null ? void 0 : html2.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        const simulatedPasteMeta = transaction.getMeta("applyPasteRules");
        const isSimulatedPaste = !!simulatedPasteMeta;
        if (!isPaste && !isDrop && !isSimulatedPaste) {
          return;
        }
        if (isSimulatedPaste) {
          let { text } = simulatedPasteMeta;
          if (typeof text === "string") {
            text = text;
          } else {
            text = getHTMLFromFragment(Fragment.from(text), state.schema);
          }
          const { from: from22 } = simulatedPasteMeta;
          const to22 = from22 + text.length;
          const pasteEvt = createClipboardPasteEvent(text);
          return processEvent({
            rule,
            state,
            from: from22,
            to: { b: to22 },
            pasteEvt
          });
        }
        const from3 = oldState.doc.content.findDiffStart(state.doc.content);
        const to2 = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber$1(from3) || !to2 || from3 === to2.b) {
          return;
        }
        return processEvent({
          rule,
          state,
          from: from3,
          to: to2,
          pasteEvt: pasteEvent
        });
      }
    });
  });
  return plugins;
}
var ExtensionManager = class {
  constructor(extensions, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = resolveExtensions(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((commands, extension) => {
      const context2 = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context2);
      if (!addCommands) {
        return commands;
      }
      return {
        ...commands,
        ...addCommands()
      };
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor } = this;
    const extensions = sortExtensions([...this.extensions].reverse());
    const allPlugins = extensions.map((extension) => {
      const context2 = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addKeyboardShortcuts = getExtensionField(
        extension,
        "addKeyboardShortcuts",
        context2
      );
      let defaultBindings = {};
      if (extension.type === "mark" && getExtensionField(extension, "exitable", context2)) {
        defaultBindings.ArrowRight = () => Mark2.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(
          Object.entries(addKeyboardShortcuts()).map(([shortcut, method2]) => {
            return [shortcut, () => method2({ editor })];
          })
        );
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context2);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        const rules2 = addInputRules();
        if (rules2 && rules2.length) {
          const inputResult = inputRulesPlugin({
            editor,
            rules: rules2
          });
          const inputPlugins = Array.isArray(inputResult) ? inputResult : [inputResult];
          plugins.push(...inputPlugins);
        }
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context2);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        const rules2 = addPasteRules();
        if (rules2 && rules2.length) {
          const pasteRules = pasteRulesPlugin({ editor, rules: rules2 });
          plugins.push(...pasteRules);
        }
      }
      const addProseMirrorPlugins = getExtensionField(
        extension,
        "addProseMirrorPlugins",
        context2
      );
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins.push(...proseMirrorPlugins);
      }
      return plugins;
    }).flat();
    return allPlugins;
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context2 = {
          name: extension.name,
          options: extension.options,
          storage: this.editor.extensionStorage[extension.name],
          editor,
          type: getNodeType(extension.name, this.schema)
        };
        const addNodeView = getExtensionField(extension, "addNodeView", context2);
        if (!addNodeView) {
          return [];
        }
        const nodeview = (node, view, getPos, decorations, innerDecorations) => {
          const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
          return addNodeView()({
            // pass-through
            node,
            view,
            getPos,
            decorations,
            innerDecorations,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes
          });
        };
        return [extension.name, nodeview];
      })
    );
  }
  get markViews() {
    const { editor } = this;
    const { markExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(
      markExtensions.filter((extension) => !!getExtensionField(extension, "addMarkView")).map((extension) => {
        const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
        const context2 = {
          name: extension.name,
          options: extension.options,
          storage: this.editor.extensionStorage[extension.name],
          editor,
          type: getMarkType(extension.name, this.schema)
        };
        const addMarkView = getExtensionField(extension, "addMarkView", context2);
        if (!addMarkView) {
          return [];
        }
        const markView = (mark, view, inline) => {
          const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes);
          return addMarkView()({
            // pass-through
            mark,
            view,
            inline,
            // tiptap-specific
            editor,
            extension,
            HTMLAttributes,
            updateAttributes: (attrs) => {
              updateMarkViewAttributes(mark, editor, attrs);
            }
          });
        };
        return [extension.name, markView];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const extensions = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      extensions.map((extension) => [extension.name, extension.storage])
    );
    extensions.forEach((extension) => {
      var _a;
      const context2 = {
        name: extension.name,
        options: extension.options,
        storage: this.editor.extensionStorage[extension.name],
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context2))) != null ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context2);
      const onCreate = getExtensionField(extension, "onCreate", context2);
      const onUpdate = getExtensionField(extension, "onUpdate", context2);
      const onSelectionUpdate = getExtensionField(
        extension,
        "onSelectionUpdate",
        context2
      );
      const onTransaction = getExtensionField(extension, "onTransaction", context2);
      const onFocus = getExtensionField(extension, "onFocus", context2);
      const onBlur = getExtensionField(extension, "onBlur", context2);
      const onDestroy = getExtensionField(extension, "onDestroy", context2);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      if (onCreate) {
        this.editor.on("create", onCreate);
      }
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      if (onDestroy) {
        this.editor.on("destroy", onDestroy);
      }
    });
  }
};
ExtensionManager.resolve = resolveExtensions;
ExtensionManager.sort = sortExtensions;
ExtensionManager.flatten = flattenExtensions;
var extensions_exports = {};
__export$1(extensions_exports, {
  ClipboardTextSerializer: () => ClipboardTextSerializer,
  Commands: () => Commands,
  Delete: () => Delete,
  Drop: () => Drop,
  Editable: () => Editable,
  FocusEvents: () => FocusEvents,
  Keymap: () => Keymap,
  Paste: () => Paste,
  Tabindex: () => Tabindex,
  focusEventsPluginKey: () => focusEventsPluginKey
});
var Extension = class _Extension extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Extension(resolvedConfig);
  }
  configure(options2) {
    return super.configure(options2);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
var ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from3 = Math.min(...ranges.map((range22) => range22.$from.pos));
            const to2 = Math.max(...ranges.map((range22) => range22.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range2 = { from: from3, to: to2 };
            return getTextBetween(doc2, range2, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers
            });
          }
        }
      })
    ];
  }
});
var commands_exports = {};
__export$1(commands_exports, {
  blur: () => blur,
  clearContent: () => clearContent,
  clearNodes: () => clearNodes,
  command: () => command,
  createParagraphNear: () => createParagraphNear,
  cut: () => cut,
  deleteCurrentNode: () => deleteCurrentNode,
  deleteNode: () => deleteNode,
  deleteRange: () => deleteRange,
  deleteSelection: () => deleteSelection,
  enter: () => enter,
  exitCode: () => exitCode,
  extendMarkRange: () => extendMarkRange,
  first: () => first$1,
  focus: () => focus,
  forEach: () => forEach,
  insertContent: () => insertContent,
  insertContentAt: () => insertContentAt,
  joinBackward: () => joinBackward,
  joinDown: () => joinDown,
  joinForward: () => joinForward,
  joinItemBackward: () => joinItemBackward,
  joinItemForward: () => joinItemForward,
  joinTextblockBackward: () => joinTextblockBackward,
  joinTextblockForward: () => joinTextblockForward,
  joinUp: () => joinUp,
  keyboardShortcut: () => keyboardShortcut,
  lift: () => lift,
  liftEmptyBlock: () => liftEmptyBlock,
  liftListItem: () => liftListItem,
  newlineInCode: () => newlineInCode,
  resetAttributes: () => resetAttributes,
  scrollIntoView: () => scrollIntoView,
  selectAll: () => selectAll,
  selectNodeBackward: () => selectNodeBackward,
  selectNodeForward: () => selectNodeForward,
  selectParentNode: () => selectParentNode,
  selectTextblockEnd: () => selectTextblockEnd,
  selectTextblockStart: () => selectTextblockStart,
  setContent: () => setContent,
  setMark: () => setMark,
  setMeta: () => setMeta,
  setNode: () => setNode,
  setNodeSelection: () => setNodeSelection,
  setTextSelection: () => setTextSelection,
  sinkListItem: () => sinkListItem,
  splitBlock: () => splitBlock,
  splitListItem: () => splitListItem,
  toggleList: () => toggleList,
  toggleMark: () => toggleMark,
  toggleNode: () => toggleNode,
  toggleWrap: () => toggleWrap,
  undoInputRule: () => undoInputRule,
  unsetAllMarks: () => unsetAllMarks,
  unsetMark: () => unsetMark,
  updateAttributes: () => updateAttributes,
  wrapIn: () => wrapIn,
  wrapInList: () => wrapInList
});
var blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
var clearContent = (emitUpdate = true) => ({ commands }) => {
  return commands.setContent("", { emitUpdate });
};
var clearNodes = () => ({ state, tr, dispatch }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
var command = (fn) => (props2) => {
  return fn(props2);
};
var createParagraphNear = () => ({ state, dispatch }) => {
  return createParagraphNear$1(state, dispatch);
};
var cut = (originRange, targetPos) => ({ editor, tr }) => {
  const { state } = editor;
  const contentSlice = state.doc.slice(originRange.from, originRange.to);
  tr.deleteRange(originRange.from, originRange.to);
  const newPos = tr.mapping.map(targetPos);
  tr.insert(newPos, contentSlice.content);
  tr.setSelection(new TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));
  return true;
};
var deleteCurrentNode = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === currentNode.type) {
      if (dispatch) {
        const from3 = $pos.before(depth);
        const to2 = $pos.after(depth);
        tr.delete(from3, to2).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node = $pos.node(depth);
    if (node.type === type) {
      if (dispatch) {
        const from3 = $pos.before(depth);
        const to2 = $pos.after(depth);
        tr.delete(from3, to2).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
var deleteRange = (range2) => ({ tr, dispatch }) => {
  const { from: from3, to: to2 } = range2;
  if (dispatch) {
    tr.delete(from3, to2);
  }
  return true;
};
var deleteSelection = () => ({ state, dispatch }) => {
  return deleteSelection$1(state, dispatch);
};
var enter = () => ({ commands }) => {
  return commands.keyboardShortcut("Enter");
};
var exitCode = () => ({ state, dispatch }) => {
  return exitCode$1(state, dispatch);
};
var extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc2, selection } = tr;
  const { $from, from: from3, to: to2 } = selection;
  if (dispatch) {
    const range2 = getMarkRange($from, type, attributes);
    if (range2 && range2.from <= from3 && range2.to >= to2) {
      const newSelection = TextSelection.create(doc2, range2.from, range2.to);
      tr.setSelection(newSelection);
    }
  }
  return true;
};
var first$1 = (commands) => (props2) => {
  const items = typeof commands === "function" ? commands(props2) : commands;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props2)) {
      return true;
    }
  }
  return false;
};
function isAndroid() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function isiOS() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var focus = (position = null, options2 = {}) => ({ editor, view, tr, dispatch }) => {
  options2 = {
    scrollIntoView: true,
    ...options2
  };
  const delayedFocus = () => {
    if (isiOS() || isAndroid()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options2 == null ? void 0 : options2.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position === null || position === false) {
    return true;
  }
  if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr.setSelection(selection);
    }
    if (isSameSelection && tr.storedMarks) {
      tr.setStoredMarks(tr.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
var forEach = (items, fn) => (props2) => {
  return items.every((item, index) => fn(item, { ...props2, index }));
};
var insertContent = (value, options2) => ({ tr, commands }) => {
  return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options2);
};
var isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
var insertContentAt = (position, value, options2) => ({ tr, dispatch, editor }) => {
  var _a;
  if (dispatch) {
    options2 = {
      parseOptions: editor.options.parseOptions,
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options2
    };
    let content;
    const { selection } = editor.state;
    const emitContentError = (error) => {
      editor.emit("contentError", {
        editor,
        error,
        disableCollaboration: () => {
          if ("collaboration" in editor.storage && typeof editor.storage.collaboration === "object" && editor.storage.collaboration) {
            editor.storage.collaboration.isDisabled = true;
          }
        }
      });
    };
    const parseOptions = {
      preserveWhitespace: "full",
      ...options2.parseOptions
    };
    if (!options2.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {
      try {
        createNodeFromContent(value, editor.schema, {
          parseOptions,
          errorOnInvalidContent: true
        });
      } catch (e) {
        emitContentError(e);
      }
    }
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions,
        errorOnInvalidContent: (_a = options2.errorOnInvalidContent) != null ? _a : editor.options.enableContentCheck
      });
    } catch (e) {
      emitContentError(e);
      return false;
    }
    let { from: from3, to: to2 } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes2 = isFragment(content) ? content : [content];
    nodes2.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from3 === to2 && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from3);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from3 -= 1;
        to2 += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (value instanceof Fragment) {
        let text = "";
        value.forEach((node) => {
          if (node.text) {
            text += node.text;
          }
        });
        newContent = text;
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr.insertText(newContent, from3, to2);
    } else {
      newContent = content;
      const fromSelectionAtStart = selection.$from.parentOffset === 0;
      const isTextSelection2 = selection.$from.node().isText || selection.$from.node().isTextblock;
      const hasContent = selection.$from.node().content.size > 0;
      if (fromSelectionAtStart && isTextSelection2 && hasContent) {
        from3 = Math.max(0, from3 - 1);
      }
      tr.replaceWith(from3, to2, newContent);
    }
    if (options2.updateSelection) {
      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
    }
    if (options2.applyInputRules) {
      tr.setMeta("applyInputRules", { from: from3, text: newContent });
    }
    if (options2.applyPasteRules) {
      tr.setMeta("applyPasteRules", { from: from3, text: newContent });
    }
  }
  return true;
};
var joinUp = () => ({ state, dispatch }) => {
  return joinUp$1(state, dispatch);
};
var joinDown = () => ({ state, dispatch }) => {
  return joinDown$1(state, dispatch);
};
var joinBackward = () => ({ state, dispatch }) => {
  return joinBackward$1(state, dispatch);
};
var joinForward = () => ({ state, dispatch }) => {
  return joinForward$1(state, dispatch);
};
var joinItemBackward = () => ({ state, dispatch, tr }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, -1);
    if (point === null || point === void 0) {
      return false;
    }
    tr.join(point, 2);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  } catch {
    return false;
  }
};
var joinItemForward = () => ({ state, dispatch, tr }) => {
  try {
    const point = joinPoint(state.doc, state.selection.$from.pos, 1);
    if (point === null || point === void 0) {
      return false;
    }
    tr.join(point, 2);
    if (dispatch) {
      dispatch(tr);
    }
    return true;
  } catch {
    return false;
  }
};
var joinTextblockBackward = () => ({ state, dispatch }) => {
  return joinTextblockBackward$1(state, dispatch);
};
var joinTextblockForward = () => ({ state, dispatch }) => {
  return joinTextblockForward$1(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  const parts = name.split(/-(?!$)/);
  let result2 = parts[parts.length - 1];
  if (result2 === "Space") {
    result2 = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i = 0; i < parts.length - 1; i += 1) {
    const mod2 = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod2)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod2)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod2)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod2)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod2)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod2}`);
    }
  }
  if (alt) {
    result2 = `Alt-${result2}`;
  }
  if (ctrl) {
    result2 = `Ctrl-${result2}`;
  }
  if (meta) {
    result2 = `Meta-${result2}`;
  }
  if (shift2) {
    result2 = `Shift-${result2}`;
  }
  return result2;
}
var keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
  const keys2 = normalizeKeyName(name).split(/-(?!$)/);
  const key = keys2.find((item) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f) => f(view, event));
  });
  capturedTransaction == null ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr.mapping);
    if (newStep && dispatch) {
      tr.maybeStep(newStep);
    }
  });
  return true;
};
var lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$1(state, dispatch);
};
var liftEmptyBlock = () => ({ state, dispatch }) => {
  return liftEmptyBlock$1(state, dispatch);
};
var liftListItem = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem$1(type)(state, dispatch);
};
var newlineInCode = () => ({ state, dispatch }) => {
  return newlineInCode$1(state, dispatch);
};
function deleteProps(obj, propOrProps) {
  const props2 = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props2.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range2) => {
      state.doc.nodesBetween(range2.$from.pos, range2.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attributes));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
var scrollIntoView = () => ({ tr, dispatch }) => {
  if (dispatch) {
    tr.scrollIntoView();
  }
  return true;
};
var selectAll = () => ({ tr, dispatch }) => {
  if (dispatch) {
    const selection = new AllSelection(tr.doc);
    tr.setSelection(selection);
  }
  return true;
};
var selectNodeBackward = () => ({ state, dispatch }) => {
  return selectNodeBackward$1(state, dispatch);
};
var selectNodeForward = () => ({ state, dispatch }) => {
  return selectNodeForward$1(state, dispatch);
};
var selectParentNode = () => ({ state, dispatch }) => {
  return selectParentNode$1(state, dispatch);
};
var selectTextblockEnd = () => ({ state, dispatch }) => {
  return selectTextblockEnd$1(state, dispatch);
};
var selectTextblockStart = () => ({ state, dispatch }) => {
  return selectTextblockStart$1(state, dispatch);
};
var setContent = (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) => ({ editor, tr, dispatch, commands }) => {
  const { doc: doc2 } = tr;
  if (parseOptions.preserveWhitespace !== "full") {
    const document2 = createDocument(content, editor.schema, parseOptions, {
      errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
    });
    if (dispatch) {
      tr.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
    }
    return true;
  }
  if (dispatch) {
    tr.setMeta("preventUpdate", !emitUpdate);
  }
  return commands.insertContentAt({ from: 0, to: doc2.content.size }, content, {
    parseOptions,
    errorOnInvalidContent: errorOnInvalidContent != null ? errorOnInvalidContent : editor.options.enableContentCheck
  });
};
function canSetMark(state, tr, newMarkType) {
  var _a;
  const { selection } = tr;
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = (_a = state.storedMarks) != null ? _a : cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range2) => {
        const from3 = range2.$from.pos;
        const to2 = range2.$to.pos;
        state.doc.nodesBetween(from3, to2, (node, pos) => {
          const trimmedFrom = Math.max(pos, from3);
          const trimmedTo = Math.min(pos + node.nodeSize, to2);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr, type);
};
var setMeta = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
var setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain: chain2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain2().command(({ commands }) => {
    const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state);
    if (canSetBlock) {
      return true;
    }
    return commands.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);
  }).run();
};
var setNodeSelection = (position) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr;
    const from3 = minMax(position, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from3);
    tr.setSelection(selection);
  }
  return true;
};
var setTextSelection = (position) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr;
    const { from: from3, to: to2 } = typeof position === "number" ? { from: position, to: position } : position;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax(from3, minPos, maxPos);
    const resolvedEnd = minMax(to2, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr.setSelection(selection);
  }
  return true;
};
var sinkListItem = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem$1(type)(state, dispatch);
};
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks == null ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
  const { selection, doc: doc2 } = tr;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  const atEnd = $to.parentOffset === $to.parent.content.size;
  const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
  let types = atEnd && deflt ? [
    {
      type: deflt,
      attrs: newAttributes
    }
  ] : void 0;
  let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
  if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
    can = true;
    types = deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
  }
  if (dispatch) {
    if (can) {
      if (selection instanceof TextSelection) {
        tr.deleteSelection();
      }
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr.scrollIntoView();
  }
  return can;
};
var splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node = state.selection.node;
  if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
        wrap2 = Fragment.from($from.node(d).copy(wrap2));
      }
      const depthAfter = (
        // eslint-disable-next-line no-nested-ternary
        $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3
      );
      const newNextTypeAttributes2 = {
        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
        ...overrideAttrs
      };
      const nextType2 = ((_a = type.contentMatch.defaultType) == null ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start = $from.before($from.depth - (depthBefore - 1));
      tr.replace(start, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n.isTextblock && n.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
      }
      tr.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),
    ...overrideAttrs
  };
  const newNextTypeAttributes = {
    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),
    ...overrideAttrs
  };
  tr.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    const { selection, storedMarks } = state;
    const { splittableMarks } = editor.extensionManager;
    const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    tr.split($from.pos, 2, types).scrollIntoView();
    if (!marks || !dispatch) {
      return true;
    }
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr.ensureMarks(filteredMarks);
  }
  return true;
};
var joinListBackwards = (tr, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const before2 = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before2 === void 0) {
    return true;
  }
  const nodeBefore = tr.doc.nodeAt(before2);
  const canJoinBackwards = list.node.type === (nodeBefore == null ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list.pos);
  return true;
};
var joinListForwards = (tr, listType) => {
  const list = findParentNode((node) => node.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const after2 = tr.doc.resolve(list.start).after(list.depth);
  if (after2 === void 0) {
    return true;
  }
  const nodeAfter = tr.doc.nodeAt(after2);
  const canJoinForwards = list.node.type === (nodeAfter == null ? void 0 : nodeAfter.type) && canJoin(tr.doc, after2);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after2);
  return true;
};
var toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain: chain2, commands, can }) => {
  const { extensions, splittableMarks } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection, storedMarks } = state;
  const { $from, $to } = selection;
  const range2 = $from.blockRange($to);
  const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
  if (!range2) {
    return false;
  }
  const parentList = findParentNode((node) => isList(node.type.name, extensions))(selection);
  if (range2.depth >= 1 && parentList && range2.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
      return chain2().command(() => {
        tr.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
  }
  if (!keepMarks || !marks || !dispatch) {
    return chain2().command(() => {
      const canWrapInList = can().wrapInList(listType, attributes);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
  }
  return chain2().command(() => {
    const canWrapInList = can().wrapInList(listType, attributes);
    const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
    tr.ensureMarks(filteredMarks);
    if (canWrapInList) {
      return true;
    }
    return commands.clearNodes();
  }).wrapInList(listType, attributes).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
};
var toggleMark = (typeOrName, attributes = {}, options2 = {}) => ({ state, commands }) => {
  const { extendEmptyMarkRange = false } = options2;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands.setMark(type, attributes);
};
var toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  let attributesToCopy;
  if (state.selection.$anchor.sameParent(state.selection.$head)) {
    attributesToCopy = state.selection.$anchor.parent.attrs;
  }
  if (isActive2) {
    return commands.setNode(toggleType, attributesToCopy);
  }
  return commands.setNode(type, { ...attributesToCopy, ...attributes });
};
var toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands.lift(type);
  }
  return commands.wrapIn(type, attributes);
};
var undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
var unsetAllMarks = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range2) => {
      tr.removeMark(range2.$from.pos, range2.$to.pos);
    });
  }
  return true;
};
var unsetMark = (typeOrName, options2 = {}) => ({ tr, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options2;
  const { selection } = tr;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from3, to: to2 } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) == null ? void 0 : _a.attrs;
    const range2 = getMarkRange($from, type, attrs);
    if (range2) {
      from3 = range2.from;
      to2 = range2.to;
    }
    tr.removeMark(from3, to2, type);
  } else {
    ranges.forEach((range2) => {
      tr.removeMark(range2.$from.pos, range2.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
var updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range2) => {
      const from3 = range2.$from.pos;
      const to2 = range2.$to.pos;
      let lastPos;
      let lastNode;
      let trimmedFrom;
      let trimmedTo;
      if (tr.selection.empty) {
        state.doc.nodesBetween(from3, to2, (node, pos) => {
          if (nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from3);
            trimmedTo = Math.min(pos + node.nodeSize, to2);
            lastPos = pos;
            lastNode = node;
          }
        });
      } else {
        state.doc.nodesBetween(from3, to2, (node, pos) => {
          if (pos < from3 && nodeType && nodeType === node.type) {
            trimmedFrom = Math.max(pos, from3);
            trimmedTo = Math.min(pos + node.nodeSize, to2);
            lastPos = pos;
            lastNode = node;
          }
          if (pos >= from3 && pos <= to2) {
            if (nodeType && nodeType === node.type) {
              tr.setNodeMarkup(pos, void 0, {
                ...node.attrs,
                ...attributes
              });
            }
            if (markType && node.marks.length) {
              node.marks.forEach((mark) => {
                if (markType === mark.type) {
                  const trimmedFrom2 = Math.max(pos, from3);
                  const trimmedTo2 = Math.min(pos + node.nodeSize, to2);
                  tr.addMark(
                    trimmedFrom2,
                    trimmedTo2,
                    markType.create({
                      ...mark.attrs,
                      ...attributes
                    })
                  );
                }
              });
            }
          }
        });
      }
      if (lastNode) {
        if (lastPos !== void 0) {
          tr.setNodeMarkup(lastPos, void 0, {
            ...lastNode.attrs,
            ...attributes
          });
        }
        if (markType && lastNode.marks.length) {
          lastNode.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(
                trimmedFrom,
                trimmedTo,
                markType.create({
                  ...mark.attrs,
                  ...attributes
                })
              );
            }
          });
        }
      }
    });
  }
  return true;
};
var wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn$1(type, attributes)(state, dispatch);
};
var wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList$1(type, attributes)(state, dispatch);
};
var Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands_exports
    };
  }
});
var Delete = Extension.create({
  name: "delete",
  onUpdate({ transaction, appendedTransactions }) {
    var _a, _b, _c;
    const callback = () => {
      var _a2, _b2, _c2, _d;
      if ((_d = (_c2 = (_b2 = (_a2 = this.editor.options.coreExtensionOptions) == null ? void 0 : _a2.delete) == null ? void 0 : _b2.filterTransaction) == null ? void 0 : _c2.call(_b2, transaction)) != null ? _d : transaction.getMeta("y-sync$")) {
        return;
      }
      const nextTransaction = combineTransactionSteps(transaction.before, [transaction, ...appendedTransactions]);
      const changes = getChangedRanges(nextTransaction);
      changes.forEach((change) => {
        if (nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter && nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore) {
          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from3) => {
            const to2 = from3 + node.nodeSize - 2;
            const isFullyWithinRange = change.oldRange.from <= from3 && to2 <= change.oldRange.to;
            this.editor.emit("delete", {
              type: "node",
              node,
              from: from3,
              to: to2,
              newFrom: nextTransaction.mapping.map(from3),
              newTo: nextTransaction.mapping.map(to2),
              deletedRange: change.oldRange,
              newRange: change.newRange,
              partial: !isFullyWithinRange,
              editor: this.editor,
              transaction,
              combinedTransform: nextTransaction
            });
          });
        }
      });
      const mapping = nextTransaction.mapping;
      nextTransaction.steps.forEach((step, index) => {
        var _a3, _b3;
        if (step instanceof RemoveMarkStep) {
          const newStart = mapping.slice(index).map(step.from, -1);
          const newEnd = mapping.slice(index).map(step.to);
          const oldStart = mapping.invert().map(newStart, -1);
          const oldEnd = mapping.invert().map(newEnd);
          const foundBeforeMark = (_a3 = nextTransaction.doc.nodeAt(newStart - 1)) == null ? void 0 : _a3.marks.some((mark) => mark.eq(step.mark));
          const foundAfterMark = (_b3 = nextTransaction.doc.nodeAt(newEnd)) == null ? void 0 : _b3.marks.some((mark) => mark.eq(step.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: step.mark,
            from: step.from,
            to: step.to,
            deletedRange: {
              from: oldStart,
              to: oldEnd
            },
            newRange: {
              from: newStart,
              to: newEnd
            },
            partial: Boolean(foundAfterMark || foundBeforeMark),
            editor: this.editor,
            transaction,
            combinedTransform: nextTransaction
          });
        }
      });
    };
    if ((_c = (_b = (_a = this.editor.options.coreExtensionOptions) == null ? void 0 : _a.delete) == null ? void 0 : _b.async) != null ? _c : true) {
      setTimeout(callback, 0);
    } else {
      callback();
    }
  }
});
var Drop = Extension.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapDrop"),
        props: {
          handleDrop: (_2, e, slice3, moved) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: slice3,
              moved
            });
          }
        }
      })
    ];
  }
});
var Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
var focusEventsPluginKey = new PluginKey("focusEvents");
var FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: focusEventsPluginKey,
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
var Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.undoInputRule(),
      // maybe convert first text block node to default node
      () => commands.command(({ tr }) => {
        const { selection, doc: doc2 } = tr;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;
        const parentIsIsolating = $parentPos.parent.type.spec.isolating;
        const parentPos = $anchor.pos - $anchor.parentOffset;
        const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : Selection.atStart(doc2).from === pos;
        if (!empty2 || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === "paragraph") {
          return false;
        }
        return commands.clearNodes();
      }),
      () => commands.deleteSelection(),
      () => commands.joinBackward(),
      () => commands.selectNodeBackward()
    ]);
    const handleDelete2 = () => this.editor.commands.first(({ commands }) => [
      () => commands.deleteSelection(),
      () => commands.deleteCurrentNode(),
      () => commands.joinForward(),
      () => commands.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands }) => [
      () => commands.newlineInCode(),
      () => commands.createParagraphNear(),
      () => commands.liftEmptyBlock(),
      () => commands.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace2,
      "Mod-Backspace": handleBackspace2,
      "Shift-Backspace": handleBackspace2,
      Delete: handleDelete2,
      "Mod-Delete": handleDelete2,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace2,
      "Alt-Backspace": handleBackspace2,
      "Ctrl-d": handleDelete2,
      "Ctrl-Alt-Backspace": handleDelete2,
      "Alt-Delete": handleDelete2,
      "Alt-d": handleDelete2,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesnât work well
      // with many other commands.
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          if (transactions.some((tr2) => tr2.getMeta("composition"))) {
            return;
          }
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          const ignoreTr = transactions.some((transaction) => transaction.getMeta("preventClearDocument"));
          if (!docChanges || ignoreTr) {
            return;
          }
          const { empty: empty2, from: from3, to: to2 } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from3 === allFrom && to2 === allEnd;
          if (empty2 || !allWasSelected) {
            return;
          }
          const isEmpty2 = isNodeEmpty(newState.doc);
          if (!isEmpty2) {
            return;
          }
          const tr = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr
          });
          const { commands } = new CommandManager({
            editor: this.editor,
            state
          });
          commands.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })
    ];
  }
});
var Paste = Extension.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tiptapPaste"),
        props: {
          handlePaste: (_view, e, slice3) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: slice3
            });
          }
        }
      })
    ];
  }
});
var Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var NodePos = class _NodePos {
  constructor(pos, editor, isBlock = false, node = null) {
    this.currentNode = null;
    this.actualDepth = null;
    this.isBlock = isBlock;
    this.resolvedPos = pos;
    this.editor = editor;
    this.currentNode = node;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var _a;
    return (_a = this.actualDepth) != null ? _a : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(content) {
    let from3 = this.from;
    let to2 = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You canât set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      from3 = this.from + 1;
      to2 = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: from3, to: to2 }, content);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    if (this.isBlock) {
      return this.pos;
    }
    return this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    if (this.isBlock) {
      return this.pos + this.size;
    }
    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0) {
      return null;
    }
    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);
    const $pos = this.resolvedPos.doc.resolve(parentPos);
    return new _NodePos($pos, this.editor);
  }
  get before() {
    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.from - 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get after() {
    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    if ($pos.depth !== this.depth) {
      $pos = this.resolvedPos.doc.resolve(this.to + 3);
    }
    return new _NodePos($pos, this.editor);
  }
  get children() {
    const children = [];
    this.node.content.forEach((node, offset2) => {
      const isBlock = node.isBlock && !node.isTextblock;
      const isNonTextAtom = node.isAtom && !node.isText;
      const targetPos = this.pos + offset2 + (isNonTextAtom ? 0 : 1);
      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {
        return;
      }
      const $pos = this.resolvedPos.doc.resolve(targetPos);
      if (!isBlock && $pos.depth <= this.depth) {
        return;
      }
      const childNodePos = new _NodePos($pos, this.editor, isBlock, isBlock ? node : null);
      if (isBlock) {
        childNodePos.actualDepth = this.depth + 1;
      }
      children.push(new _NodePos($pos, this.editor, isBlock, isBlock ? node : null));
    });
    return children;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  closest(selector, attributes = {}) {
    let node = null;
    let currentNode = this.parent;
    while (currentNode && !node) {
      if (currentNode.node.type.name === selector) {
        if (Object.keys(attributes).length > 0) {
          const nodeAttributes = currentNode.node.attrs;
          const attrKeys = Object.keys(attributes);
          for (let index = 0; index < attrKeys.length; index += 1) {
            const key = attrKeys[index];
            if (nodeAttributes[key] !== attributes[key]) {
              break;
            }
          }
        } else {
          node = currentNode;
        }
      }
      currentNode = currentNode.parent;
    }
    return node;
  }
  querySelector(selector, attributes = {}) {
    return this.querySelectorAll(selector, attributes, true)[0] || null;
  }
  querySelectorAll(selector, attributes = {}, firstItemOnly = false) {
    let nodes2 = [];
    if (!this.children || this.children.length === 0) {
      return nodes2;
    }
    const attrKeys = Object.keys(attributes);
    this.children.forEach((childPos) => {
      if (firstItemOnly && nodes2.length > 0) {
        return;
      }
      if (childPos.node.type.name === selector) {
        const doesAllAttributesMatch = attrKeys.every((key) => attributes[key] === childPos.node.attrs[key]);
        if (doesAllAttributesMatch) {
          nodes2.push(childPos);
        }
      }
      if (firstItemOnly && nodes2.length > 0) {
        return;
      }
      nodes2 = nodes2.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));
    });
    return nodes2;
  }
  setAttribute(attributes) {
    const { tr } = this.editor.state;
    tr.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...attributes
    });
    this.editor.view.dispatch(tr);
  }
};
var style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function createStyleTag(style2, nonce, suffix) {
  const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${""}]`);
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute(`data-tiptap-style${""}`, "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
var Editor$1 = class Editor extends EventEmitter {
  constructor(options2 = {}) {
    super();
    this.css = null;
    this.editorView = null;
    this.isFocused = false;
    this.isInitialized = false;
    this.extensionStorage = {};
    this.instanceId = Math.random().toString(36).slice(2, 9);
    this.options = {
      element: typeof document !== "undefined" ? document.createElement("div") : null,
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      enableContentCheck: false,
      emitContentError: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options2);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("drop", ({ event, slice: slice3, moved }) => this.options.onDrop(event, slice3, moved));
    this.on("paste", ({ event, slice: slice3 }) => this.options.onPaste(event, slice3));
    this.on("delete", this.options.onDelete);
    const initialDoc = this.createDoc();
    const selection = resolveFocusPosition(initialDoc, this.options.autofocus);
    this.editorState = EditorState.create({
      doc: initialDoc,
      schema: this.schema,
      selection: selection || void 0
    });
    if (this.options.element) {
      this.mount(this.options.element);
    }
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(el) {
    if (typeof document === "undefined") {
      throw new Error(
        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`
      );
    }
    this.createView(el);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
      this.isInitialized = true;
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const dom2 = this.editorView.dom;
      if (dom2 == null ? void 0 : dom2.editor) {
        delete dom2.editor;
      }
      this.editorView.destroy();
    }
    this.editorView = null;
    this.isInitialized = false;
    if (this.css) {
      try {
        if (typeof this.css.remove === "function") {
          this.css.remove();
        } else if (this.css.parentNode) {
          this.css.parentNode.removeChild(this.css);
        }
      } catch (error) {
        console.warn("Failed to remove CSS element:", error);
      }
    }
    this.css = null;
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    if (this.options.injectCSS && typeof document !== "undefined") {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(options2 = {}) {
    this.options = {
      ...this.options,
      ...options2
    };
    if (!this.editorView || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
    }
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    if (this.editorView) {
      return this.editorView;
    }
    return new Proxy(
      {
        state: this.editorState,
        updateState: (state) => {
          this.editorState = state;
        },
        dispatch: (tr) => {
          this.editorState = this.state.apply(tr);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: false,
        dragging: null,
        editable: true,
        isDestroyed: false
      },
      {
        get: (obj, key) => {
          if (key === "state") {
            return this.editorState;
          }
          if (key in obj) {
            return Reflect.get(obj, key);
          }
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${key}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    if (this.editorView) {
      this.editorState = this.view.state;
    }
    return this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(plugin, handlePlugins) {
    const plugins = isFunction$2(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
    return state;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(nameOrPluginKeyToRemove) {
    if (this.isDestroyed) {
      return void 0;
    }
    const prevPlugins = this.state.plugins;
    let plugins = prevPlugins;
    [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey) => {
      const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
      plugins = plugins.filter((plugin) => !plugin.key.startsWith(name));
    });
    if (prevPlugins.length === plugins.length) {
      return void 0;
    }
    const state = this.state.reconfigure({
      plugins
    });
    this.view.updateState(state);
    return state;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var _a, _b;
    const coreExtensions = this.options.enableCoreExtensions ? [
      Editable,
      ClipboardTextSerializer.configure({
        blockSeparator: (_b = (_a = this.options.coreExtensionOptions) == null ? void 0 : _a.clipboardTextSerializer) == null ? void 0 : _b.blockSeparator
      }),
      Commands,
      FocusEvents,
      Keymap,
      Tabindex,
      Drop,
      Paste,
      Delete
    ].filter((ext) => {
      if (typeof this.options.enableCoreExtensions === "object") {
        return this.options.enableCoreExtensions[ext.name] !== false;
      }
      return true;
    }) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension == null ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let doc2;
    try {
      doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message)) {
        throw e;
      }
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          if ("collaboration" in this.storage && typeof this.storage.collaboration === "object" && this.storage.collaboration) {
            this.storage.collaboration.isDisabled = true;
          }
          this.options.extensions = this.options.extensions.filter((extension) => extension.name !== "collaboration");
          this.createExtensionManager();
        }
      });
      doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: false
      });
    }
    return doc2;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(element) {
    var _a;
    this.editorView = new EditorView(element, {
      ...this.options.editorProps,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...(_a = this.options.editorProps) == null ? void 0 : _a.attributes
      },
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: this.editorState
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    this.prependClass();
    this.injectCSS();
    const dom2 = this.view.dom;
    dom2.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    if (this.view.isDestroyed) {
      return;
    }
    this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `tiptap ${this.view.dom.className}`;
  }
  captureTransaction(fn) {
    this.isCapturingTransaction = true;
    fn();
    this.isCapturingTransaction = false;
    const tr = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(transaction) {
    if (this.view.isDestroyed) {
      return;
    }
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) == null ? void 0 : _a.step(step);
      });
      return;
    }
    const { state, transactions } = this.state.applyTransaction(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    const rootTrWasApplied = transactions.includes(transaction);
    const prevState = this.state;
    this.emit("beforeTransaction", {
      editor: this,
      transaction,
      nextState: state
    });
    if (!rootTrWasApplied) {
      return;
    }
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction,
      appendedTransactions: transactions.slice(1)
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const mostRecentFocusTr = transactions.findLast((tr) => tr.getMeta("focus") || tr.getMeta("blur"));
    const focus2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("focus");
    const blur2 = mostRecentFocusTr == null ? void 0 : mostRecentFocusTr.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        transaction: mostRecentFocusTr
      });
    }
    if (transaction.getMeta("preventUpdate") || !transactions.some((tr) => tr.docChanged) || prevState.doc.eq(state.doc)) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction,
      appendedTransactions: transactions.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(options2) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options2 || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...getTextSerializersFromSchema(this.schema),
        ...textSerializers
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy");
    this.unmount();
    this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var _a, _b;
    return (_b = (_a = this.editorView) == null ? void 0 : _a.isDestroyed) != null ? _b : true;
  }
  $node(selector, attributes) {
    var _a;
    return ((_a = this.$doc) == null ? void 0 : _a.querySelector(selector, attributes)) || null;
  }
  $nodes(selector, attributes) {
    var _a;
    return ((_a = this.$doc) == null ? void 0 : _a.querySelectorAll(selector, attributes)) || null;
  }
  $pos(pos) {
    const $pos = this.state.doc.resolve(pos);
    return new NodePos($pos, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range2, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range2.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range2.from, range2.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range2.to) {
          tr.delete(textEnd, range2.to);
        }
        if (textStart > range2.from) {
          tr.delete(range2.from + startSpaces, textStart);
        }
        const markEnd = range2.from + startSpaces + captureGroup.length;
        tr.addMark(range2.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range2, match }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const { tr } = state;
      const start = range2.from;
      let end = range2.to;
      const newNode = config.type.create(attributes);
      if (match[1]) {
        const offset2 = match[0].lastIndexOf(match[1]);
        let matchStart = start + offset2;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        const lastChar = match[0][match[0].length - 1];
        tr.insertText(lastChar, start + match[0].length - 1);
        tr.replaceWith(matchStart, end, newNode);
      } else if (match[0]) {
        const insertionStart = config.type.isInline ? start : start - 1;
        tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));
      }
      tr.scrollIntoView();
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range2, match }) => {
      const $start = state.doc.resolve(range2.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range2.from, range2.to).setBlockType(range2.from, range2.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range2, match, chain: chain2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match) || {};
      const tr = state.tr.delete(range2.from, range2.to);
      const $start = tr.doc.resolve(range2.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        const { selection, storedMarks } = state;
        const { splittableMarks } = config.editor.extensionManager;
        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
          tr.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        const nodeType = config.type.name === "bulletList" || config.type.name === "orderedList" ? "listItem" : "taskList";
        chain2().updateAttributes(nodeType, attributes).run();
      }
      const before2 = tr.doc.resolve(range2.from - 1).nodeBefore;
      if (before2 && before2.type === config.type && canJoin(tr.doc, range2.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before2))) {
        tr.join(range2.from - 1);
      }
    }
  });
}
function canInsertNode(state, nodeType) {
  const { selection } = state;
  const { $from } = selection;
  if (selection instanceof NodeSelection) {
    const index = $from.index();
    const parent = $from.parent;
    return parent.canReplaceWith(index, index + 1, nodeType);
  }
  let depth = $from.depth;
  while (depth >= 0) {
    const index = $from.index(depth);
    const parent = $from.node(depth);
    const match = parent.contentMatchAt(index);
    if (match.matchType(nodeType)) {
      return true;
    }
    depth -= 1;
  }
  return false;
}
function updateMarkViewAttributes(checkMark, editor, attrs = {}) {
  const { state } = editor;
  const { doc: doc2, tr } = state;
  const thisMark = checkMark;
  doc2.descendants((node, pos) => {
    const from3 = tr.mapping.map(pos);
    const to2 = tr.mapping.map(pos) + node.nodeSize;
    let foundMark = null;
    node.marks.forEach((mark) => {
      if (mark !== thisMark) {
        return false;
      }
      foundMark = mark;
    });
    if (!foundMark) {
      return;
    }
    let needsUpdate = false;
    Object.keys(attrs).forEach((k) => {
      if (attrs[k] !== foundMark.attrs[k]) {
        needsUpdate = true;
      }
    });
    if (needsUpdate) {
      const updatedMark = checkMark.type.create({
        ...checkMark.attrs,
        ...attrs
      });
      tr.removeMark(from3, to2, checkMark.type);
      tr.addMark(from3, to2, updatedMark);
    }
  });
  if (tr.docChanged) {
    editor.view.dispatch(tr);
  }
}
var Node3 = class _Node extends Extendable {
  constructor() {
    super(...arguments);
    this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(config = {}) {
    const resolvedConfig = typeof config === "function" ? config() : config;
    return new _Node(resolvedConfig);
  }
  configure(options2) {
    return super.configure(options2);
  }
  extend(extendedConfig) {
    const resolvedConfig = typeof extendedConfig === "function" ? extendedConfig() : extendedConfig;
    return super.extend(resolvedConfig);
  }
};
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range: range2, match, pasteEvent }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match[match.length - 1];
      const fullMatch = match[0];
      let markEnd = range2.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range2.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range2.from, range2.to, state.doc).filter((item) => {
          const excluded = item.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item.mark.type);
        }).filter((item) => item.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range2.to) {
          tr.delete(textEnd, range2.to);
        }
        if (textStart > range2.from) {
          tr.delete(range2.from + startSpaces, textStart);
        }
        markEnd = range2.from + startSpaces + captureGroup.length;
        tr.addMark(range2.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function useDebouncedRef(value) {
  return customRef((track, trigger) => {
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            trigger();
          });
        });
      }
    };
  });
}
var Editor2 = class extends Editor$1 {
  constructor(options2 = {}) {
    super(options2);
    this.contentComponent = null;
    this.appContext = null;
    this.reactiveState = useDebouncedRef(this.view.state);
    this.reactiveExtensionStorage = useDebouncedRef(this.extensionStorage);
    this.on("beforeTransaction", ({ nextState }) => {
      this.reactiveState.value = nextState;
      this.reactiveExtensionStorage.value = this.extensionStorage;
    });
    return markRaw(this);
  }
  get state() {
    return this.reactiveState ? this.reactiveState.value : this.view.state;
  }
  get storage() {
    return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage;
  }
  /**
   * Register a ProseMirror plugin.
   */
  registerPlugin(plugin, handlePlugins) {
    const nextState = super.registerPlugin(plugin, handlePlugins);
    if (this.reactiveState) {
      this.reactiveState.value = nextState;
    }
    return nextState;
  }
  /**
   * Unregister a ProseMirror plugin.
   */
  unregisterPlugin(nameOrPluginKey) {
    const nextState = super.unregisterPlugin(nameOrPluginKey);
    if (this.reactiveState && nextState) {
      this.reactiveState.value = nextState;
    }
    return nextState;
  }
};
var EditorContent = defineComponent({
  name: "EditorContent",
  props: {
    editor: {
      default: null,
      type: Object
    }
  },
  setup(props2) {
    const rootEl = ref();
    const instance = getCurrentInstance();
    watchEffect(() => {
      const editor = props2.editor;
      if (editor && editor.options.element && rootEl.value) {
        nextTick(() => {
          var _a;
          if (!rootEl.value || !((_a = editor.options.element) == null ? void 0 : _a.firstChild)) {
            return;
          }
          const element = unref(rootEl.value);
          rootEl.value.append(...editor.options.element.childNodes);
          editor.contentComponent = instance.ctx._;
          if (instance) {
            editor.appContext = {
              ...instance.appContext,
              // Vue internally uses prototype chain to forward/shadow injects across the entire component chain
              // so don't use object spread operator or 'Object.assign' and just set `provides` as is on editor's appContext
              // @ts-expect-error forward instance's 'provides' into appContext
              provides: instance.provides
            };
          }
          editor.setOptions({
            element
          });
          editor.createNodeViews();
        });
      }
    });
    onBeforeUnmount(() => {
      const editor = props2.editor;
      if (!editor) {
        return;
      }
      editor.contentComponent = null;
      editor.appContext = null;
    });
    return { rootEl };
  },
  render() {
    return h$1("div", {
      ref: (el) => {
        this.rootEl = el;
      }
    });
  }
});
var useEditor = (options2 = {}) => {
  const editor = shallowRef();
  onMounted(() => {
    editor.value = new Editor2(options2);
  });
  onBeforeUnmount(() => {
    var _a, _b, _c;
    const nodes2 = (_a = editor.value) == null ? void 0 : _a.options.element;
    const newEl = nodes2 == null ? void 0 : nodes2.cloneNode(true);
    (_b = nodes2 == null ? void 0 : nodes2.parentNode) == null ? void 0 : _b.replaceChild(newEl, nodes2);
    (_c = editor.value) == null ? void 0 : _c.destroy();
  });
  return editor;
};
var h = (tag, attributes) => {
  if (tag === "slot") {
    return 0;
  }
  if (tag instanceof Function) {
    return tag(attributes);
  }
  const { children, ...rest2 } = attributes != null ? attributes : {};
  if (tag === "svg") {
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  }
  return [tag, rest2, children];
};
var inputRegex$5 = /^\s*>\s$/;
var Blockquote = Node3.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes }) {
    return /* @__PURE__ */ h("blockquote", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ h("slot", {}) });
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands }) => {
        return commands.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands }) => {
        return commands.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands }) => {
        return commands.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$5,
        type: this.type
      })
    ];
  }
});
var starInputRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/;
var starPasteRegex$1 = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g;
var underscoreInputRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/;
var underscorePasteRegex$1 = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g;
var Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node) => node.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return /* @__PURE__ */ h("strong", { ...mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), children: /* @__PURE__ */ h("slot", {}) });
  },
  addCommands() {
    return {
      setBold: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleBold: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetBold: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex$1,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })
    ];
  }
});
var inputRegex$4 = /(^|[^`])`([^`]+)`(?!`)/;
var pasteRegex$2 = /(^|[^`])`([^`]+)`(?!`)/g;
var Code = Mark2.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: true,
  exitable: true,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["code", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setCode: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleCode: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetCode: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$4,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$2,
        type: this.type
      })
    ];
  }
});
var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = Node3.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      defaultLanguage: null,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: true,
  defining: true,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (element) => {
          var _a;
          const { languageClassPrefix } = this.options;
          const classNames = [...((_a = element.firstElementChild) == null ? void 0 : _a.classList) || []];
          const languages = classNames.filter((className) => className.startsWith(languageClassPrefix)).map((className) => className.replace(languageClassPrefix, ""));
          const language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "pre",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),
      [
        "code",
        {
          class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
        },
        0
      ]
    ];
  },
  addCommands() {
    return {
      setCodeBlock: (attributes) => ({ commands }) => {
        return commands.setNode(this.name, attributes);
      },
      toggleCodeBlock: (attributes) => ({ commands }) => {
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: empty2, $anchor } = this.editor.state.selection;
        const isAtStart = $anchor.pos === 1;
        if (!empty2 || $anchor.parent.type.name !== this.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return this.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: ({ editor }) => {
        if (!this.options.exitOnTripleEnter) {
          return false;
        }
        const { state } = editor;
        const { selection } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        const endsWithDoubleNewline = $from.parent.textContent.endsWith("\n\n");
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(({ tr }) => {
          tr.delete($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor }) => {
        if (!this.options.exitOnArrowDown) {
          return false;
        }
        const { state } = editor;
        const { selection, doc: doc2 } = state;
        const { $from, empty: empty2 } = selection;
        if (!empty2 || $from.parent.type !== this.type) {
          return false;
        }
        const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        const after2 = $from.after();
        if (after2 === void 0) {
          return false;
        }
        const nodeAfter = doc2.nodeAt(after2);
        if (nodeAfter) {
          return editor.commands.command(({ tr }) => {
            tr.setSelection(Selection.near(doc2.resolve(after2)));
            return true;
          });
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      textblockTypeInputRule({
        find: backtickInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      }),
      textblockTypeInputRule({
        find: tildeInputRegex,
        type: this.type,
        getAttributes: (match) => ({
          language: match[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Plugin({
        key: new PluginKey("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (view, event) => {
            if (!event.clipboardData) {
              return false;
            }
            if (this.editor.isActive(this.type.name)) {
              return false;
            }
            const text = event.clipboardData.getData("text/plain");
            const vscode = event.clipboardData.getData("vscode-editor-data");
            const vscodeData = vscode ? JSON.parse(vscode) : void 0;
            const language = vscodeData == null ? void 0 : vscodeData.mode;
            if (!text || !language) {
              return false;
            }
            const { tr, schema } = view.state;
            const textNode = schema.text(text.replace(/\r\n?/g, "\n"));
            tr.replaceSelectionWith(this.type.create({ language }, textNode));
            if (tr.selection.$from.parent.type !== this.type) {
              tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
            }
            tr.setMeta("paste", true);
            view.dispatch(tr);
            return true;
          }
        }
      })
    ];
  }
});
var Document = Node3.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
var HardBreak = Node3.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  linebreakReplacement: true,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands, chain: chain2, state, editor }) => {
        return commands.first([
          () => commands.exitCode(),
          () => commands.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain2().insertContent({ type: this.name }).command(({ tr, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
var Heading = Node3.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
var HorizontalRule = Node3.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["hr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: chain2, state }) => {
        if (!canInsertNode(state, state.schema.nodes[this.name])) {
          return false;
        }
        const { selection } = state;
        const { $to: $originTo } = selection;
        const currentChain = chain2();
        if (isNodeSelection(selection)) {
          currentChain.insertContentAt($originTo.pos, {
            type: this.name
          });
        } else {
          currentChain.insertContent({ type: this.name });
        }
        return currentChain.command(({ tr, dispatch }) => {
          var _a;
          if (dispatch) {
            const { $to } = tr.selection;
            const posAfter = $to.end();
            if ($to.nodeAfter) {
              if ($to.nodeAfter.isTextblock) {
                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));
              } else if ($to.nodeAfter.isBlock) {
                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));
              } else {
                tr.setSelection(TextSelection.create(tr.doc, $to.pos));
              }
            } else {
              const node = (_a = $to.parent.type.contentMatch.defaultType) == null ? void 0 : _a.create();
              if (node) {
                tr.insert(posAfter, node);
                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));
              }
            }
            tr.scrollIntoView();
          }
          return true;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: /^(?:---|â-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
});
var starInputRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/;
var starPasteRegex = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g;
var underscoreInputRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/;
var underscorePasteRegex = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g;
var Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node) => node.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (mark) => mark.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleItalic: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
var UNICODE_WHITESPACE_PATTERN = "[\0- Â áá â-\u2029âã]";
var UNICODE_WHITESPACE_REGEX = new RegExp(UNICODE_WHITESPACE_PATTERN);
var UNICODE_WHITESPACE_REGEX_END = new RegExp(`${UNICODE_WHITESPACE_PATTERN}$`);
var UNICODE_WHITESPACE_REGEX_GLOBAL = new RegExp(UNICODE_WHITESPACE_PATTERN, "g");
function isValidLinkStructure(tokens2) {
  if (tokens2.length === 1) {
    return tokens2[0].isLink;
  }
  if (tokens2.length === 3 && tokens2[1].isLink) {
    return ["()", "[]"].includes(tokens2[0].value + tokens2[2].value);
  }
  return false;
}
function autolink(options2) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const changes = getChangedRanges(transform);
      changes.forEach(({ newRange }) => {
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node) => node.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(
            textBlock.pos,
            textBlock.pos + textBlock.node.nodeSize,
            void 0,
            " "
          );
        } else if (nodesInChangedRanges.length) {
          const endText = newState.doc.textBetween(newRange.from, newRange.to, " ", " ");
          if (!UNICODE_WHITESPACE_REGEX_END.test(endText)) {
            return;
          }
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(UNICODE_WHITESPACE_REGEX).filter(Boolean);
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          const linksBeforeSpace = tokenize(lastWordBeforeSpace).map((t) => t.toObject(options2.defaultProtocol));
          if (!isValidLinkStructure(linksBeforeSpace)) {
            return false;
          }
          linksBeforeSpace.filter((link) => link.isLink).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).filter((link) => {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          }).filter((link) => options2.validate(link.value)).filter((link) => options2.shouldAutoLink(link.value)).forEach((link) => {
            if (getMarksBetween(link.from, link.to, newState.doc).some((item) => item.mark.type === options2.type)) {
              return;
            }
            tr.addMark(
              link.from,
              link.to,
              options2.type.create({
                href: link.href
              })
            );
          });
        }
      });
      if (!tr.steps.length) {
        return;
      }
      return tr;
    }
  });
}
function clickHandler(options2) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a, _b;
        if (event.button !== 0) {
          return false;
        }
        if (!view.editable) {
          return false;
        }
        let link = null;
        if (event.target instanceof HTMLAnchorElement) {
          link = event.target;
        } else {
          let a = event.target;
          const els = [];
          while (a.nodeName !== "DIV") {
            els.push(a);
            a = a.parentNode;
          }
          link = els.find((value) => value.nodeName === "A");
        }
        if (!link) {
          return false;
        }
        const attrs = getAttributes(view.state, options2.type.name);
        const href = (_a = link == null ? void 0 : link.href) != null ? _a : attrs.href;
        const target = (_b = link == null ? void 0 : link.target) != null ? _b : attrs.target;
        if (options2.enableClickSelection) {
          options2.editor.commands.extendMarkRange(options2.type.name);
        }
        if (link && href) {
          window.open(href, target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options2) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice3) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent = "";
        slice3.content.forEach((node) => {
          textContent += node.textContent;
        });
        const link = find$1(textContent, { defaultProtocol: options2.defaultProtocol }).find(
          (item) => item.isLink && item.value === textContent
        );
        if (!textContent || !link) {
          return false;
        }
        return options2.editor.commands.setMark(options2.type, {
          href: link.href
        });
      }
    }
  });
}
function isAllowedUri(uri, protocols) {
  const allowedProtocols = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(UNICODE_WHITESPACE_REGEX_GLOBAL, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  exitable: true,
  onCreate() {
    if (this.options.validate && !this.options.shouldAutoLink) {
      this.options.shouldAutoLink = this.options.validate;
      console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.");
    }
    this.options.protocols.forEach((protocol) => {
      if (typeof protocol === "string") {
        registerCustomProtocol(protocol);
        return;
      }
      registerCustomProtocol(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      enableClickSelection: false,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (url, ctx) => !!isAllowedUri(url, ctx.protocols),
      validate: (url) => !!url,
      shouldAutoLink: (url) => !!url
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(element) {
          return element.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (dom2) => {
          const href = dom2.getAttribute("href");
          if (!href || !this.options.isAllowedUri(href, {
            defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          })) {
            return false;
          }
          return null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    if (!this.options.isAllowedUri(HTMLAttributes.href, {
      defaultValidate: (href) => !!isAllowedUri(href, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    })) {
      return ["a", mergeAttributes(this.options.HTMLAttributes, { ...HTMLAttributes, href: "" }), 0];
    }
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes;
        if (!this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain: chain2 }) => {
        const { href } = attributes || {};
        if (href && !this.options.isAllowedUri(href, {
          defaultValidate: (url) => !!isAllowedUri(url, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        })) {
          return false;
        }
        return chain2().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain: chain2 }) => {
        return chain2().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text) => {
          const foundLinks = [];
          if (text) {
            const { protocols, defaultProtocol } = this.options;
            const links = find$1(text).filter(
              (item) => item.isLink && this.options.isAllowedUri(item.value, {
                defaultValidate: (href) => !!isAllowedUri(href, protocols),
                protocols,
                defaultProtocol
              })
            );
            if (links.length) {
              links.forEach(
                (link) => foundLinks.push({
                  text: link.value,
                  data: {
                    href: link.href
                  },
                  index: link.start
                })
              );
            }
          }
          return foundLinks;
        },
        type: this.type,
        getAttributes: (match) => {
          var _a;
          return {
            href: (_a = match.data) == null ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins = [];
    const { protocols, defaultProtocol } = this.options;
    if (this.options.autolink) {
      plugins.push(
        autolink({
          type: this.type,
          defaultProtocol: this.options.defaultProtocol,
          validate: (url) => this.options.isAllowedUri(url, {
            defaultValidate: (href) => !!isAllowedUri(href, protocols),
            protocols,
            defaultProtocol
          }),
          shouldAutoLink: this.options.shouldAutoLink
        })
      );
    }
    if (this.options.openOnClick === true) {
      plugins.push(
        clickHandler({
          type: this.type,
          editor: this.editor,
          enableClickSelection: this.options.enableClickSelection
        })
      );
    }
    if (this.options.linkOnPaste) {
      plugins.push(
        pasteHandler({
          editor: this.editor,
          defaultProtocol: this.options.defaultProtocol,
          type: this.type
        })
      );
    }
    return plugins;
  }
});
var index_default$8 = Link;
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var ListItemName = "listItem";
var TextStyleName = "textStyle";
var bulletListInputRegex = /^\s*([-+*])\s$/;
var BulletList = Node3.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();
        }
        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: bulletListInputRegex,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: bulletListInputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: () => {
          return this.editor.getAttributes(TextStyleName);
        },
        editor: this.editor
      });
    }
    return [inputRule];
  }
});
var ListItem = Node3.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
var listHelpers_exports = {};
__export(listHelpers_exports, {
  findListItemPos: () => findListItemPos,
  getNextListDepth: () => getNextListDepth,
  handleBackspace: () => handleBackspace,
  handleDelete: () => handleDelete,
  hasListBefore: () => hasListBefore,
  hasListItemAfter: () => hasListItemAfter,
  hasListItemBefore: () => hasListItemBefore,
  listItemHasSubList: () => listItemHasSubList,
  nextListIsDeeper: () => nextListIsDeeper,
  nextListIsHigher: () => nextListIsHigher
});
var findListItemPos = (typeOrName, state) => {
  const { $from } = state.selection;
  const nodeType = getNodeType(typeOrName, state.schema);
  let currentNode = null;
  let currentDepth = $from.depth;
  let currentPos = $from.pos;
  let targetDepth = null;
  while (currentDepth > 0 && targetDepth === null) {
    currentNode = $from.node(currentDepth);
    if (currentNode.type === nodeType) {
      targetDepth = currentDepth;
    } else {
      currentDepth -= 1;
      currentPos -= 1;
    }
  }
  if (targetDepth === null) {
    return null;
  }
  return { $pos: state.doc.resolve(currentPos), depth: targetDepth };
};
var getNextListDepth = (typeOrName, state) => {
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos) {
    return false;
  }
  const [, depth] = getNodeAtPosition(state, typeOrName, listItemPos.$pos.pos + 4);
  return depth;
};
var hasListBefore = (editorState, name, parentListTypes) => {
  const { $anchor } = editorState.selection;
  const previousNodePos = Math.max(0, $anchor.pos - 2);
  const previousNode = editorState.doc.resolve(previousNodePos).node();
  if (!previousNode || !parentListTypes.includes(previousNode.type.name)) {
    return false;
  }
  return true;
};
var hasListItemBefore = (typeOrName, state) => {
  var _a;
  const { $anchor } = state.selection;
  const $targetPos = state.doc.resolve($anchor.pos - 2);
  if ($targetPos.index() === 0) {
    return false;
  }
  if (((_a = $targetPos.nodeBefore) == null ? void 0 : _a.type.name) !== typeOrName) {
    return false;
  }
  return true;
};
var listItemHasSubList = (typeOrName, state, node) => {
  if (!node) {
    return false;
  }
  const nodeType = getNodeType(typeOrName, state.schema);
  let hasSubList = false;
  node.descendants((child) => {
    if (child.type === nodeType) {
      hasSubList = true;
    }
  });
  return hasSubList;
};
var handleBackspace = (editor, name, parentListTypes) => {
  if (editor.commands.undoInputRule()) {
    return true;
  }
  if (editor.state.selection.from !== editor.state.selection.to) {
    return false;
  }
  if (!isNodeActive(editor.state, name) && hasListBefore(editor.state, name, parentListTypes)) {
    const { $anchor } = editor.state.selection;
    const $listPos = editor.state.doc.resolve($anchor.before() - 1);
    const listDescendants = [];
    $listPos.node().descendants((node, pos) => {
      if (node.type.name === name) {
        listDescendants.push({ node, pos });
      }
    });
    const lastItem = listDescendants.at(-1);
    if (!lastItem) {
      return false;
    }
    const $lastItemPos = editor.state.doc.resolve($listPos.start() + lastItem.pos + 1);
    return editor.chain().cut({ from: $anchor.start() - 1, to: $anchor.end() + 1 }, $lastItemPos.end()).joinForward().run();
  }
  if (!isNodeActive(editor.state, name)) {
    return false;
  }
  if (!isAtStartOfNode(editor.state)) {
    return false;
  }
  const listItemPos = findListItemPos(name, editor.state);
  if (!listItemPos) {
    return false;
  }
  const $prev = editor.state.doc.resolve(listItemPos.$pos.pos - 2);
  const prevNode = $prev.node(listItemPos.depth);
  const previousListItemHasSubList = listItemHasSubList(name, editor.state, prevNode);
  if (hasListItemBefore(name, editor.state) && !previousListItemHasSubList) {
    return editor.commands.joinItemBackward();
  }
  return editor.chain().liftListItem(name).run();
};
var nextListIsDeeper = (typeOrName, state) => {
  const listDepth = getNextListDepth(typeOrName, state);
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos || !listDepth) {
    return false;
  }
  if (listDepth > listItemPos.depth) {
    return true;
  }
  return false;
};
var nextListIsHigher = (typeOrName, state) => {
  const listDepth = getNextListDepth(typeOrName, state);
  const listItemPos = findListItemPos(typeOrName, state);
  if (!listItemPos || !listDepth) {
    return false;
  }
  if (listDepth < listItemPos.depth) {
    return true;
  }
  return false;
};
var handleDelete = (editor, name) => {
  if (!isNodeActive(editor.state, name)) {
    return false;
  }
  if (!isAtEndOfNode(editor.state, name)) {
    return false;
  }
  const { selection } = editor.state;
  const { $from, $to } = selection;
  if (!selection.empty && $from.sameParent($to)) {
    return false;
  }
  if (nextListIsDeeper(name, editor.state)) {
    return editor.chain().focus(editor.state.selection.from + 4).lift(name).joinBackward().run();
  }
  if (nextListIsHigher(name, editor.state)) {
    return editor.chain().joinForward().joinBackward().run();
  }
  return editor.commands.joinItemForward();
};
var hasListItemAfter = (typeOrName, state) => {
  var _a;
  const { $anchor } = state.selection;
  const $targetPos = state.doc.resolve($anchor.pos - $anchor.parentOffset - 2);
  if ($targetPos.index() === $targetPos.parent.childCount - 1) {
    return false;
  }
  if (((_a = $targetPos.nodeAfter) == null ? void 0 : _a.type.name) !== typeOrName) {
    return false;
  }
  return true;
};
var ListKeymap = Extension.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleDelete(editor, itemName)) {
            handled = true;
          }
        });
        return handled;
      },
      "Mod-Delete": ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleDelete(editor, itemName)) {
            handled = true;
          }
        });
        return handled;
      },
      Backspace: ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleBackspace(editor, itemName, wrapperNames)) {
            handled = true;
          }
        });
        return handled;
      },
      "Mod-Backspace": ({ editor }) => {
        let handled = false;
        this.options.listTypes.forEach(({ itemName, wrapperNames }) => {
          if (editor.state.schema.nodes[itemName] === void 0) {
            return;
          }
          if (handleBackspace(editor, itemName, wrapperNames)) {
            handled = true;
          }
        });
        return handled;
      }
    };
  }
});
var ListItemName2 = "listItem";
var TextStyleName2 = "textStyle";
var orderedListInputRegex = /^(\d+)\.\s$/;
var OrderedList = Node3.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      },
      type: {
        default: null,
        parseHTML: (element) => element.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start, ...attributesWithoutStart } = HTMLAttributes;
    return start === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands, chain: chain2 }) => {
        if (this.options.keepAttributes) {
          return chain2().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName2, this.editor.getAttributes(TextStyleName2)).run();
        }
        return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let inputRule = wrappingInputRule({
      find: orderedListInputRegex,
      type: this.type,
      getAttributes: (match) => ({ start: +match[1] }),
      joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1]
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = wrappingInputRule({
        find: orderedListInputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: (match) => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName2) }),
        joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],
        editor: this.editor
      });
    }
    return [inputRule];
  }
});
var inputRegex$3 = /^\s*(\[([( |x])?\])\s$/;
var TaskItem = Node3.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: false,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: true,
  addAttributes() {
    return {
      checked: {
        default: false,
        keepOnSplit: false,
        parseHTML: (element) => {
          const dataChecked = element.getAttribute("data-checked");
          return dataChecked === "" || dataChecked === "true";
        },
        renderHTML: (attributes) => ({
          "data-checked": attributes.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node, HTMLAttributes }) {
    return [
      "li",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: node.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  addKeyboardShortcuts() {
    const shortcuts = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    if (!this.options.nested) {
      return shortcuts;
    }
    return {
      ...shortcuts,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    };
  },
  addNodeView() {
    return ({ node, HTMLAttributes, getPos, editor }) => {
      const listItem = document.createElement("li");
      const checkboxWrapper = document.createElement("label");
      const checkboxStyler = document.createElement("span");
      const checkbox = document.createElement("input");
      const content = document.createElement("div");
      const updateA11Y = (currentNode) => {
        var _a, _b;
        checkbox.ariaLabel = ((_b = (_a = this.options.a11y) == null ? void 0 : _a.checkboxLabel) == null ? void 0 : _b.call(_a, currentNode, checkbox.checked)) || `Task item checkbox for ${currentNode.textContent || "empty task item"}`;
      };
      updateA11Y(node);
      checkboxWrapper.contentEditable = "false";
      checkbox.type = "checkbox";
      checkbox.addEventListener("mousedown", (event) => event.preventDefault());
      checkbox.addEventListener("change", (event) => {
        if (!editor.isEditable && !this.options.onReadOnlyChecked) {
          checkbox.checked = !checkbox.checked;
          return;
        }
        const { checked } = event.target;
        if (editor.isEditable && typeof getPos === "function") {
          editor.chain().focus(void 0, { scrollIntoView: false }).command(({ tr }) => {
            const position = getPos();
            if (typeof position !== "number") {
              return false;
            }
            const currentNode = tr.doc.nodeAt(position);
            tr.setNodeMarkup(position, void 0, {
              ...currentNode == null ? void 0 : currentNode.attrs,
              checked
            });
            return true;
          }).run();
        }
        if (!editor.isEditable && this.options.onReadOnlyChecked) {
          if (!this.options.onReadOnlyChecked(node, checked)) {
            checkbox.checked = !checkbox.checked;
          }
        }
      });
      Object.entries(this.options.HTMLAttributes).forEach(([key, value]) => {
        listItem.setAttribute(key, value);
      });
      listItem.dataset.checked = node.attrs.checked;
      checkbox.checked = node.attrs.checked;
      checkboxWrapper.append(checkbox, checkboxStyler);
      listItem.append(checkboxWrapper, content);
      Object.entries(HTMLAttributes).forEach(([key, value]) => {
        listItem.setAttribute(key, value);
      });
      return {
        dom: listItem,
        contentDOM: content,
        update: (updatedNode) => {
          if (updatedNode.type !== this.type) {
            return false;
          }
          listItem.dataset.checked = updatedNode.attrs.checked;
          checkbox.checked = updatedNode.attrs.checked;
          updateA11Y(updatedNode);
          return true;
        }
      };
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$3,
        type: this.type,
        getAttributes: (match) => ({
          checked: match[match.length - 1] === "x"
        })
      })
    ];
  }
});
var TaskList = Node3.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, { "data-type": this.name }), 0];
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands }) => {
        return commands.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
Extension.create({
  name: "listKit",
  addExtensions() {
    const extensions = [];
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.listKeymap !== false) {
      extensions.push(ListKeymap.configure(this.options.listKeymap));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.taskItem !== false) {
      extensions.push(TaskItem.configure(this.options.taskItem));
    }
    if (this.options.taskList !== false) {
      extensions.push(TaskList.configure(this.options.taskList));
    }
    return extensions;
  }
});
var Paragraph = Node3.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands }) => {
        return commands.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
var inputRegex$2 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/;
var pasteRegex$1 = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g;
var Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("line-through") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["s", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setStrike: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleStrike: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetStrike: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$2,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex$1,
        type: this.type
      })
    ];
  }
});
var Text = Node3.create({
  name: "text",
  group: "inline"
});
var Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands }) => {
        return commands.setMark(this.name);
      },
      toggleUnderline: () => ({ commands }) => {
        return commands.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
var index_default$7 = Underline;
function dropCursor(options2 = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options2);
    }
  });
}
class DropCursorView {
  constructor(editorView, options2) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options2.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options2.color === false ? void 0 : options2.color || "black";
    this.class = options2.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before2 = $pos.nodeBefore, after2 = $pos.nodeAfter;
      if (before2 || after2) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before2 ? before2.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top = before2 ? nodeRect.bottom : nodeRect.top;
          if (before2 && after2)
            top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
class GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc2, mapping) {
    let $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc2.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
}
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.index(d), parent = $pos.node(d);
    if (index == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before2 = parent.child(index - 1); ; before2 = before2.lastChild) {
      if (before2.childCount == 0 && !before2.inlineContent || before2.isAtom || before2.type.spec.isolating)
        return true;
      if (before2.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index = $pos.indexAfter(d), parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after2 = parent.child(index); ; after2 = after2.firstChild) {
      if (after2.childCount == 0 && !after2.inlineContent || after2.isAtom || after2.type.spec.isolating)
        return true;
      if (after2.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown: handleKeyDown$1,
      handleDOMEvents: { beforeinput }
    }
  });
}
const handleKeyDown$1 = keydownHandler({
  "ArrowLeft": arrow$1("horiz", -1),
  "ArrowRight": arrow$1("horiz", 1),
  "ArrowUp": arrow$1("vert", -1),
  "ArrowDown": arrow$1("vert", 1)
});
function arrow$1(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from3, to2) {
  if (from3 === void 0) from3 = 0;
  if (to2 === void 0) to2 = this.length;
  if (from3 >= to2) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from3), Math.min(this.length, to2));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from3, to2) {
  if (from3 === void 0) from3 = 0;
  if (to2 === void 0) to2 = this.length;
  if (from3 <= to2) {
    this.forEachInner(f, from3, to2, 0);
  } else {
    this.forEachInvertedInner(f, from3, to2, 0);
  }
};
RopeSequence.prototype.map = function map(f, from3, to2) {
  if (from3 === void 0) from3 = 0;
  if (to2 === void 0) to2 = this.length;
  var result2 = [];
  this.forEach(function(elt, i) {
    return result2.push(f(elt, i));
  }, from3, to2);
  return result2;
};
RopeSequence.from = function from2(values2) {
  if (values2 instanceof RopeSequence) {
    return values2;
  }
  return values2 && values2.length ? new Leaf(values2) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ (function(RopeSequence3) {
  function Leaf2(values2) {
    RopeSequence3.call(this);
    this.values = values2;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten2() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from3, to2) {
    if (from3 == 0 && to2 == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from3, to2));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from3, to2, start) {
    for (var i = from3; i < to2; i++) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from3, to2, start) {
    for (var i = from3 - 1; i >= to2; i--) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
})(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ (function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten2() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from3, to2, start) {
    var leftLen = this.left.length;
    if (from3 < leftLen && this.left.forEachInner(f, from3, Math.min(to2, leftLen), start) === false) {
      return false;
    }
    if (to2 > leftLen && this.right.forEachInner(f, Math.max(from3 - leftLen, 0), Math.min(this.length, to2) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from3, to2, start) {
    var leftLen = this.left.length;
    if (from3 > leftLen && this.right.forEachInvertedInner(f, from3 - leftLen, Math.max(to2, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to2 < leftLen && this.left.forEachInvertedInner(f, Math.min(from3, leftLen), to2, start) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from3, to2) {
    if (from3 == 0 && to2 == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to2 <= leftLen) {
      return this.left.slice(from3, to2);
    }
    if (from3 >= leftLen) {
      return this.right.slice(from3 - leftLen, to2 - leftLen);
    }
    return this.left.slice(from3, leftLen).append(this.right.slice(0, to2 - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
})(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end = this.items.length;
    for (; ; end--) {
      let next = this.items.get(end - 1);
      if (next.selection) {
        --end;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map3;
        if (step && transform.maybeStep(step).doc) {
          map3 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map3, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from3, to2) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from3 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from3, to2);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array.map((map3) => new Item(map3))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map3 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map3, step, selection));
      } else {
        rebasedItems.push(new Item(map3));
      }
    }, start);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map3 = step && step.getMap();
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map3.invert(), step, selection), merged, last2 = items.length - 1;
          if (merged = items.length && items[last2].merge(newItem))
            items[last2] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(RopeSequence.from(items.reverse()), events);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
class Item {
  constructor(map3, step, selection, mirrorOffset) {
    this.map = map3;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr, options2) {
  let historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr, void 0, options2, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options2, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options2.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options2, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start, end) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start <= prevRanges[i + 1] && end >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result2 = [];
  for (let i = maps.length - 1; i >= 0 && result2.length == 0; i--)
    maps[i].forEach((_from, _to, from3, to2) => result2.push(from3, to2));
  return result2;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result2 = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from3 = mapping.map(ranges[i], 1), to2 = mapping.map(ranges[i + 1], -1);
    if (from3 <= to2)
      result2.push(from3, to2);
  }
  return result2;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr = histTransaction(hist, state, redo2);
      if (tr)
        dispatch(scroll ? tr.scrollIntoView() : tr);
    }
    return true;
  };
}
const undo = buildCommand(false, true);
const redo = buildCommand(true, true);
var CharacterCount = Extension.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (text) => text.length,
      wordCounter: (text) => text.split(" ").filter((word) => word !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (options2) => {
      const node = (options2 == null ? void 0 : options2.node) || this.editor.state.doc;
      const mode = (options2 == null ? void 0 : options2.mode) || this.options.mode;
      if (mode === "textSize") {
        const text = node.textBetween(0, node.content.size, void 0, " ");
        return this.options.textCounter(text);
      }
      return node.nodeSize;
    };
    this.storage.words = (options2) => {
      const node = (options2 == null ? void 0 : options2.node) || this.editor.state.doc;
      const text = node.textBetween(0, node.content.size, " ", " ");
      return this.options.wordCounter(text);
    };
  },
  addProseMirrorPlugins() {
    let initialEvaluationDone = false;
    return [
      new Plugin({
        key: new PluginKey("characterCount"),
        appendTransaction: (transactions, oldState, newState) => {
          if (initialEvaluationDone) {
            return;
          }
          const limit = this.options.limit;
          if (limit === null || limit === void 0 || limit === 0) {
            initialEvaluationDone = true;
            return;
          }
          const initialContentSize = this.storage.characters({ node: newState.doc });
          if (initialContentSize > limit) {
            const over = initialContentSize - limit;
            const from3 = 0;
            const to2 = over;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${limit} characters. Content was automatically trimmed.`
            );
            const tr = newState.tr.deleteRange(from3, to2);
            initialEvaluationDone = true;
            return tr;
          }
          initialEvaluationDone = true;
        },
        filterTransaction: (transaction, state) => {
          const limit = this.options.limit;
          if (!transaction.docChanged || limit === 0 || limit === null || limit === void 0) {
            return true;
          }
          const oldSize = this.storage.characters({ node: state.doc });
          const newSize = this.storage.characters({ node: transaction.doc });
          if (newSize <= limit) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize <= oldSize) {
            return true;
          }
          if (oldSize > limit && newSize > limit && newSize > oldSize) {
            return false;
          }
          const isPaste = transaction.getMeta("paste");
          if (!isPaste) {
            return false;
          }
          const pos = transaction.selection.$head.pos;
          const over = newSize - limit;
          const from3 = pos - over;
          const to2 = pos;
          transaction.deleteRange(from3, to2);
          const updatedSize = this.storage.characters({ node: transaction.doc });
          if (updatedSize > limit) {
            return false;
          }
          return true;
        }
      })
    ];
  }
});
var Dropcursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [dropCursor(this.options)];
  }
});
Extension.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("focus"),
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const { isEditable, isFocused } = this.editor;
            const { anchor } = selection;
            const decorations = [];
            if (!isEditable || !isFocused) {
              return DecorationSet.create(doc2, []);
            }
            let maxLevels = 0;
            if (this.options.mode === "deepest") {
              doc2.descendants((node, pos) => {
                if (node.isText) {
                  return;
                }
                const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
                if (!isCurrent) {
                  return false;
                }
                maxLevels += 1;
              });
            }
            let currentLevel = 0;
            doc2.descendants((node, pos) => {
              if (node.isText) {
                return false;
              }
              const isCurrent = anchor >= pos && anchor <= pos + node.nodeSize - 1;
              if (!isCurrent) {
                return false;
              }
              currentLevel += 1;
              const outOfScope = this.options.mode === "deepest" && maxLevels - currentLevel > 0 || this.options.mode === "shallowest" && currentLevel > 1;
              if (outOfScope) {
                return this.options.mode === "deepest";
              }
              decorations.push(
                Decoration.node(pos, pos + node.nodeSize, {
                  class: this.options.className
                })
              );
            });
            return DecorationSet.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
var Gapcursor = Extension.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [gapCursor()];
  },
  extendNodeSchema(extension) {
    var _a;
    const context2 = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = callOrReturn(getExtensionField(extension, "allowGapCursor", context2))) != null ? _a : null
    };
  }
});
Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      placeholder: "Write something â¦",
      showOnlyWhenEditable: true,
      showOnlyCurrent: true,
      includeChildren: false
    };
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("placeholder"),
        props: {
          decorations: ({ doc: doc2, selection }) => {
            const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;
            const { anchor } = selection;
            const decorations = [];
            if (!active) {
              return null;
            }
            const isEmptyDoc = this.editor.isEmpty;
            doc2.descendants((node, pos) => {
              const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;
              const isEmpty2 = !node.isLeaf && isNodeEmpty(node);
              if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty2) {
                const classes = [this.options.emptyNodeClass];
                if (isEmptyDoc) {
                  classes.push(this.options.emptyEditorClass);
                }
                const decoration = Decoration.node(pos, pos + node.nodeSize, {
                  class: classes.join(" "),
                  "data-placeholder": typeof this.options.placeholder === "function" ? this.options.placeholder({
                    editor: this.editor,
                    node,
                    pos,
                    hasAnchor
                  }) : this.options.placeholder
                });
                decorations.push(decoration);
              }
              return this.options.includeChildren;
            });
            return DecorationSet.create(doc2, decorations);
          }
        }
      })
    ];
  }
});
Extension.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor, options: options2 } = this;
    return [
      new Plugin({
        key: new PluginKey("selection"),
        props: {
          decorations(state) {
            if (state.selection.empty || editor.isFocused || !editor.isEditable || isNodeSelection(state.selection) || editor.view.dragging) {
              return null;
            }
            return DecorationSet.create(state.doc, [
              Decoration.inline(state.selection.from, state.selection.to, {
                class: options2.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function nodeEqualsType({ types, node }) {
  return node && Array.isArray(types) && types.includes(node.type) || (node == null ? void 0 : node.type) === types;
}
var TrailingNode = Extension.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: "paragraph",
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    const plugin = new PluginKey(this.name);
    const disabledNodes = Object.entries(this.editor.schema.nodes).map(([, value]) => value).filter((node) => (this.options.notAfter || []).concat(this.options.node).includes(node.name));
    return [
      new Plugin({
        key: plugin,
        appendTransaction: (_2, __, state) => {
          const { doc: doc2, tr, schema } = state;
          const shouldInsertNodeAtEnd = plugin.getState(state);
          const endPosition = doc2.content.size;
          const type = schema.nodes[this.options.node];
          if (!shouldInsertNodeAtEnd) {
            return;
          }
          return tr.insert(endPosition, type.create());
        },
        state: {
          init: (_2, state) => {
            const lastNode = state.tr.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          },
          apply: (tr, value) => {
            if (!tr.docChanged) {
              return value;
            }
            const lastNode = tr.doc.lastChild;
            return !nodeEqualsType({ node: lastNode, types: disabledNodes });
          }
        }
      })
    ];
  }
});
var UndoRedo = Extension.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [history(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-Ñ": () => this.editor.commands.undo(),
      "Shift-Mod-Ñ": () => this.editor.commands.redo()
    };
  }
});
var StarterKit = Extension.create({
  name: "starterKit",
  addExtensions() {
    var _a, _b, _c, _d;
    const extensions = [];
    if (this.options.bold !== false) {
      extensions.push(Bold.configure(this.options.bold));
    }
    if (this.options.blockquote !== false) {
      extensions.push(Blockquote.configure(this.options.blockquote));
    }
    if (this.options.bulletList !== false) {
      extensions.push(BulletList.configure(this.options.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(Code.configure(this.options.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(CodeBlock.configure(this.options.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(Document.configure(this.options.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(Dropcursor.configure(this.options.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(Gapcursor.configure(this.options.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(HardBreak.configure(this.options.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(Heading.configure(this.options.heading));
    }
    if (this.options.undoRedo !== false) {
      extensions.push(UndoRedo.configure(this.options.undoRedo));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(HorizontalRule.configure(this.options.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(Italic.configure(this.options.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(ListItem.configure(this.options.listItem));
    }
    if (this.options.listKeymap !== false) {
      extensions.push(ListKeymap.configure((_a = this.options) == null ? void 0 : _a.listKeymap));
    }
    if (this.options.link !== false) {
      extensions.push(Link.configure((_b = this.options) == null ? void 0 : _b.link));
    }
    if (this.options.orderedList !== false) {
      extensions.push(OrderedList.configure(this.options.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(Paragraph.configure(this.options.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(Strike.configure(this.options.strike));
    }
    if (this.options.text !== false) {
      extensions.push(Text.configure(this.options.text));
    }
    if (this.options.underline !== false) {
      extensions.push(Underline.configure((_c = this.options) == null ? void 0 : _c.underline));
    }
    if (this.options.trailingNode !== false) {
      extensions.push(TrailingNode.configure((_d = this.options) == null ? void 0 : _d.trailingNode));
    }
    return extensions;
  }
});
var index_default$6 = StarterKit;
var inputRegex$1 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image = Node3.create({
  name: "image",
  addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: true,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["img", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands() {
    return {
      setImage: (options2) => ({ commands }) => {
        return commands.insertContent({
          type: this.name,
          attrs: options2
        });
      }
    };
  },
  addInputRules() {
    return [
      nodeInputRule({
        find: inputRegex$1,
        type: this.type,
        getAttributes: (match) => {
          const [, , alt, src, title] = match;
          return { src, alt, title };
        }
      })
    ];
  }
});
var index_default$5 = Image;
var index_default$4 = TaskItem;
var index_default$3 = TaskList;
var TextAlign = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element) => {
              const alignment = element.style.textAlign;
              return this.options.alignments.includes(alignment) ? alignment : this.options.defaultAlignment;
            },
            renderHTML: (attributes) => {
              if (!attributes.textAlign) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.map((type) => commands.updateAttributes(type, { textAlign: alignment })).every((response) => response);
      },
      unsetTextAlign: () => ({ commands }) => {
        return this.options.types.map((type) => commands.resetAttributes(type, "textAlign")).every((response) => response);
      },
      toggleTextAlign: (alignment) => ({ editor, commands }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        if (editor.isActive({ textAlign: alignment })) {
          return commands.unsetTextAlign();
        }
        return commands.setTextAlign(alignment);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
var index_default$2 = TextAlign;
var inputRegex = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/;
var pasteRegex = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g;
var Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands }) => {
        return commands.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands }) => {
        return commands.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands }) => {
        return commands.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
var index_default$1 = Highlight;
var index_default = CharacterCount;
var readFromCache;
var addToCache;
if (typeof WeakMap != "undefined") {
  let cache = /* @__PURE__ */ new WeakMap();
  readFromCache = (key) => cache.get(key);
  addToCache = (key, value) => {
    cache.set(key, value);
    return value;
  };
} else {
  const cache = [];
  const cacheSize = 10;
  let cachePos = 0;
  readFromCache = (key) => {
    for (let i = 0; i < cache.length; i += 2)
      if (cache[i] == key) return cache[i + 1];
  };
  addToCache = (key, value) => {
    if (cachePos == cacheSize) cachePos = 0;
    cache[cachePos++] = key;
    return cache[cachePos++] = value;
  };
}
var TableMap = class {
  constructor(width, height, map3, problems) {
    this.width = width;
    this.height = height;
    this.map = map3;
    this.problems = problems;
  }
  // Find the dimensions of the cell at the given position.
  findCell(pos) {
    for (let i = 0; i < this.map.length; i++) {
      const curPos = this.map[i];
      if (curPos != pos) continue;
      const left = i % this.width;
      const top = i / this.width | 0;
      let right = left + 1;
      let bottom = top + 1;
      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {
        right++;
      }
      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {
        bottom++;
      }
      return { left, top, right, bottom };
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(pos) {
    for (let i = 0; i < this.map.length; i++) {
      if (this.map[i] == pos) {
        return i % this.width;
      }
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(pos, axis, dir) {
    const { left, right, top, bottom } = this.findCell(pos);
    if (axis == "horiz") {
      if (dir < 0 ? left == 0 : right == this.width) return null;
      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
    } else {
      if (dir < 0 ? top == 0 : bottom == this.height) return null;
      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
    }
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(a, b) {
    const {
      left: leftA,
      right: rightA,
      top: topA,
      bottom: bottomA
    } = this.findCell(a);
    const {
      left: leftB,
      right: rightB,
      top: topB,
      bottom: bottomB
    } = this.findCell(b);
    return {
      left: Math.min(leftA, leftB),
      top: Math.min(topA, topB),
      right: Math.max(rightA, rightB),
      bottom: Math.max(bottomA, bottomB)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(rect) {
    const result2 = [];
    const seen = {};
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const index = row * this.width + col;
        const pos = this.map[index];
        if (seen[pos]) continue;
        seen[pos] = true;
        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {
          continue;
        }
        result2.push(pos);
      }
    }
    return result2;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(row, col, table) {
    for (let i = 0, rowStart = 0; ; i++) {
      const rowEnd = rowStart + table.child(i).nodeSize;
      if (i == row) {
        let index = col + row * this.width;
        const rowEndIndex = (row + 1) * this.width;
        while (index < rowEndIndex && this.map[index] < rowStart) index++;
        return index == rowEndIndex ? rowEnd - 1 : this.map[index];
      }
      rowStart = rowEnd;
    }
  }
  // Find the table map for the given table node.
  static get(table) {
    return readFromCache(table) || addToCache(table, computeMap(table));
  }
};
function computeMap(table) {
  if (table.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + table.type.name);
  const width = findWidth(table), height = table.childCount;
  const map3 = [];
  let mapPos = 0;
  let problems = null;
  const colWidths = [];
  for (let i = 0, e = width * height; i < e; i++) map3[i] = 0;
  for (let row = 0, pos = 0; row < height; row++) {
    const rowNode = table.child(row);
    pos++;
    for (let i = 0; ; i++) {
      while (mapPos < map3.length && map3[mapPos] != 0) mapPos++;
      if (i == rowNode.childCount) break;
      const cellNode = rowNode.child(i);
      const { colspan, rowspan, colwidth } = cellNode.attrs;
      for (let h2 = 0; h2 < rowspan; h2++) {
        if (h2 + row >= height) {
          (problems || (problems = [])).push({
            type: "overlong_rowspan",
            pos,
            n: rowspan - h2
          });
          break;
        }
        const start = mapPos + h2 * width;
        for (let w = 0; w < colspan; w++) {
          if (map3[start + w] == 0) map3[start + w] = pos;
          else
            (problems || (problems = [])).push({
              type: "collision",
              row,
              pos,
              n: colspan - w
            });
          const colW = colwidth && colwidth[w];
          if (colW) {
            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    const expectedPos = (row + 1) * width;
    let missing = 0;
    while (mapPos < expectedPos) if (map3[mapPos++] == 0) missing++;
    if (missing)
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    pos++;
  }
  if (width === 0 || height === 0)
    (problems || (problems = [])).push({ type: "zero_sized" });
  const tableMap = new TableMap(width, height, map3, problems);
  let badWidths = false;
  for (let i = 0; !badWidths && i < colWidths.length; i += 2)
    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;
  if (badWidths) findBadColWidths(tableMap, colWidths, table);
  return tableMap;
}
function findWidth(table) {
  let width = -1;
  let hasRowSpan = false;
  for (let row = 0; row < table.childCount; row++) {
    const rowNode = table.child(row);
    let rowWidth = 0;
    if (hasRowSpan)
      for (let j = 0; j < row; j++) {
        const prevRow = table.child(j);
        for (let i = 0; i < prevRow.childCount; i++) {
          const cell = prevRow.child(i);
          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;
        }
      }
    for (let i = 0; i < rowNode.childCount; i++) {
      const cell = rowNode.child(i);
      rowWidth += cell.attrs.colspan;
      if (cell.attrs.rowspan > 1) hasRowSpan = true;
    }
    if (width == -1) width = rowWidth;
    else if (width != rowWidth) width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map3, colWidths, table) {
  if (!map3.problems) map3.problems = [];
  const seen = {};
  for (let i = 0; i < map3.map.length; i++) {
    const pos = map3.map[i];
    if (seen[pos]) continue;
    seen[pos] = true;
    const node = table.nodeAt(pos);
    if (!node) {
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    let updated = null;
    const attrs = node.attrs;
    for (let j = 0; j < attrs.colspan; j++) {
      const col = (i + j) % map3.width;
      const colWidth = colWidths[col * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))
        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
    }
    if (updated)
      map3.problems.unshift({
        type: "colwidth mismatch",
        pos,
        colwidth: updated
      });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) return attrs.colwidth.slice();
  const result2 = [];
  for (let i = 0; i < attrs.colspan; i++) result2.push(0);
  return result2;
}
function tableNodeTypes(schema) {
  let result2 = schema.cached.tableNodeTypes;
  if (!result2) {
    result2 = schema.cached.tableNodeTypes = {};
    for (const name in schema.nodes) {
      const type = schema.nodes[name], role = type.spec.tableRole;
      if (role) result2[role] = type;
    }
  }
  return result2;
}
var tableEditingKey = new PluginKey("selectingCells");
function cellAround($pos) {
  for (let d = $pos.depth - 1; d > 0; d--)
    if ($pos.node(d).type.spec.tableRole == "row")
      return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function cellWrapping($pos) {
  for (let d = $pos.depth; d > 0; d--) {
    const role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d);
  }
  return null;
}
function isInTable(state) {
  const $head = state.selection.$head;
  for (let d = $head.depth; d > 0; d--)
    if ($head.node(d).type.spec.tableRole == "row") return true;
  return false;
}
function selectionCell(state) {
  const sel = state.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  const $cell = cellAround(sel.$head) || cellNear(sel.$head);
  if ($cell) {
    return $cell;
  }
  throw new RangeError(`No cell found around position ${sel.head}`);
}
function cellNear($pos) {
  for (let after2 = $pos.nodeAfter, pos = $pos.pos; after2; after2 = after2.firstChild, pos++) {
    const role = after2.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos);
  }
  for (let before2 = $pos.nodeBefore, pos = $pos.pos; before2; before2 = before2.lastChild, pos--) {
    const role = before2.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos - before2.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  const table = $pos.node(-1);
  const map3 = TableMap.get(table);
  const tableStart = $pos.start(-1);
  const moved = map3.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n = 1) {
  const result2 = { ...attrs, colspan: attrs.colspan - n };
  if (result2.colwidth) {
    result2.colwidth = result2.colwidth.slice();
    result2.colwidth.splice(pos, n);
    if (!result2.colwidth.some((w) => w > 0)) result2.colwidth = null;
  }
  return result2;
}
function addColSpan(attrs, pos, n = 1) {
  const result2 = { ...attrs, colspan: attrs.colspan + n };
  if (result2.colwidth) {
    result2.colwidth = result2.colwidth.slice();
    for (let i = 0; i < n; i++) result2.colwidth.splice(pos, 0, 0);
  }
  return result2;
}
function columnIsHeader(map3, table, col) {
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let row = 0; row < map3.height; row++)
    if (table.nodeAt(map3.map[col + row * map3.width]).type != headerCell)
      return false;
  return true;
}
var CellSelection = class _CellSelection extends Selection {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const rect = map3.rectBetween(
      $anchorCell.pos - tableStart,
      $headCell.pos - tableStart
    );
    const doc2 = $anchorCell.node(0);
    const cells = map3.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);
    cells.unshift($headCell.pos - tableStart);
    const ranges = cells.map((pos) => {
      const cell = table.nodeAt(pos);
      if (!cell) {
        throw RangeError(`No cell with offset ${pos} found`);
      }
      const from3 = tableStart + pos + 1;
      return new SelectionRange(
        doc2.resolve(from3),
        doc2.resolve(from3 + cell.content.size)
      );
    });
    super(ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  map(doc2, mapping) {
    const $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
    const $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        return _CellSelection.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection())
        return _CellSelection.colSelection($anchorCell, $headCell);
      else return new _CellSelection($anchorCell, $headCell);
    }
    return TextSelection.between($anchorCell, $headCell);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const table = this.$anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const rect = map3.rectBetween(
      this.$anchorCell.pos - tableStart,
      this.$headCell.pos - tableStart
    );
    const seen = {};
    const rows = [];
    for (let row = rect.top; row < rect.bottom; row++) {
      const rowContent = [];
      for (let index = row * map3.width + rect.left, col = rect.left; col < rect.right; col++, index++) {
        const pos = map3.map[index];
        if (seen[pos]) continue;
        seen[pos] = true;
        const cellRect = map3.findCell(pos);
        let cell = table.nodeAt(pos);
        if (!cell) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const extraLeft = rect.left - cellRect.left;
        const extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          let attrs = cell.attrs;
          if (extraLeft > 0) {
            attrs = removeColSpan(attrs, 0, extraLeft);
          }
          if (extraRight > 0) {
            attrs = removeColSpan(
              attrs,
              attrs.colspan - extraRight,
              extraRight
            );
          }
          if (cellRect.left < rect.left) {
            cell = cell.type.createAndFill(attrs);
            if (!cell) {
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(attrs)}`
              );
            }
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          const attrs = {
            ...cell.attrs,
            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
          };
          if (cellRect.top < rect.top) {
            cell = cell.type.createAndFill(attrs);
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        rowContent.push(cell);
      }
      rows.push(table.child(row).copy(Fragment.from(rowContent)));
    }
    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
    return new Slice(Fragment.from(fragment), 1, 1);
  }
  replace(tr, content = Slice.empty) {
    const mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replace(
        mapping.map($from.pos),
        mapping.map($to.pos),
        i ? Slice.empty : content
      );
    }
    const sel = Selection.findFrom(
      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),
      -1
    );
    if (sel) tr.setSelection(sel);
  }
  replaceWith(tr, node) {
    this.replace(tr, new Slice(Fragment.from(node), 0, 0));
  }
  forEachCell(f) {
    const table = this.$anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const cells = map3.cellsInRect(
      map3.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      )
    );
    for (let i = 0; i < cells.length; i++) {
      f(table.nodeAt(cells[i]), tableStart + cells[i]);
    }
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const anchorTop = this.$anchorCell.index(-1);
    const headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) return false;
    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map3.findCell($anchorCell.pos - tableStart);
    const headRect = map3.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        $anchorCell = doc2.resolve(tableStart + map3.map[anchorRect.left]);
      if (headRect.bottom < map3.height)
        $headCell = doc2.resolve(
          tableStart + map3.map[map3.width * (map3.height - 1) + headRect.right - 1]
        );
    } else {
      if (headRect.top > 0)
        $headCell = doc2.resolve(tableStart + map3.map[headRect.left]);
      if (anchorRect.bottom < map3.height)
        $anchorCell = doc2.resolve(
          tableStart + map3.map[map3.width * (map3.height - 1) + anchorRect.right - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const table = this.$anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const anchorLeft = map3.colCount(this.$anchorCell.pos - tableStart);
    const headLeft = map3.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0) return false;
    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map3.width;
  }
  eq(other) {
    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map3.findCell($anchorCell.pos - tableStart);
    const headRect = map3.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        $anchorCell = doc2.resolve(
          tableStart + map3.map[anchorRect.top * map3.width]
        );
      if (headRect.right < map3.width)
        $headCell = doc2.resolve(
          tableStart + map3.map[map3.width * (headRect.top + 1) - 1]
        );
    } else {
      if (headRect.left > 0)
        $headCell = doc2.resolve(tableStart + map3.map[headRect.top * map3.width]);
      if (anchorRect.right < map3.width)
        $anchorCell = doc2.resolve(
          tableStart + map3.map[map3.width * (anchorRect.top + 1) - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(doc2, json) {
    return new _CellSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchorCell, headCell = anchorCell) {
    return new _CellSelection(doc2.resolve(anchorCell), doc2.resolve(headCell));
  }
  getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  }
};
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = class _CellBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    const $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
      return new CellSelection($anchorCell, $headCell);
    else return Selection.near($headCell, 1);
  }
};
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) return null;
  const cells = [];
  state.selection.forEachCell((node, pos) => {
    cells.push(
      Decoration.node(pos, pos + node.nodeSize, { class: "selectedCell" })
    );
  });
  return DecorationSet.create(state.doc, cells);
}
function isCellBoundarySelection({ $from, $to }) {
  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;
  let afterFrom = $from.pos;
  let beforeTo = $to.pos;
  let depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    if ($from.after(depth + 1) < $from.end(depth)) break;
  for (let d = $to.depth; d >= 0; d--, beforeTo--)
    if ($to.before(d + 1) > $to.start(d)) break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells({ $from, $to }) {
  let fromCellBoundaryNode;
  let toCellBoundaryNode;
  for (let i = $from.depth; i > 0; i--) {
    const node = $from.node(i);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node;
      break;
    }
  }
  for (let i = $to.depth; i > 0; i--) {
    const node = $to.node(i);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr, allowTableNodeSelection) {
  const sel = (tr || state).selection;
  const doc2 = (tr || state).doc;
  let normalize2;
  let role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize2 = CellSelection.create(doc2, sel.from);
    } else if (role == "row") {
      const $cell = doc2.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      const map3 = TableMap.get(sel.node);
      const start = sel.from + 1;
      const lastCell = start + map3.map[map3.width * map3.height - 1];
      normalize2 = CellSelection.create(doc2, start + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize2 = TextSelection.create(doc2, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize2 = TextSelection.create(doc2, sel.$from.start(), sel.$from.end());
  }
  if (normalize2) (tr || (tr = state.tr)).setSelection(normalize2);
  return tr;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset2, f) {
  const oldSize = old.childCount, curSize = cur.childCount;
  outer: for (let i = 0, j = 0; i < curSize; i++) {
    const child = cur.child(i);
    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
      if (old.child(scan) == child) {
        j = scan + 1;
        offset2 += child.nodeSize;
        continue outer;
      }
    }
    f(child, offset2);
    if (j < oldSize && old.child(j).sameMarkup(child))
      changedDescendants(old.child(j), child, offset2 + 1, f);
    else child.nodesBetween(0, child.content.size, f, offset2 + 1);
    offset2 += child.nodeSize;
  }
}
function fixTables(state, oldState) {
  let tr;
  const check = (node, pos) => {
    if (node.type.spec.tableRole == "table")
      tr = fixTable(state, node, pos, tr);
  };
  if (!oldState) state.doc.descendants(check);
  else if (oldState.doc != state.doc)
    changedDescendants(oldState.doc, state.doc, 0, check);
  return tr;
}
function fixTable(state, table, tablePos, tr) {
  const map3 = TableMap.get(table);
  if (!map3.problems) return tr;
  if (!tr) tr = state.tr;
  const mustAdd = [];
  for (let i = 0; i < map3.height; i++) mustAdd.push(0);
  for (let i = 0; i < map3.problems.length; i++) {
    const prob = map3.problems[i];
    if (prob.type == "collision") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      const attrs = cell.attrs;
      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;
      tr.setNodeMarkup(
        tr.mapping.map(tablePos + 1 + prob.pos),
        null,
        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
      );
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        rowspan: cell.attrs.rowspan - prob.n
      });
    } else if (prob.type == "colwidth mismatch") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        colwidth: prob.colwidth
      });
    } else if (prob.type == "zero_sized") {
      const pos = tr.mapping.map(tablePos);
      tr.delete(pos, pos + table.nodeSize);
    }
  }
  let first2, last2;
  for (let i = 0; i < mustAdd.length; i++)
    if (mustAdd[i]) {
      if (first2 == null) first2 = i;
      last2 = i;
    }
  for (let i = 0, pos = tablePos + 1; i < map3.height; i++) {
    const row = table.child(i);
    const end = pos + row.nodeSize;
    const add2 = mustAdd[i];
    if (add2 > 0) {
      let role = "cell";
      if (row.firstChild) {
        role = row.firstChild.type.spec.tableRole;
      }
      const nodes2 = [];
      for (let j = 0; j < add2; j++) {
        const node = tableNodeTypes(state.schema)[role].createAndFill();
        if (node) nodes2.push(node);
      }
      const side = (i == 0 || first2 == i - 1) && last2 == i ? pos + 1 : end - 1;
      tr.insert(tr.mapping.map(side), nodes2);
    }
    pos = end;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  const sel = state.selection;
  const $pos = selectionCell(state);
  const table = $pos.node(-1);
  const tableStart = $pos.start(-1);
  const map3 = TableMap.get(table);
  const rect = sel instanceof CellSelection ? map3.rectBetween(
    sel.$anchorCell.pos - tableStart,
    sel.$headCell.pos - tableStart
  ) : map3.findCell($pos.pos - tableStart);
  return { ...rect, tableStart, map: map3, table };
}
function addColumn(tr, { map: map3, tableStart, table }, col) {
  let refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map3, table, col + refColumn)) {
    refColumn = col == 0 || col == map3.width ? null : 0;
  }
  for (let row = 0; row < map3.height; row++) {
    const index = row * map3.width + col;
    if (col > 0 && col < map3.width && map3.map[index - 1] == map3.map[index]) {
      const pos = map3.map[index];
      const cell = table.nodeAt(pos);
      tr.setNodeMarkup(
        tr.mapping.map(tableStart + pos),
        null,
        addColSpan(cell.attrs, col - map3.colCount(pos))
      );
      row += cell.attrs.rowspan - 1;
    } else {
      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map3.map[index + refColumn]).type;
      const pos = map3.positionAt(row, col, table);
      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());
    }
  }
  return tr;
}
function addColumnBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr, { map: map3, table, tableStart }, col) {
  const mapStart = tr.mapping.maps.length;
  for (let row = 0; row < map3.height; ) {
    const index = row * map3.width + col;
    const pos = map3.map[index];
    const cell = table.nodeAt(pos);
    const attrs = cell.attrs;
    if (col > 0 && map3.map[index - 1] == pos || col < map3.width - 1 && map3.map[index + 1] == pos) {
      tr.setNodeMarkup(
        tr.mapping.slice(mapStart).map(tableStart + pos),
        null,
        removeColSpan(attrs, col - map3.colCount(pos))
      );
    } else {
      const start = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start, start + cell.nodeSize);
    }
    row += attrs.rowspan;
  }
}
function deleteColumn(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    const tr = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) return false;
    for (let i = rect.right - 1; ; i--) {
      removeColumn(tr, rect, i);
      if (i == rect.left) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(table);
    }
    dispatch(tr);
  }
  return true;
}
function rowIsHeader(map3, table, row) {
  var _a;
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let col = 0; col < map3.width; col++)
    if (((_a = table.nodeAt(map3.map[col + row * map3.width])) == null ? void 0 : _a.type) != headerCell)
      return false;
  return true;
}
function addRow(tr, { map: map3, tableStart, table }, row) {
  var _a;
  let rowPos = tableStart;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const cells = [];
  let refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map3, table, row + refRow))
    refRow = row == 0 || row == map3.height ? null : 0;
  for (let col = 0, index = map3.width * row; col < map3.width; col++, index++) {
    if (row > 0 && row < map3.height && map3.map[index] == map3.map[index - map3.width]) {
      const pos = map3.map[index];
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tableStart + pos, null, {
        ...attrs,
        rowspan: attrs.rowspan + 1
      });
      col += attrs.colspan - 1;
    } else {
      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map3.map[index + refRow * map3.width])) == null ? void 0 : _a.type;
      const node = type == null ? void 0 : type.createAndFill();
      if (node) cells.push(node);
    }
  }
  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
  return tr;
}
function addRowBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.top));
  }
  return true;
}
function addRowAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr, { map: map3, table, tableStart }, row) {
  let rowPos = 0;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const nextRow = rowPos + table.child(row).nodeSize;
  const mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  const seen = /* @__PURE__ */ new Set();
  for (let col = 0, index = row * map3.width; col < map3.width; col++, index++) {
    const pos = map3.map[index];
    if (seen.has(pos)) continue;
    seen.add(pos);
    if (row > 0 && pos == map3.map[index - map3.width]) {
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {
        ...attrs,
        rowspan: attrs.rowspan - 1
      });
      col += attrs.colspan - 1;
    } else if (row < map3.height && pos == map3.map[index + map3.width]) {
      const cell = table.nodeAt(pos);
      const attrs = cell.attrs;
      const copy2 = cell.type.create(
        { ...attrs, rowspan: cell.attrs.rowspan - 1 },
        cell.content
      );
      const newPos = map3.positionAt(row + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy2);
      col += attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state), tr = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) return false;
    for (let i = rect.bottom - 1; ; i--) {
      removeRow(tr, rect, i);
      if (i == rect.top) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr);
  }
  return true;
}
function isEmpty$1(cell) {
  const c = cell.content;
  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;
}
function cellsOverlapRectangle({ width, height, map: map3 }, rect) {
  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (let i = rect.top; i < rect.bottom; i++) {
    if (rect.left > 0 && map3[indexLeft] == map3[indexLeft - 1] || rect.right < width && map3[indexRight] == map3[indexRight + 1])
      return true;
    indexLeft += width;
    indexRight += width;
  }
  for (let i = rect.left; i < rect.right; i++) {
    if (rect.top > 0 && map3[indexTop] == map3[indexTop - width] || rect.bottom < height && map3[indexBottom] == map3[indexBottom + width])
      return true;
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
    return false;
  const rect = selectedRect(state), { map: map3 } = rect;
  if (cellsOverlapRectangle(map3, rect)) return false;
  if (dispatch) {
    const tr = state.tr;
    const seen = {};
    let content = Fragment.empty;
    let mergedPos;
    let mergedCell;
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const cellPos = map3.map[row * map3.width + col];
        const cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos] || !cell) continue;
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty$1(cell)) content = content.append(cell.content);
          const mapped = tr.mapping.map(cellPos + rect.tableStart);
          tr.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    if (mergedPos == null || mergedCell == null) {
      return true;
    }
    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {
      ...addColSpan(
        mergedCell.attrs,
        mergedCell.attrs.colspan,
        rect.right - rect.left - mergedCell.attrs.colspan
      ),
      rowspan: rect.bottom - rect.top
    });
    if (content.size) {
      const end = mergedPos + 1 + mergedCell.content.size;
      const start = isEmpty$1(mergedCell) ? mergedPos + 1 : end;
      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);
    }
    tr.setSelection(
      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))
    );
    dispatch(tr);
  }
  return true;
}
function splitCell(state, dispatch) {
  const nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(({ node }) => {
    return nodeTypes[node.type.spec.tableRole];
  })(state, dispatch);
}
function splitCellWithType(getCellType) {
  return (state, dispatch) => {
    var _a;
    const sel = state.selection;
    let cellNode;
    let cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping(sel.$from);
      if (!cellNode) return false;
      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode == null || cellPos == null) {
      return false;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch) {
      let baseAttrs = cellNode.attrs;
      const attrs = [];
      const colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };
      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };
      const rect = selectedRect(state), tr = state.tr;
      for (let i = 0; i < rect.right - rect.left; i++)
        attrs.push(
          colwidth ? {
            ...baseAttrs,
            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
          } : baseAttrs
        );
      let lastCell;
      for (let row = rect.top; row < rect.bottom; row++) {
        let pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) pos += cellNode.nodeSize;
        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {
          if (col == rect.left && row == rect.top) continue;
          tr.insert(
            lastCell = tr.mapping.map(pos + rect.tableStart, 1),
            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])
          );
        }
      }
      tr.setNodeMarkup(
        cellPos,
        getCellType({ node: cellNode, row: rect.top, col: rect.left }),
        attrs[0]
      );
      if (sel instanceof CellSelection)
        tr.setSelection(
          new CellSelection(
            tr.doc.resolve(sel.$anchorCell.pos),
            lastCell ? tr.doc.resolve(lastCell) : void 0
          )
        );
      dispatch(tr);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) return false;
    if (dispatch) {
      const tr = state.tr;
      if (state.selection instanceof CellSelection)
        state.selection.forEachCell((node, pos) => {
          if (node.attrs[name] !== value)
            tr.setNodeMarkup(pos, null, {
              ...node.attrs,
              [name]: value
            });
        });
      else
        tr.setNodeMarkup($cell.pos, null, {
          ...$cell.nodeAfter.attrs,
          [name]: value
        });
      dispatch(tr);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr = state.tr;
      const cells = rect.map.cellsInRect(
        type == "column" ? {
          left: rect.left,
          top: 0,
          right: rect.right,
          bottom: rect.map.height
        } : type == "row" ? {
          left: 0,
          top: rect.top,
          right: rect.map.width,
          bottom: rect.bottom
        } : rect
      );
      const nodes2 = cells.map((pos) => rect.table.nodeAt(pos));
      for (let i = 0; i < cells.length; i++)
        if (nodes2[i].type == types.header_cell)
          tr.setNodeMarkup(
            rect.tableStart + cells[i],
            types.cell,
            nodes2[i].attrs
          );
      if (tr.steps.length == 0)
        for (let i = 0; i < cells.length; i++)
          tr.setNodeMarkup(
            rect.tableStart + cells[i],
            types.header_cell,
            nodes2[i].attrs
          );
      dispatch(tr);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types) {
  const cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (let i = 0; i < cellPositions.length; i++) {
    const cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options2) {
  options2 = options2 || { useDeprecatedLogic: false };
  if (options2.useDeprecatedLogic) return deprecated_toggleHeader(type);
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr = state.tr;
      const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      const isHeaderColumnEnabled = isHeaderEnabledByType(
        "column",
        rect,
        types
      );
      const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      const selectionStartsAt = isHeaderEnabled ? 1 : 0;
      const cellsRect = type == "column" ? {
        left: 0,
        top: selectionStartsAt,
        right: 1,
        bottom: rect.map.height
      } : type == "row" ? {
        left: selectionStartsAt,
        top: 0,
        right: rect.map.width,
        bottom: 1
      } : rect;
      const newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
        const cellPos = relativeCellPos + rect.tableStart;
        const cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch(tr);
    }
    return true;
  };
}
toggleHeader("row", {
  useDeprecatedLogic: true
});
toggleHeader("column", {
  useDeprecatedLogic: true
});
var toggleHeaderCell = toggleHeader("cell", {
  useDeprecatedLogic: true
});
function findNextCell($cell, dir) {
  if (dir < 0) {
    const before2 = $cell.nodeBefore;
    if (before2) return $cell.pos - before2.nodeSize;
    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      const rowNode = $cell.node(-1).child(row);
      const lastChild = rowNode.lastChild;
      if (lastChild) {
        return rowEnd - 1 - lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    const table = $cell.node(-1);
    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {
      const rowNode = table.child(row);
      if (rowNode.childCount) return rowStart + 1;
      rowStart += rowNode.nodeSize;
    }
  }
  return null;
}
function goToNextCell(direction) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const cell = findNextCell(selectionCell(state), direction);
    if (cell == null) return false;
    if (dispatch) {
      const $cell = state.doc.resolve(cell);
      dispatch(
        state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
      );
    }
    return true;
  };
}
function deleteTable(state, dispatch) {
  const $pos = state.selection.$anchor;
  for (let d = $pos.depth; d > 0; d--) {
    const node = $pos.node(d);
    if (node.type.spec.tableRole == "table") {
      if (dispatch)
        dispatch(
          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()
        );
      return true;
    }
  }
  return false;
}
function deleteCellSelection(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection)) return false;
  if (dispatch) {
    const tr = state.tr;
    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell((cell, pos) => {
      if (!cell.content.eq(baseContent))
        tr.replace(
          tr.mapping.map(pos + 1),
          tr.mapping.map(pos + cell.nodeSize - 1),
          new Slice(baseContent, 0, 0)
        );
    });
    if (tr.docChanged) dispatch(tr);
  }
  return true;
}
function pastedCells(slice3) {
  if (!slice3.size) return null;
  let { content, openStart, openEnd } = slice3;
  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content = content.child(0).content;
  }
  const first2 = content.child(0);
  const role = first2.type.spec.tableRole;
  const schema = first2.type.schema, rows = [];
  if (role == "row") {
    for (let i = 0; i < content.childCount; i++) {
      let cells = content.child(i).content;
      const left = i ? 0 : Math.max(0, openStart - 1);
      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left || right)
        cells = fitSlice(
          tableNodeTypes(schema).row,
          new Slice(cells, left, right)
        ).content;
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(
      openStart || openEnd ? fitSlice(
        tableNodeTypes(schema).row,
        new Slice(content, openStart, openEnd)
      ).content : content
    );
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  const widths = [];
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    for (let j = row.childCount - 1; j >= 0; j--) {
      const { rowspan, colspan } = row.child(j).attrs;
      for (let r = i; r < i + rowspan; r++)
        widths[r] = (widths[r] || 0) + colspan;
    }
  }
  let width = 0;
  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);
  for (let r = 0; r < widths.length; r++) {
    if (r >= rows.length) rows.push(Fragment.empty);
    if (widths[r] < width) {
      const empty2 = tableNodeTypes(schema).cell.createAndFill();
      const cells = [];
      for (let i = widths[r]; i < width; i++) {
        cells.push(empty2);
      }
      rows[r] = rows[r].append(Fragment.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice3) {
  const node = nodeType.createAndFill();
  const tr = new Transform(node).replace(0, node.content.size, slice3);
  return tr.doc;
}
function clipCells({ width, height, rows }, newWidth, newHeight) {
  if (width != newWidth) {
    const added = [];
    const newRows = [];
    for (let row = 0; row < rows.length; row++) {
      const frag = rows[row], cells = [];
      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {
        let cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth)
          cell = cell.type.createChecked(
            removeColSpan(
              cell.attrs,
              cell.attrs.colspan,
              col + cell.attrs.colspan - newWidth
            ),
            cell.content
          );
        cells.push(cell);
        col += cell.attrs.colspan;
        for (let j = 1; j < cell.attrs.rowspan; j++)
          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    const newRows = [];
    for (let row = 0, i = 0; row < newHeight; row++, i++) {
      const cells = [], source = rows[i % height];
      for (let j = 0; j < source.childCount; j++) {
        let cell = source.child(j);
        if (row + cell.attrs.rowspan > newHeight)
          cell = cell.type.create(
            {
              ...cell.attrs,
              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)
            },
            cell.content
          );
        cells.push(cell);
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr, map3, table, start, width, height, mapFrom) {
  const schema = tr.doc.type.schema;
  const types = tableNodeTypes(schema);
  let empty2;
  let emptyHead;
  if (width > map3.width) {
    for (let row = 0, rowEnd = 0; row < map3.height; row++) {
      const rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      const cells = [];
      let add2;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
        add2 = empty2 || (empty2 = types.cell.createAndFill());
      else add2 = emptyHead || (emptyHead = types.header_cell.createAndFill());
      for (let i = map3.width; i < width; i++) cells.push(add2);
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);
    }
  }
  if (height > map3.height) {
    const cells = [];
    for (let i = 0, start2 = (map3.height - 1) * map3.width; i < Math.max(map3.width, width); i++) {
      const header = i >= map3.width ? false : table.nodeAt(map3.map[start2 + i]).type == types.header_cell;
      cells.push(
        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill())
      );
    }
    const emptyRow = types.row.create(null, Fragment.from(cells)), rows = [];
    for (let i = map3.height; i < height; i++) rows.push(emptyRow);
    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr, map3, table, start, left, right, top, mapFrom) {
  if (top == 0 || top == map3.height) return false;
  let found2 = false;
  for (let col = left; col < right; col++) {
    const index = top * map3.width + col, pos = map3.map[index];
    if (map3.map[index - map3.width] == pos) {
      found2 = true;
      const cell = table.nodeAt(pos);
      const { top: cellTop, left: cellLeft } = map3.findCell(pos);
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {
        ...cell.attrs,
        rowspan: top - cellTop
      });
      tr.insert(
        tr.mapping.slice(mapFrom).map(map3.positionAt(top, cellLeft, table)),
        cell.type.createAndFill({
          ...cell.attrs,
          rowspan: cellTop + cell.attrs.rowspan - top
        })
      );
      col += cell.attrs.colspan - 1;
    }
  }
  return found2;
}
function isolateVertical(tr, map3, table, start, top, bottom, left, mapFrom) {
  if (left == 0 || left == map3.width) return false;
  let found2 = false;
  for (let row = top; row < bottom; row++) {
    const index = row * map3.width + left, pos = map3.map[index];
    if (map3.map[index - 1] == pos) {
      found2 = true;
      const cell = table.nodeAt(pos);
      const cellLeft = map3.colCount(pos);
      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);
      tr.setNodeMarkup(
        updatePos,
        null,
        removeColSpan(
          cell.attrs,
          left - cellLeft,
          cell.attrs.colspan - (left - cellLeft)
        )
      );
      tr.insert(
        updatePos + cell.nodeSize,
        cell.type.createAndFill(
          removeColSpan(cell.attrs, 0, left - cellLeft)
        )
      );
      row += cell.attrs.rowspan - 1;
    }
  }
  return found2;
}
function insertCells(state, dispatch, tableStart, rect, cells) {
  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
  if (!table) {
    throw new Error("No table found");
  }
  let map3 = TableMap.get(table);
  const { top, left } = rect;
  const right = left + cells.width, bottom = top + cells.height;
  const tr = state.tr;
  let mapFrom = 0;
  function recomp() {
    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    if (!table) {
      throw new Error("No table found");
    }
    map3 = TableMap.get(table);
    mapFrom = tr.mapping.maps.length;
  }
  if (growTable(tr, map3, table, tableStart, right, bottom, mapFrom)) recomp();
  if (isolateHorizontal(tr, map3, table, tableStart, left, right, top, mapFrom))
    recomp();
  if (isolateHorizontal(tr, map3, table, tableStart, left, right, bottom, mapFrom))
    recomp();
  if (isolateVertical(tr, map3, table, tableStart, top, bottom, left, mapFrom))
    recomp();
  if (isolateVertical(tr, map3, table, tableStart, top, bottom, right, mapFrom))
    recomp();
  for (let row = top; row < bottom; row++) {
    const from3 = map3.positionAt(row, left, table), to2 = map3.positionAt(row, right, table);
    tr.replace(
      tr.mapping.slice(mapFrom).map(from3 + tableStart),
      tr.mapping.slice(mapFrom).map(to2 + tableStart),
      new Slice(cells.rows[row - top], 0, 0)
    );
  }
  recomp();
  tr.setSelection(
    new CellSelection(
      tr.doc.resolve(tableStart + map3.positionAt(top, left, table)),
      tr.doc.resolve(tableStart + map3.positionAt(bottom - 1, right - 1, table))
    )
  );
  dispatch(tr);
}
var handleKeyDown = keydownHandler({
  ArrowLeft: arrow("horiz", -1),
  ArrowRight: arrow("horiz", 1),
  ArrowUp: arrow("vert", -1),
  ArrowDown: arrow("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  Backspace: deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  Delete: deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection)) return false;
  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(sel.$headCell, dir)
      );
    }
    if (axis != "horiz" && !sel.empty) return false;
    const end = atEndOfCell(view, axis, dir);
    if (end == null) return false;
    if (axis == "horiz") {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(state.doc.resolve(sel.head + dir), dir)
      );
    } else {
      const $cell = state.doc.resolve(end);
      const $next = nextCell($cell, axis, dir);
      let newSel;
      if ($next) newSel = Selection.near($next, 1);
      else if (dir < 0)
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    let cellSel;
    if (sel instanceof CellSelection) {
      cellSel = sel;
    } else {
      const end = atEndOfCell(view, axis, dir);
      if (end == null) return false;
      cellSel = new CellSelection(state.doc.resolve(end));
    }
    const $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head) return false;
    return maybeSetSelection(
      state,
      dispatch,
      new CellSelection(cellSel.$anchorCell, $head)
    );
  };
}
function handleTripleClick(view, pos) {
  const doc2 = view.state.doc, $cell = cellAround(doc2.resolve(pos));
  if (!$cell) return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _2, slice3) {
  if (!isInTable(view.state)) return false;
  let cells = pastedCells(slice3);
  const sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells)
      cells = {
        width: 1,
        height: 1,
        rows: [
          Fragment.from(
            fitSlice(tableNodeTypes(view.state.schema).cell, slice3)
          )
        ]
      };
    const table = sel.$anchorCell.node(-1);
    const start = sel.$anchorCell.start(-1);
    const rect = TableMap.get(table).rectBetween(
      sel.$anchorCell.pos - start,
      sel.$headCell.pos - start
    );
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start, rect, cells);
    return true;
  } else if (cells) {
    const $cell = selectionCell(view.state);
    const start = $cell.start(-1);
    insertCells(
      view.state,
      view.dispatch,
      start,
      TableMap.get($cell.node(-1)).findCell($cell.pos - start),
      cells
    );
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  var _a;
  if (startEvent.ctrlKey || startEvent.metaKey) return;
  const startDOMCell = domInCell(view, startEvent.target);
  let $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    let $head = cellUnderMouse(view, event);
    const starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) $head = $anchor2;
      else return;
    }
    const selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      const tr = view.state.tr.setSelection(selection);
      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);
      view.dispatch(tr);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move);
    if (tableEditingKey.getState(view.state) != null)
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move(_event) {
    const event = _event;
    const anchor = tableEditingKey.getState(view.state);
    let $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) return stop();
    }
    if ($anchor2) setCellSelection($anchor2, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) return null;
  const { $head } = view.state.selection;
  for (let d = $head.depth - 1; d >= 0; d--) {
    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index != (dir < 0 ? 0 : parent.childCount)) return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      const cellPos = $head.before(d);
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom2) {
  for (; dom2 && dom2 != view.dom; dom2 = dom2.parentNode) {
    if (dom2.nodeName == "TD" || dom2.nodeName == "TH") {
      return dom2;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  const mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) return null;
  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
}
var TableView$1 = class TableView {
  constructor(node, defaultCellMinWidth) {
    this.node = node;
    this.defaultCellMinWidth = defaultCellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.table.style.setProperty(
      "--default-cell-min-width",
      `${defaultCellMinWidth}px`
    );
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node) {
    if (node.type != this.node.type) return false;
    this.node = node;
    updateColumnsOnResize(
      node,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    );
    return true;
  }
  ignoreMutation(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  }
};
function updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {
  var _a;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (!row) return;
  for (let i = 0, col = 0; i < row.childCount; i++) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j = 0; j < colspan; j++, col++) {
      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      const cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || defaultCellMinWidth;
      if (!hasWidth) fixedWidth = false;
      if (!nextDOM) {
        const col2 = document.createElement("col");
        col2.style.width = cssWidth;
        colgroup.appendChild(col2);
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    const after2 = nextDOM.nextSibling;
    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
    nextDOM = after2;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
var columnResizingPluginKey = new PluginKey(
  "tableColumnResizing"
);
function columnResizing({
  handleWidth = 5,
  cellMinWidth = 25,
  defaultCellMinWidth = 100,
  View = TableView$1,
  lastColumnResizable = true
} = {}) {
  const plugin = new Plugin({
    key: columnResizingPluginKey,
    state: {
      init(_2, state) {
        var _a, _b;
        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;
        const tableName = tableNodeTypes(state.schema).table.name;
        if (View && nodeViews) {
          nodeViews[tableName] = (node, view) => {
            return new View(node, defaultCellMinWidth, view);
          };
        }
        return new ResizeState(-1, false);
      },
      apply(tr, prev) {
        return prev.apply(tr);
      }
    },
    props: {
      attributes: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (view, event) => {
          handleMouseMove(view, event, handleWidth, lastColumnResizable);
        },
        mouseleave: (view) => {
          handleMouseLeave(view);
        },
        mousedown: (view, event) => {
          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);
        }
      },
      decorations: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        if (pluginState && pluginState.activeHandle > -1) {
          return handleDecorations(state, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin;
}
var ResizeState = class _ResizeState {
  constructor(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  }
  apply(tr) {
    const state = this;
    const action = tr.getMeta(columnResizingPluginKey);
    if (action && action.setHandle != null)
      return new _ResizeState(action.setHandle, false);
    if (action && action.setDragging !== void 0)
      return new _ResizeState(state.activeHandle, action.setDragging);
    if (state.activeHandle > -1 && tr.docChanged) {
      let handle = tr.mapping.map(state.activeHandle, -1);
      if (!pointsAtCell(tr.doc.resolve(handle))) {
        handle = -1;
      }
      return new _ResizeState(handle, state.dragging);
    }
    return state;
  }
};
function handleMouseMove(view, event, handleWidth, lastColumnResizable) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState) return;
  if (!pluginState.dragging) {
    const target = domCellAround(event.target);
    let cell = -1;
    if (target) {
      const { left, right } = target.getBoundingClientRect();
      if (event.clientX - left <= handleWidth)
        cell = edgeCell(view, event, "left", handleWidth);
      else if (right - event.clientX <= handleWidth)
        cell = edgeCell(view, event, "right", handleWidth);
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        const $cell = view.state.doc.resolve(cell);
        const table = $cell.node(-1);
        const map3 = TableMap.get(table);
        const tableStart = $cell.start(-1);
        const col = map3.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map3.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
    updateHandle(view, -1);
}
function handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {
  var _a;
  if (!view.editable) return false;
  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
    return false;
  const cell = view.state.doc.nodeAt(pluginState.activeHandle);
  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, {
      setDragging: { startX: event.clientX, startWidth: width }
    })
  );
  function finish(event2) {
    win.removeEventListener("mouseup", finish);
    win.removeEventListener("mousemove", move);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (pluginState2 == null ? void 0 : pluginState2.dragging) {
      updateColumnWidth(
        view,
        pluginState2.activeHandle,
        draggedWidth(pluginState2.dragging, event2, cellMinWidth)
      );
      view.dispatch(
        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
      );
    }
  }
  function move(event2) {
    if (!event2.which) return finish(event2);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (!pluginState2) return;
    if (pluginState2.dragging) {
      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
      displayColumnWidth(
        view,
        pluginState2.activeHandle,
        dragged,
        defaultCellMinWidth
      );
    }
  }
  displayColumnWidth(
    view,
    pluginState.activeHandle,
    width,
    defaultCellMinWidth
  );
  win.addEventListener("mouseup", finish);
  win.addEventListener("mousemove", move);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, { colspan, colwidth }) {
  const width = colwidth && colwidth[colwidth.length - 1];
  if (width) return width;
  const dom2 = view.domAtPos(cellPos);
  const node = dom2.node.childNodes[dom2.offset];
  let domWidth = node.offsetWidth, parts = colspan;
  if (colwidth) {
    for (let i = 0; i < colspan; i++)
      if (colwidth[i]) {
        domWidth -= colwidth[i];
        parts--;
      }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH")
    target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
  return target;
}
function edgeCell(view, event, side, handleWidth) {
  const offset2 = side == "right" ? -handleWidth : handleWidth;
  const found2 = view.posAtCoords({
    left: event.clientX + offset2,
    top: event.clientY
  });
  if (!found2) return -1;
  const { pos } = found2;
  const $cell = cellAround(view.state.doc.resolve(pos));
  if (!$cell) return -1;
  if (side == "right") return $cell.pos;
  const map3 = TableMap.get($cell.node(-1)), start = $cell.start(-1);
  const index = map3.map.indexOf($cell.pos - start);
  return index % map3.width == 0 ? -1 : start + map3.map[index - 1];
}
function draggedWidth(dragging, event, resizeMinWidth) {
  const offset2 = event.clientX - dragging.startX;
  return Math.max(resizeMinWidth, dragging.startWidth + offset2);
}
function updateHandle(view, value) {
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
  );
}
function updateColumnWidth(view, cell, width) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), map3 = TableMap.get(table), start = $cell.start(-1);
  const col = map3.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  const tr = view.state.tr;
  for (let row = 0; row < map3.height; row++) {
    const mapIndex = row * map3.width + col;
    if (row && map3.map[mapIndex] == map3.map[mapIndex - map3.width]) continue;
    const pos = map3.map[mapIndex];
    const attrs = table.nodeAt(pos).attrs;
    const index = attrs.colspan == 1 ? 0 : col - map3.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index] == width) continue;
    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index] = width;
    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });
  }
  if (tr.docChanged) view.dispatch(tr);
}
function displayColumnWidth(view, cell, width, defaultCellMinWidth) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), start = $cell.start(-1);
  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  let dom2 = view.domAtPos($cell.start(-1)).node;
  while (dom2 && dom2.nodeName != "TABLE") {
    dom2 = dom2.parentNode;
  }
  if (!dom2) return;
  updateColumnsOnResize(
    table,
    dom2.firstChild,
    dom2,
    defaultCellMinWidth,
    col,
    width
  );
}
function zeroes(n) {
  return Array(n).fill(0);
}
function handleDecorations(state, cell) {
  var _a;
  const decorations = [];
  const $cell = state.doc.resolve(cell);
  const table = $cell.node(-1);
  if (!table) {
    return DecorationSet.empty;
  }
  const map3 = TableMap.get(table);
  const start = $cell.start(-1);
  const col = map3.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
  for (let row = 0; row < map3.height; row++) {
    const index = col + row * map3.width;
    if ((col == map3.width - 1 || map3.map[index] != map3.map[index + 1]) && (row == 0 || map3.map[index] != map3.map[index - map3.width])) {
      const cellPos = map3.map[index];
      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      const dom2 = document.createElement("div");
      dom2.className = "column-resize-handle";
      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {
        decorations.push(
          Decoration.node(
            start + cellPos,
            start + cellPos + table.nodeAt(cellPos).nodeSize,
            {
              class: "column-resize-dragging"
            }
          )
        );
      }
      decorations.push(Decoration.widget(pos, dom2));
    }
  }
  return DecorationSet.create(state.doc, decorations);
}
function tableEditing({
  allowTableNodeSelection = false
} = {}) {
  return new Plugin({
    key: tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(tr, cur) {
        const set2 = tr.getMeta(tableEditingKey);
        if (set2 != null) return set2 == -1 ? null : set2;
        if (cur == null || !tr.docChanged) return cur;
        const { deleted, pos } = tr.mapping.mapResult(cur);
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween(view) {
        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
      },
      handleTripleClick,
      handleKeyDown,
      handlePaste
    },
    appendTransaction(_2, oldState, state) {
      return normalizeSelection(
        state,
        fixTables(state, oldState),
        allowTableNodeSelection
      );
    }
  });
}
var TableCell = Node3.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (element) => {
          const colwidth = element.getAttribute("colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: true,
  parseHTML() {
    return [{ tag: "td" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["td", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
var TableHeader = Node3.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (element) => {
          const colwidth = element.getAttribute("colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: true,
  parseHTML() {
    return [{ tag: "th" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["th", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
var TableRow = Node3.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["tr", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  }
});
function getColStyleDeclaration(minWidth, width) {
  if (width) {
    return ["width", `${Math.max(width, minWidth)}px`];
  }
  return ["min-width", `${minWidth}px`];
}
function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  var _a;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (row !== null) {
    for (let i = 0, col = 0; i < row.childCount; i += 1) {
      const { colspan, colwidth } = row.child(i).attrs;
      for (let j = 0; j < colspan; j += 1, col += 1) {
        const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? `${hasWidth}px` : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) {
          fixedWidth = false;
        }
        if (!nextDOM) {
          const colElement = document.createElement("col");
          const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);
          colElement.style.setProperty(propertyKey, propertyValue);
          colgroup.appendChild(colElement);
        } else {
          if (nextDOM.style.width !== cssWidth) {
            const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);
            nextDOM.style.setProperty(propertyKey, propertyValue);
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
  }
  while (nextDOM) {
    const after2 = nextDOM.nextSibling;
    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
    nextDOM = after2;
  }
  if (fixedWidth) {
    table.style.width = `${totalWidth}px`;
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = `${totalWidth}px`;
  }
}
var TableView2 = class {
  constructor(node, cellMinWidth) {
    this.node = node;
    this.cellMinWidth = cellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumns(node, this.colgroup, this.table, cellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node) {
    if (node.type !== this.node.type) {
      return false;
    }
    this.node = node;
    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
    return true;
  }
  ignoreMutation(mutation) {
    return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
  }
};
function createColGroup(node, cellMinWidth, overrideCol, overrideValue) {
  let totalWidth = 0;
  let fixedWidth = true;
  const cols = [];
  const row = node.firstChild;
  if (!row) {
    return {};
  }
  for (let i = 0, col = 0; i < row.childCount; i += 1) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j = 0; j < colspan; j += 1, col += 1) {
      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) {
        fixedWidth = false;
      }
      const [property2, value] = getColStyleDeclaration(cellMinWidth, hasWidth);
      cols.push(["col", { style: `${property2}: ${value}` }]);
    }
  }
  const tableWidth = fixedWidth ? `${totalWidth}px` : "";
  const tableMinWidth = fixedWidth ? "" : `${totalWidth}px`;
  const colgroup = ["colgroup", {}, ...cols];
  return { colgroup, tableWidth, tableMinWidth };
}
function createCell(cellType, cellContent) {
  return cellType.createAndFill();
}
function getTableNodeTypes(schema) {
  if (schema.cached.tableNodeTypes) {
    return schema.cached.tableNodeTypes;
  }
  const roles = {};
  Object.keys(schema.nodes).forEach((type) => {
    const nodeType = schema.nodes[type];
    if (nodeType.spec.tableRole) {
      roles[nodeType.spec.tableRole] = nodeType;
    }
  });
  schema.cached.tableNodeTypes = roles;
  return roles;
}
function createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {
  const types = getTableNodeTypes(schema);
  const headerCells = [];
  const cells = [];
  for (let index = 0; index < colsCount; index += 1) {
    const cell = createCell(types.cell);
    if (cell) {
      cells.push(cell);
    }
    if (withHeaderRow) {
      const headerCell = createCell(types.header_cell);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  const rows = [];
  for (let index = 0; index < rowsCount; index += 1) {
    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));
  }
  return types.table.createChecked(null, rows);
}
function isCellSelection(value) {
  return value instanceof CellSelection;
}
var deleteTableWhenAllCellsSelected = ({ editor }) => {
  const { selection } = editor.state;
  if (!isCellSelection(selection)) {
    return false;
  }
  let cellCount = 0;
  const table = findParentNodeClosestToPos(selection.ranges[0].$from, (node) => {
    return node.type.name === "table";
  });
  table == null ? void 0 : table.node.descendants((node) => {
    if (node.type.name === "table") {
      return false;
    }
    if (["tableCell", "tableHeader"].includes(node.type.name)) {
      cellCount += 1;
    }
  });
  const allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
var Table = Node3.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: false,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: TableView2,
      lastColumnResizable: true,
      allowTableNodeSelection: false
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: true,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node, HTMLAttributes }) {
    const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);
    const table = [
      "table",
      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {
        style: tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`
      }),
      colgroup,
      ["tbody", 0]
    ];
    return table;
  },
  addCommands() {
    return {
      insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {
        const node = createTable(editor.schema, rows, cols, withHeaderRow);
        if (dispatch) {
          const offset2 = tr.selection.from + 1;
          tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr.doc.resolve(offset2)));
        }
        return true;
      },
      addColumnBefore: () => ({ state, dispatch }) => {
        return addColumnBefore(state, dispatch);
      },
      addColumnAfter: () => ({ state, dispatch }) => {
        return addColumnAfter(state, dispatch);
      },
      deleteColumn: () => ({ state, dispatch }) => {
        return deleteColumn(state, dispatch);
      },
      addRowBefore: () => ({ state, dispatch }) => {
        return addRowBefore(state, dispatch);
      },
      addRowAfter: () => ({ state, dispatch }) => {
        return addRowAfter(state, dispatch);
      },
      deleteRow: () => ({ state, dispatch }) => {
        return deleteRow(state, dispatch);
      },
      deleteTable: () => ({ state, dispatch }) => {
        return deleteTable(state, dispatch);
      },
      mergeCells: () => ({ state, dispatch }) => {
        return mergeCells(state, dispatch);
      },
      splitCell: () => ({ state, dispatch }) => {
        return splitCell(state, dispatch);
      },
      toggleHeaderColumn: () => ({ state, dispatch }) => {
        return toggleHeader("column")(state, dispatch);
      },
      toggleHeaderRow: () => ({ state, dispatch }) => {
        return toggleHeader("row")(state, dispatch);
      },
      toggleHeaderCell: () => ({ state, dispatch }) => {
        return toggleHeaderCell(state, dispatch);
      },
      mergeOrSplit: () => ({ state, dispatch }) => {
        if (mergeCells(state, dispatch)) {
          return true;
        }
        return splitCell(state, dispatch);
      },
      setCellAttribute: (name, value) => ({ state, dispatch }) => {
        return setCellAttr(name, value)(state, dispatch);
      },
      goToNextCell: () => ({ state, dispatch }) => {
        return goToNextCell(1)(state, dispatch);
      },
      goToPreviousCell: () => ({ state, dispatch }) => {
        return goToNextCell(-1)(state, dispatch);
      },
      fixTables: () => ({ state, dispatch }) => {
        if (dispatch) {
          fixTables(state);
        }
        return true;
      },
      setCellSelection: (position) => ({ tr, dispatch }) => {
        if (dispatch) {
          const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);
          tr.setSelection(selection);
        }
        return true;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => {
        if (this.editor.commands.goToNextCell()) {
          return true;
        }
        if (!this.editor.can().addRowAfter()) {
          return false;
        }
        return this.editor.chain().addRowAfter().goToNextCell().run();
      },
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: deleteTableWhenAllCellsSelected,
      "Mod-Backspace": deleteTableWhenAllCellsSelected,
      Delete: deleteTableWhenAllCellsSelected,
      "Mod-Delete": deleteTableWhenAllCellsSelected
    };
  },
  addProseMirrorPlugins() {
    const isResizable = this.options.resizable && this.editor.isEditable;
    return [
      ...isResizable ? [
        columnResizing({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      tableEditing({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(extension) {
    const context2 = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      tableRole: callOrReturn(getExtensionField(extension, "tableRole", context2))
    };
  }
});
Extension.create({
  name: "tableKit",
  addExtensions() {
    const extensions = [];
    if (this.options.table !== false) {
      extensions.push(Table.configure(this.options.table));
    }
    if (this.options.tableCell !== false) {
      extensions.push(TableCell.configure(this.options.tableCell));
    }
    if (this.options.tableHeader !== false) {
      extensions.push(TableHeader.configure(this.options.tableHeader));
    }
    if (this.options.tableRow !== false) {
      extensions.push(TableRow.configure(this.options.tableRow));
    }
    return extensions;
  }
});
var lib$2 = {};
var VERSION = "1.13.7";
var root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
var push = ArrayProto.push, slice2 = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
var _isNaN = isNaN, _isFinite = isFinite;
var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
var nonEnumerableProps = [
  "valueOf",
  "isPrototypeOf",
  "toString",
  "propertyIsEnumerable",
  "hasOwnProperty",
  "toLocaleString"
];
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
    for (; index < length; index++) {
      rest2[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
function isObject(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}
function isNull(obj) {
  return obj === null;
}
function isUndefined(obj) {
  return obj === void 0;
}
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}
const isString = tagTester("String");
const isNumber = tagTester("Number");
const isDate = tagTester("Date");
const isRegExp = tagTester("RegExp");
const isError = tagTester("Error");
const isSymbol = tagTester("Symbol");
const isArrayBuffer = tagTester("ArrayBuffer");
var isFunction = tagTester("Function");
var nodelist = root.document && root.document.childNodes;
if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
  isFunction = function(obj) {
    return typeof obj == "function" || false;
  };
}
const isFunction$1 = isFunction;
const hasObjectTag = tagTester("Object");
var hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag(new DataView(new ArrayBuffer(8)))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
var isDataView = tagTester("DataView");
function alternateIsDataView(obj) {
  return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
}
const isDataView$1 = hasDataViewBug ? alternateIsDataView : isDataView;
const isArray = nativeIsArray || tagTester("Array");
function has$1(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
var isArguments = tagTester("Arguments");
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has$1(obj, "callee");
    };
  }
})();
const isArguments$1 = isArguments;
function isFinite$1(obj) {
  return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}
function isNaN$1(obj) {
  return isNumber(obj) && _isNaN(obj);
}
function constant(value) {
  return function() {
    return value;
  };
}
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}
const getByteLength = shallowProperty("byteLength");
const isBufferLike = createSizePropertyCheck(getByteLength);
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
}
const isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
const getLength = shallowProperty("length");
function emulatedSet(keys2) {
  var hash = {};
  for (var l = keys2.length, i = 0; i < l; ++i) hash[keys2[i]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto2 = isFunction$1(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has$1(obj, prop) && !keys2.contains(prop)) keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto2[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
function keys(obj) {
  if (!isObject(obj)) return [];
  if (nativeKeys) return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj) if (has$1(obj, key)) keys2.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys2);
  return keys2;
}
function isEmpty(obj) {
  if (obj == null) return true;
  var length = getLength(obj);
  if (typeof length == "number" && (isArray(obj) || isString(obj) || isArguments$1(obj))) return length === 0;
  return getLength(keys(obj)) === 0;
}
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null) return !length;
  var obj = Object(object2);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}
function _$1(obj) {
  if (obj instanceof _$1) return obj;
  if (!(this instanceof _$1)) return new _$1(obj);
  this._wrapped = obj;
}
_$1.VERSION = VERSION;
_$1.prototype.value = function() {
  return this._wrapped;
};
_$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
_$1.prototype.toString = function() {
  return String(this._wrapped);
};
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength(bufferSource)
  );
}
var tagDataView = "[object DataView]";
function eq(a, b, aStack, bStack) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null) return false;
  if (a !== a) return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _$1) a = a._wrapped;
  if (b instanceof _$1) b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b)) return false;
  if (hasDataViewBug && className == "[object Object]" && isDataView$1(a)) {
    if (!isDataView$1(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a) return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray$1(a)) {
    var byteLength = getByteLength(a);
    if (byteLength !== getByteLength(b)) return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length) return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length) return false;
    while (length--) {
      key = _keys[length];
      if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a, b) {
  return eq(a, b);
}
function allKeys(obj) {
  if (!isObject(obj)) return [];
  var keys2 = [];
  for (var key in obj) keys2.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys2);
  return keys2;
}
function ie11fingerprint(methods) {
  var length = getLength(methods);
  return function(obj) {
    if (obj == null) return false;
    var keys2 = allKeys(obj);
    if (getLength(keys2)) return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction$1(obj[methods[i]])) return false;
    }
    return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
  };
}
var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
const isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
const isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
const isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
const isWeakSet = tagTester("WeakSet");
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i = 0; i < length; i++) {
    values2[i] = obj[_keys[i]];
  }
  return values2;
}
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i = 0; i < length; i++) {
    pairs2[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs2;
}
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result2[obj[_keys[i]]] = _keys[i];
  }
  return result2;
}
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction$1(obj[key])) names.push(key);
  }
  return names.sort();
}
function createAssigner(keysFunc, defaults2) {
  return function(obj) {
    var length = arguments.length;
    if (defaults2) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index], keys2 = keysFunc(source), l = keys2.length;
      for (var i = 0; i < l; i++) {
        var key = keys2[i];
        if (!defaults2 || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}
const extend = createAssigner(allKeys);
const extendOwn = createAssigner(keys);
const defaults = createAssigner(allKeys, true);
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
function create(prototype, props2) {
  var result2 = baseCreate(prototype);
  if (props2) extendOwn(result2, props2);
  return result2;
}
function clone(obj) {
  if (!isObject(obj)) return obj;
  return isArray(obj) ? obj.slice() : extend({}, obj);
}
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}
function toPath$1(path) {
  return isArray(path) ? path : [path];
}
_$1.toPath = toPath$1;
function toPath(path) {
  return _$1.toPath(path);
}
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}
function get2(object2, path, defaultValue) {
  var value = deepGet(object2, toPath(path));
  return isUndefined(value) ? defaultValue : value;
}
function has(obj, path) {
  path = toPath(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has$1(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}
function identity(value) {
  return value;
}
function matcher(attrs) {
  attrs = extendOwn({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}
function property(path) {
  path = toPath(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}
function optimizeCb(func, context2, argCount) {
  if (context2 === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context2, value);
      };
    // The 2-argument case is omitted because weâre not using it.
    case 3:
      return function(value, index, collection) {
        return func.call(context2, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context2, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context2, arguments);
  };
}
function baseIteratee(value, context2, argCount) {
  if (value == null) return identity;
  if (isFunction$1(value)) return optimizeCb(value, context2, argCount);
  if (isObject(value) && !isArray(value)) return matcher(value);
  return property(value);
}
function iteratee(value, context2) {
  return baseIteratee(value, context2, Infinity);
}
_$1.iteratee = iteratee;
function cb(value, context2, argCount) {
  if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context2);
  return baseIteratee(value, context2, argCount);
}
function mapObject(obj, iteratee2, context2) {
  iteratee2 = cb(iteratee2, context2);
  var _keys = keys(obj), length = _keys.length, results2 = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results2[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results2;
}
function noop() {
}
function propertyOf(obj) {
  if (obj == null) return noop;
  return function(path) {
    return get2(obj, path);
  };
}
function times(n, iteratee2, context2) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context2, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee2(i);
  return accum;
}
function random(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}
const now = Date.now || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function createEscaper(map3) {
  var escaper = function(match) {
    return map3[match];
  };
  var source = "(?:" + keys(map3).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
const escapeMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};
const escape = createEscaper(escapeMap);
const unescapeMap = invert(escapeMap);
const unescape = createEscaper(unescapeMap);
const templateSettings = _$1.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
};
var noMatch = /(.)^/;
var escapes = {
  "'": "'",
  "\\": "\\",
  "\r": "r",
  "\n": "n",
  "\u2028": "u2028",
  "\u2029": "u2029"
};
var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
function escapeChar(match) {
  return "\\" + escapes[match];
}
var bareIdentifier = /^\s*(\w|\$)+\s*$/;
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults({}, settings, _$1.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape2, interpolate, evaluate, offset2) {
    source += text.slice(index, offset2).replace(escapeRegExp, escapeChar);
    index = offset2 + match.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument)) throw new Error(
      "variable is not a bare identifier: " + argument
    );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render.call(this, data, _$1);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
function result(obj, path, fallback) {
  path = toPath(path);
  var length = path.length;
  if (!length) {
    return isFunction$1(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length;
    }
    obj = isFunction$1(prop) ? prop.call(obj) : prop;
  }
  return obj;
}
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}
function chain(obj) {
  var instance = _$1(obj);
  instance._chain = true;
  return instance;
}
function executeBound(sourceFunc, boundFunc, context2, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context2, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject(result2)) return result2;
  return self2;
}
var partial = restArguments(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});
partial.placeholder = _$1;
const bind$1 = restArguments(function(func, context2, args) {
  if (!isFunction$1(func)) throw new TypeError("Bind must be called on a function");
  var bound = restArguments(function(callArgs) {
    return executeBound(func, bound, context2, this, args.concat(callArgs));
  });
  return bound;
});
const isArrayLike = createSizePropertyCheck(getLength);
function flatten$1(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
      if (depth > 1) {
        flatten$1(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
const bindAll = restArguments(function(obj, keys2) {
  keys2 = flatten$1(keys2, false, false);
  var index = keys2.length;
  if (index < 1) throw new Error("bindAll must be passed function names");
  while (index--) {
    var key = keys2[index];
    obj[key] = bind$1(obj[key], obj);
  }
  return obj;
});
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}
const delay = restArguments(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
});
const defer = partial(delay, _$1, 1);
function throttle(func, wait, options2) {
  var timeout, context2, args, result2;
  var previous = 0;
  if (!options2) options2 = {};
  var later = function() {
    previous = options2.leading === false ? 0 : now();
    timeout = null;
    result2 = func.apply(context2, args);
    if (!timeout) context2 = args = null;
  };
  var throttled = function() {
    var _now = now();
    if (!previous && options2.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context2 = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context2, args);
      if (!timeout) context2 = args = null;
    } else if (!timeout && options2.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context2 = args = null;
  };
  return throttled;
}
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context2;
  var later = function() {
    var passed = now() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result2 = func.apply(context2, args);
      if (!timeout) args = context2 = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context2 = this;
    args = _args;
    previous = now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result2 = func.apply(context2, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context2 = null;
  };
  return debounced;
}
function wrap(func, wrapper) {
  return partial(wrapper, func);
}
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result2 = args[start].apply(this, arguments);
    while (i--) result2 = args[i].call(this, result2);
    return result2;
  };
}
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1) func = null;
    return memo;
  };
}
const once = partial(before, 2);
function findKey(obj, predicate, context2) {
  predicate = cb(predicate, context2);
  var _keys = keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context2) {
    predicate = cb(predicate, context2);
    var length = getLength(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}
const findIndex = createPredicateIndexFinder(1);
const findLastIndex = createPredicateIndexFinder(-1);
function sortedIndex(array, obj, iteratee2, context2) {
  iteratee2 = cb(iteratee2, context2, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value) low = mid + 1;
    else high = mid;
  }
  return low;
}
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i = 0, length = getLength(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice2.call(array, i, length), isNaN$1);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}
const indexOf = createIndexFinder(1, findIndex, sortedIndex);
const lastIndexOf = createIndexFinder(-1, findLastIndex);
function find(obj, predicate, context2) {
  var keyFinder = isArrayLike(obj) ? findIndex : findKey;
  var key = keyFinder(obj, predicate, context2);
  if (key !== void 0 && key !== -1) return obj[key];
}
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}
function each$1(obj, iteratee2, context2) {
  iteratee2 = optimizeCb(iteratee2, context2);
  var i, length;
  if (isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee2(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee2(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}
function map$1(obj, iteratee2, context2) {
  iteratee2 = cb(iteratee2, context2);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, results2 = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results2[index] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results2;
}
function createReduce(dir) {
  var reducer = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context2) {
    var initial2 = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee2, context2, 4), memo, initial2);
  };
}
const reduce$1 = createReduce(1);
const reduceRight = createReduce(-1);
function filter$1(obj, predicate, context2) {
  var results2 = [];
  predicate = cb(predicate, context2);
  each$1(obj, function(value, index, list) {
    if (predicate(value, index, list)) results2.push(value);
  });
  return results2;
}
function reject(obj, predicate, context2) {
  return filter$1(obj, negate(cb(predicate)), context2);
}
function every(obj, predicate, context2) {
  predicate = cb(predicate, context2);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}
function some$1(obj, predicate, context2) {
  predicate = cb(predicate, context2);
  var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike(obj)) obj = values(obj);
  if (typeof fromIndex != "number" || guard) fromIndex = 0;
  return indexOf(obj, item, fromIndex) >= 0;
}
const invoke = restArguments(function(obj, path, args) {
  var contextPath, func;
  if (isFunction$1(path)) {
    func = path;
  } else {
    path = toPath(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map$1(obj, function(context2) {
    var method2 = func;
    if (!method2) {
      if (contextPath && contextPath.length) {
        context2 = deepGet(context2, contextPath);
      }
      if (context2 == null) return void 0;
      method2 = context2[path];
    }
    return method2 == null ? method2 : method2.apply(context2, args);
  });
});
function pluck(obj, key) {
  return map$1(obj, property(key));
}
function where(obj, attrs) {
  return filter$1(obj, matcher(attrs));
}
function max(obj, iteratee2, context2) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed2;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context2);
    each$1(obj, function(v, index, list) {
      computed2 = iteratee2(v, index, list);
      if (computed2 > lastComputed || computed2 === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed2;
      }
    });
  }
  return result2;
}
function min(obj, iteratee2, context2) {
  var result2 = Infinity, lastComputed = Infinity, value, computed2;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context2);
    each$1(obj, function(v, index, list) {
      computed2 = iteratee2(v, index, list);
      if (computed2 < lastComputed || computed2 === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed2;
      }
    });
  }
  return result2;
}
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if (isArray(obj)) return slice2.call(obj);
  if (isString(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike(obj)) return map$1(obj, identity);
  return values(obj);
}
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike(obj)) obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last2);
    var temp = sample2[index];
    sample2[index] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}
function shuffle(obj) {
  return sample(obj, Infinity);
}
function sortBy(obj, iteratee2, context2) {
  var index = 0;
  iteratee2 = cb(iteratee2, context2);
  return pluck(map$1(obj, function(value, key, list) {
    return {
      value,
      index: index++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), "value");
}
function group(behavior, partition2) {
  return function(obj, iteratee2, context2) {
    var result2 = partition2 ? [[], []] : {};
    iteratee2 = cb(iteratee2, context2);
    each$1(obj, function(value, index) {
      var key = iteratee2(value, index, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}
const groupBy = group(function(result2, value, key) {
  if (has$1(result2, key)) result2[key].push(value);
  else result2[key] = [value];
});
const indexBy = group(function(result2, value, key) {
  result2[key] = value;
});
const countBy = group(function(result2, value, key) {
  if (has$1(result2, key)) result2[key]++;
  else result2[key] = 1;
});
const partition = group(function(result2, value, pass) {
  result2[pass ? 0 : 1].push(value);
}, true);
function size(obj) {
  if (obj == null) return 0;
  return isArrayLike(obj) ? obj.length : keys(obj).length;
}
function keyInObj(value, key, obj) {
  return key in obj;
}
const pick = restArguments(function(obj, keys2) {
  var result2 = {}, iteratee2 = keys2[0];
  if (obj == null) return result2;
  if (isFunction$1(iteratee2)) {
    if (keys2.length > 1) iteratee2 = optimizeCb(iteratee2, keys2[1]);
    keys2 = allKeys(obj);
  } else {
    iteratee2 = keyInObj;
    keys2 = flatten$1(keys2, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys2.length; i < length; i++) {
    var key = keys2[i];
    var value = obj[key];
    if (iteratee2(value, key, obj)) result2[key] = value;
  }
  return result2;
});
const omit = restArguments(function(obj, keys2) {
  var iteratee2 = keys2[0], context2;
  if (isFunction$1(iteratee2)) {
    iteratee2 = negate(iteratee2);
    if (keys2.length > 1) context2 = keys2[1];
  } else {
    keys2 = map$1(flatten$1(keys2, false, false), String);
    iteratee2 = function(value, key) {
      return !contains(keys2, key);
    };
  }
  return pick(obj, iteratee2, context2);
});
function initial(array, n, guard) {
  return slice2.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial(array, array.length - n);
}
function rest(array, n, guard) {
  return slice2.call(array, n == null || guard ? 1 : n);
}
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}
function compact(array) {
  return filter$1(array, Boolean);
}
function flatten(array, depth) {
  return flatten$1(array, depth, false);
}
const difference = restArguments(function(array, rest2) {
  rest2 = flatten$1(rest2, true, true);
  return filter$1(array, function(value) {
    return !contains(rest2, value);
  });
});
const without = restArguments(function(array, otherArrays) {
  return difference(array, otherArrays);
});
function uniq(array, isSorted, iteratee2, context2) {
  if (!isBoolean(isSorted)) {
    context2 = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null) iteratee2 = cb(iteratee2, context2);
  var result2 = [];
  var seen = [];
  for (var i = 0, length = getLength(array); i < length; i++) {
    var value = array[i], computed2 = iteratee2 ? iteratee2(value, i, array) : value;
    if (isSorted && !iteratee2) {
      if (!i || seen !== computed2) result2.push(value);
      seen = computed2;
    } else if (iteratee2) {
      if (!contains(seen, computed2)) {
        seen.push(computed2);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
const union = restArguments(function(arrays) {
  return uniq(flatten$1(arrays, true, true));
});
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength(array); i < length; i++) {
    var item = array[i];
    if (contains(result2, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result2.push(item);
  }
  return result2;
}
function unzip$1(array) {
  var length = array && max(array, getLength).length || 0;
  var result2 = Array(length);
  for (var index = 0; index < length; index++) {
    result2[index] = pluck(array, index);
  }
  return result2;
}
const zip = restArguments(unzip$1);
function object(list, values2) {
  var result2 = {};
  for (var i = 0, length = getLength(list); i < length; i++) {
    if (values2) {
      result2[list[i]] = values2[i];
    } else {
      result2[list[i][0]] = list[i][1];
    }
  }
  return result2;
}
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result2 = [];
  var i = 0, length = array.length;
  while (i < length) {
    result2.push(slice2.call(array, i, i += count));
  }
  return result2;
}
function chainResult(instance, obj) {
  return instance._chain ? _$1(obj).chain() : obj;
}
function mixin(obj) {
  each$1(functions(obj), function(name) {
    var func = _$1[name] = obj[name];
    _$1.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_$1, args));
    };
  });
  return _$1;
}
each$1(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
  var method2 = ArrayProto[name];
  _$1.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method2.apply(obj, arguments);
      if ((name === "shift" || name === "splice") && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});
each$1(["concat", "join", "slice"], function(name) {
  var method2 = ArrayProto[name];
  _$1.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method2.apply(obj, arguments);
    return chainResult(this, obj);
  };
});
const allExports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION,
  after,
  all: every,
  allKeys,
  any: some$1,
  assign: extendOwn,
  before,
  bind: bind$1,
  bindAll,
  chain,
  chunk,
  clone,
  collect: map$1,
  compact,
  compose,
  constant,
  contains,
  countBy,
  create,
  debounce,
  default: _$1,
  defaults,
  defer,
  delay,
  detect: find,
  difference,
  drop: rest,
  each: each$1,
  escape,
  every,
  extend,
  extendOwn,
  filter: filter$1,
  find,
  findIndex,
  findKey,
  findLastIndex,
  findWhere,
  first,
  flatten,
  foldl: reduce$1,
  foldr: reduceRight,
  forEach: each$1,
  functions,
  get: get2,
  groupBy,
  has,
  head: first,
  identity,
  include: contains,
  includes: contains,
  indexBy,
  indexOf,
  initial,
  inject: reduce$1,
  intersection,
  invert,
  invoke,
  isArguments: isArguments$1,
  isArray,
  isArrayBuffer,
  isBoolean,
  isDataView: isDataView$1,
  isDate,
  isElement,
  isEmpty,
  isEqual,
  isError,
  isFinite: isFinite$1,
  isFunction: isFunction$1,
  isMap,
  isMatch,
  isNaN: isNaN$1,
  isNull,
  isNumber,
  isObject,
  isRegExp,
  isSet,
  isString,
  isSymbol,
  isTypedArray: isTypedArray$1,
  isUndefined,
  isWeakMap,
  isWeakSet,
  iteratee,
  keys,
  last,
  lastIndexOf,
  map: map$1,
  mapObject,
  matcher,
  matches: matcher,
  max,
  memoize,
  methods: functions,
  min,
  mixin,
  negate,
  noop,
  now,
  object,
  omit,
  once,
  pairs,
  partial,
  partition,
  pick,
  pluck,
  property,
  propertyOf,
  random,
  range,
  reduce: reduce$1,
  reduceRight,
  reject,
  rest,
  restArguments,
  result,
  sample,
  select: filter$1,
  shuffle,
  size,
  some: some$1,
  sortBy,
  sortedIndex,
  tail: rest,
  take: first,
  tap,
  template,
  templateSettings,
  throttle,
  times,
  toArray,
  toPath: toPath$1,
  transpose: unzip$1,
  unescape,
  union,
  uniq,
  unique: uniq,
  uniqueId,
  unzip: unzip$1,
  values,
  where,
  without,
  wrap,
  zip
}, Symbol.toStringTag, { value: "Module" }));
var _ = mixin(allExports);
_._ = _;
const indexAll = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VERSION,
  after,
  all: every,
  allKeys,
  any: some$1,
  assign: extendOwn,
  before,
  bind: bind$1,
  bindAll,
  chain,
  chunk,
  clone,
  collect: map$1,
  compact,
  compose,
  constant,
  contains,
  countBy,
  create,
  debounce,
  default: _,
  defaults,
  defer,
  delay,
  detect: find,
  difference,
  drop: rest,
  each: each$1,
  escape,
  every,
  extend,
  extendOwn,
  filter: filter$1,
  find,
  findIndex,
  findKey,
  findLastIndex,
  findWhere,
  first,
  flatten,
  foldl: reduce$1,
  foldr: reduceRight,
  forEach: each$1,
  functions,
  get: get2,
  groupBy,
  has,
  head: first,
  identity,
  include: contains,
  includes: contains,
  indexBy,
  indexOf,
  initial,
  inject: reduce$1,
  intersection,
  invert,
  invoke,
  isArguments: isArguments$1,
  isArray,
  isArrayBuffer,
  isBoolean,
  isDataView: isDataView$1,
  isDate,
  isElement,
  isEmpty,
  isEqual,
  isError,
  isFinite: isFinite$1,
  isFunction: isFunction$1,
  isMap,
  isMatch,
  isNaN: isNaN$1,
  isNull,
  isNumber,
  isObject,
  isRegExp,
  isSet,
  isString,
  isSymbol,
  isTypedArray: isTypedArray$1,
  isUndefined,
  isWeakMap,
  isWeakSet,
  iteratee,
  keys,
  last,
  lastIndexOf,
  map: map$1,
  mapObject,
  matcher,
  matches: matcher,
  max,
  memoize,
  methods: functions,
  min,
  mixin,
  negate,
  noop,
  now,
  object,
  omit,
  once,
  pairs,
  partial,
  partition,
  pick,
  pluck,
  property,
  propertyOf,
  random,
  range,
  reduce: reduce$1,
  reduceRight,
  reject,
  rest,
  restArguments,
  result,
  sample,
  select: filter$1,
  shuffle,
  size,
  some: some$1,
  sortBy,
  sortedIndex,
  tail: rest,
  take: first,
  tap,
  template,
  templateSettings,
  throttle,
  times,
  toArray,
  toPath: toPath$1,
  transpose: unzip$1,
  unescape,
  union,
  uniq,
  unique: uniq,
  uniqueId,
  unzip: unzip$1,
  values,
  where,
  without,
  wrap,
  zip
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(indexAll);
var docxReader = {};
var promises = {};
var promise = { exports: {} };
var es5 = { exports: {} };
var hasRequiredEs5;
function requireEs5() {
  if (hasRequiredEs5) return es5.exports;
  hasRequiredEs5 = 1;
  var isES5 = /* @__PURE__ */ (function() {
    return this === void 0;
  })();
  if (isES5) {
    es5.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    var has2 = {}.hasOwnProperty;
    var str = {}.toString;
    var proto2 = {}.constructor.prototype;
    var ObjectKeys = function(o) {
      var ret = [];
      for (var key in o) {
        if (has2.call(o, key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    var ObjectGetDescriptor = function(o, key) {
      return { value: o[key] };
    };
    var ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    var ObjectFreeze = function(obj) {
      return obj;
    };
    var ObjectGetPrototypeOf = function(obj) {
      try {
        return Object(obj).constructor.prototype;
      } catch (e) {
        return proto2;
      }
    };
    var ArrayIsArray = function(obj) {
      try {
        return str.call(obj) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    es5.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  return es5.exports;
}
var util;
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  var define_process_env_default = {};
  var es52 = requireEs5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = { e: {} };
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : util !== void 0 ? util : null;
  function tryCatcher() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject2(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj2, key, defaultValue) {
    if (es52.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj2, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
    }
  }
  function notEnumerableProp(obj2, name, value) {
    if (isPrimitive(obj2)) return obj2;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es52.defineProperty(obj2, name, descriptor);
    return obj2;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = (function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0; i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es52.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj2) {
        var ret2 = [];
        var visitedKeys = /* @__PURE__ */ Object.create(null);
        while (obj2 != null && !isExcludedProto(obj2)) {
          var keys2;
          try {
            keys2 = getKeys(obj2);
          } catch (e) {
            return ret2;
          }
          for (var i = 0; i < keys2.length; ++i) {
            var key = keys2[i];
            if (visitedKeys[key]) continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj2 = es52.getPrototypeOf(obj2);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj2) {
        if (isExcludedProto(obj2)) return [];
        var ret2 = [];
        enumeration: for (var key in obj2) {
          if (hasProp.call(obj2, key)) {
            ret2.push(key);
          } else {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (hasProp.call(excludedPrototypes[i], key)) {
                continue enumeration;
              }
            }
            ret2.push(key);
          }
        }
        return ret2;
      };
    }
  })();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys2 = es52.names(fn.prototype);
        var hasMethods = es52.isES5 && keys2.length > 1;
        var hasMethodsOtherThanConstructor = keys2.length > 0 && !(keys2.length === 1 && keys2[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es52.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    return obj;
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str) {
    return rident.test(str);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0; i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj2) {
    try {
      return obj2 + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function isError2(obj2) {
    return obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {
    }
  }
  function originatesFromRejection(e) {
    if (e == null) return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj2) {
    return isError2(obj2) && es52.propertyIsWritable(obj2, "stack");
  }
  var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
      return function(value) {
        if (canAttachTrace(value)) return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value)) return value;
        return new Error(safeToString(value));
      };
    }
  })();
  function classString(obj2) {
    return {}.toString.call(obj2);
  }
  function copyDescriptors(from3, to2, filter2) {
    var keys2 = es52.names(from3);
    for (var i = 0; i < keys2.length; ++i) {
      var key = keys2[i];
      if (filter2(key)) {
        try {
          es52.defineProperty(to2, key, es52.getDescriptor(from3, key));
        } catch (ignore) {
        }
      }
    }
  }
  var asArray = function(v) {
    if (es52.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es52.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var isNode = typeof process$1 !== "undefined" && classString(process$1).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process$1 !== "undefined" && typeof define_process_env_default !== "undefined";
  function env(key) {
    return hasEnvVariables ? define_process_env_default[key] : void 0;
  }
  function getNativePromise() {
    if (typeof Promise === "function") {
      try {
        var promise2 = new Promise(function() {
        });
        if ({}.toString.call(promise2) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {
      }
    }
  }
  function domainBind(self2, cb2) {
    return self2.bind(cb2);
  }
  var ret = {
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es52.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject: isObject2,
    isError: isError2,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    domainBind
  };
  ret.isRecentNode = ret.isNode && (function() {
    var version = process$1.versions.node.split(".").map(Number);
    return version[0] === 0 && version[1] > 10 || version[0] > 0;
  })();
  if (ret.isNode) ret.toFastProperties(process$1);
  try {
    throw new Error();
  } catch (e) {
    ret.lastLineError = e;
  }
  util = ret;
  return util;
}
var async = { exports: {} };
var schedule_1;
var hasRequiredSchedule;
function requireSchedule() {
  if (hasRequiredSchedule) return schedule_1;
  hasRequiredSchedule = 1;
  var util2 = requireUtil();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
  };
  var NativePromise = util2.getNativePromise();
  if (util2.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = commonjsGlobal.setImmediate;
    var ProcessNextTick = process$1.nextTick;
    schedule = util2.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(commonjsGlobal, fn);
    } : function(fn) {
      ProcessNextTick.call(process$1, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = (function() {
      var div = document.createElement("div");
      var opts = { attributes: true };
      var toggleScheduled = false;
      var div2 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div2, opts);
      var scheduleToggle = function() {
        if (toggleScheduled) return;
        toggleScheduled = true;
        div2.classList.toggle("foo");
      };
      return function schedule2(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div, opts);
        scheduleToggle();
      };
    })();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  schedule_1 = schedule;
  return schedule_1;
}
var queue;
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue;
  hasRequiredQueue = 1;
  function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
      dst[j + dstIndex] = src[j + srcIndex];
      src[j + srcIndex] = void 0;
    }
  }
  function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue.prototype._willBeOverCapacity = function(size2) {
    return this._capacity < size2;
  };
  Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = void 0;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue.prototype.length = function() {
    return this._length;
  };
  Queue.prototype._checkCapacity = function(size2) {
    if (this._capacity < size2) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  queue = Queue;
  return queue;
}
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async.exports;
  hasRequiredAsync = 1;
  var firstLineError;
  try {
    throw new Error();
  } catch (e) {
    firstLineError = e;
  }
  var schedule = requireSchedule();
  var Queue = requireQueue();
  var util2 = requireUtil();
  function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  }
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
  };
  Async.prototype.disableTrampolineIfNecessary = function() {
    if (util2.hasDevTools) {
      this._trampolineEnabled = false;
    }
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
      process$1.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
      process$1.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else try {
      this._schedule(function() {
        fn(arg);
      });
    } catch (e) {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }
  };
  function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise2) {
    this._normalQueue._pushOne(promise2);
    this._queueTick();
  }
  if (!util2.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
  } else {
    Async.prototype.invokeLater = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvokeLater.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          setTimeout(function() {
            fn.call(receiver, arg);
          }, 100);
        });
      }
    };
    Async.prototype.invoke = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvoke.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          fn.call(receiver, arg);
        });
      }
    };
    Async.prototype.settlePromises = function(promise2) {
      if (this._trampolineEnabled) {
        AsyncSettlePromises.call(this, promise2);
      } else {
        this._schedule(function() {
          promise2._settlePromises();
        });
      }
    };
  }
  Async.prototype._drainQueue = function(queue2) {
    while (queue2.length() > 0) {
      var fn = queue2.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
        continue;
      }
      var receiver = queue2.shift();
      var arg = queue2.shift();
      fn.call(receiver, arg);
    }
  };
  Async.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  async.exports = Async;
  async.exports.firstLineError = firstLineError;
  return async.exports;
}
var errors$1;
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  var es52 = requireEs5();
  var Objectfreeze = es52.freeze;
  var util2 = requireUtil();
  var inherits = util2.inherits;
  var notEnumerableProp = util2.notEnumerableProp;
  function subError(nameProperty, defaultMessage) {
    function SubError(message) {
      if (!(this instanceof SubError)) return new SubError(message);
      notEnumerableProp(
        this,
        "message",
        typeof message === "string" ? message : defaultMessage
      );
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits(SubError, Error);
    return SubError;
  }
  var _TypeError, _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
  for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
      AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
  }
  es52.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError.prototype["isOperational"] = true;
  var level = 0;
  AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0; i2 < this.length; ++i2) {
      var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str.split("\n");
      for (var j = 0; j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str = lines.join("\n");
      ret += str + "\n";
    }
    level--;
    return ret;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp(this, "message", message.message);
      notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError
    });
    es52.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  errors$1 = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
  return errors$1;
}
var thenables;
var hasRequiredThenables;
function requireThenables() {
  if (hasRequiredThenables) return thenables;
  hasRequiredThenables = 1;
  thenables = function(Promise2, INTERNAL) {
    var util2 = requireUtil();
    var errorObj = util2.errorObj;
    var isObject2 = util2.isObject;
    function tryConvertToPromise(obj, context2) {
      if (isObject2(obj)) {
        if (obj instanceof Promise2) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
          if (context2) context2._pushContext();
          var ret = Promise2.reject(then.e);
          if (context2) context2._popContext();
          return ret;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise2(INTERNAL);
            obj._then(
              ret._fulfill,
              ret._reject,
              void 0,
              ret,
              null
            );
            return ret;
          }
          return doThenable(obj, then, context2);
        }
      }
      return obj;
    }
    function doGetThen(obj) {
      return obj.then;
    }
    function getThen(obj) {
      try {
        return doGetThen(obj);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
      try {
        return hasProp.call(obj, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context2) {
      var promise2 = new Promise2(INTERNAL);
      var ret = promise2;
      if (context2) context2._pushContext();
      promise2._captureStackTrace();
      if (context2) context2._popContext();
      var synchronous = true;
      var result2 = util2.tryCatch(then).call(x, resolve, reject2);
      synchronous = false;
      if (promise2 && result2 === errorObj) {
        promise2._rejectCallback(result2.e, true, true);
        promise2 = null;
      }
      function resolve(value) {
        if (!promise2) return;
        promise2._resolveCallback(value);
        promise2 = null;
      }
      function reject2(reason) {
        if (!promise2) return;
        promise2._rejectCallback(reason, synchronous, true);
        promise2 = null;
      }
      return ret;
    }
    return tryConvertToPromise;
  };
  return thenables;
}
var promise_array;
var hasRequiredPromise_array;
function requirePromise_array() {
  if (hasRequiredPromise_array) return promise_array;
  hasRequiredPromise_array = 1;
  promise_array = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util2 = requireUtil();
    util2.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function PromiseArray(values2) {
      var promise2 = this._promise = new Promise2(INTERNAL);
      if (values2 instanceof Promise2) {
        promise2._propagateFrom(values2, 3);
      }
      promise2._setOnCancel(this);
      this._values = values2;
      this._length = 0;
      this._totalResolved = 0;
      this._init(void 0, -2);
    }
    util2.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_2, resolveValueIfEmpty) {
      var values2 = tryConvertToPromise(this._values, this._promise);
      if (values2 instanceof Promise2) {
        values2 = values2._target();
        var bitField = values2._bitField;
        this._values = values2;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values2._then(
            init,
            this._reject,
            void 0,
            this,
            resolveValueIfEmpty
          );
        } else if ((bitField & 33554432) !== 0) {
          values2 = values2._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values2._reason());
        } else {
          return this._cancel();
        }
      }
      values2 = util2.asArray(values2);
      if (values2 === null) {
        var err = apiRejection(
          "expecting an array or an iterable object but got " + util2.classString(values2)
        ).reason();
        this._promise._rejectCallback(err, false);
        return;
      }
      if (values2.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values2);
    };
    PromiseArray.prototype._iterate = function(values2) {
      var len = this.getActualLength(values2.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result2 = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values2[i], result2);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved) result2._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable()) return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved()) return;
      var values2 = this._values;
      this._cancel();
      if (values2 instanceof Promise2) {
        values2.cancel();
      } else {
        for (var i = 0; i < values2.length; ++i) {
          if (values2[i] instanceof Promise2) {
            values2[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
  return promise_array;
}
var context;
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context;
  hasRequiredContext = 1;
  context = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {
    };
    Promise2.prototype._pushContext = function() {
    };
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {
    };
    function Context() {
      this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
      if (this._trace !== void 0) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
      }
      return null;
    };
    function createContext() {
      if (longStackTraces) return new Context();
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return void 0;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function() {
    };
    Context.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context.prototype._pushContext;
      Promise2.prototype._popContext = Context.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
      };
    };
    return Context;
  };
  return context;
}
var debuggability;
var hasRequiredDebuggability;
function requireDebuggability() {
  if (hasRequiredDebuggability) return debuggability;
  hasRequiredDebuggability = 1;
  debuggability = function(Promise2, Context) {
    var getDomain = Promise2._getDomain;
    var async2 = Promise2._async;
    var Warning = requireErrors$1().Warning;
    var util2 = requireUtil();
    var canAttachTrace = util2.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util2.env("BLUEBIRD_DEBUG") != 0 && (util2.env("BLUEBIRD_DEBUG") || util2.env("NODE_ENV") === "development"));
    var warnings = !!(util2.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util2.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util2.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util2.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util2.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util2.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target = this._target();
      target._bitField = target._bitField & -1048577 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0) return;
      this._setRejectionIsUnhandled();
      async2.invokeLater(this._notifyUnhandledRejection, this, void 0);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent(
        "rejectionHandled",
        unhandledRejectionHandled,
        void 0,
        this
      );
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent(
          "unhandledRejection",
          possiblyUnhandledRejection,
          reason,
          this
        );
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & -262145;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & -1048577;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise2) {
      return warn2(message, shouldUseOwnTrace, promise2 || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var domain = getDomain();
      possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var domain = getDomain();
      unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
    };
    var disableLongStackTraces = function() {
    };
    Promise2.longStackTraces = function() {
      if (async2.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
      }
      if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async2.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Context.deactivateLongStackTraces();
          async2.enableTrampoline();
          config.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async2.disableTrampolineIfNecessary();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config.longStackTraces && longStackTracesIsSupported();
    };
    var fireDomEvent = (function() {
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new CustomEvent(name.toLowerCase(), {
              detail: event2,
              cancelable: true
            });
            return !util2.global.dispatchEvent(domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new Event(name.toLowerCase(), {
              cancelable: true
            });
            domEvent.detail = event2;
            return !util2.global.dispatchEvent(domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(
              name.toLowerCase(),
              false,
              true,
              event2
            );
            return !util2.global.dispatchEvent(domEvent);
          };
        }
      } catch (e) {
      }
      return function() {
        return false;
      };
    })();
    var fireGlobalEvent = (function() {
      if (util2.isNode) {
        return function() {
          return process$1.emit.apply(process$1, arguments);
        };
      } else {
        if (!util2.global) {
          return function() {
            return false;
          };
        }
        return function(name) {
          var methodName = "on" + name.toLowerCase();
          var method2 = util2.global[methodName];
          if (!method2) return false;
          method2.apply(util2.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    })();
    function generatePromiseLifecycleEventObject(name, promise2) {
      return { promise: promise2 };
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name, promise2, child) {
        return { promise: promise2, child };
      },
      warning: function(name, warning) {
        return { warning };
      },
      unhandledRejection: function(name, reason, promise2) {
        return { reason, promise: promise2 };
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async2.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(
          name,
          eventToObjectGenerator[name].apply(null, arguments)
        );
      } catch (e) {
        async2.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;
        if (util2.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async2.haveItemsQueued()) {
          throw new Error(
            "cannot enable cancellation after promises are in use"
          );
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
          config.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
          config.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve, reject2) {
      try {
        executor(resolve, reject2);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {
    };
    Promise2.prototype._setOnCancel = function(handler) {
    };
    Promise2.prototype._attachCancellationCallback = function(onCancel) {
    };
    Promise2.prototype._captureStackTrace = function() {
    };
    Promise2.prototype._attachExtraTrace = function() {
    };
    Promise2.prototype._clearCancellationData = function() {
    };
    Promise2.prototype._propagateFrom = function(parent, flags) {
    };
    function cancellationExecute(executor, resolve, reject2) {
      var promise2 = this;
      try {
        executor(resolve, reject2, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util2.toString(onCancel));
          }
          promise2._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable()) return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== void 0) {
        if (util2.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = void 0;
      this._onCancelField = void 0;
    }
    function cancellationPropagateFrom(parent, flags) {
      if ((flags & 1) !== 0) {
        this._cancellationParent = parent;
        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
        if (branchesRemainingToCancel === void 0) {
          branchesRemainingToCancel = 0;
        }
        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    function bindingPropagateFrom(parent, flags) {
      if ((flags & 2) !== 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret = this._boundTo;
      if (ret !== void 0) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return void 0;
          }
        }
      }
      return ret;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error, ignoreSelf) {
      if (canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== void 0) {
          if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== void 0) {
          trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
          var parsed = parseStackAndMessage(error);
          util2.notEnumerableProp(
            error,
            "stack",
            parsed.message + "\n" + parsed.stack.join("\n")
          );
          util2.notEnumerableProp(error, "__stackCleaned__", true);
        }
      }
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise2, parent) {
      if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
        if (parent !== void 0 && parent._returnedNonUndefined()) return;
        if ((promise2._bitField & 65535) === 0) return;
        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split("\n");
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1; i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0; i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = "\n" + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
        promise2._warn(msg, true, promiseCreated);
      }
    }
    function deprecated(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      if (replacement) message += " Use " + replacement + " instead.";
      return warn2(message);
    }
    function warn2(message, shouldUseOwnTrace, promise2) {
      if (!config.warnings) return;
      var warning = new Warning(message);
      var ctx;
      if (shouldUseOwnTrace) {
        promise2._attachExtraTrace(warning);
      } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message, stacks) {
      for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
      }
      return message + "\n" + stacks.join("\n");
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1; j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint; j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error) {
      var stack = error.stack.replace(/\s+$/g, "").split("\n");
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error) {
      var stack = error.stack;
      var message = error.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
      return {
        message,
        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error, title, isSoft) {
      if (typeof console !== "undefined") {
        var message;
        if (util2.isObject(error)) {
          var stack = error.stack;
          message = title + formatStack(stack, error);
        } else {
          message = title + String(error);
        }
        if (typeof printWarning === "function") {
          printWarning(message, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    }
    function fireRejectionEvent(name, localHandler, reason, promise2) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise2);
          } else {
            localHandler(reason, promise2);
          }
        }
      } catch (e) {
        async2.throwLater(e);
      }
      if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise2) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name, promise2);
      }
    }
    function formatNonError(obj) {
      var str;
      if (typeof obj === "function") {
        str = "[function " + (obj.name || "anonymous") + "]";
      } else {
        str = obj && typeof obj.toString === "function" ? obj.toString() : util2.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
          try {
            var newStr = JSON.stringify(obj);
            str = newStr;
          } catch (e) {
          }
        }
        if (str.length === 0) {
          str = "(empty array)";
        }
      }
      return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
      var maxChars = 41;
      if (str.length < maxChars) {
        return str;
      }
      return str.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches2 = line.match(parseLineInfoRegex);
      if (matches2) {
        return {
          fileName: matches2[1],
          line: parseInt(matches2[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported()) return;
      var firstStackLines = firstLineError.stack.split("\n");
      var lastStackLines = lastLineError.stack.split("\n");
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0; i < firstStackLines.length; ++i) {
        var result2 = parseLineInfo(firstStackLines[i]);
        if (result2) {
          firstFileName = result2.fileName;
          firstIndex = result2.line;
          break;
        }
      }
      for (var i = 0; i < lastStackLines.length; ++i) {
        var result2 = parseLineInfo(lastStackLines[i]);
        if (result2) {
          lastFileName = result2.fileName;
          lastIndex = result2.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent) {
      this._parent = parent;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32) this.uncycle();
    }
    util2.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2) return;
      var nodes2 = [];
      var stackToIndex = {};
      for (var i = 0, node = this; node !== void 0; ++i) {
        nodes2.push(node);
        node = node._parent;
      }
      length = this._length = i;
      for (var i = length - 1; i >= 0; --i) {
        var stack = nodes2[i].stack;
        if (stackToIndex[stack] === void 0) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0; i < length; ++i) {
        var currentStack = nodes2[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== void 0 && index !== i) {
          if (index > 0) {
            nodes2[index - 1]._parent = void 0;
            nodes2[index - 1]._length = 1;
          }
          nodes2[i]._parent = void 0;
          nodes2[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes2[i - 1] : this;
          if (index < length - 1) {
            cycleEdgeNode._parent = nodes2[index + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = void 0;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2; j >= 0; --j) {
            nodes2[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error) {
      if (error.__stackCleaned__) return;
      this.uncycle();
      var parsed = parseStackAndMessage(error);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== void 0) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util2.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
      util2.notEnumerableProp(error, "__stackCleaned__", true);
    };
    var captureStackTrace = (function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;
        if (error.name !== void 0 && error.message !== void 0) {
          return error.toString();
        }
        return formatNonError(error);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err = new Error();
      if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace3(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error();
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace3(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error();
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;
        if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
          return error.toString();
        }
        return formatNonError(error);
      };
      return null;
    })();
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message) {
        console.warn(message);
      };
      if (util2.isNode && process$1.stderr.isTTY) {
        printWarning = function(message, isSoft) {
          var color = isSoft ? "\x1B[33m" : "\x1B[31m";
          console.warn(color + message + "\x1B[0m\n");
        };
      } else if (!util2.isNode && typeof new Error().stack === "string") {
        printWarning = function(message, isSoft) {
          console.warn(
            "%c" + message,
            isSoft ? "color: darkorange" : "color: red"
          );
        };
      }
    }
    var config = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false
    };
    if (longStackTraces) Promise2.longStackTraces();
    return {
      longStackTraces: function() {
        return config.longStackTraces;
      },
      warnings: function() {
        return config.warnings;
      },
      cancellation: function() {
        return config.cancellation;
      },
      monitoring: function() {
        return config.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn: warn2,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
  return debuggability;
}
var _finally;
var hasRequired_finally;
function require_finally() {
  if (hasRequired_finally) return _finally;
  hasRequired_finally = 1;
  _finally = function(Promise2, tryConvertToPromise) {
    var util2 = requireUtil();
    var CancellationError = Promise2.CancellationError;
    var errorObj = util2.errorObj;
    function PassThroughHandlerContext(promise2, type, handler) {
      this.promise = promise2;
      this.type = type;
      this.handler = handler;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason)) return;
      errorObj.e = reason;
      return errorObj;
    }
    function finallyHandler(reasonOrValue) {
      var promise2 = this.promise;
      var handler = this.handler;
      if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler() ? handler.call(promise2._boundValue()) : handler.call(promise2._boundValue(), reasonOrValue);
        if (ret !== void 0) {
          promise2._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret, promise2);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise2._attachExtraTrace(reason);
                errorObj.e = reason;
                return errorObj;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(
                  new FinallyHandlerCancelReaction(this)
                );
              }
            }
            return maybePromise._then(
              succeed,
              fail,
              void 0,
              this,
              void 0
            );
          }
        }
      }
      if (promise2.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler, type, success, fail2) {
      if (typeof handler !== "function") return this.then();
      return this._then(
        success,
        fail2,
        void 0,
        new PassThroughHandlerContext(this, type, handler),
        void 0
      );
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThrough(
        handler,
        0,
        finallyHandler,
        finallyHandler
      );
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThrough(handler, 1, finallyHandler);
    };
    return PassThroughHandlerContext;
  };
  return _finally;
}
var catch_filter;
var hasRequiredCatch_filter;
function requireCatch_filter() {
  if (hasRequiredCatch_filter) return catch_filter;
  hasRequiredCatch_filter = 1;
  catch_filter = function(NEXT_FILTER) {
    var util2 = requireUtil();
    var getKeys = requireEs5().keys;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function catchFilter(instances, cb2, promise2) {
      return function(e) {
        var boundTo = promise2._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
          var item = instances[i];
          if (item === Error || item != null && item.prototype instanceof Error) {
            if (e instanceof item) {
              return tryCatch(cb2).call(boundTo, e);
            }
          } else if (typeof item === "function") {
            var matchesPredicate = tryCatch(item).call(boundTo, e);
            if (matchesPredicate === errorObj) {
              return matchesPredicate;
            } else if (matchesPredicate) {
              return tryCatch(cb2).call(boundTo, e);
            }
          } else if (util2.isObject(e)) {
            var keys2 = getKeys(item);
            for (var j = 0; j < keys2.length; ++j) {
              var key = keys2[j];
              if (item[key] != e[key]) {
                continue predicateLoop;
              }
            }
            return tryCatch(cb2).call(boundTo, e);
          }
        }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
  return catch_filter;
}
var nodeback;
var hasRequiredNodeback;
function requireNodeback() {
  if (hasRequiredNodeback) return nodeback;
  hasRequiredNodeback = 1;
  var util2 = requireUtil();
  var maybeWrapAsError = util2.maybeWrapAsError;
  var errors2 = requireErrors$1();
  var OperationalError = errors2.OperationalError;
  var es52 = requireEs5();
  function isUntypedError(obj) {
    return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
      ret = new OperationalError(obj);
      ret.name = obj.name;
      ret.message = obj.message;
      ret.stack = obj.stack;
      var keys2 = es52.keys(obj);
      for (var i = 0; i < keys2.length; ++i) {
        var key = keys2[i];
        if (!rErrorKey.test(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    util2.markAsOriginatingFromRejection(obj);
    return obj;
  }
  function nodebackForPromise(promise2, multiArgs) {
    return function(err, value) {
      if (promise2 === null) return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
        promise2._attachExtraTrace(wrapped);
        promise2._reject(wrapped);
      } else if (!multiArgs) {
        promise2._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise2._fulfill(args);
      }
      promise2 = null;
    };
  }
  nodeback = nodebackForPromise;
  return nodeback;
}
var method;
var hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod) return method;
  hasRequiredMethod = 1;
  method = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util2.classString(fn));
      }
      return function() {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.method",
          ret
        );
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._pushContext();
      var value;
      if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util2.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
      } else {
        value = tryCatch(fn)();
      }
      var promiseCreated = ret._popContext();
      debug.checkForgottenReturns(
        value,
        promiseCreated,
        "Promise.try",
        ret
      );
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util2.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
  return method;
}
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind) return bind;
  hasRequiredBind = 1;
  bind = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function(_2, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context2) {
      context2.promiseRejectionQueued = true;
      context2.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context2) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context2.target);
      }
    };
    var bindingRejected = function(e, context2) {
      if (!context2.promiseRejectionQueued) this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug.propagateFromFunction();
        Promise2.prototype._boundValue = debug.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._propagateFrom(this, 1);
      var target = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context2 = {
          promiseRejectionQueued: false,
          promise: ret,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, void 0, ret, context2);
        maybePromise._then(
          bindingResolved,
          bindingRejected,
          void 0,
          ret,
          context2
        );
        ret._setOnCancel(maybePromise);
      } else {
        ret._resolveCallback(target);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj) {
      if (obj !== void 0) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
      } else {
        this._bitField = this._bitField & -2097153;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
  return bind;
}
var cancel;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel) return cancel;
  hasRequiredCancel = 1;
  cancel = function(Promise2, PromiseArray, apiRejection, debug) {
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug.cancellation()) return this._warn("cancellation is disabled");
      var promise2 = this;
      var child = promise2;
      while (promise2._isCancellable()) {
        if (!promise2._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent = promise2._cancellationParent;
        if (parent == null || !parent._isCancellable()) {
          if (promise2._isFollowing()) {
            promise2._followee().cancel();
          } else {
            promise2._cancelBranched();
          }
          break;
        } else {
          if (promise2._isFollowing()) promise2._followee().cancel();
          promise2._setWillBeCancelled();
          child = promise2;
          promise2 = parent;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable()) return;
      this._setCancelled();
      async2.invoke(this._cancelPromises, this, void 0);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0) this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util2.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== void 0) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch(onCancelCallback).call(this._boundValue());
            if (e === errorObj) {
              this._attachExtraTrace(e.e);
              async2.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async2.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
  return cancel;
}
var direct_resolve;
var hasRequiredDirect_resolve;
function requireDirect_resolve() {
  if (hasRequiredDirect_resolve) return direct_resolve;
  hasRequiredDirect_resolve = 1;
  direct_resolve = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2) value.suppressUnhandledRejections();
      return this._then(
        returner,
        void 0,
        void 0,
        { value },
        void 0
      );
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(
        thrower,
        void 0,
        void 0,
        { reason },
        void 0
      );
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(
          void 0,
          thrower,
          void 0,
          { reason },
          void 0
        );
      } else {
        var _reason = arguments[1];
        var handler = function() {
          throw _reason;
        };
        return this.caught(reason, handler);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2) value.suppressUnhandledRejections();
        return this._then(
          void 0,
          returner,
          void 0,
          { value },
          void 0
        );
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2) _value.suppressUnhandledRejections();
        var handler = function() {
          return _value;
        };
        return this.caught(value, handler);
      }
    };
  };
  return direct_resolve;
}
var synchronous_inspection;
var hasRequiredSynchronous_inspection;
function requireSynchronous_inspection() {
  if (hasRequiredSynchronous_inspection) return synchronous_inspection;
  hasRequiredSynchronous_inspection = 1;
  synchronous_inspection = function(Promise2) {
    function PromiseInspection(promise2) {
      if (promise2 !== void 0) {
        promise2 = promise2._target();
        this._bitField = promise2._bitField;
        this._settledValueField = promise2._isFateSealed() ? promise2._settledValue() : void 0;
      } else {
        this._bitField = 0;
        this._settledValueField = void 0;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      target._unsetRejectionIsUnhandled();
      return reason.call(target);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
  return synchronous_inspection;
}
var join;
var hasRequiredJoin;
function requireJoin() {
  if (hasRequiredJoin) return join;
  hasRequiredJoin = 1;
  join = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async2, getDomain) {
    var util2 = requireUtil();
    var canEvaluate = util2.canEvaluate;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var reject2;
    {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", "                             \n	            'use strict';                                                    \n	            holder.pIndex = value;                                           \n	            holder.checkFulfillment(this);                                   \n	            ".replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", "                           \n	            'use strict';                                                    \n	            holder.pIndex = promise;                                         \n	            ".replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props2 = new Array(total);
          for (var i2 = 0; i2 < props2.length; ++i2) {
            props2[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props2.join(" = ") + " = null;";
          var cancellationCode = "var promise;\n" + props2.map(function(prop) {
            return "                                                         \n	                promise = " + prop + ";                                      \n	                if (promise instanceof Promise) {                            \n	                    promise.cancel();                                        \n	                }                                                            \n	            ";
          }).join("\n");
          var passedArguments = props2.join(", ");
          var name = "Holder$" + total;
          var code = "return function(tryCatch, errorObj, Promise, async) {    \n	            'use strict';                                                    \n	            function [TheName](fn) {                                         \n	                [TheProperties]                                              \n	                this.fn = fn;                                                \n	                this.asyncNeeded = true;                                     \n	                this.now = 0;                                                \n	            }                                                                \n	                                                                             \n	            [TheName].prototype._callFunction = function(promise) {          \n	                promise._pushContext();                                      \n	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n	                promise._popContext();                                       \n	                if (ret === errorObj) {                                      \n	                    promise._rejectCallback(ret.e, false);                   \n	                } else {                                                     \n	                    promise._resolveCallback(ret);                           \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype.checkFulfillment = function(promise) {       \n	                var now = ++this.now;                                        \n	                if (now === [TheTotal]) {                                    \n	                    if (this.asyncNeeded) {                                  \n	                        async.invoke(this._callFunction, this, promise);     \n	                    } else {                                                 \n	                        this._callFunction(promise);                         \n	                    }                                                        \n	                                                                             \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype._resultCancelled = function() {              \n	                [CancellationCode]                                           \n	            };                                                               \n	                                                                             \n	            return [TheName];                                                \n	        }(tryCatch, errorObj, Promise, async);                               \n	        ";
          code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise2, async2);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0; i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject2 = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last2 = arguments.length - 1;
      var fn;
      if (last2 > 0 && typeof arguments[last2] === "function") {
        fn = arguments[last2];
        {
          if (last2 <= 8 && canEvaluate) {
            var ret = new Promise2(INTERNAL);
            ret._captureStackTrace();
            var HolderClass = holderClasses[last2 - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0; i2 < last2; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(
                    callbacks[i2],
                    reject2,
                    void 0,
                    ret,
                    holder
                  );
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(
                    ret,
                    maybePromise._value(),
                    holder
                  );
                } else if ((bitField & 16777216) !== 0) {
                  ret._reject(maybePromise._reason());
                } else {
                  ret._cancel();
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            if (!ret._isFateSealed()) {
              if (holder.asyncNeeded) {
                var domain = getDomain();
                if (domain !== null) {
                  holder.fn = util2.domainBind(domain, holder.fn);
                }
              }
              ret._setAsyncGuaranteed();
              ret._setOnCancel(holder);
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0; $_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn) args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== void 0 ? ret.spread(fn) : ret;
    };
  };
  return join;
}
var map2;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map2;
  hasRequiredMap = 1;
  map2 = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise2._getDomain;
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    function MappingPromiseArray(promises2, fn, limit, _filter) {
      this.constructor$(promises2);
      this._promise._captureStackTrace();
      var domain = getDomain();
      this._callback = domain === null ? fn : util2.domainBind(domain, fn);
      this._preservedValues = _filter === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit;
      this._inFlight = 0;
      this._queue = [];
      async2.invoke(this._asyncInit, this, void 0);
    }
    util2.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    };
    MappingPromiseArray.prototype._init = function() {
    };
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var values2 = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit = this._limit;
      if (index < 0) {
        index = index * -1 - 1;
        values2[index] = value;
        if (limit >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved()) return true;
        }
      } else {
        if (limit >= 1 && this._inFlight >= limit) {
          values2[index] = value;
          this._queue.push(index);
          return false;
        }
        if (preservedValues !== null) preservedValues[index] = value;
        var promise2 = this._promise;
        var callback = this._callback;
        var receiver = promise2._boundValue();
        promise2._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        var promiseCreated = promise2._popContext();
        debug.checkForgottenReturns(
          ret,
          promiseCreated,
          preservedValues !== null ? "Promise.filter" : "Promise.map",
          promise2
        );
        if (ret === errorObj) {
          this._reject(ret.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          if ((bitField & 50397184) === 0) {
            if (limit >= 1) this._inFlight++;
            values2[index] = maybePromise;
            maybePromise._proxy(this, (index + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values2[index] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values2, preservedValues);
        } else {
          this._resolve(values2);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue2 = this._queue;
      var limit = this._limit;
      var values2 = this._values;
      while (queue2.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue2.pop();
        this._promiseFulfilled(values2[index], index);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values2) {
      var len = values2.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values2[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map3(promises2, fn, options2, _filter) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var limit = 0;
      if (options2 !== void 0) {
        if (typeof options2 === "object" && options2 !== null) {
          if (typeof options2.concurrency !== "number") {
            return Promise2.reject(
              new TypeError("'concurrency' must be a number but it is " + util2.classString(options2.concurrency))
            );
          }
          limit = options2.concurrency;
        } else {
          return Promise2.reject(new TypeError(
            "options argument must be an object but it is " + util2.classString(options2)
          ));
        }
      }
      limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
      return new MappingPromiseArray(promises2, fn, limit, _filter).promise();
    }
    Promise2.prototype.map = function(fn, options2) {
      return map3(this, fn, options2, null);
    };
    Promise2.map = function(promises2, fn, options2, _filter) {
      return map3(promises2, fn, options2, _filter);
    };
  };
  return map2;
}
var call_get;
var hasRequiredCall_get;
function requireCall_get() {
  if (hasRequiredCall_get) return call_get;
  hasRequiredCall_get = 1;
  var cr = Object.create;
  if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  call_get = function(Promise2) {
    var util2 = requireUtil();
    var canEvaluate = util2.canEvaluate;
    var isIdentifier = util2.isIdentifier;
    var getMethodCaller;
    var getGetter;
    {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", "                                    \n	        return function(obj) {                                               \n	            'use strict'                                                     \n	            var len = this.length;                                           \n	            ensureMethod(obj, 'methodName');                                 \n	            switch(len) {                                                    \n	                case 1: return obj.methodName(this[0]);                      \n	                case 2: return obj.methodName(this[0], this[1]);             \n	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n	                case 0: return obj.methodName();                             \n	                default:                                                     \n	                    return obj.methodName.apply(obj, this);                  \n	            }                                                                \n	        };                                                                   \n	        ".replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter2 = function(propertyName) {
        return new Function("obj", "                                             \n	        'use strict';                                                        \n	        return obj.propertyName;                                             \n	        ".replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys2 = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys2[i]];
            cache[" size"] = keys2.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter2, getterCache);
      };
    }
    function ensureMethod(obj, methodName) {
      var fn;
      if (obj != null) fn = obj[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util2.classString(obj) + " has no method '" + util2.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj) {
      var methodName = this.pop();
      var fn = ensureMethod(obj, methodName);
      return fn.apply(obj, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1; $_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(
              maybeCaller,
              void 0,
              void 0,
              args,
              void 0
            );
          }
        }
      }
      args.push(methodName);
      return this._then(caller, void 0, void 0, args, void 0);
    };
    function namedGetter(obj) {
      return obj[this];
    }
    function indexedGetter(obj) {
      var index = +this;
      if (index < 0) index = Math.max(0, index + obj.length);
      return obj[index];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, void 0, void 0, propertyName, void 0);
    };
  };
  return call_get;
}
var using;
var hasRequiredUsing;
function requireUsing() {
  if (hasRequiredUsing) return using;
  hasRequiredUsing = 1;
  using = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util2 = requireUtil();
    var TypeError2 = requireErrors$1().TypeError;
    var inherits = requireUtil().inherits;
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var NULL = {};
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = new Promise2(INTERNAL);
      function iterator() {
        if (i >= len) return ret._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(
              maybePromise._getDisposer().tryDispose(inspection),
              resources.promise
            );
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(
              iterator,
              thrower,
              null,
              null,
              null
            );
          }
        }
        iterator();
      }
      iterator();
      return ret;
    }
    function Disposer(data, promise2, context2) {
      this._data = data;
      this._promise = promise2;
      this._context = context2;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context2 = this._context;
      if (context2 !== void 0) context2._pushContext();
      var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
      if (context2 !== void 0) context2._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise2, context2) {
      this.constructor$(fn, promise2, context2);
    }
    inherits(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0; i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2) return apiRejection(
        "you must pass at least 2 arguments to Promise.using"
      );
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0; i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, void 0);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0; i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0; i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj.e = inspection.error();
            return errorObj;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise2._pushContext();
        fn = tryCatch(fn);
        var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
        var promiseCreated = promise2._popContext();
        debug.checkForgottenReturns(
          ret,
          promiseCreated,
          "Promise.using",
          promise2
        );
        return ret;
      });
      var promise2 = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise2;
      promise2._setOnCancel(resources);
      return promise2;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & -131073;
      this._disposer = void 0;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2();
    };
  };
  return using;
}
var timers;
var hasRequiredTimers;
function requireTimers() {
  if (hasRequiredTimers) return timers;
  hasRequiredTimers = 1;
  timers = function(Promise2, INTERNAL, debug) {
    var util2 = requireUtil();
    var TimeoutError = Promise2.TimeoutError;
    function HandleWrapper(handle) {
      this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay2(+this).thenReturn(value);
    };
    var delay2 = Promise2.delay = function(ms, value) {
      var ret;
      var handle;
      if (value !== void 0) {
        ret = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
        if (debug.cancellation() && value instanceof Promise2) {
          ret._setOnCancel(value);
        }
      } else {
        ret = new Promise2(INTERNAL);
        handle = setTimeout(function() {
          ret._fulfill();
        }, +ms);
        if (debug.cancellation()) {
          ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
      }
      ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.prototype.delay = function(ms) {
      return delay2(ms, this);
    };
    var afterTimeout = function(promise2, message, parent) {
      var err;
      if (typeof message !== "string") {
        if (message instanceof Error) {
          err = message;
        } else {
          err = new TimeoutError("operation timed out");
        }
      } else {
        err = new TimeoutError(message);
      }
      util2.markAsOriginatingFromRejection(err);
      promise2._attachExtraTrace(err);
      promise2._reject(err);
      if (parent != null) {
        parent.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms, message) {
      ms = +ms;
      var ret, parent;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
          afterTimeout(ret, message, parent);
        }
      }, ms));
      if (debug.cancellation()) {
        parent = this.then();
        ret = parent._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
        ret._setOnCancel(handleWrapper);
      } else {
        ret = this._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
      }
      return ret;
    };
  };
  return timers;
}
var generators;
var hasRequiredGenerators;
function requireGenerators() {
  if (hasRequiredGenerators) return generators;
  hasRequiredGenerators = 1;
  generators = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors2 = requireErrors$1();
    var TypeError2 = errors2.TypeError;
    var util2 = requireUtil();
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0; i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result2 = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result2 === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result2, traceParent);
        if (maybePromise instanceof Promise2) return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      if (debug.cancellation()) {
        var internal = new Promise2(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
        this._promise = internal.lastly(function() {
          return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
      } else {
        var promise2 = this._promise = new Promise2(INTERNAL);
        promise2._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = void 0;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util2.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved()) return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result2;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError(
          "generator .return() sentinel"
        );
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result2 = tryCatch(this._generator["throw"]).call(
          this._generator,
          reason
        );
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result2 = tryCatch(this._generator["return"]).call(
          this._generator,
          void 0
        );
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result2);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result2 = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result2);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result2 = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result2);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise2 = this._yieldedPromise;
        this._yieldedPromise = null;
        promise2.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = void 0;
      this._promiseFulfilled(void 0);
    };
    PromiseSpawn.prototype._continue = function(result2) {
      var promise2 = this._promise;
      if (result2 === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._rejectCallback(result2.e, false);
        }
      }
      var value = result2.value;
      if (result2.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(
            maybePromise,
            this._yieldHandlers,
            this._promise
          );
          if (maybePromise === null) {
            this._promiseRejected(
              new TypeError2(
                "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
              )
            );
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(
            this._promiseFulfilled,
            this,
            maybePromise._value()
          );
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(
            this._promiseRejected,
            this,
            maybePromise._reason()
          );
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options2) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var yieldHandler = Object(options2).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(
          void 0,
          void 0,
          yieldHandler,
          stack
        );
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(void 0);
        return ret;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
  return generators;
}
var nodeify;
var hasRequiredNodeify;
function requireNodeify() {
  if (hasRequiredNodeify) return nodeify;
  hasRequiredNodeify = 1;
  nodeify = function(Promise2) {
    var util2 = requireUtil();
    var async2 = Promise2._async;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function spreadAdapter(val, nodeback2) {
      var promise2 = this;
      if (!util2.isArray(val)) return successAdapter.call(promise2, val, nodeback2);
      var ret = tryCatch(nodeback2).apply(promise2._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback2) {
      var promise2 = this;
      var receiver = promise2._boundValue();
      var ret = val === void 0 ? tryCatch(nodeback2).call(receiver, null) : tryCatch(nodeback2).call(receiver, null, val);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback2) {
      var promise2 = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback2).call(promise2._boundValue(), reason);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback2, options2) {
      if (typeof nodeback2 == "function") {
        var adapter = successAdapter;
        if (options2 !== void 0 && Object(options2).spread) {
          adapter = spreadAdapter;
        }
        this._then(
          adapter,
          errorAdapter,
          void 0,
          this,
          nodeback2
        );
      }
      return this;
    };
  };
  return nodeify;
}
var promisify;
var hasRequiredPromisify;
function requirePromisify() {
  if (hasRequiredPromisify) return promisify;
  hasRequiredPromisify = 1;
  promisify = function(Promise2, INTERNAL) {
    var THIS = {};
    var util2 = requireUtil();
    var nodebackForPromise = requireNodeback();
    var withAppended = util2.withAppended;
    var maybeWrapAsError = util2.maybeWrapAsError;
    var canEvaluate = util2.canEvaluate;
    var TypeError2 = requireErrors$1().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util2.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj, key, suffix) {
      var val = util2.getDataPropertyOrDefault(
        obj,
        key + suffix,
        defaultPromisified
      );
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0; j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter2) {
      var keys2 = util2.inheritedDataKeys(obj);
      var ret = [];
      for (var i = 0; i < keys2.length; ++i) {
        var key = keys2[i];
        var value = obj[key];
        var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter2(key, value, obj, passesDefaultFilter)) {
          ret.push(key, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str) {
      return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min2 = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1; i >= min2; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util2.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util2.filledRange(
          Math.max(parameterCount2, 3),
          "_arg",
          ""
        );
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _2, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
          } else {
            ret = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
          }
          return ret.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += "                                                             \n	        default:                                                             \n	            var args = new Array(len + 1);                                   \n	            var i = 0;                                                       \n	            for (var i = 0; i < len; ++i) {                                  \n	               args[i] = arguments[i];                                       \n	            }                                                                \n	            args[i] = nodeback;                                              \n	            [CodeForCall]                                                    \n	            break;                                                           \n	        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body = "'use strict';                                                \n	        var ret = function (Parameters) {                                    \n	            'use strict';                                                    \n	            var len = arguments.length;                                      \n	            var promise = new Promise(INTERNAL);                             \n	            promise._captureStackTrace();                                    \n	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n	            var ret;                                                         \n	            var callback = tryCatch([GetFunctionCode]);                      \n	            switch(len) {                                                    \n	                [CodeForSwitchCase]                                          \n	            }                                                                \n	            if (ret === errorObj) {                                          \n	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n	            }                                                                \n	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n	            return promise;                                                  \n	        };                                                                   \n	        notEnumerableProp(ret, '__isPromisified__', true);                   \n	        return ret;                                                          \n	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function(
          "Promise",
          "fn",
          "receiver",
          "withAppended",
          "maybeWrapAsError",
          "nodebackForPromise",
          "tryCatch",
          "errorObj",
          "notEnumerableProp",
          "INTERNAL",
          body
        )(
          Promise2,
          fn,
          receiver,
          withAppended,
          maybeWrapAsError,
          nodebackForPromise,
          util2.tryCatch,
          util2.errorObj,
          util2.notEnumerableProp,
          INTERNAL
        );
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _2, fn, __, multiArgs) {
      var defaultThis = /* @__PURE__ */ (function() {
        return this;
      })();
      var method2 = callback;
      if (typeof method2 === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise2 = new Promise2(INTERNAL);
        promise2._captureStackTrace();
        var cb2 = typeof method2 === "string" && this !== defaultThis ? this[method2] : callback;
        var fn2 = nodebackForPromise(promise2, multiArgs);
        try {
          cb2.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise2._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise2._isFateSealed()) promise2._setAsyncGuaranteed();
        return promise2;
      }
      util2.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj, suffix, filter2, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter2);
      for (var i = 0, len = methods.length; i < len; i += 2) {
        var key = methods[i];
        var fn = methods[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(
              key,
              THIS,
              key,
              fn,
              suffix,
              multiArgs
            );
          });
          util2.notEnumerableProp(promisified, "__isPromisified__", true);
          obj[promisifiedKey] = promisified;
        }
      }
      util2.toFastProperties(obj);
      return obj;
    }
    function promisify2(callback, receiver, multiArgs) {
      return makeNodePromisified(
        callback,
        receiver,
        void 0,
        callback,
        null,
        multiArgs
      );
    }
    Promise2.promisify = function(fn, options2) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options2 = Object(options2);
      var receiver = options2.context === void 0 ? THIS : options2.context;
      var multiArgs = !!options2.multiArgs;
      var ret = promisify2(fn, receiver, multiArgs);
      util2.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target, options2) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      options2 = Object(options2);
      var multiArgs = !!options2.multiArgs;
      var suffix = options2.suffix;
      if (typeof suffix !== "string") suffix = defaultSuffix;
      var filter2 = options2.filter;
      if (typeof filter2 !== "function") filter2 = defaultFilter;
      var promisifier = options2.promisifier;
      if (typeof promisifier !== "function") promisifier = makeNodePromisified;
      if (!util2.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
      }
      var keys2 = util2.inheritedDataKeys(target);
      for (var i = 0; i < keys2.length; ++i) {
        var value = target[keys2[i]];
        if (keys2[i] !== "constructor" && util2.isClass(value)) {
          promisifyAll(
            value.prototype,
            suffix,
            filter2,
            promisifier,
            multiArgs
          );
          promisifyAll(value, suffix, filter2, promisifier, multiArgs);
        }
      }
      return promisifyAll(target, suffix, filter2, promisifier, multiArgs);
    };
  };
  return promisify;
}
var props;
var hasRequiredProps;
function requireProps() {
  if (hasRequiredProps) return props;
  hasRequiredProps = 1;
  props = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil();
    var isObject2 = util2.isObject;
    var es52 = requireEs5();
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;
    var mapToEntries = /* @__PURE__ */ (function() {
      var index = 0;
      var size2 = 0;
      function extractEntry(value, key) {
        this[index] = value;
        this[index + size2] = key;
        index++;
      }
      return function mapToEntries2(map3) {
        size2 = map3.size;
        index = 0;
        var ret = new Array(map3.size * 2);
        map3.forEach(extractEntry, ret);
        return ret;
      };
    })();
    var entriesToMap = function(entries) {
      var ret = new Es6Map();
      var length = entries.length / 2 | 0;
      for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
      }
      return ret;
    };
    function PropertiesPromiseArray(obj) {
      var isMap2 = false;
      var entries;
      if (Es6Map !== void 0 && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap2 = true;
      } else {
        var keys2 = es52.keys(obj);
        var len = keys2.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
          var key = keys2[i];
          entries[i] = obj[key];
          entries[i + len] = key;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap2;
      this._init$(void 0, -3);
    }
    util2.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {
    };
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
      this._values[index] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props2(promises2) {
      var ret;
      var castValue = tryConvertToPromise(promises2);
      if (!isObject2(castValue)) {
        return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(
          Promise2.props,
          void 0,
          void 0,
          void 0,
          void 0
        );
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 2);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props2(this);
    };
    Promise2.props = function(promises2) {
      return props2(promises2);
    };
  };
  return props;
}
var race;
var hasRequiredRace;
function requireRace() {
  if (hasRequiredRace) return race;
  hasRequiredRace = 1;
  race = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil();
    var raceLater = function(promise2) {
      return promise2.then(function(array) {
        return race2(array, promise2);
      });
    };
    function race2(promises2, parent) {
      var maybePromise = tryConvertToPromise(promises2);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises2 = util2.asArray(promises2);
        if (promises2 === null)
          return apiRejection("expecting an array or an iterable object but got " + util2.classString(promises2));
      }
      var ret = new Promise2(INTERNAL);
      if (parent !== void 0) {
        ret._propagateFrom(parent, 3);
      }
      var fulfill = ret._fulfill;
      var reject2 = ret._reject;
      for (var i = 0, len = promises2.length; i < len; ++i) {
        var val = promises2[i];
        if (val === void 0 && !(i in promises2)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject2, void 0, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises2) {
      return race2(promises2, void 0);
    };
    Promise2.prototype.race = function() {
      return race2(this, void 0);
    };
  };
  return race;
}
var reduce;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce) return reduce;
  hasRequiredReduce = 1;
  reduce = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise2._getDomain;
    var util2 = requireUtil();
    var tryCatch = util2.tryCatch;
    function ReductionPromiseArray(promises2, fn, initialValue, _each) {
      this.constructor$(promises2);
      var domain = getDomain();
      this._fn = domain === null ? fn : util2.domainBind(domain, fn);
      if (initialValue !== void 0) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = void 0;
      }
      this._promise._captureStackTrace();
      this._init$(void 0, -5);
    }
    util2.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {
    };
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue) return this._cancel();
      if (this._isResolved()) return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values2) {
      this._values = values2;
      var value;
      var i;
      var length = values2.length;
      if (this._initialValue !== void 0) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values2[0]);
        i = 1;
      }
      this._currentCancellable = value;
      if (!value.isRejected()) {
        for (; i < length; ++i) {
          var ctx = {
            accum: null,
            value: values2[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, void 0, void 0, ctx, void 0);
        }
      }
      if (this._eachValues !== void 0) {
        value = value._then(this._eachComplete, void 0, void 0, this, void 0);
      }
      value._then(completed, completed, void 0, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce2(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises2, fn, initialValue, _each) {
      return reduce2(promises2, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
      if (this.isFulfilled()) {
        array._resolve(valueOrReason);
      } else {
        array._reject(valueOrReason);
      }
    }
    function reduce2(promises2, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var array = new ReductionPromiseArray(promises2, fn, initialValue, _each);
      return array.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, void 0, void 0, this, void 0);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array = this.array;
      var promise2 = array._promise;
      var fn = tryCatch(array._fn);
      promise2._pushContext();
      var ret;
      if (array._eachValues !== void 0) {
        ret = fn.call(promise2._boundValue(), value, this.index, this.length);
      } else {
        ret = fn.call(
          promise2._boundValue(),
          this.accum,
          value,
          this.index,
          this.length
        );
      }
      if (ret instanceof Promise2) {
        array._currentCancellable = ret;
      }
      var promiseCreated = promise2._popContext();
      debug.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
        promise2
      );
      return ret;
    }
  };
  return reduce;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle) return settle;
  hasRequiredSettle = 1;
  settle = function(Promise2, PromiseArray, debug) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util2 = requireUtil();
    function SettledPromiseArray(values2) {
      this.constructor$(values2);
    }
    util2.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
      this._values[index] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
      var ret = new PromiseInspection();
      ret._bitField = 33554432;
      ret._settledValueField = value;
      return this._promiseResolved(index, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
      var ret = new PromiseInspection();
      ret._bitField = 16777216;
      ret._settledValueField = reason;
      return this._promiseResolved(index, ret);
    };
    Promise2.settle = function(promises2) {
      debug.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises2).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
  return settle;
}
var some;
var hasRequiredSome;
function requireSome() {
  if (hasRequiredSome) return some;
  hasRequiredSome = 1;
  some = function(Promise2, PromiseArray, apiRejection) {
    var util2 = requireUtil();
    var RangeError2 = requireErrors$1().RangeError;
    var AggregateError = requireErrors$1().AggregateError;
    var isArray2 = util2.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values2) {
      this.constructor$(values2);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util2.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(void 0, -5);
      var isArrayResolved = isArray2(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some2(promises2, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
      }
      var ret = new SomePromiseArray(promises2);
      var promise2 = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise2;
    }
    Promise2.some = function(promises2, howMany) {
      return some2(promises2, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some2(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
  return some;
}
var filter;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter;
  hasRequiredFilter = 1;
  filter = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options2) {
      return PromiseMap(this, fn, options2, INTERNAL);
    };
    Promise2.filter = function(promises2, fn, options2) {
      return PromiseMap(promises2, fn, options2, INTERNAL);
    };
  };
  return filter;
}
var each;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach) return each;
  hasRequiredEach = 1;
  each = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises2, fn) {
      return PromiseReduce(promises2, fn, INTERNAL, INTERNAL);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise2.each = function(promises2, fn) {
      return PromiseReduce(promises2, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises2, void 0);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
  return each;
}
var any;
var hasRequiredAny;
function requireAny() {
  if (hasRequiredAny) return any;
  hasRequiredAny = 1;
  any = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any2(promises2) {
      var ret = new SomePromiseArray(promises2);
      var promise2 = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise2;
    }
    Promise2.any = function(promises2) {
      return any2(promises2);
    };
    Promise2.prototype.any = function() {
      return any2(this);
    };
  };
  return any;
}
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise.exports;
  hasRequiredPromise = 1;
  (function(module2) {
    module2.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util2 = requireUtil();
      var getDomain;
      if (util2.isNode) {
        getDomain = function() {
          var ret = process$1.domain;
          if (ret === void 0) ret = null;
          return ret;
        };
      } else {
        getDomain = function() {
          return null;
        };
      }
      util2.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = requireEs5();
      var Async = requireAsync();
      var async2 = new Async();
      es52.defineProperty(Promise2, "_async", { value: async2 });
      var errors2 = requireErrors$1();
      var TypeError2 = Promise2.TypeError = errors2.TypeError;
      Promise2.RangeError = errors2.RangeError;
      var CancellationError = Promise2.CancellationError = errors2.CancellationError;
      Promise2.TimeoutError = errors2.TimeoutError;
      Promise2.OperationalError = errors2.OperationalError;
      Promise2.RejectionError = errors2.OperationalError;
      Promise2.AggregateError = errors2.AggregateError;
      var INTERNAL = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = requireThenables()(Promise2, INTERNAL);
      var PromiseArray = requirePromise_array()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        Proxyable
      );
      var Context = requireContext()(Promise2);
      var createContext = Context.create;
      var debug = requireDebuggability()(Promise2, Context);
      debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
      var catchFilter = requireCatch_filter()(NEXT_FILTER);
      var nodebackForPromise = requireNodeback();
      var errorObj = util2.errorObj;
      var tryCatch = util2.tryCatch;
      function check(self2, executor) {
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(executor));
        }
        if (self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
      }
      function Promise2(executor) {
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        if (executor !== INTERNAL) {
          check(this, executor);
          this._resolveFromExecutor(executor);
        }
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util2.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("expecting an object but got A catch statement predicate " + util2.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(
          reflectHandler,
          reflectHandler,
          void 0,
          this,
          void 0
        );
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util2.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util2.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise2 = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise2._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util2.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret.fulfillmentValue = this.value();
          ret.isFulfilled = true;
        } else if (this.isRejected()) {
          ret.rejectionReason = this.reason();
          ret.isRejected = true;
        }
        return ret;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util2.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result2 = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
        if (result2 === errorObj) {
          ret._rejectCallback(result2.e, true);
        }
        if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
        return ret;
      };
      Promise2.all = function(promises2) {
        return new PromiseArray(promises2).promise();
      };
      Promise2.cast = function(obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise2)) {
          ret = new Promise2(INTERNAL);
          ret._captureStackTrace();
          ret._setFulfilled();
          ret._rejectionHandler0 = obj;
        }
        return ret;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(fn));
        }
        return async2.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _2, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise2 = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise2._propagateFrom(this, 3);
          promise2._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise2);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
          }
          async2.invoke(settler, target, {
            handler: domain === null ? handler : typeof handler === "function" && util2.domainBind(domain, handler),
            promise: promise2,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise2, receiver, domain);
        }
        return promise2;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & -65537;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async2.hasCustomScheduler()) return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index) {
        var ret = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret;
      };
      Promise2.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject2 = follower._rejectionHandler0;
        var promise2 = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject2, promise2, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject2 = follower._rejectionHandlerAt(index);
        var promise2 = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === void 0) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject2, promise2, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject2, promise2, receiver, domain) {
        var index = this._length();
        if (index >= 65535 - 4) {
          index = 0;
          this._setLength(0);
        }
        if (index === 0) {
          this._promise0 = promise2;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain === null ? fulfill : util2.domainBind(domain, fulfill);
          }
          if (typeof reject2 === "function") {
            this._rejectionHandler0 = domain === null ? reject2 : util2.domainBind(domain, reject2);
          }
        } else {
          var base2 = index * 4 - 4;
          this[base2 + 2] = promise2;
          this[base2 + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base2 + 0] = domain === null ? fulfill : util2.domainBind(domain, fulfill);
          }
          if (typeof reject2 === "function") {
            this[base2 + 1] = domain === null ? reject2 : util2.domainBind(domain, reject2);
          }
        }
        this._setLength(index + 1);
        return index;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0) return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2)) return this._fulfill(value);
        if (shouldBind) this._propagateFrom(maybePromise, 2);
        var promise2 = maybePromise._target();
        if (promise2 === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise2._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0) promise2._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise2._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise2);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise2._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise2._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise2._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util2.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util2.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        var promise2 = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise2._resolveCallback(value);
        }, function(reason) {
          promise2._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise2._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise2) {
        var bitField = promise2._bitField;
        if ((bitField & 65536) !== 0) return;
        promise2._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError2("cannot .spread() a non-array: " + util2.classString(value));
          } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch(handler).call(receiver, value);
        }
        var promiseCreated = promise2._popContext();
        bitField = promise2._bitField;
        if ((bitField & 65536) !== 0) return;
        if (x === NEXT_FILTER) {
          promise2._reject(value);
        } else if (x === errorObj) {
          promise2._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise2, this);
          promise2._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise2) {
        this._rejectionHandler0 = promise2;
      };
      Promise2.prototype._settlePromise = function(promise2, handler, receiver, value) {
        var isPromise = promise2 instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise) promise2._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise2;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
              promise2._reject(errorObj.e);
            }
          } else if (handler === reflectHandler) {
            promise2._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise2);
          } else if (isPromise || promise2 instanceof PromiseArray) {
            promise2._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver, value, promise2);
          } else {
            if (asyncGuaranteed) promise2._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise2);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise2);
            } else {
              receiver._promiseRejected(value, promise2);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed) promise2._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise2._fulfill(value);
          } else {
            promise2._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise2 = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise2 instanceof Promise2)) {
            handler.call(receiver, value, promise2);
          } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise2);
          }
        } else if (promise2 instanceof Promise2) {
          promise2._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise2 = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise2, handler, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index) {
        var base2 = index * 4 - 4;
        this[base2 + 2] = this[base2 + 3] = this[base2 + 0] = this[base2 + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async2.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async2.fatalError(reason, util2.isNode);
        }
        if ((bitField & 65535) > 0) {
          async2.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler = this._fulfillmentHandlerAt(i);
          var promise2 = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise2, handler, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler = this._rejectionHandlerAt(i);
          var promise2 = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise2, handler, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise2 = new Promise2(INTERNAL);
        return {
          promise: promise2,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util2.notEnumerableProp(
        Promise2,
        "_makeSelfResolutionError",
        makeSelfResolutionError
      );
      requireMethod()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        debug
      );
      requireBind()(Promise2, INTERNAL, tryConvertToPromise, debug);
      requireCancel()(Promise2, PromiseArray, apiRejection, debug);
      requireDirect_resolve()(Promise2);
      requireSynchronous_inspection()(Promise2);
      requireJoin()(
        Promise2,
        PromiseArray,
        tryConvertToPromise,
        INTERNAL,
        async2,
        getDomain
      );
      Promise2.Promise = Promise2;
      Promise2.version = "3.4.7";
      requireMap()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      requireCall_get()(Promise2);
      requireUsing()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
      requireTimers()(Promise2, INTERNAL, debug);
      requireGenerators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
      requireNodeify()(Promise2);
      requirePromisify()(Promise2, INTERNAL);
      requireProps()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      requireRace()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      requireReduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      requireSettle()(Promise2, PromiseArray, debug);
      requireSome()(Promise2, PromiseArray, apiRejection);
      requireFilter()(Promise2, INTERNAL);
      requireEach()(Promise2, INTERNAL);
      requireAny()(Promise2);
      util2.toFastProperties(Promise2);
      util2.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug.setBounds(Async.firstLineError, util2.lastLineError);
      return Promise2;
    };
  })(promise);
  return promise.exports;
}
var hasRequiredPromises;
function requirePromises() {
  if (hasRequiredPromises) return promises;
  hasRequiredPromises = 1;
  var _2 = require$$0;
  var bluebird = requirePromise()();
  promises.defer = defer2;
  promises.when = bluebird.resolve;
  promises.resolve = bluebird.resolve;
  promises.all = bluebird.all;
  promises.props = bluebird.props;
  promises.reject = bluebird.reject;
  promises.promisify = bluebird.promisify;
  promises.mapSeries = bluebird.mapSeries;
  promises.attempt = bluebird.attempt;
  promises.nfcall = function(func) {
    var args = Array.prototype.slice.call(arguments, 1);
    var promisedFunc = bluebird.promisify(func);
    return promisedFunc.apply(null, args);
  };
  bluebird.prototype.fail = bluebird.prototype.caught;
  bluebird.prototype.also = function(func) {
    return this.then(function(value) {
      var returnValue = _2.extend({}, value, func(value));
      return bluebird.props(returnValue);
    });
  };
  function defer2() {
    var resolve;
    var reject2;
    var promise2 = new bluebird.Promise(function(resolveArg, rejectArg) {
      resolve = resolveArg;
      reject2 = rejectArg;
    });
    return {
      resolve,
      reject: reject2,
      promise: promise2
    };
  }
  return promises;
}
var documents = {};
var hasRequiredDocuments;
function requireDocuments() {
  if (hasRequiredDocuments) return documents;
  hasRequiredDocuments = 1;
  var _2 = require$$0;
  var types = documents.types = {
    document: "document",
    paragraph: "paragraph",
    run: "run",
    text: "text",
    tab: "tab",
    checkbox: "checkbox",
    hyperlink: "hyperlink",
    noteReference: "noteReference",
    image: "image",
    note: "note",
    commentReference: "commentReference",
    comment: "comment",
    table: "table",
    tableRow: "tableRow",
    tableCell: "tableCell",
    "break": "break",
    bookmarkStart: "bookmarkStart"
  };
  function Document2(children, options2) {
    options2 = options2 || {};
    return {
      type: types.document,
      children,
      notes: options2.notes || new Notes({}),
      comments: options2.comments || []
    };
  }
  function Paragraph2(children, properties) {
    properties = properties || {};
    var indent = properties.indent || {};
    return {
      type: types.paragraph,
      children,
      styleId: properties.styleId || null,
      styleName: properties.styleName || null,
      numbering: properties.numbering || null,
      alignment: properties.alignment || null,
      indent: {
        start: indent.start || null,
        end: indent.end || null,
        firstLine: indent.firstLine || null,
        hanging: indent.hanging || null
      }
    };
  }
  function Run(children, properties) {
    properties = properties || {};
    return {
      type: types.run,
      children,
      styleId: properties.styleId || null,
      styleName: properties.styleName || null,
      isBold: !!properties.isBold,
      isUnderline: !!properties.isUnderline,
      isItalic: !!properties.isItalic,
      isStrikethrough: !!properties.isStrikethrough,
      isAllCaps: !!properties.isAllCaps,
      isSmallCaps: !!properties.isSmallCaps,
      verticalAlignment: properties.verticalAlignment || verticalAlignment.baseline,
      font: properties.font || null,
      fontSize: properties.fontSize || null,
      highlight: properties.highlight || null
    };
  }
  var verticalAlignment = {
    baseline: "baseline",
    superscript: "superscript",
    subscript: "subscript"
  };
  function Text2(value) {
    return {
      type: types.text,
      value
    };
  }
  function Tab() {
    return {
      type: types.tab
    };
  }
  function Checkbox(options2) {
    return {
      type: types.checkbox,
      checked: options2.checked
    };
  }
  function Hyperlink(children, options2) {
    return {
      type: types.hyperlink,
      children,
      href: options2.href,
      anchor: options2.anchor,
      targetFrame: options2.targetFrame
    };
  }
  function NoteReference(options2) {
    return {
      type: types.noteReference,
      noteType: options2.noteType,
      noteId: options2.noteId
    };
  }
  function Notes(notes) {
    this._notes = _2.indexBy(notes, function(note) {
      return noteKey(note.noteType, note.noteId);
    });
  }
  Notes.prototype.resolve = function(reference) {
    return this.findNoteByKey(noteKey(reference.noteType, reference.noteId));
  };
  Notes.prototype.findNoteByKey = function(key) {
    return this._notes[key] || null;
  };
  function Note(options2) {
    return {
      type: types.note,
      noteType: options2.noteType,
      noteId: options2.noteId,
      body: options2.body
    };
  }
  function commentReference(options2) {
    return {
      type: types.commentReference,
      commentId: options2.commentId
    };
  }
  function comment(options2) {
    return {
      type: types.comment,
      commentId: options2.commentId,
      body: options2.body,
      authorName: options2.authorName,
      authorInitials: options2.authorInitials
    };
  }
  function noteKey(noteType, id) {
    return noteType + "-" + id;
  }
  function Image2(options2) {
    return {
      type: types.image,
      // `read` is retained for backwards compatibility, but other read
      // methods should be preferred.
      read: function(encoding) {
        if (encoding) {
          return options2.readImage(encoding);
        } else {
          return options2.readImage().then(function(arrayBuffer) {
            return Buffer.from(arrayBuffer);
          });
        }
      },
      readAsArrayBuffer: function() {
        return options2.readImage();
      },
      readAsBase64String: function() {
        return options2.readImage("base64");
      },
      readAsBuffer: function() {
        return options2.readImage().then(function(arrayBuffer) {
          return Buffer.from(arrayBuffer);
        });
      },
      altText: options2.altText,
      contentType: options2.contentType
    };
  }
  function Table2(children, properties) {
    properties = properties || {};
    return {
      type: types.table,
      children,
      styleId: properties.styleId || null,
      styleName: properties.styleName || null
    };
  }
  function TableRow2(children, options2) {
    options2 = options2 || {};
    return {
      type: types.tableRow,
      children,
      isHeader: options2.isHeader || false
    };
  }
  function TableCell2(children, options2) {
    options2 = options2 || {};
    return {
      type: types.tableCell,
      children,
      colSpan: options2.colSpan == null ? 1 : options2.colSpan,
      rowSpan: options2.rowSpan == null ? 1 : options2.rowSpan
    };
  }
  function Break(breakType) {
    return {
      type: types["break"],
      breakType
    };
  }
  function BookmarkStart(options2) {
    return {
      type: types.bookmarkStart,
      name: options2.name
    };
  }
  documents.document = documents.Document = Document2;
  documents.paragraph = documents.Paragraph = Paragraph2;
  documents.run = documents.Run = Run;
  documents.text = documents.Text = Text2;
  documents.tab = documents.Tab = Tab;
  documents.checkbox = documents.Checkbox = Checkbox;
  documents.Hyperlink = Hyperlink;
  documents.noteReference = documents.NoteReference = NoteReference;
  documents.Notes = Notes;
  documents.Note = Note;
  documents.commentReference = commentReference;
  documents.comment = comment;
  documents.Image = Image2;
  documents.Table = Table2;
  documents.TableRow = TableRow2;
  documents.TableCell = TableCell2;
  documents.lineBreak = Break("line");
  documents.pageBreak = Break("page");
  documents.columnBreak = Break("column");
  documents.BookmarkStart = BookmarkStart;
  documents.verticalAlignment = verticalAlignment;
  return documents;
}
var results = {};
var hasRequiredResults;
function requireResults() {
  if (hasRequiredResults) return results;
  hasRequiredResults = 1;
  var _2 = require$$0;
  results.Result = Result;
  results.success = success;
  results.warning = warning;
  results.error = error;
  function Result(value, messages) {
    this.value = value;
    this.messages = messages || [];
  }
  Result.prototype.map = function(func) {
    return new Result(func(this.value), this.messages);
  };
  Result.prototype.flatMap = function(func) {
    var funcResult = func(this.value);
    return new Result(funcResult.value, combineMessages([this, funcResult]));
  };
  Result.prototype.flatMapThen = function(func) {
    var that = this;
    return func(this.value).then(function(otherResult) {
      return new Result(otherResult.value, combineMessages([that, otherResult]));
    });
  };
  Result.combine = function(results2) {
    var values2 = _2.flatten(_2.pluck(results2, "value"));
    var messages = combineMessages(results2);
    return new Result(values2, messages);
  };
  function success(value) {
    return new Result(value, []);
  }
  function warning(message) {
    return {
      type: "warning",
      message
    };
  }
  function error(exception) {
    return {
      type: "error",
      message: exception.message,
      error: exception
    };
  }
  function combineMessages(results2) {
    var messages = [];
    _2.flatten(_2.pluck(results2, "messages"), true).forEach(function(message) {
      if (!containsMessage(messages, message)) {
        messages.push(message);
      }
    });
    return messages;
  }
  function containsMessage(messages, message) {
    return _2.find(messages, isSameMessage.bind(null, message)) !== void 0;
  }
  function isSameMessage(first2, second) {
    return first2.type === second.type && first2.message === second.message;
  }
  return results;
}
var zipfile = {};
var base64Js = {};
var hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1;
  base64Js.byteLength = byteLength;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
      );
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(
        lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
      );
    }
    return parts.join("");
  }
  return base64Js;
}
var jszip_min = { exports: {} };
var hasRequiredJszip_min;
function requireJszip_min() {
  if (hasRequiredJszip_min) return jszip_min.exports;
  hasRequiredJszip_min = 1;
  (function(module2, exports) {
    !(function(e) {
      module2.exports = e();
    })(function() {
      return (function s(a, o, h2) {
        function u(r, e2) {
          if (!o[r]) {
            if (!a[r]) {
              var t = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e2 && t) return t(r, true);
              if (l) return l(r, true);
              var n = new Error("Cannot find module '" + r + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r] = { exports: {} };
            a[r][0].call(i.exports, function(e3) {
              var t2 = a[r][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h2);
          }
          return o[r].exports;
        }
        for (var l = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h2.length; e++) u(h2[e]);
        return u;
      })({ 1: [function(e, t, r) {
        var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r.encode = function(e2) {
          for (var t2, r2, n, i, s, a, o, h2 = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; ) f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h2.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h2.join("");
        }, r.decode = function(e2) {
          var t2, r2, n, i, s, a, o = 0, h2 = 0, u = "data:";
          if (e2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
          var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; ) t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h2++] = t2, 64 !== s && (l[h2++] = r2), 64 !== a && (l[h2++] = n);
          return l;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r2, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r2) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
        var n = e("./stream/GenericWorker");
        r.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
        var n = e("./utils");
        var o = (function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        })();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? (function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          })(0 | t2, e2, e2.length, 0) : (function(e3, t3, r2, n2) {
            var i = o, s = n2 + r2;
            e3 ^= -1;
            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          })(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r) {
        r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
      }, {}], 6: [function(e, t, r) {
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h2(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r.magic = "\b\0", s.inherits(h2, a), h2.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h2.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h2.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h2.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r.compressWorker = function(e2) {
          return new h2("Deflate", e2);
        }, r.uncompressWorker = function() {
          return new h2("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
        function A(e2, t2) {
          var r2, n2 = "";
          for (r2 = 0; r2 < t2; r2++) n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r2, n2, i2, s2) {
          var a, o, h2 = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h2.name)), c = I.transformTo("string", O.utf8encode(h2.name)), d = h2.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _2 = c.length !== h2.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h2.dir, k = h2.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S = 0;
          t2 && (S |= 8), l || !_2 && !g || (S |= 2048);
          var z = 0, C = 0;
          w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= (function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          })(h2.unixPermissions, w)) : (C = 20, z |= (function(e3) {
            return 63 & (e3 || 0);
          })(h2.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _2 && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
          var E = "";
          return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
        }
        var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
        function s(e2, t2, r2, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r2.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r2.dirRecord), t2) this.push({ data: (function(e3) {
            return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
          })(e2), meta: { percent: 100 } });
          else for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++) this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r2 = this.bytesWritten - e2, n2 = (function(e3, t3, r3, n3, i2) {
            var s2 = I.transformTo("string", i2(n3));
            return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          })(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2)) return false;
          for (var r2 = 0; r2 < t2.length; r2++) try {
            t2[r2].error(e2);
          } catch (e3) {
          }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++) e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h2 = 0;
          try {
            e2.forEach(function(e3, t3) {
              h2++;
              var r2 = (function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3) throw new Error(r3 + " is not a valid compression method !");
                return n3;
              })(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h2;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
        function n() {
          if (!(this instanceof n)) return new n();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this) "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r2 = n2.decompressed.getContentWorker().pipe(new a());
            r2.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h2 = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
            if (o.checkCRC32) for (var n2 = 0; n2 < r2.length; n2++) t2.push(f(r2[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
              var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h2.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h2.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h2.comment = t2.zipComment), h2;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
        var i = e("readable-stream").Readable;
        function n(e2, t2, r2) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
        t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
          if (Buffer.from && Buffer.from !== Uint8Array.from) return Buffer.from(e2, t2);
          if ("number" == typeof e2) throw new Error('The "data" argument must not be a number');
          return new Buffer(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer.alloc) return Buffer.alloc(e2);
          var t2 = new Buffer(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r) {
        function s(e2, t2, r2) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _2(e2)) && b.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h3 = new d(e2, o2, s2);
          this.files[e2] = h3;
        }
        var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _2 = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h2(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r2, n2;
          for (t2 in this.files) n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
        }, filter: function(r2) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r2(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r2) {
          if (1 !== arguments.length) return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
          if (h2(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r2) {
          if (!r2) return this;
          if (h2(r2)) return this.filter(function(e3, t3) {
            return t3.dir && r2.test(e3);
          });
          var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r2) {
          r2 = this.root + r2;
          var e2 = this.files[r2];
          if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir) delete this.files[r2];
          else for (var t2 = this.filter(function(e3, t3) {
            return t3.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t2.length; n2++) delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r2 = {};
          try {
            if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type) throw new Error("No output type specified.");
            u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
            var n2 = r2.comment || this.comment || "";
            t2 = o.generateWorker(this, r2, n2);
          } catch (e3) {
            (t2 = new l("error")).error(e3);
          }
          return new a(t2, r2.type || "string", r2.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++) e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2) return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r2 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--) r2 = (r2 << 8) + this.byteAt(t2);
          return this.index += e2, r2;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r) {
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2) return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h2 = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h2(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
        r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r) {
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished) return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2]) for (var r2 = 0; r2 < this._listeners[e2].length; r2++) this._listeners[e2][r2].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r) {
        var h2 = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream) try {
          o = e("../nodejs/NodejsStreamOutputAdapter");
        } catch (e2) {
        }
        function l(e2, o2) {
          return new a.Promise(function(t2, r2) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r2(e3);
            }).on("end", function() {
              try {
                var e3 = (function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h2.newBlob(h2.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h2.transformTo(e4, t3);
                  }
                })(s2, (function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                })(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r2(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r2) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r2, h2.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l(this, e2);
        }, on: function(e2, t2) {
          var r2 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r2, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h2.delay(t2, arguments, r2);
          }), this;
        }, resume: function() {
          return h2.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
        if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r.blob = false;
            }
          }
        }
        try {
          r.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        for (var o = e("./utils"), h2 = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h2.nodebuffer ? r.newBufferFrom(e2, "utf-8") : (function(e3) {
            var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
            for (t2 = h2.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
            return t2;
          })(e2);
        }, s.utf8decode = function(e2) {
          return h2.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : (function(e3) {
            var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r2 = 0; t2 < s2; ) if ((n2 = e3[t2++]) < 128) a2[r2++] = n2;
            else if (4 < (i2 = u[n2])) a2[r2++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; ) n2 = n2 << 6 | 63 & e3[t2++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
            return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
          })(e2 = o.transformTo(h2.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h2.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h2.uint8array) {
              var r2 = t2;
              (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
            } else t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = (function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          })(t2), i2 = t2;
          n2 !== t2.length && (h2.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        var o = e("./support"), h2 = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l(e2, t2) {
          for (var r2 = 0; r2 < e2.length; ++r2) t2[r2] = 255 & e2.charCodeAt(r2);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r2) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r2 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r2);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r2) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r2) return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; ) "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r2 = 0; r2 < e2.length; r2++) t2 += String.fromCharCode(e2[r2]);
          return t2;
        }, applyCanBeUsed: { uint8array: (function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        })(), nodebuffer: (function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        })() } };
        function s(e2) {
          var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t2; ) try {
            return i.stringifyByChunk(e2, r2, t2);
          } catch (e3) {
            t2 = Math.floor(t2 / 2);
          }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r2 = 0; r2 < e2.length; r2++) t2[r2] = e2[r2];
          return t2;
        }
        a.applyFromCharCode = s;
        var c = {};
        c.string = { string: n, array: function(e2) {
          return l(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l(e2, r.allocBuffer(e2.length));
        } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r.newBufferFrom(new Uint8Array(e2));
        } }, c.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r.newBufferFrom(e2);
        } }, c.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2) return t2;
          a.checkSupport(e2);
          var r2 = a.getTypeOf(t2);
          return c[r2][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
          }
          return r2.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()]) throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r2, n2 = "";
          for (r2 = 0; r2 < (e2 || "").length; r2++) n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r2) {
          setImmediate(function() {
            e2.apply(r2 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r2() {
          }
          r2.prototype = t2.prototype, e2.prototype = new r2();
        }, a.extend = function() {
          var e2, t2, r2 = {};
          for (e2 = 0; e2 < arguments.length; e2++) for (t2 in arguments[e2]) Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
          return r2;
        }, a.prepareContent = function(r2, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h2.decode(e3) : n2 && true !== i2 && (e3 = (function(e4) {
              return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            })(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h2(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h2.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r2 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r2), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r2);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++) t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r2 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r2;
          if (0 < n2) this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h2;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h2 = e("./compressions"), u = e("./support");
        function l(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r2;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = (function(e3) {
            for (var t3 in h2) if (Object.prototype.hasOwnProperty.call(h2, t3) && h2[t3].magic === e3) return h2[t3];
            return null;
          })(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; ) t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2) this.fileNameStr = t2;
            else {
              var r2 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r2);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2) this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
        function n(e2, t2, r2) {
          this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h2 = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r2 = "string";
          try {
            if (!e2) throw new Error("No output type specified.");
            var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
            "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h2("error")).error(e3);
          }
          return new s(t2, r2, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic) return this._data.getCompressedWorker();
          var r2 = this._decompressWorker();
          return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++) n.prototype[u[f]] = l;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
        (function(t2) {
          var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel) r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e3 = t2.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t2.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r = function() {
              o.port2.postMessage(0);
            };
          }
          var h2 = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r2 = h2.length; r2; ) {
              for (t3 = h2, h2 = [], e3 = -1; ++e3 < r2; ) t3[e3]();
              r2 = h2.length;
            }
            n = false;
          }
          l.exports = function(e3) {
            1 !== h2.push(e3) || n || r();
          };
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r) {
        var i = e("immediate");
        function u() {
        }
        var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2) throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
        }
        function h2(e2, t2, r2) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r2, n2) {
          i(function() {
            var e2;
            try {
              e2 = r2(n2);
            } catch (e3) {
              return l.reject(t2, e3);
            }
            e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
          });
        }
        function c(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2) return function() {
            t2.apply(e2, arguments);
          };
        }
        function d(t2, e2) {
          var r2 = false;
          function n2(e3) {
            r2 || (r2 = true, l.reject(t2, e3));
          }
          function i2(e3) {
            r2 || (r2 = true, l.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r2 = {};
          try {
            r2.value = e2(t2), r2.status = "success";
          } catch (e3) {
            r2.status = "error", r2.value = e3;
          }
          return r2;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2) return this;
          var r2 = this.constructor;
          return this.then(function(e2) {
            return r2.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r2.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s) return this;
          var r2 = new this.constructor(u);
          this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h2(r2, e2, t2));
          return r2;
        }, h2.prototype.callFulfilled = function(e2) {
          l.resolve(this.promise, e2);
        }, h2.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h2.prototype.callRejected = function(e2) {
          l.reject(this.promise, e2);
        }, h2.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l.resolve = function(e2, t2) {
          var r2 = p(c, t2);
          if ("error" === r2.status) return l.reject(e2, r2.value);
          var n2 = r2.value;
          if (n2) d(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; ) e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; ) e2.queue[r2].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this) return e2;
          return l.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l.reject(t2, e2);
        }, o.all = function(e2) {
          var r2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2) return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; ) h3(e2[t2], t2);
          return o2;
          function h3(e3, t3) {
            r2.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
          var r2 = e2.length, n2 = false;
          if (!r2) return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r2; ) a2 = e2[i2], t2.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l.reject(s2, e3));
          });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r) {
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
        var a = e("./zlib/deflate"), o = e("./utils/common"), h2 = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
        function p(e2) {
          if (!(this instanceof p)) return new p(e2);
          this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r2 !== l) throw new Error(i[r2]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h2.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l) throw new Error(i[r2]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r2 = new p(t2);
          if (r2.push(e2, true), r2.err) throw r2.msg || i[r2.err];
          return r2.result;
        }
        p.prototype.push = function(e2, t2) {
          var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended) return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h2.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l) return this.onEnd(r2), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
          return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
        var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _2 = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a)) return new a(e2);
          this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r2 = c.inflateInit2(this.strm, t2.windowBits);
          if (r2 !== m.Z_OK) throw new Error(n[r2]);
          this.header = new s(), c.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r2 = new a(t2);
          if (r2.push(e2, true), r2.err) throw r2.msg || n[r2.err];
          return r2.result;
        }
        a.prototype.push = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h2 = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
          if (this.ended) return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h2.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _2.call(e2) ? h2.input = new Uint8Array(e2) : h2.input = e2, h2.next_in = 0, h2.avail_in = h2.input.length;
          do {
            if (0 === h2.avail_out && (h2.output = new d.Buf8(u), h2.next_out = 0, h2.avail_out = u), (r2 = c.inflate(h2, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _2.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK) return this.onEnd(r2), !(this.ended = true);
            h2.next_out && (0 !== h2.avail_out && r2 !== m.Z_STREAM_END && (0 !== h2.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h2.output, h2.next_out), s2 = h2.next_out - i2, a2 = p.buf2string(h2.output, i2), h2.next_out = s2, h2.avail_out = u - s2, s2 && d.arraySet(h2.output, h2.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f = true);
          } while ((0 < h2.avail_in || 0 === h2.avail_out) && r2 !== m.Z_STREAM_END);
          return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h2.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r2 = t2.shift();
            if (r2) {
              if ("object" != typeof r2) throw new TypeError(r2 + "must be non-object");
              for (var n2 in r2) r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
            }
          }
          return e2;
        }, r.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r2, n2, i2) {
          if (t2.subarray && e2.subarray) e2.set(t2.subarray(r2, r2 + n2), i2);
          else for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          var t2, r2, n2, i2, s2, a;
          for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++) n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++) s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r2 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r.setTyped = function(e2) {
          e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
        }, r.setTyped(n);
      }, {}], 42: [function(e, t, r) {
        var h2 = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h2.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i)) return String.fromCharCode.apply(null, h2.shrinkBuf(e2, t2));
          for (var r2 = "", n2 = 0; n2 < t2; n2++) r2 += String.fromCharCode(e2[n2]);
          return r2;
        }
        u[254] = u[254] = 1, r.string2buf = function(e2) {
          var t2, r2, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = new h2.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }, r.buf2binstring = function(e2) {
          return l(e2, e2.length);
        }, r.binstring2buf = function(e2) {
          for (var t2 = new h2.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++) t2[r2] = e2.charCodeAt(r2);
          return t2;
        }, r.buf2string = function(e2, t2) {
          var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r2 = n2 = 0; r2 < a; ) if ((i2 = e2[r2++]) < 128) o[n2++] = i2;
          else if (4 < (s2 = u[i2])) o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; ) i2 = i2 << 6 | 63 & e2[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
          return l(o, n2);
        }, r.utf8border = function(e2, t2) {
          var r2;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); ) r2--;
          return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r) {
        t.exports = function(e2, t2, r2, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
            for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; ) ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r) {
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r) {
        var o = (function() {
          for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
            e2 = r2;
            for (var n = 0; n < 8; n++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r2] = e2;
          }
          return t2;
        })();
        t.exports = function(e2, t2, r2, n) {
          var i = o, s = n + r2;
          e2 ^= -1;
          for (var a = n; a < s; a++) e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r) {
        var h2, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _2 = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
        function R(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D(e2) {
          for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
        }
        function F(e2) {
          var t2 = e2.state, r2 = t2.pending;
          r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L(e2, t2) {
          var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h3 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
              s2 += 2, r2++;
              do {
              } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
              if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2)) break;
                d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l2]) > h3 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j(e2) {
          var t2, r2, n2, i2, s2, a2, o2, h3, u2, l2, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
              for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
              for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; ) ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in) break;
            if (a2 = e2.strm, o2 = e2.window, h3 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h3), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h3) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h3)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); ) ;
          } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r2, n2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l) return A;
              if (0 === e2.lookahead) break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x) if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
              for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; ) ;
              e2.strstart++;
            } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function W(e2, t2) {
          for (var r2, n2, i2; ; ) {
            if (e2.lookahead < z) {
              if (j(e2), e2.lookahead < z && t2 === l) return A;
              if (0 === e2.lookahead) break;
            }
            if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; ) ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out)) return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return A;
            } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
        }
        function M(e2, t2, r2, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
        }
        function H() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _2);
        }
        function K(e2) {
          var t2 = G(e2);
          return t2 === m && (function(e3) {
            e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h2[e3.level].max_lazy, e3.good_match = h2[e3.level].good_length, e3.nice_match = h2[e3.level].nice_length, e3.max_chain_length = h2[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          })(e2.state), t2;
        }
        function Y(e2, t2, r2, n2, i2, s2) {
          if (!e2) return _2;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2) return R(e2, _2);
          8 === n2 && (n2 = 9);
          var o2 = new H();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
        }
        h2 = [new M(0, 0, 0, 0, function(e2, t2) {
          var r2 = 65535;
          for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j(e2), 0 === e2.lookahead && t2 === l) return A;
              if (0 === e2.lookahead) break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r2;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out)) return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out)) return A;
          }
          return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
        }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
          return Y(e2, t2, v, 15, 8, 0);
        }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _2 : (e2.state.gzhead = t2, m) : _2;
        }, r.deflate = function(e2, t2) {
          var r2, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0) return e2 ? R(e2, _2) : _2;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f) return R(e2, 0 === e2.avail_out ? -5 : _2);
          if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C) if (2 === n2.wrap) e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
          }
          if (69 === n2.status) if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else n2.status = 73;
          if (73 === n2.status) if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else n2.status = 91;
          if (91 === n2.status) if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
            if (F(e2), 0 === e2.avail_out) return n2.last_flush = -1, m;
          } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f) return R(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in) return R(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? (function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                  if (t3 === l) return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            })(n2, t2) : 3 === n2.strategy ? (function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S) {
                  if (j(e3), e3.lookahead <= S && t3 === l) return A;
                  if (0 === e3.lookahead) break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out)) return A;
              }
              return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
            })(n2, t2) : h2[n2.level].func(n2, t2);
            if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O) return 0 === e2.avail_out && (n2.last_flush = -1), m;
            if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out)) return n2.last_flush = -1, m;
          }
          return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
        }, r.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _2) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _2;
        }, r.deflateSetDictionary = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h3, u2, l2 = t2.length;
          if (!e2 || !e2.state) return _2;
          if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead) return _2;
          for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h3 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
            for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; ) ;
            r2.strstart = n2, r2.lookahead = x - 1, j(r2);
          }
          return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h3, e2.avail_in = a2, r2.wrap = s2, m;
        }, r.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r) {
        t.exports = function(e2, t2) {
          var r2, n, i, s, a, o, h2, u, l, f, c, d, p, m, _2, g, b, v, y, w, k, x, S, z, C;
          r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h2 = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _2 = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
          e: do {
            p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
            t: for (; ; ) {
              if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255)) C[s++] = 65535 & v;
              else {
                if (!(16 & y)) {
                  if (0 == (64 & y)) {
                    v = m[(65535 & v) + (d & (1 << y) - 1)];
                    continue t;
                  }
                  if (32 & y) {
                    r2.mode = 12;
                    break e;
                  }
                  e2.msg = "invalid literal/length code", r2.mode = 30;
                  break e;
                }
                w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _2[d & b];
                r: for (; ; ) {
                  if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                    if (0 == (64 & y)) {
                      v = _2[(65535 & v) + (d & (1 << y) - 1)];
                      continue r;
                    }
                    e2.msg = "invalid distance code", r2.mode = 30;
                    break e;
                  }
                  if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h2 < (k += d & (1 << y) - 1)) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break e;
                  }
                  if (d >>>= y, p -= y, (y = s - a) < k) {
                    if (l < (y = k - y) && r2.sane) {
                      e2.msg = "invalid distance too far back", r2.mode = 30;
                      break e;
                    }
                    if (S = c, (x = 0) === f) {
                      if (x += u - y, y < w) {
                        for (w -= y; C[s++] = c[x++], --y; ) ;
                        x = s - k, S = C;
                      }
                    } else if (f < y) {
                      if (x += u + f - y, (y -= f) < w) {
                        for (w -= y; C[s++] = c[x++], --y; ) ;
                        if (x = 0, f < w) {
                          for (w -= y = f; C[s++] = c[x++], --y; ) ;
                          x = s - k, S = C;
                        }
                      }
                    } else if (x += f - y, y < w) {
                      for (w -= y; C[s++] = c[x++], --y; ) ;
                      x = s - k, S = C;
                    }
                    for (; 2 < w; ) C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                    w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                  } else {
                    for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); ) ;
                    w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (n < i && s < o);
          n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
        };
      }, {}], 49: [function(e, t, r) {
        var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
        function L(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
        }
        function h2(e2, t2) {
          var r2, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
        }
        function u(e2, t2) {
          var r2, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h2(e2, t2)) !== N && (e2.state = null), r2) : U;
        }
        var l, f, c = true;
        function j(e2) {
          if (c) {
            var t2;
            for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; ) e2.lens[t2++] = 8;
            for (; t2 < 256; ) e2.lens[t2++] = 9;
            for (; t2 < 280; ) e2.lens[t2++] = 7;
            for (; t2 < 288; ) e2.lens[t2++] = 8;
            for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
            T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
          }
          e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r2, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r.inflateReset = o, r.inflateReset2 = h2, r.inflateResetKeep = a, r.inflateInit = function(e2) {
          return u(e2, 15);
        }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
          var r2, n2, i2, s2, a2, o2, h3, u2, l2, f2, c2, d, p, m, _2, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return U;
          12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h3 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h3, x = N;
          e: for (; ; ) switch (r2.mode) {
            case P:
              if (0 === r2.wrap) {
                r2.mode = 13;
                break;
              }
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (2 & r2.wrap && 35615 === u2) {
                E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                break;
              }
              if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                e2.msg = "incorrect header check", r2.mode = 30;
                break;
              }
              if (8 != (15 & u2)) {
                e2.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits) r2.wbits = k;
              else if (k > r2.wbits) {
                e2.msg = "invalid window size", r2.mode = 30;
                break;
              }
              r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
              break;
            case 2:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (r2.flags = u2, 8 != (255 & r2.flags)) {
                e2.msg = "unknown compression method", r2.mode = 30;
                break;
              }
              if (57344 & r2.flags) {
                e2.msg = "unknown header flags set", r2.mode = 30;
                break;
              }
              r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
            case 3:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
            case 4:
              for (; l2 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
            case 5:
              if (1024 & r2.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
              } else r2.head && (r2.head.extra = null);
              r2.mode = 6;
            case 6:
              if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length)) break e;
              r2.length = 0, r2.mode = 7;
            case 7:
              if (2048 & r2.flags) {
                if (0 === o2) break e;
                for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; ) ;
                if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
              } else r2.head && (r2.head.name = null);
              r2.length = 0, r2.mode = 8;
            case 8:
              if (4096 & r2.flags) {
                if (0 === o2) break e;
                for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; ) ;
                if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k) break e;
              } else r2.head && (r2.head.comment = null);
              r2.mode = 9;
            case 9:
              if (512 & r2.flags) {
                for (; l2 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (u2 !== (65535 & r2.check)) {
                  e2.msg = "header crc mismatch", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
              break;
            case 10:
              for (; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
            case 11:
              if (0 === r2.havedict) return e2.next_out = a2, e2.avail_out = h3, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
              e2.adler = r2.check = 1, r2.mode = 12;
            case 12:
              if (5 === t2 || 6 === t2) break e;
            case 13:
              if (r2.last) {
                u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                break;
              }
              for (; l2 < 3; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                case 0:
                  r2.mode = 14;
                  break;
                case 1:
                  if (j(r2), r2.mode = 20, 6 !== t2) break;
                  u2 >>>= 2, l2 -= 2;
                  break e;
                case 2:
                  r2.mode = 17;
                  break;
                case 3:
                  e2.msg = "invalid block type", r2.mode = 30;
              }
              u2 >>>= 2, l2 -= 2;
              break;
            case 14:
              for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                e2.msg = "invalid stored block lengths", r2.mode = 30;
                break;
              }
              if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2) break e;
            case 15:
              r2.mode = 16;
            case 16:
              if (d = r2.length) {
                if (o2 < d && (d = o2), h3 < d && (d = h3), 0 === d) break e;
                I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h3 -= d, a2 += d, r2.length -= d;
                break;
              }
              r2.mode = 12;
              break;
            case 17:
              for (; l2 < 14; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                e2.msg = "too many length or distance symbols", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 18;
            case 18:
              for (; r2.have < r2.ncode; ) {
                for (; l2 < 3; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
              }
              for (; r2.have < 19; ) r2.lens[A[r2.have++]] = 0;
              if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                e2.msg = "invalid code lengths set", r2.mode = 30;
                break;
              }
              r2.have = 0, r2.mode = 19;
            case 19:
              for (; r2.have < r2.nlen + r2.ndist; ) {
                for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (b < 16) u2 >>>= _2, l2 -= _2, r2.lens[r2.have++] = b;
                else {
                  if (16 === b) {
                    for (z = _2 + 2; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    if (u2 >>>= _2, l2 -= _2, 0 === r2.have) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                  } else if (17 === b) {
                    for (z = _2 + 3; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    l2 -= _2, k = 0, d = 3 + (7 & (u2 >>>= _2)), u2 >>>= 3, l2 -= 3;
                  } else {
                    for (z = _2 + 7; l2 < z; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l2, l2 += 8;
                    }
                    l2 -= _2, k = 0, d = 11 + (127 & (u2 >>>= _2)), u2 >>>= 7, l2 -= 7;
                  }
                  if (r2.have + d > r2.nlen + r2.ndist) {
                    e2.msg = "invalid bit length repeat", r2.mode = 30;
                    break;
                  }
                  for (; d--; ) r2.lens[r2.have++] = k;
                }
              }
              if (30 === r2.mode) break;
              if (0 === r2.lens[256]) {
                e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                break;
              }
              if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                e2.msg = "invalid literal/lengths set", r2.mode = 30;
                break;
              }
              if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                e2.msg = "invalid distances set", r2.mode = 30;
                break;
              }
              if (r2.mode = 20, 6 === t2) break e;
            case 20:
              r2.mode = 21;
            case 21:
              if (6 <= o2 && 258 <= h3) {
                e2.next_out = a2, e2.avail_out = h3, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h3 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                break;
              }
              for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (g && 0 == (240 & g)) {
                for (v = _2, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_2 = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                u2 >>>= v, l2 -= v, r2.back += v;
              }
              if (u2 >>>= _2, l2 -= _2, r2.back += _2, r2.length = b, 0 === g) {
                r2.mode = 26;
                break;
              }
              if (32 & g) {
                r2.back = -1, r2.mode = 12;
                break;
              }
              if (64 & g) {
                e2.msg = "invalid literal/length code", r2.mode = 30;
                break;
              }
              r2.extra = 15 & g, r2.mode = 22;
            case 22:
              if (r2.extra) {
                for (z = r2.extra; l2 < z; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
              }
              r2.was = r2.length, r2.mode = 23;
            case 23:
              for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l2); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l2, l2 += 8;
              }
              if (0 == (240 & g)) {
                for (v = _2, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_2 = C >>> 24) <= l2); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                u2 >>>= v, l2 -= v, r2.back += v;
              }
              if (u2 >>>= _2, l2 -= _2, r2.back += _2, 64 & g) {
                e2.msg = "invalid distance code", r2.mode = 30;
                break;
              }
              r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
            case 24:
              if (r2.extra) {
                for (z = r2.extra; l2 < z; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
              }
              if (r2.offset > r2.dmax) {
                e2.msg = "invalid distance too far back", r2.mode = 30;
                break;
              }
              r2.mode = 25;
            case 25:
              if (0 === h3) break e;
              if (d = c2 - h3, r2.offset > d) {
                if ((d = r2.offset - d) > r2.whave && r2.sane) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
              } else m = i2, p = a2 - r2.offset, d = r2.length;
              for (h3 < d && (d = h3), h3 -= d, r2.length -= d; i2[a2++] = m[p++], --d; ) ;
              0 === r2.length && (r2.mode = 21);
              break;
            case 26:
              if (0 === h3) break e;
              i2[a2++] = r2.length, h3--, r2.mode = 21;
              break;
            case 27:
              if (r2.wrap) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 |= n2[s2++] << l2, l2 += 8;
                }
                if (c2 -= h3, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h3, (r2.flags ? u2 : L(u2)) !== r2.check) {
                  e2.msg = "incorrect data check", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.mode = 28;
            case 28:
              if (r2.wrap && r2.flags) {
                for (; l2 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (u2 !== (4294967295 & r2.total)) {
                  e2.msg = "incorrect length check", r2.mode = 30;
                  break;
                }
                l2 = u2 = 0;
              }
              r2.mode = 29;
            case 29:
              x = 1;
              break e;
            case 30:
              x = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return U;
          }
          return e2.next_out = a2, e2.avail_out = h3, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
        }, r.inflateEnd = function(e2) {
          if (!e2 || !e2.state) return U;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N;
        }, r.inflateGetHeader = function(e2, t2) {
          var r2;
          return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
        }, r.inflateSetDictionary = function(e2, t2) {
          var r2, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
        }, r.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
        var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r2, n, i, s, a, o) {
          var h2, u, l, f, c, d, p, m, _2, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
          for (b = 0; b <= 15; b++) O[b] = 0;
          for (v = 0; v < n; v++) O[t2[r2 + v]]++;
          for (k = g, w = 15; 1 <= w && 0 === O[w]; w--) ;
          if (w < k && (k = w), 0 === w) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y = 1; y < w && 0 === O[y]; y++) ;
          for (k < y && (k = y), b = z = 1; b <= 15; b++) if (z <<= 1, (z -= O[b]) < 0) return -1;
          if (0 < z && (0 === e2 || 1 !== w)) return -1;
          for (B[1] = 0, b = 1; b < 15; b++) B[b + 1] = B[b] + O[b];
          for (v = 0; v < n; v++) 0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
          if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
          for (; ; ) {
            for (p = b - S, _2 = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h2 = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h2)] = p << 24 | m << 16 | _2 | 0, 0 !== u; ) ;
            for (h2 = 1 << b - 1; E & h2; ) h2 >>= 1;
            if (0 !== h2 ? (E &= h2 - 1, E += h2) : E = 0, v++, 0 == --O[b]) {
              if (b === w) break;
              b = t2[r2 + a[v]];
            }
            if (k < b && (E & f) !== l) {
              for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); ) x++, z <<= 1;
              if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C) return 1;
              i[l = E & f] = k << 24 | x << 16 | c - s | 0;
            }
          }
          return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r) {
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r) {
        var i = e("../utils/common"), o = 0, h2 = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _2 = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
        n(z);
        var C = new Array(2 * f);
        n(C);
        var E = new Array(512);
        n(E);
        var A = new Array(256);
        n(A);
        var I = new Array(a);
        n(I);
        var O, B, R, T = new Array(f);
        function D(e2, t2, r2, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N(e2) {
          return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
        }
        function U(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P(e2, t2, r2) {
          e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
        }
        function L(e2, t2, r2) {
          P(e2, r2[2 * t2], r2[2 * t2 + 1]);
        }
        function j(e2, t2) {
          for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; ) ;
          return r2 >>> 1;
        }
        function Z(e2, t2, r2) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++) s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
          }
        }
        function W(e2) {
          var t2;
          for (t2 = 0; t2 < l; t2++) e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++) e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c; t2++) e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M(e2) {
          8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H(e2, t2, r2, n2) {
          var i2 = 2 * t2, s2 = 2 * r2;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
        }
        function G(e2, t2, r2) {
          for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); ) e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
          e2.heap[r2] = n2;
        }
        function K(e2, t2, r2) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit) for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; ) ;
          L(e2, m, t2);
        }
        function Y(e2, t2) {
          var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h3 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _2, r2 = 0; r2 < h3; r2++) 0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
          for (; e2.heap_len < 2; ) s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--) G(e2, s2, r2);
          for (i2 = h3; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; ) ;
          e2.heap[--e2.heap_max] = e2.heap[1], (function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h4 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
            for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;
            for (h4[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _2; r3++) p2 < (s3 = h4[2 * h4[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h4[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h4[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
            if (0 !== m2) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
              } while (0 < m2);
              for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h4[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h4[2 * i3 + 1]) * h4[2 * i3], h4[2 * i3 + 1] = s3), n3--);
            }
          })(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h3 = 7, u2 = 4;
          for (0 === a2 && (h3 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++) i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h3 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h3 = 138, 3) : i2 === a2 ? (h3 = 6, 3) : (h3 = 7, 4));
        }
        function V(e2, t2, r2) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h3 = 7, u2 = 4;
          for (0 === a2 && (h3 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++) if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h3 && i2 === a2)) {
            if (o2 < u2) for (; L(e2, i2, e2.bl_tree), 0 != --o2; ) ;
            else 0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h3 = 138, 3) : i2 === a2 ? (h3 = 6, 3) : (h3 = 7, 4);
          }
        }
        n(T);
        var q = false;
        function J(e2, t2, r2, n2) {
          P(e2, (s << 1) + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
            M(e3), U(e3, r3), U(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          })(e2, t2, r2);
        }
        r._tr_init = function(e2) {
          q || ((function() {
            var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
            for (n2 = r2 = 0; n2 < a - 1; n2++) for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++) A[r2++] = n2;
            for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++) E[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++) s2[t2] = 0;
            for (e3 = 0; e3 <= 143; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; ) z[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; ) z[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; ) z[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++) C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
            O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
          })(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
        }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = (function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h2;
            for (t3 = 32; t3 < u; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return h2;
            return o;
          })(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = (function(e3) {
            var t3;
            for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--) ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          })(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
            var i3;
            for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
            V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
          })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
        }, r._tr_tally = function(e2, t2, r2) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r._tr_align = function(e2) {
          P(e2, 2, 3), L(e2, m, z), (function(e3) {
            16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          })(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r) {
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r) {
        (function(e2) {
          !(function(r2, n) {
            if (!r2.setImmediate) {
              var i, s, t2, a, o = 1, h2 = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
              e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
                process$1.nextTick(function() {
                  c(e4);
                });
              } : (function() {
                if (r2.postMessage && !r2.importScripts) {
                  var e4 = true, t3 = r2.onmessage;
                  return r2.onmessage = function() {
                    e4 = false;
                  }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
                }
              })() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
                r2.postMessage(a + e4, "*");
              }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
                var t3 = l.createElement("script");
                t3.onreadystatechange = function() {
                  c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h2[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h2[e4];
            }
            function c(e4) {
              if (u) setTimeout(c, 0, e4);
              else {
                var t3 = h2[e4];
                if (t3) {
                  u = true;
                  try {
                    !(function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    })(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d(e4) {
              e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
            }
          })("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(jszip_min);
  return jszip_min.exports;
}
var hasRequiredZipfile;
function requireZipfile() {
  if (hasRequiredZipfile) return zipfile;
  hasRequiredZipfile = 1;
  var base64js = requireBase64Js();
  var JSZip = requireJszip_min();
  zipfile.openArrayBuffer = openArrayBuffer;
  zipfile.splitPath = splitPath;
  zipfile.joinPath = joinPath;
  function openArrayBuffer(arrayBuffer) {
    return JSZip.loadAsync(arrayBuffer).then(function(zipFile) {
      function exists(name) {
        return zipFile.file(name) !== null;
      }
      function read(name, encoding) {
        return zipFile.file(name).async("uint8array").then(function(array) {
          if (encoding === "base64") {
            return base64js.fromByteArray(array);
          } else if (encoding) {
            var decoder = new TextDecoder(encoding);
            return decoder.decode(array);
          } else {
            return array;
          }
        });
      }
      function write(name, contents) {
        zipFile.file(name, contents);
      }
      function toArrayBuffer() {
        return zipFile.generateAsync({ type: "arraybuffer" });
      }
      return {
        exists,
        read,
        write,
        toArrayBuffer
      };
    });
  }
  function splitPath(path) {
    var lastIndex = path.lastIndexOf("/");
    if (lastIndex === -1) {
      return { dirname: "", basename: path };
    } else {
      return {
        dirname: path.substring(0, lastIndex),
        basename: path.substring(lastIndex + 1)
      };
    }
  }
  function joinPath() {
    var nonEmptyPaths = Array.prototype.filter.call(arguments, function(path) {
      return path;
    });
    var relevantPaths = [];
    nonEmptyPaths.forEach(function(path) {
      if (/^\//.test(path)) {
        relevantPaths = [path];
      } else {
        relevantPaths.push(path);
      }
    });
    return relevantPaths.join("/");
  }
  return zipfile;
}
var officeXmlReader = {};
var xml = {};
var nodes = {};
var hasRequiredNodes;
function requireNodes() {
  if (hasRequiredNodes) return nodes;
  hasRequiredNodes = 1;
  var _2 = require$$0;
  nodes.Element = Element;
  nodes.element = function(name, attributes, children) {
    return new Element(name, attributes, children);
  };
  nodes.text = function(value) {
    return {
      type: "text",
      value
    };
  };
  var emptyElement = nodes.emptyElement = {
    first: function() {
      return null;
    },
    firstOrEmpty: function() {
      return emptyElement;
    },
    attributes: {},
    children: []
  };
  function Element(name, attributes, children) {
    this.type = "element";
    this.name = name;
    this.attributes = attributes || {};
    this.children = children || [];
  }
  Element.prototype.first = function(name) {
    return _2.find(this.children, function(child) {
      return child.name === name;
    });
  };
  Element.prototype.firstOrEmpty = function(name) {
    return this.first(name) || emptyElement;
  };
  Element.prototype.getElementsByTagName = function(name) {
    var elements = _2.filter(this.children, function(child) {
      return child.name === name;
    });
    return toElementList(elements);
  };
  Element.prototype.text = function() {
    if (this.children.length === 0) {
      return "";
    } else if (this.children.length !== 1 || this.children[0].type !== "text") {
      throw new Error("Not implemented");
    }
    return this.children[0].value;
  };
  var elementListPrototype = {
    getElementsByTagName: function(name) {
      return toElementList(_2.flatten(this.map(function(element) {
        return element.getElementsByTagName(name);
      }, true)));
    }
  };
  function toElementList(array) {
    return _2.extend(array, elementListPrototype);
  }
  return nodes;
}
var reader = {};
var xmldom = {};
var lib$1 = {};
var dom = {};
var conventions = {};
var hasRequiredConventions;
function requireConventions() {
  if (hasRequiredConventions) return conventions;
  hasRequiredConventions = 1;
  function find2(list, predicate, ac) {
    if (ac === void 0) {
      ac = Array.prototype;
    }
    if (list && typeof ac.find === "function") {
      return ac.find.call(list, predicate);
    }
    for (var i = 0; i < list.length; i++) {
      if (Object.prototype.hasOwnProperty.call(list, i)) {
        var item = list[i];
        if (predicate.call(void 0, item, i, list)) {
          return item;
        }
      }
    }
  }
  function freeze(object2, oc) {
    if (oc === void 0) {
      oc = Object;
    }
    return oc && typeof oc.freeze === "function" ? oc.freeze(object2) : object2;
  }
  function assign(target, source) {
    if (target === null || typeof target !== "object") {
      throw new TypeError("target is not an object");
    }
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
    return target;
  }
  var MIME_TYPE = freeze({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(value) {
      return value === MIME_TYPE.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  });
  var NAMESPACE = freeze({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(uri) {
      return uri === NAMESPACE.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  conventions.assign = assign;
  conventions.find = find2;
  conventions.freeze = freeze;
  conventions.MIME_TYPE = MIME_TYPE;
  conventions.NAMESPACE = NAMESPACE;
  return conventions;
}
var hasRequiredDom;
function requireDom() {
  if (hasRequiredDom) return dom;
  hasRequiredDom = 1;
  var conventions2 = requireConventions();
  var find2 = conventions2.find;
  var NAMESPACE = conventions2.NAMESPACE;
  function notEmptyString(input) {
    return input !== "";
  }
  function splitOnASCIIWhitespace(input) {
    return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
  }
  function orderedSetReducer(current, element) {
    if (!current.hasOwnProperty(element)) {
      current[element] = true;
    }
    return current;
  }
  function toOrderedSet(input) {
    if (!input) return [];
    var list = splitOnASCIIWhitespace(input);
    return Object.keys(list.reduce(orderedSetReducer, {}));
  }
  function arrayIncludes(list) {
    return function(element) {
      return list && list.indexOf(element) !== -1;
    };
  }
  function copy2(src, dest) {
    for (var p in src) {
      if (Object.prototype.hasOwnProperty.call(src, p)) {
        dest[p] = src[p];
      }
    }
  }
  function _extends(Class, Super) {
    var pt = Class.prototype;
    if (!(pt instanceof Super)) {
      let t = function() {
      };
      t.prototype = Super.prototype;
      t = new t();
      copy2(pt, t);
      Class.prototype = pt = t;
    }
    if (pt.constructor != Class) {
      if (typeof Class != "function") {
        console.error("unknown Class:" + Class);
      }
      pt.constructor = Class;
    }
  }
  var NodeType3 = {};
  var ELEMENT_NODE = NodeType3.ELEMENT_NODE = 1;
  var ATTRIBUTE_NODE = NodeType3.ATTRIBUTE_NODE = 2;
  var TEXT_NODE = NodeType3.TEXT_NODE = 3;
  var CDATA_SECTION_NODE = NodeType3.CDATA_SECTION_NODE = 4;
  var ENTITY_REFERENCE_NODE = NodeType3.ENTITY_REFERENCE_NODE = 5;
  var ENTITY_NODE = NodeType3.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = NodeType3.PROCESSING_INSTRUCTION_NODE = 7;
  var COMMENT_NODE = NodeType3.COMMENT_NODE = 8;
  var DOCUMENT_NODE = NodeType3.DOCUMENT_NODE = 9;
  var DOCUMENT_TYPE_NODE = NodeType3.DOCUMENT_TYPE_NODE = 10;
  var DOCUMENT_FRAGMENT_NODE = NodeType3.DOCUMENT_FRAGMENT_NODE = 11;
  var NOTATION_NODE = NodeType3.NOTATION_NODE = 12;
  var ExceptionCode = {};
  var ExceptionMessage = {};
  ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
  ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
  ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
  ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
  ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
  ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
  ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
  ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
  ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
  ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
  ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
  ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
  function DOMException(code, message) {
    if (message instanceof Error) {
      var error = message;
    } else {
      error = this;
      Error.call(this, ExceptionMessage[code]);
      this.message = ExceptionMessage[code];
      if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
    }
    error.code = code;
    if (message) this.message = this.message + ": " + message;
    return error;
  }
  DOMException.prototype = Error.prototype;
  copy2(ExceptionCode, DOMException);
  function NodeList() {
  }
  NodeList.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(index) {
      return index >= 0 && index < this.length ? this[index] : null;
    },
    toString: function(isHTML, nodeFilter) {
      for (var buf = [], i = 0; i < this.length; i++) {
        serializeToString(this[i], buf, isHTML, nodeFilter);
      }
      return buf.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(predicate) {
      return Array.prototype.filter.call(this, predicate);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(item) {
      return Array.prototype.indexOf.call(this, item);
    }
  };
  function LiveNodeList(node, refresh) {
    this._node = node;
    this._refresh = refresh;
    _updateLiveList(this);
  }
  function _updateLiveList(list) {
    var inc = list._node._inc || list._node.ownerDocument._inc;
    if (list._inc !== inc) {
      var ls = list._refresh(list._node);
      __set__(list, "length", ls.length);
      if (!list.$$length || ls.length < list.$$length) {
        for (var i = ls.length; i in list; i++) {
          if (Object.prototype.hasOwnProperty.call(list, i)) {
            delete list[i];
          }
        }
      }
      copy2(ls, list);
      list._inc = inc;
    }
  }
  LiveNodeList.prototype.item = function(i) {
    _updateLiveList(this);
    return this[i] || null;
  };
  _extends(LiveNodeList, NodeList);
  function NamedNodeMap() {
  }
  function _findNodeIndex(list, node) {
    var i = list.length;
    while (i--) {
      if (list[i] === node) {
        return i;
      }
    }
  }
  function _addNamedNode(el, list, newAttr, oldAttr) {
    if (oldAttr) {
      list[_findNodeIndex(list, oldAttr)] = newAttr;
    } else {
      list[list.length++] = newAttr;
    }
    if (el) {
      newAttr.ownerElement = el;
      var doc2 = el.ownerDocument;
      if (doc2) {
        oldAttr && _onRemoveAttribute(doc2, el, oldAttr);
        _onAddAttribute(doc2, el, newAttr);
      }
    }
  }
  function _removeNamedNode(el, list, attr) {
    var i = _findNodeIndex(list, attr);
    if (i >= 0) {
      var lastIndex = list.length - 1;
      while (i < lastIndex) {
        list[i] = list[++i];
      }
      list.length = lastIndex;
      if (el) {
        var doc2 = el.ownerDocument;
        if (doc2) {
          _onRemoveAttribute(doc2, el, attr);
          attr.ownerElement = null;
        }
      }
    } else {
      throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
    }
  }
  NamedNodeMap.prototype = {
    length: 0,
    item: NodeList.prototype.item,
    getNamedItem: function(key) {
      var i = this.length;
      while (i--) {
        var attr = this[i];
        if (attr.nodeName == key) {
          return attr;
        }
      }
    },
    setNamedItem: function(attr) {
      var el = attr.ownerElement;
      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }
      var oldAttr = this.getNamedItem(attr.nodeName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    setNamedItemNS: function(attr) {
      var el = attr.ownerElement, oldAttr;
      if (el && el != this._ownerElement) {
        throw new DOMException(INUSE_ATTRIBUTE_ERR);
      }
      oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
      _addNamedNode(this._ownerElement, this, attr, oldAttr);
      return oldAttr;
    },
    /* returns Node */
    removeNamedItem: function(key) {
      var attr = this.getNamedItem(key);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(namespaceURI, localName) {
      var attr = this.getNamedItemNS(namespaceURI, localName);
      _removeNamedNode(this._ownerElement, this, attr);
      return attr;
    },
    getNamedItemNS: function(namespaceURI, localName) {
      var i = this.length;
      while (i--) {
        var node = this[i];
        if (node.localName == localName && node.namespaceURI == namespaceURI) {
          return node;
        }
      }
      return null;
    }
  };
  function DOMImplementation() {
  }
  DOMImplementation.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(feature, version) {
      return true;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(namespaceURI, qualifiedName, doctype) {
      var doc2 = new Document2();
      doc2.implementation = this;
      doc2.childNodes = new NodeList();
      doc2.doctype = doctype || null;
      if (doctype) {
        doc2.appendChild(doctype);
      }
      if (qualifiedName) {
        var root2 = doc2.createElementNS(namespaceURI, qualifiedName);
        doc2.appendChild(root2);
      }
      return doc2;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(qualifiedName, publicId, systemId) {
      var node = new DocumentType();
      node.name = qualifiedName;
      node.nodeName = qualifiedName;
      node.publicId = publicId || "";
      node.systemId = systemId || "";
      return node;
    }
  };
  function Node2() {
  }
  Node2.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(newChild, refChild) {
      return _insertBefore(this, newChild, refChild);
    },
    replaceChild: function(newChild, oldChild) {
      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
      if (oldChild) {
        this.removeChild(oldChild);
      }
    },
    removeChild: function(oldChild) {
      return _removeChild(this, oldChild);
    },
    appendChild: function(newChild) {
      return this.insertBefore(newChild, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(deep) {
      return cloneNode(this.ownerDocument || this, this, deep);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      var child = this.firstChild;
      while (child) {
        var next = child.nextSibling;
        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
          this.removeChild(next);
          child.appendData(next.data);
        } else {
          child.normalize();
          child = next;
        }
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(feature, version) {
      return this.ownerDocument.implementation.hasFeature(feature, version);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(namespaceURI) {
      var el = this;
      while (el) {
        var map3 = el._nsMap;
        if (map3) {
          for (var n in map3) {
            if (Object.prototype.hasOwnProperty.call(map3, n) && map3[n] === namespaceURI) {
              return n;
            }
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(prefix) {
      var el = this;
      while (el) {
        var map3 = el._nsMap;
        if (map3) {
          if (Object.prototype.hasOwnProperty.call(map3, prefix)) {
            return map3[prefix];
          }
        }
        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(namespaceURI) {
      var prefix = this.lookupPrefix(namespaceURI);
      return prefix == null;
    }
  };
  function _xmlEncoder(c) {
    return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
  }
  copy2(NodeType3, Node2);
  copy2(NodeType3, Node2.prototype);
  function _visitNode(node, callback) {
    if (callback(node)) {
      return true;
    }
    if (node = node.firstChild) {
      do {
        if (_visitNode(node, callback)) {
          return true;
        }
      } while (node = node.nextSibling);
    }
  }
  function Document2() {
    this.ownerDocument = this;
  }
  function _onAddAttribute(doc2, el, newAttr) {
    doc2 && doc2._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE.XMLNS) {
      el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
    }
  }
  function _onRemoveAttribute(doc2, el, newAttr, remove) {
    doc2 && doc2._inc++;
    var ns = newAttr.namespaceURI;
    if (ns === NAMESPACE.XMLNS) {
      delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
    }
  }
  function _onUpdateChild(doc2, el, newChild) {
    if (doc2 && doc2._inc) {
      doc2._inc++;
      var cs = el.childNodes;
      if (newChild) {
        cs[cs.length++] = newChild;
      } else {
        var child = el.firstChild;
        var i = 0;
        while (child) {
          cs[i++] = child;
          child = child.nextSibling;
        }
        cs.length = i;
        delete cs[cs.length];
      }
    }
  }
  function _removeChild(parentNode2, child) {
    var previous = child.previousSibling;
    var next = child.nextSibling;
    if (previous) {
      previous.nextSibling = next;
    } else {
      parentNode2.firstChild = next;
    }
    if (next) {
      next.previousSibling = previous;
    } else {
      parentNode2.lastChild = previous;
    }
    child.parentNode = null;
    child.previousSibling = null;
    child.nextSibling = null;
    _onUpdateChild(parentNode2.ownerDocument, parentNode2);
    return child;
  }
  function hasValidParentNodeType(node) {
    return node && (node.nodeType === Node2.DOCUMENT_NODE || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.ELEMENT_NODE);
  }
  function hasInsertableNodeType(node) {
    return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.COMMENT_NODE || node.nodeType === Node2.PROCESSING_INSTRUCTION_NODE);
  }
  function isDocTypeNode(node) {
    return node && node.nodeType === Node2.DOCUMENT_TYPE_NODE;
  }
  function isElementNode(node) {
    return node && node.nodeType === Node2.ELEMENT_NODE;
  }
  function isTextNode(node) {
    return node && node.nodeType === Node2.TEXT_NODE;
  }
  function isElementInsertionPossible(doc2, child) {
    var parentChildNodes = doc2.childNodes || [];
    if (find2(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
      return false;
    }
    var docTypeNode = find2(parentChildNodes, isDocTypeNode);
    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  }
  function isElementReplacementPossible(doc2, child) {
    var parentChildNodes = doc2.childNodes || [];
    function hasElementChildThatIsNotChild(node) {
      return isElementNode(node) && node !== child;
    }
    if (find2(parentChildNodes, hasElementChildThatIsNotChild)) {
      return false;
    }
    var docTypeNode = find2(parentChildNodes, isDocTypeNode);
    return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
  }
  function assertPreInsertionValidity1to5(parent, node, child) {
    if (!hasValidParentNodeType(parent)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
    }
    if (child && child.parentNode !== parent) {
      throw new DOMException(NOT_FOUND_ERR, "child not in parent");
    }
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      isDocTypeNode(node) && parent.nodeType !== Node2.DOCUMENT_NODE
    ) {
      throw new DOMException(
        HIERARCHY_REQUEST_ERR,
        "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
      );
    }
  }
  function assertPreInsertionValidityInDocument(parent, node, child) {
    var parentChildNodes = parent.childNodes || [];
    var nodeChildNodes = node.childNodes || [];
    if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node)) {
      if (!isElementInsertionPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
      }
    }
    if (isDocTypeNode(node)) {
      if (find2(parentChildNodes, isDocTypeNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      var parentElementChild = find2(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
      if (!child && parentElementChild) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
      }
    }
  }
  function assertPreReplacementValidityInDocument(parent, node, child) {
    var parentChildNodes = parent.childNodes || [];
    var nodeChildNodes = node.childNodes || [];
    if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node)) {
      if (!isElementReplacementPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
      }
    }
    if (isDocTypeNode(node)) {
      let hasDoctypeChildThatIsNotChild = function(node2) {
        return isDocTypeNode(node2) && node2 !== child;
      };
      if (find2(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      var parentElementChild = find2(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
    }
  }
  function _insertBefore(parent, node, child, _inDocumentAssertion) {
    assertPreInsertionValidity1to5(parent, node, child);
    if (parent.nodeType === Node2.DOCUMENT_NODE) {
      (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
    }
    var cp = node.parentNode;
    if (cp) {
      cp.removeChild(node);
    }
    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      var newFirst = node.firstChild;
      if (newFirst == null) {
        return node;
      }
      var newLast = node.lastChild;
    } else {
      newFirst = newLast = node;
    }
    var pre = child ? child.previousSibling : parent.lastChild;
    newFirst.previousSibling = pre;
    newLast.nextSibling = child;
    if (pre) {
      pre.nextSibling = newFirst;
    } else {
      parent.firstChild = newFirst;
    }
    if (child == null) {
      parent.lastChild = newLast;
    } else {
      child.previousSibling = newLast;
    }
    do {
      newFirst.parentNode = parent;
      var targetDoc = parent.ownerDocument || parent;
      _updateOwnerDocument(newFirst, targetDoc);
    } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
    _onUpdateChild(parent.ownerDocument || parent, parent);
    if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
      node.firstChild = node.lastChild = null;
    }
    return node;
  }
  function _updateOwnerDocument(node, newOwnerDocument) {
    if (node.ownerDocument === newOwnerDocument) {
      return;
    }
    node.ownerDocument = newOwnerDocument;
    if (node.nodeType === ELEMENT_NODE && node.attributes) {
      for (var i = 0; i < node.attributes.length; i++) {
        var attr = node.attributes.item(i);
        if (attr) {
          attr.ownerDocument = newOwnerDocument;
        }
      }
    }
    var child = node.firstChild;
    while (child) {
      _updateOwnerDocument(child, newOwnerDocument);
      child = child.nextSibling;
    }
  }
  function _appendSingleChild(parentNode2, newChild) {
    if (newChild.parentNode) {
      newChild.parentNode.removeChild(newChild);
    }
    newChild.parentNode = parentNode2;
    newChild.previousSibling = parentNode2.lastChild;
    newChild.nextSibling = null;
    if (newChild.previousSibling) {
      newChild.previousSibling.nextSibling = newChild;
    } else {
      parentNode2.firstChild = newChild;
    }
    parentNode2.lastChild = newChild;
    _onUpdateChild(parentNode2.ownerDocument, parentNode2, newChild);
    var targetDoc = parentNode2.ownerDocument || parentNode2;
    _updateOwnerDocument(newChild, targetDoc);
    return newChild;
  }
  Document2.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: DOCUMENT_NODE,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(newChild, refChild) {
      if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
        var child = newChild.firstChild;
        while (child) {
          var next = child.nextSibling;
          this.insertBefore(child, refChild);
          child = next;
        }
        return newChild;
      }
      _insertBefore(this, newChild, refChild);
      _updateOwnerDocument(newChild, this);
      if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
        this.documentElement = newChild;
      }
      return newChild;
    },
    removeChild: function(oldChild) {
      if (this.documentElement == oldChild) {
        this.documentElement = null;
      }
      return _removeChild(this, oldChild);
    },
    replaceChild: function(newChild, oldChild) {
      _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
      _updateOwnerDocument(newChild, this);
      if (oldChild) {
        this.removeChild(oldChild);
      }
      if (isElementNode(newChild)) {
        this.documentElement = newChild;
      }
    },
    // Introduced in DOM Level 2:
    importNode: function(importedNode, deep) {
      return importNode(this, importedNode, deep);
    },
    // Introduced in DOM Level 2:
    getElementById: function(id) {
      var rtv = null;
      _visitNode(this.documentElement, function(node) {
        if (node.nodeType == ELEMENT_NODE) {
          if (node.getAttribute("id") == id) {
            rtv = node;
            return true;
          }
        }
      });
      return rtv;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(classNames) {
      var classNamesSet = toOrderedSet(classNames);
      return new LiveNodeList(this, function(base2) {
        var ls = [];
        if (classNamesSet.length > 0) {
          _visitNode(base2.documentElement, function(node) {
            if (node !== base2 && node.nodeType === ELEMENT_NODE) {
              var nodeClassNames = node.getAttribute("class");
              if (nodeClassNames) {
                var matches2 = classNames === nodeClassNames;
                if (!matches2) {
                  var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                  matches2 = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                }
                if (matches2) {
                  ls.push(node);
                }
              }
            }
          });
        }
        return ls;
      });
    },
    //document factory method:
    createElement: function(tagName) {
      var node = new Element();
      node.ownerDocument = this;
      node.nodeName = tagName;
      node.tagName = tagName;
      node.localName = tagName;
      node.childNodes = new NodeList();
      var attrs = node.attributes = new NamedNodeMap();
      attrs._ownerElement = node;
      return node;
    },
    createDocumentFragment: function() {
      var node = new DocumentFragment();
      node.ownerDocument = this;
      node.childNodes = new NodeList();
      return node;
    },
    createTextNode: function(data) {
      var node = new Text2();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createComment: function(data) {
      var node = new Comment();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createCDATASection: function(data) {
      var node = new CDATASection();
      node.ownerDocument = this;
      node.appendData(data);
      return node;
    },
    createProcessingInstruction: function(target, data) {
      var node = new ProcessingInstruction();
      node.ownerDocument = this;
      node.tagName = node.nodeName = node.target = target;
      node.nodeValue = node.data = data;
      return node;
    },
    createAttribute: function(name) {
      var node = new Attr();
      node.ownerDocument = this;
      node.name = name;
      node.nodeName = name;
      node.localName = name;
      node.specified = true;
      return node;
    },
    createEntityReference: function(name) {
      var node = new EntityReference();
      node.ownerDocument = this;
      node.nodeName = name;
      return node;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(namespaceURI, qualifiedName) {
      var node = new Element();
      var pl = qualifiedName.split(":");
      var attrs = node.attributes = new NamedNodeMap();
      node.childNodes = new NodeList();
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.tagName = qualifiedName;
      node.namespaceURI = namespaceURI;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      attrs._ownerElement = node;
      return node;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(namespaceURI, qualifiedName) {
      var node = new Attr();
      var pl = qualifiedName.split(":");
      node.ownerDocument = this;
      node.nodeName = qualifiedName;
      node.name = qualifiedName;
      node.namespaceURI = namespaceURI;
      node.specified = true;
      if (pl.length == 2) {
        node.prefix = pl[0];
        node.localName = pl[1];
      } else {
        node.localName = qualifiedName;
      }
      return node;
    }
  };
  _extends(Document2, Node2);
  function Element() {
    this._nsMap = {};
  }
  Element.prototype = {
    nodeType: ELEMENT_NODE,
    hasAttribute: function(name) {
      return this.getAttributeNode(name) != null;
    },
    getAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      return attr && attr.value || "";
    },
    getAttributeNode: function(name) {
      return this.attributes.getNamedItem(name);
    },
    setAttribute: function(name, value) {
      var attr = this.ownerDocument.createAttribute(name);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    removeAttribute: function(name) {
      var attr = this.getAttributeNode(name);
      attr && this.removeAttributeNode(attr);
    },
    //four real opeartion method
    appendChild: function(newChild) {
      if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
        return this.insertBefore(newChild, null);
      } else {
        return _appendSingleChild(this, newChild);
      }
    },
    setAttributeNode: function(newAttr) {
      return this.attributes.setNamedItem(newAttr);
    },
    setAttributeNodeNS: function(newAttr) {
      return this.attributes.setNamedItemNS(newAttr);
    },
    removeAttributeNode: function(oldAttr) {
      return this.attributes.removeNamedItem(oldAttr.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(namespaceURI, localName) {
      var old = this.getAttributeNodeNS(namespaceURI, localName);
      old && this.removeAttributeNode(old);
    },
    hasAttributeNS: function(namespaceURI, localName) {
      return this.getAttributeNodeNS(namespaceURI, localName) != null;
    },
    getAttributeNS: function(namespaceURI, localName) {
      var attr = this.getAttributeNodeNS(namespaceURI, localName);
      return attr && attr.value || "";
    },
    setAttributeNS: function(namespaceURI, qualifiedName, value) {
      var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
      attr.value = attr.nodeValue = "" + value;
      this.setAttributeNode(attr);
    },
    getAttributeNodeNS: function(namespaceURI, localName) {
      return this.attributes.getNamedItemNS(namespaceURI, localName);
    },
    getElementsByTagName: function(tagName) {
      return new LiveNodeList(this, function(base2) {
        var ls = [];
        _visitNode(base2, function(node) {
          if (node !== base2 && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    },
    getElementsByTagNameNS: function(namespaceURI, localName) {
      return new LiveNodeList(this, function(base2) {
        var ls = [];
        _visitNode(base2, function(node) {
          if (node !== base2 && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
            ls.push(node);
          }
        });
        return ls;
      });
    }
  };
  Document2.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
  Document2.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
  _extends(Element, Node2);
  function Attr() {
  }
  Attr.prototype.nodeType = ATTRIBUTE_NODE;
  _extends(Attr, Node2);
  function CharacterData() {
  }
  CharacterData.prototype = {
    data: "",
    substringData: function(offset2, count) {
      return this.data.substring(offset2, offset2 + count);
    },
    appendData: function(text) {
      text = this.data + text;
      this.nodeValue = this.data = text;
      this.length = text.length;
    },
    insertData: function(offset2, text) {
      this.replaceData(offset2, 0, text);
    },
    appendChild: function(newChild) {
      throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
    },
    deleteData: function(offset2, count) {
      this.replaceData(offset2, count, "");
    },
    replaceData: function(offset2, count, text) {
      var start = this.data.substring(0, offset2);
      var end = this.data.substring(offset2 + count);
      text = start + text + end;
      this.nodeValue = this.data = text;
      this.length = text.length;
    }
  };
  _extends(CharacterData, Node2);
  function Text2() {
  }
  Text2.prototype = {
    nodeName: "#text",
    nodeType: TEXT_NODE,
    splitText: function(offset2) {
      var text = this.data;
      var newText = text.substring(offset2);
      text = text.substring(0, offset2);
      this.data = this.nodeValue = text;
      this.length = text.length;
      var newNode = this.ownerDocument.createTextNode(newText);
      if (this.parentNode) {
        this.parentNode.insertBefore(newNode, this.nextSibling);
      }
      return newNode;
    }
  };
  _extends(Text2, CharacterData);
  function Comment() {
  }
  Comment.prototype = {
    nodeName: "#comment",
    nodeType: COMMENT_NODE
  };
  _extends(Comment, CharacterData);
  function CDATASection() {
  }
  CDATASection.prototype = {
    nodeName: "#cdata-section",
    nodeType: CDATA_SECTION_NODE
  };
  _extends(CDATASection, CharacterData);
  function DocumentType() {
  }
  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  _extends(DocumentType, Node2);
  function Notation() {
  }
  Notation.prototype.nodeType = NOTATION_NODE;
  _extends(Notation, Node2);
  function Entity() {
  }
  Entity.prototype.nodeType = ENTITY_NODE;
  _extends(Entity, Node2);
  function EntityReference() {
  }
  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  _extends(EntityReference, Node2);
  function DocumentFragment() {
  }
  DocumentFragment.prototype.nodeName = "#document-fragment";
  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
  _extends(DocumentFragment, Node2);
  function ProcessingInstruction() {
  }
  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  _extends(ProcessingInstruction, Node2);
  function XMLSerializer() {
  }
  XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
    return nodeSerializeToString.call(node, isHtml, nodeFilter);
  };
  Node2.prototype.toString = nodeSerializeToString;
  function nodeSerializeToString(isHtml, nodeFilter) {
    var buf = [];
    var refNode = this.nodeType == 9 && this.documentElement || this;
    var prefix = refNode.prefix;
    var uri = refNode.namespaceURI;
    if (uri && prefix == null) {
      var prefix = refNode.lookupPrefix(uri);
      if (prefix == null) {
        var visibleNamespaces = [
          { namespace: uri, prefix: null }
          //{namespace:uri,prefix:''}
        ];
      }
    }
    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
    return buf.join("");
  }
  function needNamespaceDefine(node, isHTML, visibleNamespaces) {
    var prefix = node.prefix || "";
    var uri = node.namespaceURI;
    if (!uri) {
      return false;
    }
    if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
      return false;
    }
    var i = visibleNamespaces.length;
    while (i--) {
      var ns = visibleNamespaces[i];
      if (ns.prefix === prefix) {
        return ns.namespace !== uri;
      }
    }
    return true;
  }
  function addSerializedAttribute(buf, qualifiedName, value) {
    buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
  }
  function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
    if (!visibleNamespaces) {
      visibleNamespaces = [];
    }
    if (nodeFilter) {
      node = nodeFilter(node);
      if (node) {
        if (typeof node == "string") {
          buf.push(node);
          return;
        }
      } else {
        return;
      }
    }
    switch (node.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var len = attrs.length;
        var child = node.firstChild;
        var nodeName = node.tagName;
        isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
        var prefixedNodeName = nodeName;
        if (!isHTML && !node.prefix && node.namespaceURI) {
          var defaultNS;
          for (var ai = 0; ai < attrs.length; ai++) {
            if (attrs.item(ai).name === "xmlns") {
              defaultNS = attrs.item(ai).value;
              break;
            }
          }
          if (!defaultNS) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                defaultNS = namespace.namespace;
                break;
              }
            }
          }
          if (defaultNS !== node.namespaceURI) {
            for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
              var namespace = visibleNamespaces[nsi];
              if (namespace.namespace === node.namespaceURI) {
                if (namespace.prefix) {
                  prefixedNodeName = namespace.prefix + ":" + nodeName;
                }
                break;
              }
            }
          }
        }
        buf.push("<", prefixedNodeName);
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (attr.prefix == "xmlns") {
            visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
          } else if (attr.nodeName == "xmlns") {
            visibleNamespaces.push({ prefix: "", namespace: attr.value });
          }
        }
        for (var i = 0; i < len; i++) {
          var attr = attrs.item(i);
          if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
            var prefix = attr.prefix || "";
            var uri = attr.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
        }
        if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
          var prefix = node.prefix || "";
          var uri = node.namespaceURI;
          addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
          visibleNamespaces.push({ prefix, namespace: uri });
        }
        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
          buf.push(">");
          if (isHTML && /^script$/i.test(nodeName)) {
            while (child) {
              if (child.data) {
                buf.push(child.data);
              } else {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              }
              child = child.nextSibling;
            }
          } else {
            while (child) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
              child = child.nextSibling;
            }
          }
          buf.push("</", prefixedNodeName, ">");
        } else {
          buf.push("/>");
        }
        return;
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        var child = node.firstChild;
        while (child) {
          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
          child = child.nextSibling;
        }
        return;
      case ATTRIBUTE_NODE:
        return addSerializedAttribute(buf, node.name, node.value);
      case TEXT_NODE:
        return buf.push(
          node.data.replace(/[<&>]/g, _xmlEncoder)
        );
      case CDATA_SECTION_NODE:
        return buf.push("<![CDATA[", node.data, "]]>");
      case COMMENT_NODE:
        return buf.push("<!--", node.data, "-->");
      case DOCUMENT_TYPE_NODE:
        var pubid = node.publicId;
        var sysid = node.systemId;
        buf.push("<!DOCTYPE ", node.name);
        if (pubid) {
          buf.push(" PUBLIC ", pubid);
          if (sysid && sysid != ".") {
            buf.push(" ", sysid);
          }
          buf.push(">");
        } else if (sysid && sysid != ".") {
          buf.push(" SYSTEM ", sysid, ">");
        } else {
          var sub = node.internalSubset;
          if (sub) {
            buf.push(" [", sub, "]");
          }
          buf.push(">");
        }
        return;
      case PROCESSING_INSTRUCTION_NODE:
        return buf.push("<?", node.target, " ", node.data, "?>");
      case ENTITY_REFERENCE_NODE:
        return buf.push("&", node.nodeName, ";");
      //case ENTITY_NODE:
      //case NOTATION_NODE:
      default:
        buf.push("??", node.nodeName);
    }
  }
  function importNode(doc2, node, deep) {
    var node2;
    switch (node.nodeType) {
      case ELEMENT_NODE:
        node2 = node.cloneNode(false);
        node2.ownerDocument = doc2;
      //var attrs = node2.attributes;
      //var len = attrs.length;
      //for(var i=0;i<len;i++){
      //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
      //}
      case DOCUMENT_FRAGMENT_NODE:
        break;
      case ATTRIBUTE_NODE:
        deep = true;
        break;
    }
    if (!node2) {
      node2 = node.cloneNode(false);
    }
    node2.ownerDocument = doc2;
    node2.parentNode = null;
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(importNode(doc2, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function cloneNode(doc2, node, deep) {
    var node2 = new node.constructor();
    for (var n in node) {
      if (Object.prototype.hasOwnProperty.call(node, n)) {
        var v = node[n];
        if (typeof v != "object") {
          if (v != node2[n]) {
            node2[n] = v;
          }
        }
      }
    }
    if (node.childNodes) {
      node2.childNodes = new NodeList();
    }
    node2.ownerDocument = doc2;
    switch (node2.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes;
        var attrs2 = node2.attributes = new NamedNodeMap();
        var len = attrs.length;
        attrs2._ownerElement = node2;
        for (var i = 0; i < len; i++) {
          node2.setAttributeNode(cloneNode(doc2, attrs.item(i), true));
        }
        break;
      case ATTRIBUTE_NODE:
        deep = true;
    }
    if (deep) {
      var child = node.firstChild;
      while (child) {
        node2.appendChild(cloneNode(doc2, child, deep));
        child = child.nextSibling;
      }
    }
    return node2;
  }
  function __set__(object2, key, value) {
    object2[key] = value;
  }
  try {
    if (Object.defineProperty) {
      let getTextContent = function(node) {
        switch (node.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var buf = [];
            node = node.firstChild;
            while (node) {
              if (node.nodeType !== 7 && node.nodeType !== 8) {
                buf.push(getTextContent(node));
              }
              node = node.nextSibling;
            }
            return buf.join("");
          default:
            return node.nodeValue;
        }
      };
      Object.defineProperty(LiveNodeList.prototype, "length", {
        get: function() {
          _updateLiveList(this);
          return this.$$length;
        }
      });
      Object.defineProperty(Node2.prototype, "textContent", {
        get: function() {
          return getTextContent(this);
        },
        set: function(data) {
          switch (this.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              while (this.firstChild) {
                this.removeChild(this.firstChild);
              }
              if (data || String(data)) {
                this.appendChild(this.ownerDocument.createTextNode(data));
              }
              break;
            default:
              this.data = data;
              this.value = data;
              this.nodeValue = data;
          }
        }
      });
      __set__ = function(object2, key, value) {
        object2["$$" + key] = value;
      };
    }
  } catch (e) {
  }
  dom.DocumentType = DocumentType;
  dom.DOMException = DOMException;
  dom.DOMImplementation = DOMImplementation;
  dom.Element = Element;
  dom.Node = Node2;
  dom.NodeList = NodeList;
  dom.XMLSerializer = XMLSerializer;
  return dom;
}
var domParser = {};
var entities = {};
var hasRequiredEntities;
function requireEntities() {
  if (hasRequiredEntities) return entities;
  hasRequiredEntities = 1;
  (function(exports) {
    var freeze = requireConventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "Ã",
      aacute: "Ã¡",
      Abreve: "Ä",
      abreve: "Ä",
      ac: "â¾",
      acd: "â¿",
      acE: "â¾Ì³",
      Acirc: "Ã",
      acirc: "Ã¢",
      acute: "Â´",
      Acy: "Ð",
      acy: "Ð°",
      AElig: "Ã",
      aelig: "Ã¦",
      af: "â¡",
      Afr: "ð",
      afr: "ð",
      Agrave: "Ã",
      agrave: "Ã ",
      alefsym: "âµ",
      aleph: "âµ",
      Alpha: "Î",
      alpha: "Î±",
      Amacr: "Ä",
      amacr: "Ä",
      amalg: "â¨¿",
      AMP: "&",
      amp: "&",
      And: "â©",
      and: "â§",
      andand: "â©",
      andd: "â©",
      andslope: "â©",
      andv: "â©",
      ang: "â ",
      ange: "â¦¤",
      angle: "â ",
      angmsd: "â¡",
      angmsdaa: "â¦¨",
      angmsdab: "â¦©",
      angmsdac: "â¦ª",
      angmsdad: "â¦«",
      angmsdae: "â¦¬",
      angmsdaf: "â¦­",
      angmsdag: "â¦®",
      angmsdah: "â¦¯",
      angrt: "â",
      angrtvb: "â¾",
      angrtvbd: "â¦",
      angsph: "â¢",
      angst: "Ã",
      angzarr: "â¼",
      Aogon: "Ä",
      aogon: "Ä",
      Aopf: "ð¸",
      aopf: "ð",
      ap: "â",
      apacir: "â©¯",
      apE: "â©°",
      ape: "â",
      apid: "â",
      apos: "'",
      ApplyFunction: "â¡",
      approx: "â",
      approxeq: "â",
      Aring: "Ã",
      aring: "Ã¥",
      Ascr: "ð",
      ascr: "ð¶",
      Assign: "â",
      ast: "*",
      asymp: "â",
      asympeq: "â",
      Atilde: "Ã",
      atilde: "Ã£",
      Auml: "Ã",
      auml: "Ã¤",
      awconint: "â³",
      awint: "â¨",
      backcong: "â",
      backepsilon: "Ï¶",
      backprime: "âµ",
      backsim: "â½",
      backsimeq: "â",
      Backslash: "â",
      Barv: "â«§",
      barvee: "â½",
      Barwed: "â",
      barwed: "â",
      barwedge: "â",
      bbrk: "âµ",
      bbrktbrk: "â¶",
      bcong: "â",
      Bcy: "Ð",
      bcy: "Ð±",
      bdquo: "â",
      becaus: "âµ",
      Because: "âµ",
      because: "âµ",
      bemptyv: "â¦°",
      bepsi: "Ï¶",
      bernou: "â¬",
      Bernoullis: "â¬",
      Beta: "Î",
      beta: "Î²",
      beth: "â¶",
      between: "â¬",
      Bfr: "ð",
      bfr: "ð",
      bigcap: "â",
      bigcirc: "â¯",
      bigcup: "â",
      bigodot: "â¨",
      bigoplus: "â¨",
      bigotimes: "â¨",
      bigsqcup: "â¨",
      bigstar: "â",
      bigtriangledown: "â½",
      bigtriangleup: "â³",
      biguplus: "â¨",
      bigvee: "â",
      bigwedge: "â",
      bkarow: "â¤",
      blacklozenge: "â§«",
      blacksquare: "âª",
      blacktriangle: "â´",
      blacktriangledown: "â¾",
      blacktriangleleft: "â",
      blacktriangleright: "â¸",
      blank: "â£",
      blk12: "â",
      blk14: "â",
      blk34: "â",
      block: "â",
      bne: "=â¥",
      bnequiv: "â¡â¥",
      bNot: "â«­",
      bnot: "â",
      Bopf: "ð¹",
      bopf: "ð",
      bot: "â¥",
      bottom: "â¥",
      bowtie: "â",
      boxbox: "â§",
      boxDL: "â",
      boxDl: "â",
      boxdL: "â",
      boxdl: "â",
      boxDR: "â",
      boxDr: "â",
      boxdR: "â",
      boxdr: "â",
      boxH: "â",
      boxh: "â",
      boxHD: "â¦",
      boxHd: "â¤",
      boxhD: "â¥",
      boxhd: "â¬",
      boxHU: "â©",
      boxHu: "â§",
      boxhU: "â¨",
      boxhu: "â´",
      boxminus: "â",
      boxplus: "â",
      boxtimes: "â ",
      boxUL: "â",
      boxUl: "â",
      boxuL: "â",
      boxul: "â",
      boxUR: "â",
      boxUr: "â",
      boxuR: "â",
      boxur: "â",
      boxV: "â",
      boxv: "â",
      boxVH: "â¬",
      boxVh: "â«",
      boxvH: "âª",
      boxvh: "â¼",
      boxVL: "â£",
      boxVl: "â¢",
      boxvL: "â¡",
      boxvl: "â¤",
      boxVR: "â ",
      boxVr: "â",
      boxvR: "â",
      boxvr: "â",
      bprime: "âµ",
      Breve: "Ë",
      breve: "Ë",
      brvbar: "Â¦",
      Bscr: "â¬",
      bscr: "ð·",
      bsemi: "â",
      bsim: "â½",
      bsime: "â",
      bsol: "\\",
      bsolb: "â§",
      bsolhsub: "â",
      bull: "â¢",
      bullet: "â¢",
      bump: "â",
      bumpE: "âª®",
      bumpe: "â",
      Bumpeq: "â",
      bumpeq: "â",
      Cacute: "Ä",
      cacute: "Ä",
      Cap: "â",
      cap: "â©",
      capand: "â©",
      capbrcup: "â©",
      capcap: "â©",
      capcup: "â©",
      capdot: "â©",
      CapitalDifferentialD: "â",
      caps: "â©ï¸",
      caret: "â",
      caron: "Ë",
      Cayleys: "â­",
      ccaps: "â©",
      Ccaron: "Ä",
      ccaron: "Ä",
      Ccedil: "Ã",
      ccedil: "Ã§",
      Ccirc: "Ä",
      ccirc: "Ä",
      Cconint: "â°",
      ccups: "â©",
      ccupssm: "â©",
      Cdot: "Ä",
      cdot: "Ä",
      cedil: "Â¸",
      Cedilla: "Â¸",
      cemptyv: "â¦²",
      cent: "Â¢",
      CenterDot: "Â·",
      centerdot: "Â·",
      Cfr: "â­",
      cfr: "ð ",
      CHcy: "Ð§",
      chcy: "Ñ",
      check: "â",
      checkmark: "â",
      Chi: "Î§",
      chi: "Ï",
      cir: "â",
      circ: "Ë",
      circeq: "â",
      circlearrowleft: "âº",
      circlearrowright: "â»",
      circledast: "â",
      circledcirc: "â",
      circleddash: "â",
      CircleDot: "â",
      circledR: "Â®",
      circledS: "â",
      CircleMinus: "â",
      CirclePlus: "â",
      CircleTimes: "â",
      cirE: "â§",
      cire: "â",
      cirfnint: "â¨",
      cirmid: "â«¯",
      cirscir: "â§",
      ClockwiseContourIntegral: "â²",
      CloseCurlyDoubleQuote: "â",
      CloseCurlyQuote: "â",
      clubs: "â£",
      clubsuit: "â£",
      Colon: "â·",
      colon: ":",
      Colone: "â©´",
      colone: "â",
      coloneq: "â",
      comma: ",",
      commat: "@",
      comp: "â",
      compfn: "â",
      complement: "â",
      complexes: "â",
      cong: "â",
      congdot: "â©­",
      Congruent: "â¡",
      Conint: "â¯",
      conint: "â®",
      ContourIntegral: "â®",
      Copf: "â",
      copf: "ð",
      coprod: "â",
      Coproduct: "â",
      COPY: "Â©",
      copy: "Â©",
      copysr: "â",
      CounterClockwiseContourIntegral: "â³",
      crarr: "âµ",
      Cross: "â¨¯",
      cross: "â",
      Cscr: "ð",
      cscr: "ð¸",
      csub: "â«",
      csube: "â«",
      csup: "â«",
      csupe: "â«",
      ctdot: "â¯",
      cudarrl: "â¤¸",
      cudarrr: "â¤µ",
      cuepr: "â",
      cuesc: "â",
      cularr: "â¶",
      cularrp: "â¤½",
      Cup: "â",
      cup: "âª",
      cupbrcap: "â©",
      CupCap: "â",
      cupcap: "â©",
      cupcup: "â©",
      cupdot: "â",
      cupor: "â©",
      cups: "âªï¸",
      curarr: "â·",
      curarrm: "â¤¼",
      curlyeqprec: "â",
      curlyeqsucc: "â",
      curlyvee: "â",
      curlywedge: "â",
      curren: "Â¤",
      curvearrowleft: "â¶",
      curvearrowright: "â·",
      cuvee: "â",
      cuwed: "â",
      cwconint: "â²",
      cwint: "â±",
      cylcty: "â­",
      Dagger: "â¡",
      dagger: "â ",
      daleth: "â¸",
      Darr: "â¡",
      dArr: "â",
      darr: "â",
      dash: "â",
      Dashv: "â«¤",
      dashv: "â£",
      dbkarow: "â¤",
      dblac: "Ë",
      Dcaron: "Ä",
      dcaron: "Ä",
      Dcy: "Ð",
      dcy: "Ð´",
      DD: "â",
      dd: "â",
      ddagger: "â¡",
      ddarr: "â",
      DDotrahd: "â¤",
      ddotseq: "â©·",
      deg: "Â°",
      Del: "â",
      Delta: "Î",
      delta: "Î´",
      demptyv: "â¦±",
      dfisht: "â¥¿",
      Dfr: "ð",
      dfr: "ð¡",
      dHar: "â¥¥",
      dharl: "â",
      dharr: "â",
      DiacriticalAcute: "Â´",
      DiacriticalDot: "Ë",
      DiacriticalDoubleAcute: "Ë",
      DiacriticalGrave: "`",
      DiacriticalTilde: "Ë",
      diam: "â",
      Diamond: "â",
      diamond: "â",
      diamondsuit: "â¦",
      diams: "â¦",
      die: "Â¨",
      DifferentialD: "â",
      digamma: "Ï",
      disin: "â²",
      div: "Ã·",
      divide: "Ã·",
      divideontimes: "â",
      divonx: "â",
      DJcy: "Ð",
      djcy: "Ñ",
      dlcorn: "â",
      dlcrop: "â",
      dollar: "$",
      Dopf: "ð»",
      dopf: "ð",
      Dot: "Â¨",
      dot: "Ë",
      DotDot: "â",
      doteq: "â",
      doteqdot: "â",
      DotEqual: "â",
      dotminus: "â¸",
      dotplus: "â",
      dotsquare: "â¡",
      doublebarwedge: "â",
      DoubleContourIntegral: "â¯",
      DoubleDot: "Â¨",
      DoubleDownArrow: "â",
      DoubleLeftArrow: "â",
      DoubleLeftRightArrow: "â",
      DoubleLeftTee: "â«¤",
      DoubleLongLeftArrow: "â¸",
      DoubleLongLeftRightArrow: "âº",
      DoubleLongRightArrow: "â¹",
      DoubleRightArrow: "â",
      DoubleRightTee: "â¨",
      DoubleUpArrow: "â",
      DoubleUpDownArrow: "â",
      DoubleVerticalBar: "â¥",
      DownArrow: "â",
      Downarrow: "â",
      downarrow: "â",
      DownArrowBar: "â¤",
      DownArrowUpArrow: "âµ",
      DownBreve: "Ì",
      downdownarrows: "â",
      downharpoonleft: "â",
      downharpoonright: "â",
      DownLeftRightVector: "â¥",
      DownLeftTeeVector: "â¥",
      DownLeftVector: "â½",
      DownLeftVectorBar: "â¥",
      DownRightTeeVector: "â¥",
      DownRightVector: "â",
      DownRightVectorBar: "â¥",
      DownTee: "â¤",
      DownTeeArrow: "â§",
      drbkarow: "â¤",
      drcorn: "â",
      drcrop: "â",
      Dscr: "ð",
      dscr: "ð¹",
      DScy: "Ð",
      dscy: "Ñ",
      dsol: "â§¶",
      Dstrok: "Ä",
      dstrok: "Ä",
      dtdot: "â±",
      dtri: "â¿",
      dtrif: "â¾",
      duarr: "âµ",
      duhar: "â¥¯",
      dwangle: "â¦¦",
      DZcy: "Ð",
      dzcy: "Ñ",
      dzigrarr: "â¿",
      Eacute: "Ã",
      eacute: "Ã©",
      easter: "â©®",
      Ecaron: "Ä",
      ecaron: "Ä",
      ecir: "â",
      Ecirc: "Ã",
      ecirc: "Ãª",
      ecolon: "â",
      Ecy: "Ð­",
      ecy: "Ñ",
      eDDot: "â©·",
      Edot: "Ä",
      eDot: "â",
      edot: "Ä",
      ee: "â",
      efDot: "â",
      Efr: "ð",
      efr: "ð¢",
      eg: "âª",
      Egrave: "Ã",
      egrave: "Ã¨",
      egs: "âª",
      egsdot: "âª",
      el: "âª",
      Element: "â",
      elinters: "â§",
      ell: "â",
      els: "âª",
      elsdot: "âª",
      Emacr: "Ä",
      emacr: "Ä",
      empty: "â",
      emptyset: "â",
      EmptySmallSquare: "â»",
      emptyv: "â",
      EmptyVerySmallSquare: "â«",
      emsp: "â",
      emsp13: "â",
      emsp14: "â",
      ENG: "Å",
      eng: "Å",
      ensp: "â",
      Eogon: "Ä",
      eogon: "Ä",
      Eopf: "ð¼",
      eopf: "ð",
      epar: "â",
      eparsl: "â§£",
      eplus: "â©±",
      epsi: "Îµ",
      Epsilon: "Î",
      epsilon: "Îµ",
      epsiv: "Ïµ",
      eqcirc: "â",
      eqcolon: "â",
      eqsim: "â",
      eqslantgtr: "âª",
      eqslantless: "âª",
      Equal: "â©µ",
      equals: "=",
      EqualTilde: "â",
      equest: "â",
      Equilibrium: "â",
      equiv: "â¡",
      equivDD: "â©¸",
      eqvparsl: "â§¥",
      erarr: "â¥±",
      erDot: "â",
      Escr: "â°",
      escr: "â¯",
      esdot: "â",
      Esim: "â©³",
      esim: "â",
      Eta: "Î",
      eta: "Î·",
      ETH: "Ã",
      eth: "Ã°",
      Euml: "Ã",
      euml: "Ã«",
      euro: "â¬",
      excl: "!",
      exist: "â",
      Exists: "â",
      expectation: "â°",
      ExponentialE: "â",
      exponentiale: "â",
      fallingdotseq: "â",
      Fcy: "Ð¤",
      fcy: "Ñ",
      female: "â",
      ffilig: "ï¬",
      fflig: "ï¬",
      ffllig: "ï¬",
      Ffr: "ð",
      ffr: "ð£",
      filig: "ï¬",
      FilledSmallSquare: "â¼",
      FilledVerySmallSquare: "âª",
      fjlig: "fj",
      flat: "â­",
      fllig: "ï¬",
      fltns: "â±",
      fnof: "Æ",
      Fopf: "ð½",
      fopf: "ð",
      ForAll: "â",
      forall: "â",
      fork: "â",
      forkv: "â«",
      Fouriertrf: "â±",
      fpartint: "â¨",
      frac12: "Â½",
      frac13: "â",
      frac14: "Â¼",
      frac15: "â",
      frac16: "â",
      frac18: "â",
      frac23: "â",
      frac25: "â",
      frac34: "Â¾",
      frac35: "â",
      frac38: "â",
      frac45: "â",
      frac56: "â",
      frac58: "â",
      frac78: "â",
      frasl: "â",
      frown: "â¢",
      Fscr: "â±",
      fscr: "ð»",
      gacute: "Çµ",
      Gamma: "Î",
      gamma: "Î³",
      Gammad: "Ï",
      gammad: "Ï",
      gap: "âª",
      Gbreve: "Ä",
      gbreve: "Ä",
      Gcedil: "Ä¢",
      Gcirc: "Ä",
      gcirc: "Ä",
      Gcy: "Ð",
      gcy: "Ð³",
      Gdot: "Ä ",
      gdot: "Ä¡",
      gE: "â§",
      ge: "â¥",
      gEl: "âª",
      gel: "â",
      geq: "â¥",
      geqq: "â§",
      geqslant: "â©¾",
      ges: "â©¾",
      gescc: "âª©",
      gesdot: "âª",
      gesdoto: "âª",
      gesdotol: "âª",
      gesl: "âï¸",
      gesles: "âª",
      Gfr: "ð",
      gfr: "ð¤",
      Gg: "â",
      gg: "â«",
      ggg: "â",
      gimel: "â·",
      GJcy: "Ð",
      gjcy: "Ñ",
      gl: "â·",
      gla: "âª¥",
      glE: "âª",
      glj: "âª¤",
      gnap: "âª",
      gnapprox: "âª",
      gnE: "â©",
      gne: "âª",
      gneq: "âª",
      gneqq: "â©",
      gnsim: "â§",
      Gopf: "ð¾",
      gopf: "ð",
      grave: "`",
      GreaterEqual: "â¥",
      GreaterEqualLess: "â",
      GreaterFullEqual: "â§",
      GreaterGreater: "âª¢",
      GreaterLess: "â·",
      GreaterSlantEqual: "â©¾",
      GreaterTilde: "â³",
      Gscr: "ð¢",
      gscr: "â",
      gsim: "â³",
      gsime: "âª",
      gsiml: "âª",
      Gt: "â«",
      GT: ">",
      gt: ">",
      gtcc: "âª§",
      gtcir: "â©º",
      gtdot: "â",
      gtlPar: "â¦",
      gtquest: "â©¼",
      gtrapprox: "âª",
      gtrarr: "â¥¸",
      gtrdot: "â",
      gtreqless: "â",
      gtreqqless: "âª",
      gtrless: "â·",
      gtrsim: "â³",
      gvertneqq: "â©ï¸",
      gvnE: "â©ï¸",
      Hacek: "Ë",
      hairsp: "â",
      half: "Â½",
      hamilt: "â",
      HARDcy: "Ðª",
      hardcy: "Ñ",
      hArr: "â",
      harr: "â",
      harrcir: "â¥",
      harrw: "â­",
      Hat: "^",
      hbar: "â",
      Hcirc: "Ä¤",
      hcirc: "Ä¥",
      hearts: "â¥",
      heartsuit: "â¥",
      hellip: "â¦",
      hercon: "â¹",
      Hfr: "â",
      hfr: "ð¥",
      HilbertSpace: "â",
      hksearow: "â¤¥",
      hkswarow: "â¤¦",
      hoarr: "â¿",
      homtht: "â»",
      hookleftarrow: "â©",
      hookrightarrow: "âª",
      Hopf: "â",
      hopf: "ð",
      horbar: "â",
      HorizontalLine: "â",
      Hscr: "â",
      hscr: "ð½",
      hslash: "â",
      Hstrok: "Ä¦",
      hstrok: "Ä§",
      HumpDownHump: "â",
      HumpEqual: "â",
      hybull: "â",
      hyphen: "â",
      Iacute: "Ã",
      iacute: "Ã­",
      ic: "â£",
      Icirc: "Ã",
      icirc: "Ã®",
      Icy: "Ð",
      icy: "Ð¸",
      Idot: "Ä°",
      IEcy: "Ð",
      iecy: "Ðµ",
      iexcl: "Â¡",
      iff: "â",
      Ifr: "â",
      ifr: "ð¦",
      Igrave: "Ã",
      igrave: "Ã¬",
      ii: "â",
      iiiint: "â¨",
      iiint: "â­",
      iinfin: "â§",
      iiota: "â©",
      IJlig: "Ä²",
      ijlig: "Ä³",
      Im: "â",
      Imacr: "Äª",
      imacr: "Ä«",
      image: "â",
      ImaginaryI: "â",
      imagline: "â",
      imagpart: "â",
      imath: "Ä±",
      imof: "â·",
      imped: "Æµ",
      Implies: "â",
      in: "â",
      incare: "â",
      infin: "â",
      infintie: "â§",
      inodot: "Ä±",
      Int: "â¬",
      int: "â«",
      intcal: "âº",
      integers: "â¤",
      Integral: "â«",
      intercal: "âº",
      Intersection: "â",
      intlarhk: "â¨",
      intprod: "â¨¼",
      InvisibleComma: "â£",
      InvisibleTimes: "â¢",
      IOcy: "Ð",
      iocy: "Ñ",
      Iogon: "Ä®",
      iogon: "Ä¯",
      Iopf: "ð",
      iopf: "ð",
      Iota: "Î",
      iota: "Î¹",
      iprod: "â¨¼",
      iquest: "Â¿",
      Iscr: "â",
      iscr: "ð¾",
      isin: "â",
      isindot: "âµ",
      isinE: "â¹",
      isins: "â´",
      isinsv: "â³",
      isinv: "â",
      it: "â¢",
      Itilde: "Ä¨",
      itilde: "Ä©",
      Iukcy: "Ð",
      iukcy: "Ñ",
      Iuml: "Ã",
      iuml: "Ã¯",
      Jcirc: "Ä´",
      jcirc: "Äµ",
      Jcy: "Ð",
      jcy: "Ð¹",
      Jfr: "ð",
      jfr: "ð§",
      jmath: "È·",
      Jopf: "ð",
      jopf: "ð",
      Jscr: "ð¥",
      jscr: "ð¿",
      Jsercy: "Ð",
      jsercy: "Ñ",
      Jukcy: "Ð",
      jukcy: "Ñ",
      Kappa: "Î",
      kappa: "Îº",
      kappav: "Ï°",
      Kcedil: "Ä¶",
      kcedil: "Ä·",
      Kcy: "Ð",
      kcy: "Ðº",
      Kfr: "ð",
      kfr: "ð¨",
      kgreen: "Ä¸",
      KHcy: "Ð¥",
      khcy: "Ñ",
      KJcy: "Ð",
      kjcy: "Ñ",
      Kopf: "ð",
      kopf: "ð",
      Kscr: "ð¦",
      kscr: "ð",
      lAarr: "â",
      Lacute: "Ä¹",
      lacute: "Äº",
      laemptyv: "â¦´",
      lagran: "â",
      Lambda: "Î",
      lambda: "Î»",
      Lang: "âª",
      lang: "â¨",
      langd: "â¦",
      langle: "â¨",
      lap: "âª",
      Laplacetrf: "â",
      laquo: "Â«",
      Larr: "â",
      lArr: "â",
      larr: "â",
      larrb: "â¤",
      larrbfs: "â¤",
      larrfs: "â¤",
      larrhk: "â©",
      larrlp: "â«",
      larrpl: "â¤¹",
      larrsim: "â¥³",
      larrtl: "â¢",
      lat: "âª«",
      lAtail: "â¤",
      latail: "â¤",
      late: "âª­",
      lates: "âª­ï¸",
      lBarr: "â¤",
      lbarr: "â¤",
      lbbrk: "â²",
      lbrace: "{",
      lbrack: "[",
      lbrke: "â¦",
      lbrksld: "â¦",
      lbrkslu: "â¦",
      Lcaron: "Ä½",
      lcaron: "Ä¾",
      Lcedil: "Ä»",
      lcedil: "Ä¼",
      lceil: "â",
      lcub: "{",
      Lcy: "Ð",
      lcy: "Ð»",
      ldca: "â¤¶",
      ldquo: "â",
      ldquor: "â",
      ldrdhar: "â¥§",
      ldrushar: "â¥",
      ldsh: "â²",
      lE: "â¦",
      le: "â¤",
      LeftAngleBracket: "â¨",
      LeftArrow: "â",
      Leftarrow: "â",
      leftarrow: "â",
      LeftArrowBar: "â¤",
      LeftArrowRightArrow: "â",
      leftarrowtail: "â¢",
      LeftCeiling: "â",
      LeftDoubleBracket: "â¦",
      LeftDownTeeVector: "â¥¡",
      LeftDownVector: "â",
      LeftDownVectorBar: "â¥",
      LeftFloor: "â",
      leftharpoondown: "â½",
      leftharpoonup: "â¼",
      leftleftarrows: "â",
      LeftRightArrow: "â",
      Leftrightarrow: "â",
      leftrightarrow: "â",
      leftrightarrows: "â",
      leftrightharpoons: "â",
      leftrightsquigarrow: "â­",
      LeftRightVector: "â¥",
      LeftTee: "â£",
      LeftTeeArrow: "â¤",
      LeftTeeVector: "â¥",
      leftthreetimes: "â",
      LeftTriangle: "â²",
      LeftTriangleBar: "â§",
      LeftTriangleEqual: "â´",
      LeftUpDownVector: "â¥",
      LeftUpTeeVector: "â¥ ",
      LeftUpVector: "â¿",
      LeftUpVectorBar: "â¥",
      LeftVector: "â¼",
      LeftVectorBar: "â¥",
      lEg: "âª",
      leg: "â",
      leq: "â¤",
      leqq: "â¦",
      leqslant: "â©½",
      les: "â©½",
      lescc: "âª¨",
      lesdot: "â©¿",
      lesdoto: "âª",
      lesdotor: "âª",
      lesg: "âï¸",
      lesges: "âª",
      lessapprox: "âª",
      lessdot: "â",
      lesseqgtr: "â",
      lesseqqgtr: "âª",
      LessEqualGreater: "â",
      LessFullEqual: "â¦",
      LessGreater: "â¶",
      lessgtr: "â¶",
      LessLess: "âª¡",
      lesssim: "â²",
      LessSlantEqual: "â©½",
      LessTilde: "â²",
      lfisht: "â¥¼",
      lfloor: "â",
      Lfr: "ð",
      lfr: "ð©",
      lg: "â¶",
      lgE: "âª",
      lHar: "â¥¢",
      lhard: "â½",
      lharu: "â¼",
      lharul: "â¥ª",
      lhblk: "â",
      LJcy: "Ð",
      ljcy: "Ñ",
      Ll: "â",
      ll: "âª",
      llarr: "â",
      llcorner: "â",
      Lleftarrow: "â",
      llhard: "â¥«",
      lltri: "âº",
      Lmidot: "Ä¿",
      lmidot: "Å",
      lmoust: "â°",
      lmoustache: "â°",
      lnap: "âª",
      lnapprox: "âª",
      lnE: "â¨",
      lne: "âª",
      lneq: "âª",
      lneqq: "â¨",
      lnsim: "â¦",
      loang: "â¬",
      loarr: "â½",
      lobrk: "â¦",
      LongLeftArrow: "âµ",
      Longleftarrow: "â¸",
      longleftarrow: "âµ",
      LongLeftRightArrow: "â·",
      Longleftrightarrow: "âº",
      longleftrightarrow: "â·",
      longmapsto: "â¼",
      LongRightArrow: "â¶",
      Longrightarrow: "â¹",
      longrightarrow: "â¶",
      looparrowleft: "â«",
      looparrowright: "â¬",
      lopar: "â¦",
      Lopf: "ð",
      lopf: "ð",
      loplus: "â¨­",
      lotimes: "â¨´",
      lowast: "â",
      lowbar: "_",
      LowerLeftArrow: "â",
      LowerRightArrow: "â",
      loz: "â",
      lozenge: "â",
      lozf: "â§«",
      lpar: "(",
      lparlt: "â¦",
      lrarr: "â",
      lrcorner: "â",
      lrhar: "â",
      lrhard: "â¥­",
      lrm: "â",
      lrtri: "â¿",
      lsaquo: "â¹",
      Lscr: "â",
      lscr: "ð",
      Lsh: "â°",
      lsh: "â°",
      lsim: "â²",
      lsime: "âª",
      lsimg: "âª",
      lsqb: "[",
      lsquo: "â",
      lsquor: "â",
      Lstrok: "Å",
      lstrok: "Å",
      Lt: "âª",
      LT: "<",
      lt: "<",
      ltcc: "âª¦",
      ltcir: "â©¹",
      ltdot: "â",
      lthree: "â",
      ltimes: "â",
      ltlarr: "â¥¶",
      ltquest: "â©»",
      ltri: "â",
      ltrie: "â´",
      ltrif: "â",
      ltrPar: "â¦",
      lurdshar: "â¥",
      luruhar: "â¥¦",
      lvertneqq: "â¨ï¸",
      lvnE: "â¨ï¸",
      macr: "Â¯",
      male: "â",
      malt: "â ",
      maltese: "â ",
      Map: "â¤",
      map: "â¦",
      mapsto: "â¦",
      mapstodown: "â§",
      mapstoleft: "â¤",
      mapstoup: "â¥",
      marker: "â®",
      mcomma: "â¨©",
      Mcy: "Ð",
      mcy: "Ð¼",
      mdash: "â",
      mDDot: "âº",
      measuredangle: "â¡",
      MediumSpace: "â",
      Mellintrf: "â³",
      Mfr: "ð",
      mfr: "ðª",
      mho: "â§",
      micro: "Âµ",
      mid: "â£",
      midast: "*",
      midcir: "â«°",
      middot: "Â·",
      minus: "â",
      minusb: "â",
      minusd: "â¸",
      minusdu: "â¨ª",
      MinusPlus: "â",
      mlcp: "â«",
      mldr: "â¦",
      mnplus: "â",
      models: "â§",
      Mopf: "ð",
      mopf: "ð",
      mp: "â",
      Mscr: "â³",
      mscr: "ð",
      mstpos: "â¾",
      Mu: "Î",
      mu: "Î¼",
      multimap: "â¸",
      mumap: "â¸",
      nabla: "â",
      Nacute: "Å",
      nacute: "Å",
      nang: "â â",
      nap: "â",
      napE: "â©°Ì¸",
      napid: "âÌ¸",
      napos: "Å",
      napprox: "â",
      natur: "â®",
      natural: "â®",
      naturals: "â",
      nbsp: "Â ",
      nbump: "âÌ¸",
      nbumpe: "âÌ¸",
      ncap: "â©",
      Ncaron: "Å",
      ncaron: "Å",
      Ncedil: "Å",
      ncedil: "Å",
      ncong: "â",
      ncongdot: "â©­Ì¸",
      ncup: "â©",
      Ncy: "Ð",
      ncy: "Ð½",
      ndash: "â",
      ne: "â ",
      nearhk: "â¤¤",
      neArr: "â",
      nearr: "â",
      nearrow: "â",
      nedot: "âÌ¸",
      NegativeMediumSpace: "â",
      NegativeThickSpace: "â",
      NegativeThinSpace: "â",
      NegativeVeryThinSpace: "â",
      nequiv: "â¢",
      nesear: "â¤¨",
      nesim: "âÌ¸",
      NestedGreaterGreater: "â«",
      NestedLessLess: "âª",
      NewLine: "\n",
      nexist: "â",
      nexists: "â",
      Nfr: "ð",
      nfr: "ð«",
      ngE: "â§Ì¸",
      nge: "â±",
      ngeq: "â±",
      ngeqq: "â§Ì¸",
      ngeqslant: "â©¾Ì¸",
      nges: "â©¾Ì¸",
      nGg: "âÌ¸",
      ngsim: "âµ",
      nGt: "â«â",
      ngt: "â¯",
      ngtr: "â¯",
      nGtv: "â«Ì¸",
      nhArr: "â",
      nharr: "â®",
      nhpar: "â«²",
      ni: "â",
      nis: "â¼",
      nisd: "âº",
      niv: "â",
      NJcy: "Ð",
      njcy: "Ñ",
      nlArr: "â",
      nlarr: "â",
      nldr: "â¥",
      nlE: "â¦Ì¸",
      nle: "â°",
      nLeftarrow: "â",
      nleftarrow: "â",
      nLeftrightarrow: "â",
      nleftrightarrow: "â®",
      nleq: "â°",
      nleqq: "â¦Ì¸",
      nleqslant: "â©½Ì¸",
      nles: "â©½Ì¸",
      nless: "â®",
      nLl: "âÌ¸",
      nlsim: "â´",
      nLt: "âªâ",
      nlt: "â®",
      nltri: "âª",
      nltrie: "â¬",
      nLtv: "âªÌ¸",
      nmid: "â¤",
      NoBreak: "â ",
      NonBreakingSpace: "Â ",
      Nopf: "â",
      nopf: "ð",
      Not: "â«¬",
      not: "Â¬",
      NotCongruent: "â¢",
      NotCupCap: "â­",
      NotDoubleVerticalBar: "â¦",
      NotElement: "â",
      NotEqual: "â ",
      NotEqualTilde: "âÌ¸",
      NotExists: "â",
      NotGreater: "â¯",
      NotGreaterEqual: "â±",
      NotGreaterFullEqual: "â§Ì¸",
      NotGreaterGreater: "â«Ì¸",
      NotGreaterLess: "â¹",
      NotGreaterSlantEqual: "â©¾Ì¸",
      NotGreaterTilde: "âµ",
      NotHumpDownHump: "âÌ¸",
      NotHumpEqual: "âÌ¸",
      notin: "â",
      notindot: "âµÌ¸",
      notinE: "â¹Ì¸",
      notinva: "â",
      notinvb: "â·",
      notinvc: "â¶",
      NotLeftTriangle: "âª",
      NotLeftTriangleBar: "â§Ì¸",
      NotLeftTriangleEqual: "â¬",
      NotLess: "â®",
      NotLessEqual: "â°",
      NotLessGreater: "â¸",
      NotLessLess: "âªÌ¸",
      NotLessSlantEqual: "â©½Ì¸",
      NotLessTilde: "â´",
      NotNestedGreaterGreater: "âª¢Ì¸",
      NotNestedLessLess: "âª¡Ì¸",
      notni: "â",
      notniva: "â",
      notnivb: "â¾",
      notnivc: "â½",
      NotPrecedes: "â",
      NotPrecedesEqual: "âª¯Ì¸",
      NotPrecedesSlantEqual: "â ",
      NotReverseElement: "â",
      NotRightTriangle: "â«",
      NotRightTriangleBar: "â§Ì¸",
      NotRightTriangleEqual: "â­",
      NotSquareSubset: "âÌ¸",
      NotSquareSubsetEqual: "â¢",
      NotSquareSuperset: "âÌ¸",
      NotSquareSupersetEqual: "â£",
      NotSubset: "ââ",
      NotSubsetEqual: "â",
      NotSucceeds: "â",
      NotSucceedsEqual: "âª°Ì¸",
      NotSucceedsSlantEqual: "â¡",
      NotSucceedsTilde: "â¿Ì¸",
      NotSuperset: "ââ",
      NotSupersetEqual: "â",
      NotTilde: "â",
      NotTildeEqual: "â",
      NotTildeFullEqual: "â",
      NotTildeTilde: "â",
      NotVerticalBar: "â¤",
      npar: "â¦",
      nparallel: "â¦",
      nparsl: "â«½â¥",
      npart: "âÌ¸",
      npolint: "â¨",
      npr: "â",
      nprcue: "â ",
      npre: "âª¯Ì¸",
      nprec: "â",
      npreceq: "âª¯Ì¸",
      nrArr: "â",
      nrarr: "â",
      nrarrc: "â¤³Ì¸",
      nrarrw: "âÌ¸",
      nRightarrow: "â",
      nrightarrow: "â",
      nrtri: "â«",
      nrtrie: "â­",
      nsc: "â",
      nsccue: "â¡",
      nsce: "âª°Ì¸",
      Nscr: "ð©",
      nscr: "ð",
      nshortmid: "â¤",
      nshortparallel: "â¦",
      nsim: "â",
      nsime: "â",
      nsimeq: "â",
      nsmid: "â¤",
      nspar: "â¦",
      nsqsube: "â¢",
      nsqsupe: "â£",
      nsub: "â",
      nsubE: "â«Ì¸",
      nsube: "â",
      nsubset: "ââ",
      nsubseteq: "â",
      nsubseteqq: "â«Ì¸",
      nsucc: "â",
      nsucceq: "âª°Ì¸",
      nsup: "â",
      nsupE: "â«Ì¸",
      nsupe: "â",
      nsupset: "ââ",
      nsupseteq: "â",
      nsupseteqq: "â«Ì¸",
      ntgl: "â¹",
      Ntilde: "Ã",
      ntilde: "Ã±",
      ntlg: "â¸",
      ntriangleleft: "âª",
      ntrianglelefteq: "â¬",
      ntriangleright: "â«",
      ntrianglerighteq: "â­",
      Nu: "Î",
      nu: "Î½",
      num: "#",
      numero: "â",
      numsp: "â",
      nvap: "ââ",
      nVDash: "â¯",
      nVdash: "â®",
      nvDash: "â­",
      nvdash: "â¬",
      nvge: "â¥â",
      nvgt: ">â",
      nvHarr: "â¤",
      nvinfin: "â§",
      nvlArr: "â¤",
      nvle: "â¤â",
      nvlt: "<â",
      nvltrie: "â´â",
      nvrArr: "â¤",
      nvrtrie: "âµâ",
      nvsim: "â¼â",
      nwarhk: "â¤£",
      nwArr: "â",
      nwarr: "â",
      nwarrow: "â",
      nwnear: "â¤§",
      Oacute: "Ã",
      oacute: "Ã³",
      oast: "â",
      ocir: "â",
      Ocirc: "Ã",
      ocirc: "Ã´",
      Ocy: "Ð",
      ocy: "Ð¾",
      odash: "â",
      Odblac: "Å",
      odblac: "Å",
      odiv: "â¨¸",
      odot: "â",
      odsold: "â¦¼",
      OElig: "Å",
      oelig: "Å",
      ofcir: "â¦¿",
      Ofr: "ð",
      ofr: "ð¬",
      ogon: "Ë",
      Ograve: "Ã",
      ograve: "Ã²",
      ogt: "â§",
      ohbar: "â¦µ",
      ohm: "Î©",
      oint: "â®",
      olarr: "âº",
      olcir: "â¦¾",
      olcross: "â¦»",
      oline: "â¾",
      olt: "â§",
      Omacr: "Å",
      omacr: "Å",
      Omega: "Î©",
      omega: "Ï",
      Omicron: "Î",
      omicron: "Î¿",
      omid: "â¦¶",
      ominus: "â",
      Oopf: "ð",
      oopf: "ð ",
      opar: "â¦·",
      OpenCurlyDoubleQuote: "â",
      OpenCurlyQuote: "â",
      operp: "â¦¹",
      oplus: "â",
      Or: "â©",
      or: "â¨",
      orarr: "â»",
      ord: "â©",
      order: "â´",
      orderof: "â´",
      ordf: "Âª",
      ordm: "Âº",
      origof: "â¶",
      oror: "â©",
      orslope: "â©",
      orv: "â©",
      oS: "â",
      Oscr: "ðª",
      oscr: "â´",
      Oslash: "Ã",
      oslash: "Ã¸",
      osol: "â",
      Otilde: "Ã",
      otilde: "Ãµ",
      Otimes: "â¨·",
      otimes: "â",
      otimesas: "â¨¶",
      Ouml: "Ã",
      ouml: "Ã¶",
      ovbar: "â½",
      OverBar: "â¾",
      OverBrace: "â",
      OverBracket: "â´",
      OverParenthesis: "â",
      par: "â¥",
      para: "Â¶",
      parallel: "â¥",
      parsim: "â«³",
      parsl: "â«½",
      part: "â",
      PartialD: "â",
      Pcy: "Ð",
      pcy: "Ð¿",
      percnt: "%",
      period: ".",
      permil: "â°",
      perp: "â¥",
      pertenk: "â±",
      Pfr: "ð",
      pfr: "ð­",
      Phi: "Î¦",
      phi: "Ï",
      phiv: "Ï",
      phmmat: "â³",
      phone: "â",
      Pi: "Î ",
      pi: "Ï",
      pitchfork: "â",
      piv: "Ï",
      planck: "â",
      planckh: "â",
      plankv: "â",
      plus: "+",
      plusacir: "â¨£",
      plusb: "â",
      pluscir: "â¨¢",
      plusdo: "â",
      plusdu: "â¨¥",
      pluse: "â©²",
      PlusMinus: "Â±",
      plusmn: "Â±",
      plussim: "â¨¦",
      plustwo: "â¨§",
      pm: "Â±",
      Poincareplane: "â",
      pointint: "â¨",
      Popf: "â",
      popf: "ð¡",
      pound: "Â£",
      Pr: "âª»",
      pr: "âº",
      prap: "âª·",
      prcue: "â¼",
      prE: "âª³",
      pre: "âª¯",
      prec: "âº",
      precapprox: "âª·",
      preccurlyeq: "â¼",
      Precedes: "âº",
      PrecedesEqual: "âª¯",
      PrecedesSlantEqual: "â¼",
      PrecedesTilde: "â¾",
      preceq: "âª¯",
      precnapprox: "âª¹",
      precneqq: "âªµ",
      precnsim: "â¨",
      precsim: "â¾",
      Prime: "â³",
      prime: "â²",
      primes: "â",
      prnap: "âª¹",
      prnE: "âªµ",
      prnsim: "â¨",
      prod: "â",
      Product: "â",
      profalar: "â®",
      profline: "â",
      profsurf: "â",
      prop: "â",
      Proportion: "â·",
      Proportional: "â",
      propto: "â",
      prsim: "â¾",
      prurel: "â°",
      Pscr: "ð«",
      pscr: "ð",
      Psi: "Î¨",
      psi: "Ï",
      puncsp: "â",
      Qfr: "ð",
      qfr: "ð®",
      qint: "â¨",
      Qopf: "â",
      qopf: "ð¢",
      qprime: "â",
      Qscr: "ð¬",
      qscr: "ð",
      quaternions: "â",
      quatint: "â¨",
      quest: "?",
      questeq: "â",
      QUOT: '"',
      quot: '"',
      rAarr: "â",
      race: "â½Ì±",
      Racute: "Å",
      racute: "Å",
      radic: "â",
      raemptyv: "â¦³",
      Rang: "â«",
      rang: "â©",
      rangd: "â¦",
      range: "â¦¥",
      rangle: "â©",
      raquo: "Â»",
      Rarr: "â ",
      rArr: "â",
      rarr: "â",
      rarrap: "â¥µ",
      rarrb: "â¥",
      rarrbfs: "â¤ ",
      rarrc: "â¤³",
      rarrfs: "â¤",
      rarrhk: "âª",
      rarrlp: "â¬",
      rarrpl: "â¥",
      rarrsim: "â¥´",
      Rarrtl: "â¤",
      rarrtl: "â£",
      rarrw: "â",
      rAtail: "â¤",
      ratail: "â¤",
      ratio: "â¶",
      rationals: "â",
      RBarr: "â¤",
      rBarr: "â¤",
      rbarr: "â¤",
      rbbrk: "â³",
      rbrace: "}",
      rbrack: "]",
      rbrke: "â¦",
      rbrksld: "â¦",
      rbrkslu: "â¦",
      Rcaron: "Å",
      rcaron: "Å",
      Rcedil: "Å",
      rcedil: "Å",
      rceil: "â",
      rcub: "}",
      Rcy: "Ð ",
      rcy: "Ñ",
      rdca: "â¤·",
      rdldhar: "â¥©",
      rdquo: "â",
      rdquor: "â",
      rdsh: "â³",
      Re: "â",
      real: "â",
      realine: "â",
      realpart: "â",
      reals: "â",
      rect: "â­",
      REG: "Â®",
      reg: "Â®",
      ReverseElement: "â",
      ReverseEquilibrium: "â",
      ReverseUpEquilibrium: "â¥¯",
      rfisht: "â¥½",
      rfloor: "â",
      Rfr: "â",
      rfr: "ð¯",
      rHar: "â¥¤",
      rhard: "â",
      rharu: "â",
      rharul: "â¥¬",
      Rho: "Î¡",
      rho: "Ï",
      rhov: "Ï±",
      RightAngleBracket: "â©",
      RightArrow: "â",
      Rightarrow: "â",
      rightarrow: "â",
      RightArrowBar: "â¥",
      RightArrowLeftArrow: "â",
      rightarrowtail: "â£",
      RightCeiling: "â",
      RightDoubleBracket: "â§",
      RightDownTeeVector: "â¥",
      RightDownVector: "â",
      RightDownVectorBar: "â¥",
      RightFloor: "â",
      rightharpoondown: "â",
      rightharpoonup: "â",
      rightleftarrows: "â",
      rightleftharpoons: "â",
      rightrightarrows: "â",
      rightsquigarrow: "â",
      RightTee: "â¢",
      RightTeeArrow: "â¦",
      RightTeeVector: "â¥",
      rightthreetimes: "â",
      RightTriangle: "â³",
      RightTriangleBar: "â§",
      RightTriangleEqual: "âµ",
      RightUpDownVector: "â¥",
      RightUpTeeVector: "â¥",
      RightUpVector: "â¾",
      RightUpVectorBar: "â¥",
      RightVector: "â",
      RightVectorBar: "â¥",
      ring: "Ë",
      risingdotseq: "â",
      rlarr: "â",
      rlhar: "â",
      rlm: "â",
      rmoust: "â±",
      rmoustache: "â±",
      rnmid: "â«®",
      roang: "â­",
      roarr: "â¾",
      robrk: "â§",
      ropar: "â¦",
      Ropf: "â",
      ropf: "ð£",
      roplus: "â¨®",
      rotimes: "â¨µ",
      RoundImplies: "â¥°",
      rpar: ")",
      rpargt: "â¦",
      rppolint: "â¨",
      rrarr: "â",
      Rrightarrow: "â",
      rsaquo: "âº",
      Rscr: "â",
      rscr: "ð",
      Rsh: "â±",
      rsh: "â±",
      rsqb: "]",
      rsquo: "â",
      rsquor: "â",
      rthree: "â",
      rtimes: "â",
      rtri: "â¹",
      rtrie: "âµ",
      rtrif: "â¸",
      rtriltri: "â§",
      RuleDelayed: "â§´",
      ruluhar: "â¥¨",
      rx: "â",
      Sacute: "Å",
      sacute: "Å",
      sbquo: "â",
      Sc: "âª¼",
      sc: "â»",
      scap: "âª¸",
      Scaron: "Å ",
      scaron: "Å¡",
      sccue: "â½",
      scE: "âª´",
      sce: "âª°",
      Scedil: "Å",
      scedil: "Å",
      Scirc: "Å",
      scirc: "Å",
      scnap: "âªº",
      scnE: "âª¶",
      scnsim: "â©",
      scpolint: "â¨",
      scsim: "â¿",
      Scy: "Ð¡",
      scy: "Ñ",
      sdot: "â",
      sdotb: "â¡",
      sdote: "â©¦",
      searhk: "â¤¥",
      seArr: "â",
      searr: "â",
      searrow: "â",
      sect: "Â§",
      semi: ";",
      seswar: "â¤©",
      setminus: "â",
      setmn: "â",
      sext: "â¶",
      Sfr: "ð",
      sfr: "ð°",
      sfrown: "â¢",
      sharp: "â¯",
      SHCHcy: "Ð©",
      shchcy: "Ñ",
      SHcy: "Ð¨",
      shcy: "Ñ",
      ShortDownArrow: "â",
      ShortLeftArrow: "â",
      shortmid: "â£",
      shortparallel: "â¥",
      ShortRightArrow: "â",
      ShortUpArrow: "â",
      shy: "Â­",
      Sigma: "Î£",
      sigma: "Ï",
      sigmaf: "Ï",
      sigmav: "Ï",
      sim: "â¼",
      simdot: "â©ª",
      sime: "â",
      simeq: "â",
      simg: "âª",
      simgE: "âª ",
      siml: "âª",
      simlE: "âª",
      simne: "â",
      simplus: "â¨¤",
      simrarr: "â¥²",
      slarr: "â",
      SmallCircle: "â",
      smallsetminus: "â",
      smashp: "â¨³",
      smeparsl: "â§¤",
      smid: "â£",
      smile: "â£",
      smt: "âªª",
      smte: "âª¬",
      smtes: "âª¬ï¸",
      SOFTcy: "Ð¬",
      softcy: "Ñ",
      sol: "/",
      solb: "â§",
      solbar: "â¿",
      Sopf: "ð",
      sopf: "ð¤",
      spades: "â ",
      spadesuit: "â ",
      spar: "â¥",
      sqcap: "â",
      sqcaps: "âï¸",
      sqcup: "â",
      sqcups: "âï¸",
      Sqrt: "â",
      sqsub: "â",
      sqsube: "â",
      sqsubset: "â",
      sqsubseteq: "â",
      sqsup: "â",
      sqsupe: "â",
      sqsupset: "â",
      sqsupseteq: "â",
      squ: "â¡",
      Square: "â¡",
      square: "â¡",
      SquareIntersection: "â",
      SquareSubset: "â",
      SquareSubsetEqual: "â",
      SquareSuperset: "â",
      SquareSupersetEqual: "â",
      SquareUnion: "â",
      squarf: "âª",
      squf: "âª",
      srarr: "â",
      Sscr: "ð®",
      sscr: "ð",
      ssetmn: "â",
      ssmile: "â£",
      sstarf: "â",
      Star: "â",
      star: "â",
      starf: "â",
      straightepsilon: "Ïµ",
      straightphi: "Ï",
      strns: "Â¯",
      Sub: "â",
      sub: "â",
      subdot: "âª½",
      subE: "â«",
      sube: "â",
      subedot: "â«",
      submult: "â«",
      subnE: "â«",
      subne: "â",
      subplus: "âª¿",
      subrarr: "â¥¹",
      Subset: "â",
      subset: "â",
      subseteq: "â",
      subseteqq: "â«",
      SubsetEqual: "â",
      subsetneq: "â",
      subsetneqq: "â«",
      subsim: "â«",
      subsub: "â«",
      subsup: "â«",
      succ: "â»",
      succapprox: "âª¸",
      succcurlyeq: "â½",
      Succeeds: "â»",
      SucceedsEqual: "âª°",
      SucceedsSlantEqual: "â½",
      SucceedsTilde: "â¿",
      succeq: "âª°",
      succnapprox: "âªº",
      succneqq: "âª¶",
      succnsim: "â©",
      succsim: "â¿",
      SuchThat: "â",
      Sum: "â",
      sum: "â",
      sung: "âª",
      Sup: "â",
      sup: "â",
      sup1: "Â¹",
      sup2: "Â²",
      sup3: "Â³",
      supdot: "âª¾",
      supdsub: "â«",
      supE: "â«",
      supe: "â",
      supedot: "â«",
      Superset: "â",
      SupersetEqual: "â",
      suphsol: "â",
      suphsub: "â«",
      suplarr: "â¥»",
      supmult: "â«",
      supnE: "â«",
      supne: "â",
      supplus: "â«",
      Supset: "â",
      supset: "â",
      supseteq: "â",
      supseteqq: "â«",
      supsetneq: "â",
      supsetneqq: "â«",
      supsim: "â«",
      supsub: "â«",
      supsup: "â«",
      swarhk: "â¤¦",
      swArr: "â",
      swarr: "â",
      swarrow: "â",
      swnwar: "â¤ª",
      szlig: "Ã",
      Tab: "	",
      target: "â",
      Tau: "Î¤",
      tau: "Ï",
      tbrk: "â´",
      Tcaron: "Å¤",
      tcaron: "Å¥",
      Tcedil: "Å¢",
      tcedil: "Å£",
      Tcy: "Ð¢",
      tcy: "Ñ",
      tdot: "â",
      telrec: "â",
      Tfr: "ð",
      tfr: "ð±",
      there4: "â´",
      Therefore: "â´",
      therefore: "â´",
      Theta: "Î",
      theta: "Î¸",
      thetasym: "Ï",
      thetav: "Ï",
      thickapprox: "â",
      thicksim: "â¼",
      ThickSpace: "ââ",
      thinsp: "â",
      ThinSpace: "â",
      thkap: "â",
      thksim: "â¼",
      THORN: "Ã",
      thorn: "Ã¾",
      Tilde: "â¼",
      tilde: "Ë",
      TildeEqual: "â",
      TildeFullEqual: "â",
      TildeTilde: "â",
      times: "Ã",
      timesb: "â ",
      timesbar: "â¨±",
      timesd: "â¨°",
      tint: "â­",
      toea: "â¤¨",
      top: "â¤",
      topbot: "â¶",
      topcir: "â«±",
      Topf: "ð",
      topf: "ð¥",
      topfork: "â«",
      tosa: "â¤©",
      tprime: "â´",
      TRADE: "â¢",
      trade: "â¢",
      triangle: "âµ",
      triangledown: "â¿",
      triangleleft: "â",
      trianglelefteq: "â´",
      triangleq: "â",
      triangleright: "â¹",
      trianglerighteq: "âµ",
      tridot: "â¬",
      trie: "â",
      triminus: "â¨º",
      TripleDot: "â",
      triplus: "â¨¹",
      trisb: "â§",
      tritime: "â¨»",
      trpezium: "â¢",
      Tscr: "ð¯",
      tscr: "ð",
      TScy: "Ð¦",
      tscy: "Ñ",
      TSHcy: "Ð",
      tshcy: "Ñ",
      Tstrok: "Å¦",
      tstrok: "Å§",
      twixt: "â¬",
      twoheadleftarrow: "â",
      twoheadrightarrow: "â ",
      Uacute: "Ã",
      uacute: "Ãº",
      Uarr: "â",
      uArr: "â",
      uarr: "â",
      Uarrocir: "â¥",
      Ubrcy: "Ð",
      ubrcy: "Ñ",
      Ubreve: "Å¬",
      ubreve: "Å­",
      Ucirc: "Ã",
      ucirc: "Ã»",
      Ucy: "Ð£",
      ucy: "Ñ",
      udarr: "â",
      Udblac: "Å°",
      udblac: "Å±",
      udhar: "â¥®",
      ufisht: "â¥¾",
      Ufr: "ð",
      ufr: "ð²",
      Ugrave: "Ã",
      ugrave: "Ã¹",
      uHar: "â¥£",
      uharl: "â¿",
      uharr: "â¾",
      uhblk: "â",
      ulcorn: "â",
      ulcorner: "â",
      ulcrop: "â",
      ultri: "â¸",
      Umacr: "Åª",
      umacr: "Å«",
      uml: "Â¨",
      UnderBar: "_",
      UnderBrace: "â",
      UnderBracket: "âµ",
      UnderParenthesis: "â",
      Union: "â",
      UnionPlus: "â",
      Uogon: "Å²",
      uogon: "Å³",
      Uopf: "ð",
      uopf: "ð¦",
      UpArrow: "â",
      Uparrow: "â",
      uparrow: "â",
      UpArrowBar: "â¤",
      UpArrowDownArrow: "â",
      UpDownArrow: "â",
      Updownarrow: "â",
      updownarrow: "â",
      UpEquilibrium: "â¥®",
      upharpoonleft: "â¿",
      upharpoonright: "â¾",
      uplus: "â",
      UpperLeftArrow: "â",
      UpperRightArrow: "â",
      Upsi: "Ï",
      upsi: "Ï",
      upsih: "Ï",
      Upsilon: "Î¥",
      upsilon: "Ï",
      UpTee: "â¥",
      UpTeeArrow: "â¥",
      upuparrows: "â",
      urcorn: "â",
      urcorner: "â",
      urcrop: "â",
      Uring: "Å®",
      uring: "Å¯",
      urtri: "â¹",
      Uscr: "ð°",
      uscr: "ð",
      utdot: "â°",
      Utilde: "Å¨",
      utilde: "Å©",
      utri: "âµ",
      utrif: "â´",
      uuarr: "â",
      Uuml: "Ã",
      uuml: "Ã¼",
      uwangle: "â¦§",
      vangrt: "â¦",
      varepsilon: "Ïµ",
      varkappa: "Ï°",
      varnothing: "â",
      varphi: "Ï",
      varpi: "Ï",
      varpropto: "â",
      vArr: "â",
      varr: "â",
      varrho: "Ï±",
      varsigma: "Ï",
      varsubsetneq: "âï¸",
      varsubsetneqq: "â«ï¸",
      varsupsetneq: "âï¸",
      varsupsetneqq: "â«ï¸",
      vartheta: "Ï",
      vartriangleleft: "â²",
      vartriangleright: "â³",
      Vbar: "â««",
      vBar: "â«¨",
      vBarv: "â«©",
      Vcy: "Ð",
      vcy: "Ð²",
      VDash: "â«",
      Vdash: "â©",
      vDash: "â¨",
      vdash: "â¢",
      Vdashl: "â«¦",
      Vee: "â",
      vee: "â¨",
      veebar: "â»",
      veeeq: "â",
      vellip: "â®",
      Verbar: "â",
      verbar: "|",
      Vert: "â",
      vert: "|",
      VerticalBar: "â£",
      VerticalLine: "|",
      VerticalSeparator: "â",
      VerticalTilde: "â",
      VeryThinSpace: "â",
      Vfr: "ð",
      vfr: "ð³",
      vltri: "â²",
      vnsub: "ââ",
      vnsup: "ââ",
      Vopf: "ð",
      vopf: "ð§",
      vprop: "â",
      vrtri: "â³",
      Vscr: "ð±",
      vscr: "ð",
      vsubnE: "â«ï¸",
      vsubne: "âï¸",
      vsupnE: "â«ï¸",
      vsupne: "âï¸",
      Vvdash: "âª",
      vzigzag: "â¦",
      Wcirc: "Å´",
      wcirc: "Åµ",
      wedbar: "â©",
      Wedge: "â",
      wedge: "â§",
      wedgeq: "â",
      weierp: "â",
      Wfr: "ð",
      wfr: "ð´",
      Wopf: "ð",
      wopf: "ð¨",
      wp: "â",
      wr: "â",
      wreath: "â",
      Wscr: "ð²",
      wscr: "ð",
      xcap: "â",
      xcirc: "â¯",
      xcup: "â",
      xdtri: "â½",
      Xfr: "ð",
      xfr: "ðµ",
      xhArr: "âº",
      xharr: "â·",
      Xi: "Î",
      xi: "Î¾",
      xlArr: "â¸",
      xlarr: "âµ",
      xmap: "â¼",
      xnis: "â»",
      xodot: "â¨",
      Xopf: "ð",
      xopf: "ð©",
      xoplus: "â¨",
      xotime: "â¨",
      xrArr: "â¹",
      xrarr: "â¶",
      Xscr: "ð³",
      xscr: "ð",
      xsqcup: "â¨",
      xuplus: "â¨",
      xutri: "â³",
      xvee: "â",
      xwedge: "â",
      Yacute: "Ã",
      yacute: "Ã½",
      YAcy: "Ð¯",
      yacy: "Ñ",
      Ycirc: "Å¶",
      ycirc: "Å·",
      Ycy: "Ð«",
      ycy: "Ñ",
      yen: "Â¥",
      Yfr: "ð",
      yfr: "ð¶",
      YIcy: "Ð",
      yicy: "Ñ",
      Yopf: "ð",
      yopf: "ðª",
      Yscr: "ð´",
      yscr: "ð",
      YUcy: "Ð®",
      yucy: "Ñ",
      Yuml: "Å¸",
      yuml: "Ã¿",
      Zacute: "Å¹",
      zacute: "Åº",
      Zcaron: "Å½",
      zcaron: "Å¾",
      Zcy: "Ð",
      zcy: "Ð·",
      Zdot: "Å»",
      zdot: "Å¼",
      zeetrf: "â¨",
      ZeroWidthSpace: "â",
      Zeta: "Î",
      zeta: "Î¶",
      Zfr: "â¨",
      zfr: "ð·",
      ZHcy: "Ð",
      zhcy: "Ð¶",
      zigrarr: "â",
      Zopf: "â¤",
      zopf: "ð«",
      Zscr: "ðµ",
      zscr: "ð",
      zwj: "â",
      zwnj: "â"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  })(entities);
  return entities;
}
var sax = {};
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  var NAMESPACE = requireConventions().NAMESPACE;
  var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
  var S_TAG = 0;
  var S_ATTR = 1;
  var S_ATTR_SPACE = 2;
  var S_EQ = 3;
  var S_ATTR_NOQUOT_VALUE = 4;
  var S_ATTR_END = 5;
  var S_TAG_SPACE = 6;
  var S_TAG_CLOSE = 7;
  function ParseError(message, locator) {
    this.message = message;
    this.locator = locator;
    if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
  }
  ParseError.prototype = new Error();
  ParseError.prototype.name = ParseError.name;
  function XMLReader() {
  }
  XMLReader.prototype = {
    parse: function(source, defaultNSMap, entityMap) {
      var domBuilder = this.domBuilder;
      domBuilder.startDocument();
      _copy(defaultNSMap, defaultNSMap = {});
      parse(
        source,
        defaultNSMap,
        entityMap,
        domBuilder,
        this.errorHandler
      );
      domBuilder.endDocument();
    }
  };
  function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
    function fixedFromCharCode(code) {
      if (code > 65535) {
        code -= 65536;
        var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      } else {
        return String.fromCharCode(code);
      }
    }
    function entityReplacer(a2) {
      var k = a2.slice(1, -1);
      if (Object.hasOwnProperty.call(entityMap, k)) {
        return entityMap[k];
      } else if (k.charAt(0) === "#") {
        return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
      } else {
        errorHandler.error("entity not found:" + a2);
        return a2;
      }
    }
    function appendText(end2) {
      if (end2 > start) {
        var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
        locator && position(start);
        domBuilder.characters(xt, 0, end2 - start);
        start = end2;
      }
    }
    function position(p, m) {
      while (p >= lineEnd && (m = linePattern.exec(source))) {
        lineStart = m.index;
        lineEnd = lineStart + m[0].length;
        locator.lineNumber++;
      }
      locator.columnNumber = p - lineStart + 1;
    }
    var lineStart = 0;
    var lineEnd = 0;
    var linePattern = /.*(?:\r\n?|\n)|.*$/g;
    var locator = domBuilder.locator;
    var parseStack = [{ currentNSMap: defaultNSMapCopy }];
    var closeMap = {};
    var start = 0;
    while (true) {
      try {
        var tagStart = source.indexOf("<", start);
        if (tagStart < 0) {
          if (!source.substr(start).match(/^\s*$/)) {
            var doc2 = domBuilder.doc;
            var text = doc2.createTextNode(source.substr(start));
            doc2.appendChild(text);
            domBuilder.currentElement = text;
          }
          return;
        }
        if (tagStart > start) {
          appendText(tagStart);
        }
        switch (source.charAt(tagStart + 1)) {
          case "/":
            var end = source.indexOf(">", tagStart + 3);
            var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
            var config = parseStack.pop();
            if (end < 0) {
              tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
              end = tagStart + 1 + tagName.length;
            } else if (tagName.match(/\s</)) {
              tagName = tagName.replace(/[\s<].*/, "");
              errorHandler.error("end tag name: " + tagName + " maybe not complete");
              end = tagStart + 1 + tagName.length;
            }
            var localNSMap = config.localNSMap;
            var endMatch = config.tagName == tagName;
            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
            if (endIgnoreCaseMach) {
              domBuilder.endElement(config.uri, config.localName, tagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
              }
              if (!endMatch) {
                errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
              }
            } else {
              parseStack.push(config);
            }
            end++;
            break;
          // end elment
          case "?":
            locator && position(tagStart);
            end = parseInstruction(source, tagStart, domBuilder);
            break;
          case "!":
            locator && position(tagStart);
            end = parseDCC(source, tagStart, domBuilder, errorHandler);
            break;
          default:
            locator && position(tagStart);
            var el = new ElementAttributes();
            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
            var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
            var len = el.length;
            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
              el.closed = true;
              if (!entityMap.nbsp) {
                errorHandler.warning("unclosed xml attribute");
              }
            }
            if (locator && len) {
              var locator2 = copyLocator(locator, {});
              for (var i = 0; i < len; i++) {
                var a = el[i];
                position(a.offset);
                a.locator = copyLocator(locator, {});
              }
              domBuilder.locator = locator2;
              if (appendElement(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
              domBuilder.locator = locator;
            } else {
              if (appendElement(el, domBuilder, currentNSMap)) {
                parseStack.push(el);
              }
            }
            if (NAMESPACE.isHTML(el.uri) && !el.closed) {
              end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
            } else {
              end++;
            }
        }
      } catch (e) {
        if (e instanceof ParseError) {
          throw e;
        }
        errorHandler.error("element parse error: " + e);
        end = -1;
      }
      if (end > start) {
        start = end;
      } else {
        appendText(Math.max(tagStart, start) + 1);
      }
    }
  }
  function copyLocator(f, t) {
    t.lineNumber = f.lineNumber;
    t.columnNumber = f.columnNumber;
    return t;
  }
  function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
    function addAttribute(qname, value2, startIndex) {
      if (el.attributeNames.hasOwnProperty(qname)) {
        errorHandler.fatalError("Attribute " + qname + " redefined");
      }
      el.addValue(
        qname,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
        startIndex
      );
    }
    var attrName;
    var value;
    var p = ++start;
    var s = S_TAG;
    while (true) {
      var c = source.charAt(p);
      switch (c) {
        case "=":
          if (s === S_ATTR) {
            attrName = source.slice(start, p);
            s = S_EQ;
          } else if (s === S_ATTR_SPACE) {
            s = S_EQ;
          } else {
            throw new Error("attribute equal must after attrName");
          }
          break;
        case "'":
        case '"':
          if (s === S_EQ || s === S_ATTR) {
            if (s === S_ATTR) {
              errorHandler.warning('attribute value must after "="');
              attrName = source.slice(start, p);
            }
            start = p + 1;
            p = source.indexOf(c, start);
            if (p > 0) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start - 1);
              s = S_ATTR_END;
            } else {
              throw new Error("attribute value no end '" + c + "' match");
            }
          } else if (s == S_ATTR_NOQUOT_VALUE) {
            value = source.slice(start, p);
            addAttribute(attrName, value, start);
            errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
            start = p + 1;
            s = S_ATTR_END;
          } else {
            throw new Error('attribute value must after "="');
          }
          break;
        case "/":
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              s = S_TAG_CLOSE;
              el.closed = true;
            case S_ATTR_NOQUOT_VALUE:
            case S_ATTR:
              break;
            case S_ATTR_SPACE:
              el.closed = true;
              break;
            //case S_EQ:
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          errorHandler.error("unexpected end of input");
          if (s == S_TAG) {
            el.setTagName(source.slice(start, p));
          }
          return p;
        case ">":
          switch (s) {
            case S_TAG:
              el.setTagName(source.slice(start, p));
            case S_ATTR_END:
            case S_TAG_SPACE:
            case S_TAG_CLOSE:
              break;
            //normal
            case S_ATTR_NOQUOT_VALUE:
            //Compatible state
            case S_ATTR:
              value = source.slice(start, p);
              if (value.slice(-1) === "/") {
                el.closed = true;
                value = value.slice(0, -1);
              }
            case S_ATTR_SPACE:
              if (s === S_ATTR_SPACE) {
                value = attrName;
              }
              if (s == S_ATTR_NOQUOT_VALUE) {
                errorHandler.warning('attribute "' + value + '" missed quot(")!');
                addAttribute(attrName, value, start);
              } else {
                if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                }
                addAttribute(value, value, start);
              }
              break;
            case S_EQ:
              throw new Error("attribute value missed!!");
          }
          return p;
        /*xml space '\x20' | #x9 | #xD | #xA; */
        case "Â":
          c = " ";
        default:
          if (c <= " ") {
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
                s = S_TAG_SPACE;
                break;
              case S_ATTR:
                attrName = source.slice(start, p);
                s = S_ATTR_SPACE;
                break;
              case S_ATTR_NOQUOT_VALUE:
                var value = source.slice(start, p);
                errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                addAttribute(attrName, value, start);
              case S_ATTR_END:
                s = S_TAG_SPACE;
                break;
            }
          } else {
            switch (s) {
              //case S_TAG:void();break;
              //case S_ATTR:void();break;
              //case S_ATTR_NOQUOT_VALUE:void();break;
              case S_ATTR_SPACE:
                el.tagName;
                if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                  errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                }
                addAttribute(attrName, attrName, start);
                start = p;
                s = S_ATTR;
                break;
              case S_ATTR_END:
                errorHandler.warning('attribute space is required"' + attrName + '"!!');
              case S_TAG_SPACE:
                s = S_ATTR;
                start = p;
                break;
              case S_EQ:
                s = S_ATTR_NOQUOT_VALUE;
                start = p;
                break;
              case S_TAG_CLOSE:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
          }
      }
      p++;
    }
  }
  function appendElement(el, domBuilder, currentNSMap) {
    var tagName = el.tagName;
    var localNSMap = null;
    var i = el.length;
    while (i--) {
      var a = el[i];
      var qName = a.qName;
      var value = a.value;
      var nsp = qName.indexOf(":");
      if (nsp > 0) {
        var prefix = a.prefix = qName.slice(0, nsp);
        var localName = qName.slice(nsp + 1);
        var nsPrefix = prefix === "xmlns" && localName;
      } else {
        localName = qName;
        prefix = null;
        nsPrefix = qName === "xmlns" && "";
      }
      a.localName = localName;
      if (nsPrefix !== false) {
        if (localNSMap == null) {
          localNSMap = {};
          _copy(currentNSMap, currentNSMap = {});
        }
        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
        a.uri = NAMESPACE.XMLNS;
        domBuilder.startPrefixMapping(nsPrefix, value);
      }
    }
    var i = el.length;
    while (i--) {
      a = el[i];
      var prefix = a.prefix;
      if (prefix) {
        if (prefix === "xml") {
          a.uri = NAMESPACE.XML;
        }
        if (prefix !== "xmlns") {
          a.uri = currentNSMap[prefix || ""];
        }
      }
    }
    var nsp = tagName.indexOf(":");
    if (nsp > 0) {
      prefix = el.prefix = tagName.slice(0, nsp);
      localName = el.localName = tagName.slice(nsp + 1);
    } else {
      prefix = null;
      localName = el.localName = tagName;
    }
    var ns = el.uri = currentNSMap[prefix || ""];
    domBuilder.startElement(ns, localName, tagName, el);
    if (el.closed) {
      domBuilder.endElement(ns, localName, tagName);
      if (localNSMap) {
        for (prefix in localNSMap) {
          if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
            domBuilder.endPrefixMapping(prefix);
          }
        }
      }
    } else {
      el.currentNSMap = currentNSMap;
      el.localNSMap = localNSMap;
      return true;
    }
  }
  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
    if (/^(?:script|textarea)$/i.test(tagName)) {
      var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
      var text = source.substring(elStartEnd + 1, elEndStart);
      if (/[&<]/.test(text)) {
        if (/^script$/i.test(tagName)) {
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
        text = text.replace(/&#?\w+;/g, entityReplacer);
        domBuilder.characters(text, 0, text.length);
        return elEndStart;
      }
    }
    return elStartEnd + 1;
  }
  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
    var pos = closeMap[tagName];
    if (pos == null) {
      pos = source.lastIndexOf("</" + tagName + ">");
      if (pos < elStartEnd) {
        pos = source.lastIndexOf("</" + tagName);
      }
      closeMap[tagName] = pos;
    }
    return pos < elStartEnd;
  }
  function _copy(source, target) {
    for (var n in source) {
      if (Object.prototype.hasOwnProperty.call(source, n)) {
        target[n] = source[n];
      }
    }
  }
  function parseDCC(source, start, domBuilder, errorHandler) {
    var next = source.charAt(start + 2);
    switch (next) {
      case "-":
        if (source.charAt(start + 3) === "-") {
          var end = source.indexOf("-->", start + 4);
          if (end > start) {
            domBuilder.comment(source, start + 4, end - start - 4);
            return end + 3;
          } else {
            errorHandler.error("Unclosed comment");
            return -1;
          }
        } else {
          return -1;
        }
      default:
        if (source.substr(start + 3, 6) == "CDATA[") {
          var end = source.indexOf("]]>", start + 9);
          domBuilder.startCDATA();
          domBuilder.characters(source, start + 9, end - start - 9);
          domBuilder.endCDATA();
          return end + 3;
        }
        var matchs = split2(source, start);
        var len = matchs.length;
        if (len > 1 && /!doctype/i.test(matchs[0][0])) {
          var name = matchs[1][0];
          var pubid = false;
          var sysid = false;
          if (len > 3) {
            if (/^public$/i.test(matchs[2][0])) {
              pubid = matchs[3][0];
              sysid = len > 4 && matchs[4][0];
            } else if (/^system$/i.test(matchs[2][0])) {
              sysid = matchs[3][0];
            }
          }
          var lastMatch = matchs[len - 1];
          domBuilder.startDTD(name, pubid, sysid);
          domBuilder.endDTD();
          return lastMatch.index + lastMatch[0].length;
        }
    }
    return -1;
  }
  function parseInstruction(source, start, domBuilder) {
    var end = source.indexOf("?>", start);
    if (end) {
      var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      if (match) {
        match[0].length;
        domBuilder.processingInstruction(match[1], match[2]);
        return end + 2;
      } else {
        return -1;
      }
    }
    return -1;
  }
  function ElementAttributes() {
    this.attributeNames = {};
  }
  ElementAttributes.prototype = {
    setTagName: function(tagName) {
      if (!tagNamePattern.test(tagName)) {
        throw new Error("invalid tagName:" + tagName);
      }
      this.tagName = tagName;
    },
    addValue: function(qName, value, offset2) {
      if (!tagNamePattern.test(qName)) {
        throw new Error("invalid attribute:" + qName);
      }
      this.attributeNames[qName] = this.length;
      this[this.length++] = { qName, value, offset: offset2 };
    },
    length: 0,
    getLocalName: function(i) {
      return this[i].localName;
    },
    getLocator: function(i) {
      return this[i].locator;
    },
    getQName: function(i) {
      return this[i].qName;
    },
    getURI: function(i) {
      return this[i].uri;
    },
    getValue: function(i) {
      return this[i].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function split2(source, start) {
    var match;
    var buf = [];
    var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    reg.lastIndex = start;
    reg.exec(source);
    while (match = reg.exec(source)) {
      buf.push(match);
      if (match[1]) return buf;
    }
  }
  sax.XMLReader = XMLReader;
  sax.ParseError = ParseError;
  return sax;
}
var hasRequiredDomParser;
function requireDomParser() {
  if (hasRequiredDomParser) return domParser;
  hasRequiredDomParser = 1;
  var conventions2 = requireConventions();
  var dom2 = requireDom();
  var entities2 = requireEntities();
  var sax2 = requireSax();
  var DOMImplementation = dom2.DOMImplementation;
  var NAMESPACE = conventions2.NAMESPACE;
  var ParseError = sax2.ParseError;
  var XMLReader = sax2.XMLReader;
  function normalizeLineEndings(input) {
    return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
  }
  function DOMParser2(options2) {
    this.options = options2 || { locator: {} };
  }
  DOMParser2.prototype.parseFromString = function(source, mimeType) {
    var options2 = this.options;
    var sax3 = new XMLReader();
    var domBuilder = options2.domBuilder || new DOMHandler();
    var errorHandler = options2.errorHandler;
    var locator = options2.locator;
    var defaultNSMap = options2.xmlns || {};
    var isHTML = /\/x?html?$/.test(mimeType);
    var entityMap = isHTML ? entities2.HTML_ENTITIES : entities2.XML_ENTITIES;
    if (locator) {
      domBuilder.setDocumentLocator(locator);
    }
    sax3.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
    sax3.domBuilder = options2.domBuilder || domBuilder;
    if (isHTML) {
      defaultNSMap[""] = NAMESPACE.HTML;
    }
    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
    var normalize2 = options2.normalizeLineEndings || normalizeLineEndings;
    if (source && typeof source === "string") {
      sax3.parse(
        normalize2(source),
        defaultNSMap,
        entityMap
      );
    } else {
      sax3.errorHandler.error("invalid doc source");
    }
    return domBuilder.doc;
  };
  function buildErrorHandler(errorImpl, domBuilder, locator) {
    if (!errorImpl) {
      if (domBuilder instanceof DOMHandler) {
        return domBuilder;
      }
      errorImpl = domBuilder;
    }
    var errorHandler = {};
    var isCallback = errorImpl instanceof Function;
    locator = locator || {};
    function build(key) {
      var fn = errorImpl[key];
      if (!fn && isCallback) {
        fn = errorImpl.length == 2 ? function(msg) {
          errorImpl(key, msg);
        } : errorImpl;
      }
      errorHandler[key] = fn && function(msg) {
        fn("[xmldom " + key + "]	" + msg + _locator(locator));
      } || function() {
      };
    }
    build("warning");
    build("error");
    build("fatalError");
    return errorHandler;
  }
  function DOMHandler() {
    this.cdata = false;
  }
  function position(locator, node) {
    node.lineNumber = locator.lineNumber;
    node.columnNumber = locator.columnNumber;
  }
  DOMHandler.prototype = {
    startDocument: function() {
      this.doc = new DOMImplementation().createDocument(null, null, null);
      if (this.locator) {
        this.doc.documentURI = this.locator.systemId;
      }
    },
    startElement: function(namespaceURI, localName, qName, attrs) {
      var doc2 = this.doc;
      var el = doc2.createElementNS(namespaceURI, qName || localName);
      var len = attrs.length;
      appendElement(this, el);
      this.currentElement = el;
      this.locator && position(this.locator, el);
      for (var i = 0; i < len; i++) {
        var namespaceURI = attrs.getURI(i);
        var value = attrs.getValue(i);
        var qName = attrs.getQName(i);
        var attr = doc2.createAttributeNS(namespaceURI, qName);
        this.locator && position(attrs.getLocator(i), attr);
        attr.value = attr.nodeValue = value;
        el.setAttributeNode(attr);
      }
    },
    endElement: function(namespaceURI, localName, qName) {
      var current = this.currentElement;
      current.tagName;
      this.currentElement = current.parentNode;
    },
    startPrefixMapping: function(prefix, uri) {
    },
    endPrefixMapping: function(prefix) {
    },
    processingInstruction: function(target, data) {
      var ins = this.doc.createProcessingInstruction(target, data);
      this.locator && position(this.locator, ins);
      appendElement(this, ins);
    },
    ignorableWhitespace: function(ch, start, length) {
    },
    characters: function(chars, start, length) {
      chars = _toString.apply(this, arguments);
      if (chars) {
        if (this.cdata) {
          var charNode = this.doc.createCDATASection(chars);
        } else {
          var charNode = this.doc.createTextNode(chars);
        }
        if (this.currentElement) {
          this.currentElement.appendChild(charNode);
        } else if (/^\s*$/.test(chars)) {
          this.doc.appendChild(charNode);
        }
        this.locator && position(this.locator, charNode);
      }
    },
    skippedEntity: function(name) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(locator) {
      if (this.locator = locator) {
        locator.lineNumber = 0;
      }
    },
    //LexicalHandler
    comment: function(chars, start, length) {
      chars = _toString.apply(this, arguments);
      var comm = this.doc.createComment(chars);
      this.locator && position(this.locator, comm);
      appendElement(this, comm);
    },
    startCDATA: function() {
      this.cdata = true;
    },
    endCDATA: function() {
      this.cdata = false;
    },
    startDTD: function(name, publicId, systemId) {
      var impl = this.doc.implementation;
      if (impl && impl.createDocumentType) {
        var dt = impl.createDocumentType(name, publicId, systemId);
        this.locator && position(this.locator, dt);
        appendElement(this, dt);
        this.doc.doctype = dt;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(error) {
      console.warn("[xmldom warning]	" + error, _locator(this.locator));
    },
    error: function(error) {
      console.error("[xmldom error]	" + error, _locator(this.locator));
    },
    fatalError: function(error) {
      throw new ParseError(error, this.locator);
    }
  };
  function _locator(l) {
    if (l) {
      return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
    }
  }
  function _toString(chars, start, length) {
    if (typeof chars == "string") {
      return chars.substr(start, length);
    } else {
      if (chars.length >= start + length || start) {
        return new java.lang.String(chars, start, length) + "";
      }
      return chars;
    }
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
    DOMHandler.prototype[key] = function() {
      return null;
    };
  });
  function appendElement(hander, node) {
    if (!hander.currentElement) {
      hander.doc.appendChild(node);
    } else {
      hander.currentElement.appendChild(node);
    }
  }
  domParser.__DOMHandler = DOMHandler;
  domParser.normalizeLineEndings = normalizeLineEndings;
  domParser.DOMParser = DOMParser2;
  return domParser;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$1;
  hasRequiredLib$2 = 1;
  var dom2 = requireDom();
  lib$1.DOMImplementation = dom2.DOMImplementation;
  lib$1.XMLSerializer = dom2.XMLSerializer;
  lib$1.DOMParser = requireDomParser().DOMParser;
  return lib$1;
}
var hasRequiredXmldom;
function requireXmldom() {
  if (hasRequiredXmldom) return xmldom;
  hasRequiredXmldom = 1;
  var xmldom$1 = requireLib$2();
  var dom2 = requireDom();
  function parseFromString(string) {
    var error = null;
    var domParser2 = new xmldom$1.DOMParser({
      errorHandler: function(level, message) {
        error = { level, message };
      }
    });
    var document2 = domParser2.parseFromString(string);
    if (error === null) {
      return document2;
    } else {
      throw new Error(error.level + ": " + error.message);
    }
  }
  xmldom.parseFromString = parseFromString;
  xmldom.Node = dom2.Node;
  return xmldom;
}
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  var promises2 = requirePromises();
  var _2 = require$$0;
  var xmldom2 = requireXmldom();
  var nodes2 = requireNodes();
  var Element = nodes2.Element;
  reader.readString = readString;
  var Node2 = xmldom2.Node;
  function readString(xmlString, namespaceMap) {
    namespaceMap = namespaceMap || {};
    try {
      var document2 = xmldom2.parseFromString(xmlString, "text/xml");
    } catch (error) {
      return promises2.reject(error);
    }
    if (document2.documentElement.tagName === "parsererror") {
      return promises2.resolve(new Error(document2.documentElement.textContent));
    }
    function convertNode(node) {
      switch (node.nodeType) {
        case Node2.ELEMENT_NODE:
          return convertElement(node);
        case Node2.TEXT_NODE:
          return nodes2.text(node.nodeValue);
      }
    }
    function convertElement(element) {
      var convertedName = convertName(element);
      var convertedChildren = [];
      _2.forEach(element.childNodes, function(childNode) {
        var convertedNode = convertNode(childNode);
        if (convertedNode) {
          convertedChildren.push(convertedNode);
        }
      });
      var convertedAttributes = {};
      _2.forEach(element.attributes, function(attribute) {
        convertedAttributes[convertName(attribute)] = attribute.value;
      });
      return new Element(convertedName, convertedAttributes, convertedChildren);
    }
    function convertName(node) {
      if (node.namespaceURI) {
        var mappedPrefix = namespaceMap[node.namespaceURI];
        var prefix;
        if (mappedPrefix) {
          prefix = mappedPrefix + ":";
        } else {
          prefix = "{" + node.namespaceURI + "}";
        }
        return prefix + node.localName;
      } else {
        return node.localName;
      }
    }
    return promises2.resolve(convertNode(document2.documentElement));
  }
  return reader;
}
var writer = {};
var lib = {};
var Utility = {};
var hasRequiredUtility;
function requireUtility() {
  if (hasRequiredUtility) return Utility;
  hasRequiredUtility = 1;
  (function() {
    var assign, getValue, isArray2, isEmpty2, isFunction2, isObject2, isPlainObject2, slice3 = [].slice, hasProp = {}.hasOwnProperty;
    assign = function() {
      var i, key, len, source, sources, target;
      target = arguments[0], sources = 2 <= arguments.length ? slice3.call(arguments, 1) : [];
      if (isFunction2(Object.assign)) {
        Object.assign.apply(null, arguments);
      } else {
        for (i = 0, len = sources.length; i < len; i++) {
          source = sources[i];
          if (source != null) {
            for (key in source) {
              if (!hasProp.call(source, key)) continue;
              target[key] = source[key];
            }
          }
        }
      }
      return target;
    };
    isFunction2 = function(val) {
      return !!val && Object.prototype.toString.call(val) === "[object Function]";
    };
    isObject2 = function(val) {
      var ref2;
      return !!val && ((ref2 = typeof val) === "function" || ref2 === "object");
    };
    isArray2 = function(val) {
      if (isFunction2(Array.isArray)) {
        return Array.isArray(val);
      } else {
        return Object.prototype.toString.call(val) === "[object Array]";
      }
    };
    isEmpty2 = function(val) {
      var key;
      if (isArray2(val)) {
        return !val.length;
      } else {
        for (key in val) {
          if (!hasProp.call(val, key)) continue;
          return false;
        }
        return true;
      }
    };
    isPlainObject2 = function(val) {
      var ctor2, proto2;
      return isObject2(val) && (proto2 = Object.getPrototypeOf(val)) && (ctor2 = proto2.constructor) && typeof ctor2 === "function" && ctor2 instanceof ctor2 && Function.prototype.toString.call(ctor2) === Function.prototype.toString.call(Object);
    };
    getValue = function(obj) {
      if (isFunction2(obj.valueOf)) {
        return obj.valueOf();
      } else {
        return obj;
      }
    };
    Utility.assign = assign;
    Utility.isFunction = isFunction2;
    Utility.isObject = isObject2;
    Utility.isArray = isArray2;
    Utility.isEmpty = isEmpty2;
    Utility.isPlainObject = isPlainObject2;
    Utility.getValue = getValue;
  }).call(Utility);
  return Utility;
}
var XMLDocument$1 = { exports: {} };
var XMLNode$1 = { exports: {} };
var XMLElement$1 = { exports: {} };
var XMLAttribute$1 = { exports: {} };
var XMLAttribute = XMLAttribute$1.exports;
var hasRequiredXMLAttribute;
function requireXMLAttribute() {
  if (hasRequiredXMLAttribute) return XMLAttribute$1.exports;
  hasRequiredXMLAttribute = 1;
  (function() {
    XMLAttribute$1.exports = (function() {
      function XMLAttribute2(parent, name, value) {
        this.options = parent.options;
        this.stringify = parent.stringify;
        this.parent = parent;
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo(name));
        }
        if (value == null) {
          throw new Error("Missing attribute value. " + this.debugInfo(name));
        }
        this.name = this.stringify.attName(name);
        this.value = this.stringify.attValue(value);
      }
      XMLAttribute2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLAttribute2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).attribute(this);
      };
      XMLAttribute2.prototype.debugInfo = function(name) {
        name = name || this.name;
        if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else {
          return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
        }
      };
      return XMLAttribute2;
    })();
  }).call(XMLAttribute);
  return XMLAttribute$1.exports;
}
var XMLElement = XMLElement$1.exports;
var hasRequiredXMLElement;
function requireXMLElement() {
  if (hasRequiredXMLElement) return XMLElement$1.exports;
  hasRequiredXMLElement = 1;
  (function() {
    var XMLAttribute2, XMLNode2, getValue, isFunction2, isObject2, ref2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    ref2 = requireUtility(), isObject2 = ref2.isObject, isFunction2 = ref2.isFunction, getValue = ref2.getValue;
    XMLNode2 = requireXMLNode();
    XMLAttribute2 = requireXMLAttribute();
    XMLElement$1.exports = (function(superClass) {
      extend2(XMLElement2, superClass);
      function XMLElement2(parent, name, attributes) {
        XMLElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing element name. " + this.debugInfo());
        }
        this.name = this.stringify.eleName(name);
        this.attributes = {};
        if (attributes != null) {
          this.attribute(attributes);
        }
        if (parent.isDocument) {
          this.isRoot = true;
          this.documentObject = parent;
          parent.rootObject = this;
        }
      }
      XMLElement2.prototype.clone = function() {
        var att, attName, clonedSelf, ref1;
        clonedSelf = Object.create(this);
        if (clonedSelf.isRoot) {
          clonedSelf.documentObject = null;
        }
        clonedSelf.attributes = {};
        ref1 = this.attributes;
        for (attName in ref1) {
          if (!hasProp.call(ref1, attName)) continue;
          att = ref1[attName];
          clonedSelf.attributes[attName] = att.clone();
        }
        clonedSelf.children = [];
        this.children.forEach(function(child) {
          var clonedChild;
          clonedChild = child.clone();
          clonedChild.parent = clonedSelf;
          return clonedSelf.children.push(clonedChild);
        });
        return clonedSelf;
      };
      XMLElement2.prototype.attribute = function(name, value) {
        var attName, attValue;
        if (name != null) {
          name = getValue(name);
        }
        if (isObject2(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction2(value)) {
            value = value.apply();
          }
          if (!this.options.skipNullAttributes || value != null) {
            this.attributes[name] = new XMLAttribute2(this, name, value);
          }
        }
        return this;
      };
      XMLElement2.prototype.removeAttribute = function(name) {
        var attName, i, len;
        if (name == null) {
          throw new Error("Missing attribute name. " + this.debugInfo());
        }
        name = getValue(name);
        if (Array.isArray(name)) {
          for (i = 0, len = name.length; i < len; i++) {
            attName = name[i];
            delete this.attributes[attName];
          }
        } else {
          delete this.attributes[name];
        }
        return this;
      };
      XMLElement2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).element(this);
      };
      XMLElement2.prototype.att = function(name, value) {
        return this.attribute(name, value);
      };
      XMLElement2.prototype.a = function(name, value) {
        return this.attribute(name, value);
      };
      return XMLElement2;
    })(XMLNode2);
  }).call(XMLElement);
  return XMLElement$1.exports;
}
var XMLCData$1 = { exports: {} };
var XMLCData = XMLCData$1.exports;
var hasRequiredXMLCData;
function requireXMLCData() {
  if (hasRequiredXMLCData) return XMLCData$1.exports;
  hasRequiredXMLCData = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLCData$1.exports = (function(superClass) {
      extend2(XMLCData2, superClass);
      function XMLCData2(parent, text) {
        XMLCData2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing CDATA text. " + this.debugInfo());
        }
        this.text = this.stringify.cdata(text);
      }
      XMLCData2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLCData2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).cdata(this);
      };
      return XMLCData2;
    })(XMLNode2);
  }).call(XMLCData);
  return XMLCData$1.exports;
}
var XMLComment$1 = { exports: {} };
var XMLComment = XMLComment$1.exports;
var hasRequiredXMLComment;
function requireXMLComment() {
  if (hasRequiredXMLComment) return XMLComment$1.exports;
  hasRequiredXMLComment = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLComment$1.exports = (function(superClass) {
      extend2(XMLComment2, superClass);
      function XMLComment2(parent, text) {
        XMLComment2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing comment text. " + this.debugInfo());
        }
        this.text = this.stringify.comment(text);
      }
      XMLComment2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLComment2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).comment(this);
      };
      return XMLComment2;
    })(XMLNode2);
  }).call(XMLComment);
  return XMLComment$1.exports;
}
var XMLDeclaration$1 = { exports: {} };
var XMLDeclaration = XMLDeclaration$1.exports;
var hasRequiredXMLDeclaration;
function requireXMLDeclaration() {
  if (hasRequiredXMLDeclaration) return XMLDeclaration$1.exports;
  hasRequiredXMLDeclaration = 1;
  (function() {
    var XMLNode2, isObject2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject2 = requireUtility().isObject;
    XMLNode2 = requireXMLNode();
    XMLDeclaration$1.exports = (function(superClass) {
      extend2(XMLDeclaration2, superClass);
      function XMLDeclaration2(parent, version, encoding, standalone) {
        var ref2;
        XMLDeclaration2.__super__.constructor.call(this, parent);
        if (isObject2(version)) {
          ref2 = version, version = ref2.version, encoding = ref2.encoding, standalone = ref2.standalone;
        }
        if (!version) {
          version = "1.0";
        }
        this.version = this.stringify.xmlVersion(version);
        if (encoding != null) {
          this.encoding = this.stringify.xmlEncoding(encoding);
        }
        if (standalone != null) {
          this.standalone = this.stringify.xmlStandalone(standalone);
        }
      }
      XMLDeclaration2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).declaration(this);
      };
      return XMLDeclaration2;
    })(XMLNode2);
  }).call(XMLDeclaration);
  return XMLDeclaration$1.exports;
}
var XMLDocType$1 = { exports: {} };
var XMLDTDAttList$1 = { exports: {} };
var XMLDTDAttList = XMLDTDAttList$1.exports;
var hasRequiredXMLDTDAttList;
function requireXMLDTDAttList() {
  if (hasRequiredXMLDTDAttList) return XMLDTDAttList$1.exports;
  hasRequiredXMLDTDAttList = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLDTDAttList$1.exports = (function(superClass) {
      extend2(XMLDTDAttList2, superClass);
      function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        XMLDTDAttList2.__super__.constructor.call(this, parent);
        if (elementName == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (attributeName == null) {
          throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
        }
        if (!attributeType) {
          throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
        }
        if (!defaultValueType) {
          throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
        }
        if (defaultValueType.indexOf("#") !== 0) {
          defaultValueType = "#" + defaultValueType;
        }
        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
          throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
        }
        this.elementName = this.stringify.eleName(elementName);
        this.attributeName = this.stringify.attName(attributeName);
        this.attributeType = this.stringify.dtdAttType(attributeType);
        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
        this.defaultValueType = defaultValueType;
      }
      XMLDTDAttList2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).dtdAttList(this);
      };
      return XMLDTDAttList2;
    })(XMLNode2);
  }).call(XMLDTDAttList);
  return XMLDTDAttList$1.exports;
}
var XMLDTDEntity$1 = { exports: {} };
var XMLDTDEntity = XMLDTDEntity$1.exports;
var hasRequiredXMLDTDEntity;
function requireXMLDTDEntity() {
  if (hasRequiredXMLDTDEntity) return XMLDTDEntity$1.exports;
  hasRequiredXMLDTDEntity = 1;
  (function() {
    var XMLNode2, isObject2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject2 = requireUtility().isObject;
    XMLNode2 = requireXMLNode();
    XMLDTDEntity$1.exports = (function(superClass) {
      extend2(XMLDTDEntity2, superClass);
      function XMLDTDEntity2(parent, pe, name, value) {
        XMLDTDEntity2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD entity name. " + this.debugInfo(name));
        }
        if (value == null) {
          throw new Error("Missing DTD entity value. " + this.debugInfo(name));
        }
        this.pe = !!pe;
        this.name = this.stringify.eleName(name);
        if (!isObject2(value)) {
          this.value = this.stringify.dtdEntityValue(value);
        } else {
          if (!value.pubID && !value.sysID) {
            throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          if (value.pubID && !value.sysID) {
            throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
          }
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
          if (value.nData != null) {
            this.nData = this.stringify.dtdNData(value.nData);
          }
          if (this.pe && this.nData) {
            throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
          }
        }
      }
      XMLDTDEntity2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).dtdEntity(this);
      };
      return XMLDTDEntity2;
    })(XMLNode2);
  }).call(XMLDTDEntity);
  return XMLDTDEntity$1.exports;
}
var XMLDTDElement$1 = { exports: {} };
var XMLDTDElement = XMLDTDElement$1.exports;
var hasRequiredXMLDTDElement;
function requireXMLDTDElement() {
  if (hasRequiredXMLDTDElement) return XMLDTDElement$1.exports;
  hasRequiredXMLDTDElement = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLDTDElement$1.exports = (function(superClass) {
      extend2(XMLDTDElement2, superClass);
      function XMLDTDElement2(parent, name, value) {
        XMLDTDElement2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD element name. " + this.debugInfo());
        }
        if (!value) {
          value = "(#PCDATA)";
        }
        if (Array.isArray(value)) {
          value = "(" + value.join(",") + ")";
        }
        this.name = this.stringify.eleName(name);
        this.value = this.stringify.dtdElementValue(value);
      }
      XMLDTDElement2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).dtdElement(this);
      };
      return XMLDTDElement2;
    })(XMLNode2);
  }).call(XMLDTDElement);
  return XMLDTDElement$1.exports;
}
var XMLDTDNotation$1 = { exports: {} };
var XMLDTDNotation = XMLDTDNotation$1.exports;
var hasRequiredXMLDTDNotation;
function requireXMLDTDNotation() {
  if (hasRequiredXMLDTDNotation) return XMLDTDNotation$1.exports;
  hasRequiredXMLDTDNotation = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLDTDNotation$1.exports = (function(superClass) {
      extend2(XMLDTDNotation2, superClass);
      function XMLDTDNotation2(parent, name, value) {
        XMLDTDNotation2.__super__.constructor.call(this, parent);
        if (name == null) {
          throw new Error("Missing DTD notation name. " + this.debugInfo(name));
        }
        if (!value.pubID && !value.sysID) {
          throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
        }
        this.name = this.stringify.eleName(name);
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
      }
      XMLDTDNotation2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).dtdNotation(this);
      };
      return XMLDTDNotation2;
    })(XMLNode2);
  }).call(XMLDTDNotation);
  return XMLDTDNotation$1.exports;
}
var XMLDocType = XMLDocType$1.exports;
var hasRequiredXMLDocType;
function requireXMLDocType() {
  if (hasRequiredXMLDocType) return XMLDocType$1.exports;
  hasRequiredXMLDocType = 1;
  (function() {
    var XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLNode2, isObject2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isObject2 = requireUtility().isObject;
    XMLNode2 = requireXMLNode();
    XMLDTDAttList2 = requireXMLDTDAttList();
    XMLDTDEntity2 = requireXMLDTDEntity();
    XMLDTDElement2 = requireXMLDTDElement();
    XMLDTDNotation2 = requireXMLDTDNotation();
    XMLDocType$1.exports = (function(superClass) {
      extend2(XMLDocType2, superClass);
      function XMLDocType2(parent, pubID, sysID) {
        var ref2, ref1;
        XMLDocType2.__super__.constructor.call(this, parent);
        this.name = "!DOCTYPE";
        this.documentObject = parent;
        if (isObject2(pubID)) {
          ref2 = pubID, pubID = ref2.pubID, sysID = ref2.sysID;
        }
        if (sysID == null) {
          ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
        }
        if (pubID != null) {
          this.pubID = this.stringify.dtdPubID(pubID);
        }
        if (sysID != null) {
          this.sysID = this.stringify.dtdSysID(sysID);
        }
      }
      XMLDocType2.prototype.element = function(name, value) {
        var child;
        child = new XMLDTDElement2(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var child;
        child = new XMLDTDAttList2(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.entity = function(name, value) {
        var child;
        child = new XMLDTDEntity2(this, false, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.pEntity = function(name, value) {
        var child;
        child = new XMLDTDEntity2(this, true, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.notation = function(name, value) {
        var child;
        child = new XMLDTDNotation2(this, name, value);
        this.children.push(child);
        return this;
      };
      XMLDocType2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).docType(this);
      };
      XMLDocType2.prototype.ele = function(name, value) {
        return this.element(name, value);
      };
      XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
      };
      XMLDocType2.prototype.ent = function(name, value) {
        return this.entity(name, value);
      };
      XMLDocType2.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      };
      XMLDocType2.prototype.not = function(name, value) {
        return this.notation(name, value);
      };
      XMLDocType2.prototype.up = function() {
        return this.root() || this.documentObject;
      };
      return XMLDocType2;
    })(XMLNode2);
  }).call(XMLDocType);
  return XMLDocType$1.exports;
}
var XMLRaw$1 = { exports: {} };
var XMLRaw = XMLRaw$1.exports;
var hasRequiredXMLRaw;
function requireXMLRaw() {
  if (hasRequiredXMLRaw) return XMLRaw$1.exports;
  hasRequiredXMLRaw = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLRaw$1.exports = (function(superClass) {
      extend2(XMLRaw2, superClass);
      function XMLRaw2(parent, text) {
        XMLRaw2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing raw text. " + this.debugInfo());
        }
        this.value = this.stringify.raw(text);
      }
      XMLRaw2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLRaw2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).raw(this);
      };
      return XMLRaw2;
    })(XMLNode2);
  }).call(XMLRaw);
  return XMLRaw$1.exports;
}
var XMLText$1 = { exports: {} };
var XMLText = XMLText$1.exports;
var hasRequiredXMLText;
function requireXMLText() {
  if (hasRequiredXMLText) return XMLText$1.exports;
  hasRequiredXMLText = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLText$1.exports = (function(superClass) {
      extend2(XMLText2, superClass);
      function XMLText2(parent, text) {
        XMLText2.__super__.constructor.call(this, parent);
        if (text == null) {
          throw new Error("Missing element text. " + this.debugInfo());
        }
        this.value = this.stringify.eleText(text);
      }
      XMLText2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLText2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).text(this);
      };
      return XMLText2;
    })(XMLNode2);
  }).call(XMLText);
  return XMLText$1.exports;
}
var XMLProcessingInstruction$1 = { exports: {} };
var XMLProcessingInstruction = XMLProcessingInstruction$1.exports;
var hasRequiredXMLProcessingInstruction;
function requireXMLProcessingInstruction() {
  if (hasRequiredXMLProcessingInstruction) return XMLProcessingInstruction$1.exports;
  hasRequiredXMLProcessingInstruction = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLProcessingInstruction$1.exports = (function(superClass) {
      extend2(XMLProcessingInstruction2, superClass);
      function XMLProcessingInstruction2(parent, target, value) {
        XMLProcessingInstruction2.__super__.constructor.call(this, parent);
        if (target == null) {
          throw new Error("Missing instruction target. " + this.debugInfo());
        }
        this.target = this.stringify.insTarget(target);
        if (value) {
          this.value = this.stringify.insValue(value);
        }
      }
      XMLProcessingInstruction2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLProcessingInstruction2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).processingInstruction(this);
      };
      return XMLProcessingInstruction2;
    })(XMLNode2);
  }).call(XMLProcessingInstruction);
  return XMLProcessingInstruction$1.exports;
}
var XMLDummy$1 = { exports: {} };
var XMLDummy = XMLDummy$1.exports;
var hasRequiredXMLDummy;
function requireXMLDummy() {
  if (hasRequiredXMLDummy) return XMLDummy$1.exports;
  hasRequiredXMLDummy = 1;
  (function() {
    var XMLNode2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLNode2 = requireXMLNode();
    XMLDummy$1.exports = (function(superClass) {
      extend2(XMLDummy2, superClass);
      function XMLDummy2(parent) {
        XMLDummy2.__super__.constructor.call(this, parent);
        this.isDummy = true;
      }
      XMLDummy2.prototype.clone = function() {
        return Object.create(this);
      };
      XMLDummy2.prototype.toString = function(options2) {
        return "";
      };
      return XMLDummy2;
    })(XMLNode2);
  }).call(XMLDummy);
  return XMLDummy$1.exports;
}
var XMLNode = XMLNode$1.exports;
var hasRequiredXMLNode;
function requireXMLNode() {
  if (hasRequiredXMLNode) return XMLNode$1.exports;
  hasRequiredXMLNode = 1;
  (function() {
    var XMLCData2, XMLComment2, XMLDeclaration2, XMLDocType2, XMLDummy2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLText2, getValue, isEmpty2, isFunction2, isObject2, ref2, hasProp = {}.hasOwnProperty;
    ref2 = requireUtility(), isObject2 = ref2.isObject, isFunction2 = ref2.isFunction, isEmpty2 = ref2.isEmpty, getValue = ref2.getValue;
    XMLElement2 = null;
    XMLCData2 = null;
    XMLComment2 = null;
    XMLDeclaration2 = null;
    XMLDocType2 = null;
    XMLRaw2 = null;
    XMLText2 = null;
    XMLProcessingInstruction2 = null;
    XMLDummy2 = null;
    XMLNode$1.exports = (function() {
      function XMLNode2(parent) {
        this.parent = parent;
        if (this.parent) {
          this.options = this.parent.options;
          this.stringify = this.parent.stringify;
        }
        this.children = [];
        if (!XMLElement2) {
          XMLElement2 = requireXMLElement();
          XMLCData2 = requireXMLCData();
          XMLComment2 = requireXMLComment();
          XMLDeclaration2 = requireXMLDeclaration();
          XMLDocType2 = requireXMLDocType();
          XMLRaw2 = requireXMLRaw();
          XMLText2 = requireXMLText();
          XMLProcessingInstruction2 = requireXMLProcessingInstruction();
          XMLDummy2 = requireXMLDummy();
        }
      }
      XMLNode2.prototype.element = function(name, attributes, text) {
        var childNode, item, j, k, key, lastChild, len, len1, ref1, ref22, val;
        lastChild = null;
        if (attributes === null && text == null) {
          ref1 = [{}, null], attributes = ref1[0], text = ref1[1];
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject2(attributes)) {
          ref22 = [attributes, text], text = ref22[0], attributes = ref22[1];
        }
        if (name != null) {
          name = getValue(name);
        }
        if (Array.isArray(name)) {
          for (j = 0, len = name.length; j < len; j++) {
            item = name[j];
            lastChild = this.element(item);
          }
        } else if (isFunction2(name)) {
          lastChild = this.element(name.apply());
        } else if (isObject2(name)) {
          for (key in name) {
            if (!hasProp.call(name, key)) continue;
            val = name[key];
            if (isFunction2(val)) {
              val = val.apply();
            }
            if (isObject2(val) && isEmpty2(val)) {
              val = null;
            }
            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
            } else if (!this.options.separateArrayItems && Array.isArray(val)) {
              for (k = 0, len1 = val.length; k < len1; k++) {
                item = val[k];
                childNode = {};
                childNode[key] = item;
                lastChild = this.element(childNode);
              }
            } else if (isObject2(val)) {
              lastChild = this.element(key);
              lastChild.element(val);
            } else {
              lastChild = this.element(key, val);
            }
          }
        } else if (this.options.skipNullNodes && text === null) {
          lastChild = this.dummy();
        } else {
          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
            lastChild = this.text(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
            lastChild = this.cdata(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
            lastChild = this.comment(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
            lastChild = this.raw(text);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
          } else {
            lastChild = this.node(name, attributes, text);
          }
        }
        if (lastChild == null) {
          throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
        }
        return lastChild;
      };
      XMLNode2.prototype.insertBefore = function(name, attributes, text) {
        var child, i, removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode2.prototype.insertAfter = function(name, attributes, text) {
        var child, i, removed;
        if (this.isRoot) {
          throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
        }
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        child = this.parent.element(name, attributes, text);
        Array.prototype.push.apply(this.parent.children, removed);
        return child;
      };
      XMLNode2.prototype.remove = function() {
        var i;
        if (this.isRoot) {
          throw new Error("Cannot remove the root element. " + this.debugInfo());
        }
        i = this.parent.children.indexOf(this);
        [].splice.apply(this.parent.children, [i, i - i + 1].concat([]));
        return this.parent;
      };
      XMLNode2.prototype.node = function(name, attributes, text) {
        var child, ref1;
        if (name != null) {
          name = getValue(name);
        }
        attributes || (attributes = {});
        attributes = getValue(attributes);
        if (!isObject2(attributes)) {
          ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
        }
        child = new XMLElement2(this, name, attributes);
        if (text != null) {
          child.text(text);
        }
        this.children.push(child);
        return child;
      };
      XMLNode2.prototype.text = function(value) {
        var child;
        child = new XMLText2(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.cdata = function(value) {
        var child;
        child = new XMLCData2(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.comment = function(value) {
        var child;
        child = new XMLComment2(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.commentBefore = function(value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.commentAfter = function(value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        this.parent.comment(value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.raw = function(value) {
        var child;
        child = new XMLRaw2(this, value);
        this.children.push(child);
        return this;
      };
      XMLNode2.prototype.dummy = function() {
        var child;
        child = new XMLDummy2(this);
        this.children.push(child);
        return child;
      };
      XMLNode2.prototype.instruction = function(target, value) {
        var insTarget, insValue, instruction, j, len;
        if (target != null) {
          target = getValue(target);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target)) {
          for (j = 0, len = target.length; j < len; j++) {
            insTarget = target[j];
            this.instruction(insTarget);
          }
        } else if (isObject2(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget)) continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction2(value)) {
            value = value.apply();
          }
          instruction = new XMLProcessingInstruction2(this, target, value);
          this.children.push(instruction);
        }
        return this;
      };
      XMLNode2.prototype.instructionBefore = function(target, value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i);
        this.parent.instruction(target, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.instructionAfter = function(target, value) {
        var i, removed;
        i = this.parent.children.indexOf(this);
        removed = this.parent.children.splice(i + 1);
        this.parent.instruction(target, value);
        Array.prototype.push.apply(this.parent.children, removed);
        return this;
      };
      XMLNode2.prototype.declaration = function(version, encoding, standalone) {
        var doc2, xmldec;
        doc2 = this.document();
        xmldec = new XMLDeclaration2(doc2, version, encoding, standalone);
        if (doc2.children[0] instanceof XMLDeclaration2) {
          doc2.children[0] = xmldec;
        } else {
          doc2.children.unshift(xmldec);
        }
        return doc2.root() || doc2;
      };
      XMLNode2.prototype.doctype = function(pubID, sysID) {
        var child, doc2, doctype, i, j, k, len, len1, ref1, ref22;
        doc2 = this.document();
        doctype = new XMLDocType2(doc2, pubID, sysID);
        ref1 = doc2.children;
        for (i = j = 0, len = ref1.length; j < len; i = ++j) {
          child = ref1[i];
          if (child instanceof XMLDocType2) {
            doc2.children[i] = doctype;
            return doctype;
          }
        }
        ref22 = doc2.children;
        for (i = k = 0, len1 = ref22.length; k < len1; i = ++k) {
          child = ref22[i];
          if (child.isRoot) {
            doc2.children.splice(i, 0, doctype);
            return doctype;
          }
        }
        doc2.children.push(doctype);
        return doctype;
      };
      XMLNode2.prototype.up = function() {
        if (this.isRoot) {
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
        }
        return this.parent;
      };
      XMLNode2.prototype.root = function() {
        var node;
        node = this;
        while (node) {
          if (node.isDocument) {
            return node.rootObject;
          } else if (node.isRoot) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.document = function() {
        var node;
        node = this;
        while (node) {
          if (node.isDocument) {
            return node;
          } else {
            node = node.parent;
          }
        }
      };
      XMLNode2.prototype.end = function(options2) {
        return this.document().end(options2);
      };
      XMLNode2.prototype.prev = function() {
        var i;
        i = this.parent.children.indexOf(this);
        while (i > 0 && this.parent.children[i - 1].isDummy) {
          i = i - 1;
        }
        if (i < 1) {
          throw new Error("Already at the first node. " + this.debugInfo());
        }
        return this.parent.children[i - 1];
      };
      XMLNode2.prototype.next = function() {
        var i;
        i = this.parent.children.indexOf(this);
        while (i < this.parent.children.length - 1 && this.parent.children[i + 1].isDummy) {
          i = i + 1;
        }
        if (i === -1 || i === this.parent.children.length - 1) {
          throw new Error("Already at the last node. " + this.debugInfo());
        }
        return this.parent.children[i + 1];
      };
      XMLNode2.prototype.importDocument = function(doc2) {
        var clonedRoot;
        clonedRoot = doc2.root().clone();
        clonedRoot.parent = this;
        clonedRoot.isRoot = false;
        this.children.push(clonedRoot);
        return this;
      };
      XMLNode2.prototype.debugInfo = function(name) {
        var ref1, ref22;
        name = name || this.name;
        if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {
          return "";
        } else if (name == null) {
          return "parent: <" + this.parent.name + ">";
        } else if (!((ref22 = this.parent) != null ? ref22.name : void 0)) {
          return "node: <" + name + ">";
        } else {
          return "node: <" + name + ">, parent: <" + this.parent.name + ">";
        }
      };
      XMLNode2.prototype.ele = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.txt = function(value) {
        return this.text(value);
      };
      XMLNode2.prototype.dat = function(value) {
        return this.cdata(value);
      };
      XMLNode2.prototype.com = function(value) {
        return this.comment(value);
      };
      XMLNode2.prototype.ins = function(target, value) {
        return this.instruction(target, value);
      };
      XMLNode2.prototype.doc = function() {
        return this.document();
      };
      XMLNode2.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLNode2.prototype.dtd = function(pubID, sysID) {
        return this.doctype(pubID, sysID);
      };
      XMLNode2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLNode2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLNode2.prototype.t = function(value) {
        return this.text(value);
      };
      XMLNode2.prototype.d = function(value) {
        return this.cdata(value);
      };
      XMLNode2.prototype.c = function(value) {
        return this.comment(value);
      };
      XMLNode2.prototype.r = function(value) {
        return this.raw(value);
      };
      XMLNode2.prototype.i = function(target, value) {
        return this.instruction(target, value);
      };
      XMLNode2.prototype.u = function() {
        return this.up();
      };
      XMLNode2.prototype.importXMLBuilder = function(doc2) {
        return this.importDocument(doc2);
      };
      return XMLNode2;
    })();
  }).call(XMLNode);
  return XMLNode$1.exports;
}
var XMLStringifier$1 = { exports: {} };
var XMLStringifier = XMLStringifier$1.exports;
var hasRequiredXMLStringifier;
function requireXMLStringifier() {
  if (hasRequiredXMLStringifier) return XMLStringifier$1.exports;
  hasRequiredXMLStringifier = 1;
  (function() {
    var bind2 = function(fn, me) {
      return function() {
        return fn.apply(me, arguments);
      };
    }, hasProp = {}.hasOwnProperty;
    XMLStringifier$1.exports = (function() {
      function XMLStringifier2(options2) {
        this.assertLegalChar = bind2(this.assertLegalChar, this);
        var key, ref2, value;
        options2 || (options2 = {});
        this.noDoubleEncoding = options2.noDoubleEncoding;
        ref2 = options2.stringify || {};
        for (key in ref2) {
          if (!hasProp.call(ref2, key)) continue;
          value = ref2[key];
          this[key] = value;
        }
      }
      XMLStringifier2.prototype.eleName = function(val) {
        val = "" + val || "";
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.eleText = function(val) {
        val = "" + val || "";
        return this.assertLegalChar(this.elEscape(val));
      };
      XMLStringifier2.prototype.cdata = function(val) {
        val = "" + val || "";
        val = val.replace("]]>", "]]]]><![CDATA[>");
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.comment = function(val) {
        val = "" + val || "";
        if (val.match(/--/)) {
          throw new Error("Comment text cannot contain double-hypen: " + val);
        }
        return this.assertLegalChar(val);
      };
      XMLStringifier2.prototype.raw = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.attName = function(val) {
        return val = "" + val || "";
      };
      XMLStringifier2.prototype.attValue = function(val) {
        val = "" + val || "";
        return this.attEscape(val);
      };
      XMLStringifier2.prototype.insTarget = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.insValue = function(val) {
        val = "" + val || "";
        if (val.match(/\?>/)) {
          throw new Error("Invalid processing instruction value: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlVersion = function(val) {
        val = "" + val || "";
        if (!val.match(/1\.[0-9]+/)) {
          throw new Error("Invalid version number: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlEncoding = function(val) {
        val = "" + val || "";
        if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
          throw new Error("Invalid encoding: " + val);
        }
        return val;
      };
      XMLStringifier2.prototype.xmlStandalone = function(val) {
        if (val) {
          return "yes";
        } else {
          return "no";
        }
      };
      XMLStringifier2.prototype.dtdPubID = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdSysID = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdElementValue = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdAttType = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdAttDefault = function(val) {
        if (val != null) {
          return "" + val || "";
        } else {
          return val;
        }
      };
      XMLStringifier2.prototype.dtdEntityValue = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.dtdNData = function(val) {
        return "" + val || "";
      };
      XMLStringifier2.prototype.convertAttKey = "@";
      XMLStringifier2.prototype.convertPIKey = "?";
      XMLStringifier2.prototype.convertTextKey = "#text";
      XMLStringifier2.prototype.convertCDataKey = "#cdata";
      XMLStringifier2.prototype.convertCommentKey = "#comment";
      XMLStringifier2.prototype.convertRawKey = "#raw";
      XMLStringifier2.prototype.assertLegalChar = function(str) {
        var res;
        res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
        if (res) {
          throw new Error("Invalid character in string: " + str + " at index " + res.index);
        }
        return str;
      };
      XMLStringifier2.prototype.elEscape = function(str) {
        var ampregex;
        ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
      };
      XMLStringifier2.prototype.attEscape = function(str) {
        var ampregex;
        ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
        return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
      };
      return XMLStringifier2;
    })();
  }).call(XMLStringifier);
  return XMLStringifier$1.exports;
}
var XMLStringWriter$1 = { exports: {} };
var XMLWriterBase$1 = { exports: {} };
var XMLWriterBase = XMLWriterBase$1.exports;
var hasRequiredXMLWriterBase;
function requireXMLWriterBase() {
  if (hasRequiredXMLWriterBase) return XMLWriterBase$1.exports;
  hasRequiredXMLWriterBase = 1;
  (function() {
    var hasProp = {}.hasOwnProperty;
    XMLWriterBase$1.exports = (function() {
      function XMLWriterBase2(options2) {
        var key, ref2, ref1, ref22, ref3, ref4, ref5, ref6, value;
        options2 || (options2 = {});
        this.pretty = options2.pretty || false;
        this.allowEmpty = (ref2 = options2.allowEmpty) != null ? ref2 : false;
        if (this.pretty) {
          this.indent = (ref1 = options2.indent) != null ? ref1 : "  ";
          this.newline = (ref22 = options2.newline) != null ? ref22 : "\n";
          this.offset = (ref3 = options2.offset) != null ? ref3 : 0;
          this.dontprettytextnodes = (ref4 = options2.dontprettytextnodes) != null ? ref4 : 0;
        } else {
          this.indent = "";
          this.newline = "";
          this.offset = 0;
          this.dontprettytextnodes = 0;
        }
        this.spacebeforeslash = (ref5 = options2.spacebeforeslash) != null ? ref5 : "";
        if (this.spacebeforeslash === true) {
          this.spacebeforeslash = " ";
        }
        this.newlinedefault = this.newline;
        this.prettydefault = this.pretty;
        ref6 = options2.writer || {};
        for (key in ref6) {
          if (!hasProp.call(ref6, key)) continue;
          value = ref6[key];
          this[key] = value;
        }
      }
      XMLWriterBase2.prototype.set = function(options2) {
        var key, ref2, value;
        options2 || (options2 = {});
        if ("pretty" in options2) {
          this.pretty = options2.pretty;
        }
        if ("allowEmpty" in options2) {
          this.allowEmpty = options2.allowEmpty;
        }
        if (this.pretty) {
          this.indent = "indent" in options2 ? options2.indent : "  ";
          this.newline = "newline" in options2 ? options2.newline : "\n";
          this.offset = "offset" in options2 ? options2.offset : 0;
          this.dontprettytextnodes = "dontprettytextnodes" in options2 ? options2.dontprettytextnodes : 0;
        } else {
          this.indent = "";
          this.newline = "";
          this.offset = 0;
          this.dontprettytextnodes = 0;
        }
        this.spacebeforeslash = "spacebeforeslash" in options2 ? options2.spacebeforeslash : "";
        if (this.spacebeforeslash === true) {
          this.spacebeforeslash = " ";
        }
        this.newlinedefault = this.newline;
        this.prettydefault = this.pretty;
        ref2 = options2.writer || {};
        for (key in ref2) {
          if (!hasProp.call(ref2, key)) continue;
          value = ref2[key];
          this[key] = value;
        }
        return this;
      };
      XMLWriterBase2.prototype.space = function(level) {
        var indent;
        if (this.pretty) {
          indent = (level || 0) + this.offset + 1;
          if (indent > 0) {
            return new Array(indent).join(this.indent);
          } else {
            return "";
          }
        } else {
          return "";
        }
      };
      return XMLWriterBase2;
    })();
  }).call(XMLWriterBase);
  return XMLWriterBase$1.exports;
}
var XMLStringWriter = XMLStringWriter$1.exports;
var hasRequiredXMLStringWriter;
function requireXMLStringWriter() {
  if (hasRequiredXMLStringWriter) return XMLStringWriter$1.exports;
  hasRequiredXMLStringWriter = 1;
  (function() {
    var XMLCData2, XMLComment2, XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLDeclaration2, XMLDocType2, XMLDummy2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLText2, XMLWriterBase2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLDeclaration2 = requireXMLDeclaration();
    XMLDocType2 = requireXMLDocType();
    XMLCData2 = requireXMLCData();
    XMLComment2 = requireXMLComment();
    XMLElement2 = requireXMLElement();
    XMLRaw2 = requireXMLRaw();
    XMLText2 = requireXMLText();
    XMLProcessingInstruction2 = requireXMLProcessingInstruction();
    XMLDummy2 = requireXMLDummy();
    XMLDTDAttList2 = requireXMLDTDAttList();
    XMLDTDElement2 = requireXMLDTDElement();
    XMLDTDEntity2 = requireXMLDTDEntity();
    XMLDTDNotation2 = requireXMLDTDNotation();
    XMLWriterBase2 = requireXMLWriterBase();
    XMLStringWriter$1.exports = (function(superClass) {
      extend2(XMLStringWriter2, superClass);
      function XMLStringWriter2(options2) {
        XMLStringWriter2.__super__.constructor.call(this, options2);
      }
      XMLStringWriter2.prototype.document = function(doc2) {
        var child, i, len, r, ref2;
        this.textispresent = false;
        r = "";
        ref2 = doc2.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          if (child instanceof XMLDummy2) {
            continue;
          }
          r += (function() {
            switch (false) {
              case !(child instanceof XMLDeclaration2):
                return this.declaration(child);
              case !(child instanceof XMLDocType2):
                return this.docType(child);
              case !(child instanceof XMLComment2):
                return this.comment(child);
              case !(child instanceof XMLProcessingInstruction2):
                return this.processingInstruction(child);
              default:
                return this.element(child, 0);
            }
          }).call(this);
        }
        if (this.pretty && r.slice(-this.newline.length) === this.newline) {
          r = r.slice(0, -this.newline.length);
        }
        return r;
      };
      XMLStringWriter2.prototype.attribute = function(att) {
        return " " + att.name + '="' + att.value + '"';
      };
      XMLStringWriter2.prototype.cdata = function(node, level) {
        return this.space(level) + "<![CDATA[" + node.text + "]]>" + this.newline;
      };
      XMLStringWriter2.prototype.comment = function(node, level) {
        return this.space(level) + "<!-- " + node.text + " -->" + this.newline;
      };
      XMLStringWriter2.prototype.declaration = function(node, level) {
        var r;
        r = this.space(level);
        r += '<?xml version="' + node.version + '"';
        if (node.encoding != null) {
          r += ' encoding="' + node.encoding + '"';
        }
        if (node.standalone != null) {
          r += ' standalone="' + node.standalone + '"';
        }
        r += this.spacebeforeslash + "?>";
        r += this.newline;
        return r;
      };
      XMLStringWriter2.prototype.docType = function(node, level) {
        var child, i, len, r, ref2;
        level || (level = 0);
        r = this.space(level);
        r += "<!DOCTYPE " + node.root().name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.children.length > 0) {
          r += " [";
          r += this.newline;
          ref2 = node.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            r += (function() {
              switch (false) {
                case !(child instanceof XMLDTDAttList2):
                  return this.dtdAttList(child, level + 1);
                case !(child instanceof XMLDTDElement2):
                  return this.dtdElement(child, level + 1);
                case !(child instanceof XMLDTDEntity2):
                  return this.dtdEntity(child, level + 1);
                case !(child instanceof XMLDTDNotation2):
                  return this.dtdNotation(child, level + 1);
                case !(child instanceof XMLCData2):
                  return this.cdata(child, level + 1);
                case !(child instanceof XMLComment2):
                  return this.comment(child, level + 1);
                case !(child instanceof XMLProcessingInstruction2):
                  return this.processingInstruction(child, level + 1);
                default:
                  throw new Error("Unknown DTD node type: " + child.constructor.name);
              }
            }).call(this);
          }
          r += "]";
        }
        r += this.spacebeforeslash + ">";
        r += this.newline;
        return r;
      };
      XMLStringWriter2.prototype.element = function(node, level) {
        var att, child, i, j, len, len1, name, r, ref2, ref1, ref22, space, textispresentwasset;
        level || (level = 0);
        textispresentwasset = false;
        if (this.textispresent) {
          this.newline = "";
          this.pretty = false;
        } else {
          this.newline = this.newlinedefault;
          this.pretty = this.prettydefault;
        }
        space = this.space(level);
        r = "";
        r += space + "<" + node.name;
        ref2 = node.attributes;
        for (name in ref2) {
          if (!hasProp.call(ref2, name)) continue;
          att = ref2[name];
          r += this.attribute(att);
        }
        if (node.children.length === 0 || node.children.every(function(e) {
          return e.value === "";
        })) {
          if (this.allowEmpty) {
            r += "></" + node.name + ">" + this.newline;
          } else {
            r += this.spacebeforeslash + "/>" + this.newline;
          }
        } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
          r += ">";
          r += node.children[0].value;
          r += "</" + node.name + ">" + this.newline;
        } else {
          if (this.dontprettytextnodes) {
            ref1 = node.children;
            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              if (child.value != null) {
                this.textispresent++;
                textispresentwasset = true;
                break;
              }
            }
          }
          if (this.textispresent) {
            this.newline = "";
            this.pretty = false;
            space = this.space(level);
          }
          r += ">" + this.newline;
          ref22 = node.children;
          for (j = 0, len1 = ref22.length; j < len1; j++) {
            child = ref22[j];
            r += (function() {
              switch (false) {
                case !(child instanceof XMLCData2):
                  return this.cdata(child, level + 1);
                case !(child instanceof XMLComment2):
                  return this.comment(child, level + 1);
                case !(child instanceof XMLElement2):
                  return this.element(child, level + 1);
                case !(child instanceof XMLRaw2):
                  return this.raw(child, level + 1);
                case !(child instanceof XMLText2):
                  return this.text(child, level + 1);
                case !(child instanceof XMLProcessingInstruction2):
                  return this.processingInstruction(child, level + 1);
                case !(child instanceof XMLDummy2):
                  return "";
                default:
                  throw new Error("Unknown XML node type: " + child.constructor.name);
              }
            }).call(this);
          }
          if (textispresentwasset) {
            this.textispresent--;
          }
          if (!this.textispresent) {
            this.newline = this.newlinedefault;
            this.pretty = this.prettydefault;
          }
          r += space + "</" + node.name + ">" + this.newline;
        }
        return r;
      };
      XMLStringWriter2.prototype.processingInstruction = function(node, level) {
        var r;
        r = this.space(level) + "<?" + node.target;
        if (node.value) {
          r += " " + node.value;
        }
        r += this.spacebeforeslash + "?>" + this.newline;
        return r;
      };
      XMLStringWriter2.prototype.raw = function(node, level) {
        return this.space(level) + node.value + this.newline;
      };
      XMLStringWriter2.prototype.text = function(node, level) {
        return this.space(level) + node.value + this.newline;
      };
      XMLStringWriter2.prototype.dtdAttList = function(node, level) {
        var r;
        r = this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType;
        if (node.defaultValueType !== "#DEFAULT") {
          r += " " + node.defaultValueType;
        }
        if (node.defaultValue) {
          r += ' "' + node.defaultValue + '"';
        }
        r += this.spacebeforeslash + ">" + this.newline;
        return r;
      };
      XMLStringWriter2.prototype.dtdElement = function(node, level) {
        return this.space(level) + "<!ELEMENT " + node.name + " " + node.value + this.spacebeforeslash + ">" + this.newline;
      };
      XMLStringWriter2.prototype.dtdEntity = function(node, level) {
        var r;
        r = this.space(level) + "<!ENTITY";
        if (node.pe) {
          r += " %";
        }
        r += " " + node.name;
        if (node.value) {
          r += ' "' + node.value + '"';
        } else {
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.nData) {
            r += " NDATA " + node.nData;
          }
        }
        r += this.spacebeforeslash + ">" + this.newline;
        return r;
      };
      XMLStringWriter2.prototype.dtdNotation = function(node, level) {
        var r;
        r = this.space(level) + "<!NOTATION " + node.name;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.pubID) {
          r += ' PUBLIC "' + node.pubID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        r += this.spacebeforeslash + ">" + this.newline;
        return r;
      };
      XMLStringWriter2.prototype.openNode = function(node, level) {
        var att, name, r, ref2;
        level || (level = 0);
        if (node instanceof XMLElement2) {
          r = this.space(level) + "<" + node.name;
          ref2 = node.attributes;
          for (name in ref2) {
            if (!hasProp.call(ref2, name)) continue;
            att = ref2[name];
            r += this.attribute(att);
          }
          r += (node.children ? ">" : "/>") + this.newline;
          return r;
        } else {
          r = this.space(level) + "<!DOCTYPE " + node.rootNodeName;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          r += (node.children ? " [" : ">") + this.newline;
          return r;
        }
      };
      XMLStringWriter2.prototype.closeNode = function(node, level) {
        level || (level = 0);
        switch (false) {
          case !(node instanceof XMLElement2):
            return this.space(level) + "</" + node.name + ">" + this.newline;
          case !(node instanceof XMLDocType2):
            return this.space(level) + "]>" + this.newline;
        }
      };
      return XMLStringWriter2;
    })(XMLWriterBase2);
  }).call(XMLStringWriter);
  return XMLStringWriter$1.exports;
}
var XMLDocument = XMLDocument$1.exports;
var hasRequiredXMLDocument;
function requireXMLDocument() {
  if (hasRequiredXMLDocument) return XMLDocument$1.exports;
  hasRequiredXMLDocument = 1;
  (function() {
    var XMLNode2, XMLStringWriter2, XMLStringifier2, isPlainObject2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    isPlainObject2 = requireUtility().isPlainObject;
    XMLNode2 = requireXMLNode();
    XMLStringifier2 = requireXMLStringifier();
    XMLStringWriter2 = requireXMLStringWriter();
    XMLDocument$1.exports = (function(superClass) {
      extend2(XMLDocument2, superClass);
      function XMLDocument2(options2) {
        XMLDocument2.__super__.constructor.call(this, null);
        this.name = "?xml";
        options2 || (options2 = {});
        if (!options2.writer) {
          options2.writer = new XMLStringWriter2();
        }
        this.options = options2;
        this.stringify = new XMLStringifier2(options2);
        this.isDocument = true;
      }
      XMLDocument2.prototype.end = function(writer2) {
        var writerOptions;
        if (!writer2) {
          writer2 = this.options.writer;
        } else if (isPlainObject2(writer2)) {
          writerOptions = writer2;
          writer2 = this.options.writer.set(writerOptions);
        }
        return writer2.document(this);
      };
      XMLDocument2.prototype.toString = function(options2) {
        return this.options.writer.set(options2).document(this);
      };
      return XMLDocument2;
    })(XMLNode2);
  }).call(XMLDocument);
  return XMLDocument$1.exports;
}
var XMLDocumentCB$1 = { exports: {} };
var XMLDocumentCB = XMLDocumentCB$1.exports;
var hasRequiredXMLDocumentCB;
function requireXMLDocumentCB() {
  if (hasRequiredXMLDocumentCB) return XMLDocumentCB$1.exports;
  hasRequiredXMLDocumentCB = 1;
  (function() {
    var XMLAttribute2, XMLCData2, XMLComment2, XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLDeclaration2, XMLDocType2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLStringWriter2, XMLStringifier2, XMLText2, getValue, isFunction2, isObject2, isPlainObject2, ref2, hasProp = {}.hasOwnProperty;
    ref2 = requireUtility(), isObject2 = ref2.isObject, isFunction2 = ref2.isFunction, isPlainObject2 = ref2.isPlainObject, getValue = ref2.getValue;
    XMLElement2 = requireXMLElement();
    XMLCData2 = requireXMLCData();
    XMLComment2 = requireXMLComment();
    XMLRaw2 = requireXMLRaw();
    XMLText2 = requireXMLText();
    XMLProcessingInstruction2 = requireXMLProcessingInstruction();
    XMLDeclaration2 = requireXMLDeclaration();
    XMLDocType2 = requireXMLDocType();
    XMLDTDAttList2 = requireXMLDTDAttList();
    XMLDTDEntity2 = requireXMLDTDEntity();
    XMLDTDElement2 = requireXMLDTDElement();
    XMLDTDNotation2 = requireXMLDTDNotation();
    XMLAttribute2 = requireXMLAttribute();
    XMLStringifier2 = requireXMLStringifier();
    XMLStringWriter2 = requireXMLStringWriter();
    XMLDocumentCB$1.exports = (function() {
      function XMLDocumentCB2(options2, onData, onEnd) {
        var writerOptions;
        this.name = "?xml";
        options2 || (options2 = {});
        if (!options2.writer) {
          options2.writer = new XMLStringWriter2(options2);
        } else if (isPlainObject2(options2.writer)) {
          writerOptions = options2.writer;
          options2.writer = new XMLStringWriter2(writerOptions);
        }
        this.options = options2;
        this.writer = options2.writer;
        this.stringify = new XMLStringifier2(options2);
        this.onDataCallback = onData || function() {
        };
        this.onEndCallback = onEnd || function() {
        };
        this.currentNode = null;
        this.currentLevel = -1;
        this.openTags = {};
        this.documentStarted = false;
        this.documentCompleted = false;
        this.root = null;
      }
      XMLDocumentCB2.prototype.node = function(name, attributes, text) {
        var ref1, ref22;
        if (name == null) {
          throw new Error("Missing node name.");
        }
        if (this.root && this.currentLevel === -1) {
          throw new Error("Document can only have one root node. " + this.debugInfo(name));
        }
        this.openCurrent();
        name = getValue(name);
        if (attributes === null && text == null) {
          ref1 = [{}, null], attributes = ref1[0], text = ref1[1];
        }
        if (attributes == null) {
          attributes = {};
        }
        attributes = getValue(attributes);
        if (!isObject2(attributes)) {
          ref22 = [attributes, text], text = ref22[0], attributes = ref22[1];
        }
        this.currentNode = new XMLElement2(this, name, attributes);
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        if (text != null) {
          this.text(text);
        }
        return this;
      };
      XMLDocumentCB2.prototype.element = function(name, attributes, text) {
        if (this.currentNode && this.currentNode instanceof XMLDocType2) {
          return this.dtdElement.apply(this, arguments);
        } else {
          return this.node(name, attributes, text);
        }
      };
      XMLDocumentCB2.prototype.attribute = function(name, value) {
        var attName, attValue;
        if (!this.currentNode || this.currentNode.children) {
          throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
        }
        if (name != null) {
          name = getValue(name);
        }
        if (isObject2(name)) {
          for (attName in name) {
            if (!hasProp.call(name, attName)) continue;
            attValue = name[attName];
            this.attribute(attName, attValue);
          }
        } else {
          if (isFunction2(value)) {
            value = value.apply();
          }
          if (!this.options.skipNullAttributes || value != null) {
            this.currentNode.attributes[name] = new XMLAttribute2(this, name, value);
          }
        }
        return this;
      };
      XMLDocumentCB2.prototype.text = function(value) {
        var node;
        this.openCurrent();
        node = new XMLText2(this, value);
        this.onData(this.writer.text(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.cdata = function(value) {
        var node;
        this.openCurrent();
        node = new XMLCData2(this, value);
        this.onData(this.writer.cdata(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.comment = function(value) {
        var node;
        this.openCurrent();
        node = new XMLComment2(this, value);
        this.onData(this.writer.comment(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.raw = function(value) {
        var node;
        this.openCurrent();
        node = new XMLRaw2(this, value);
        this.onData(this.writer.raw(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.instruction = function(target, value) {
        var i, insTarget, insValue, len, node;
        this.openCurrent();
        if (target != null) {
          target = getValue(target);
        }
        if (value != null) {
          value = getValue(value);
        }
        if (Array.isArray(target)) {
          for (i = 0, len = target.length; i < len; i++) {
            insTarget = target[i];
            this.instruction(insTarget);
          }
        } else if (isObject2(target)) {
          for (insTarget in target) {
            if (!hasProp.call(target, insTarget)) continue;
            insValue = target[insTarget];
            this.instruction(insTarget, insValue);
          }
        } else {
          if (isFunction2(value)) {
            value = value.apply();
          }
          node = new XMLProcessingInstruction2(this, target, value);
          this.onData(this.writer.processingInstruction(node, this.currentLevel + 1), this.currentLevel + 1);
        }
        return this;
      };
      XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
        var node;
        this.openCurrent();
        if (this.documentStarted) {
          throw new Error("declaration() must be the first node.");
        }
        node = new XMLDeclaration2(this, version, encoding, standalone);
        this.onData(this.writer.declaration(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.doctype = function(root2, pubID, sysID) {
        this.openCurrent();
        if (root2 == null) {
          throw new Error("Missing root node name.");
        }
        if (this.root) {
          throw new Error("dtd() must come before the root node.");
        }
        this.currentNode = new XMLDocType2(this, pubID, sysID);
        this.currentNode.rootNodeName = root2;
        this.currentNode.children = false;
        this.currentLevel++;
        this.openTags[this.currentLevel] = this.currentNode;
        return this;
      };
      XMLDocumentCB2.prototype.dtdElement = function(name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDElement2(this, name, value);
        this.onData(this.writer.dtdElement(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
        var node;
        this.openCurrent();
        node = new XMLDTDAttList2(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
        this.onData(this.writer.dtdAttList(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.entity = function(name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity2(this, false, name, value);
        this.onData(this.writer.dtdEntity(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.pEntity = function(name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDEntity2(this, true, name, value);
        this.onData(this.writer.dtdEntity(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.notation = function(name, value) {
        var node;
        this.openCurrent();
        node = new XMLDTDNotation2(this, name, value);
        this.onData(this.writer.dtdNotation(node, this.currentLevel + 1), this.currentLevel + 1);
        return this;
      };
      XMLDocumentCB2.prototype.up = function() {
        if (this.currentLevel < 0) {
          throw new Error("The document node has no parent.");
        }
        if (this.currentNode) {
          if (this.currentNode.children) {
            this.closeNode(this.currentNode);
          } else {
            this.openNode(this.currentNode);
          }
          this.currentNode = null;
        } else {
          this.closeNode(this.openTags[this.currentLevel]);
        }
        delete this.openTags[this.currentLevel];
        this.currentLevel--;
        return this;
      };
      XMLDocumentCB2.prototype.end = function() {
        while (this.currentLevel >= 0) {
          this.up();
        }
        return this.onEnd();
      };
      XMLDocumentCB2.prototype.openCurrent = function() {
        if (this.currentNode) {
          this.currentNode.children = true;
          return this.openNode(this.currentNode);
        }
      };
      XMLDocumentCB2.prototype.openNode = function(node) {
        if (!node.isOpen) {
          if (!this.root && this.currentLevel === 0 && node instanceof XMLElement2) {
            this.root = node;
          }
          this.onData(this.writer.openNode(node, this.currentLevel), this.currentLevel);
          return node.isOpen = true;
        }
      };
      XMLDocumentCB2.prototype.closeNode = function(node) {
        if (!node.isClosed) {
          this.onData(this.writer.closeNode(node, this.currentLevel), this.currentLevel);
          return node.isClosed = true;
        }
      };
      XMLDocumentCB2.prototype.onData = function(chunk2, level) {
        this.documentStarted = true;
        return this.onDataCallback(chunk2, level + 1);
      };
      XMLDocumentCB2.prototype.onEnd = function() {
        this.documentCompleted = true;
        return this.onEndCallback();
      };
      XMLDocumentCB2.prototype.debugInfo = function(name) {
        if (name == null) {
          return "";
        } else {
          return "node: <" + name + ">";
        }
      };
      XMLDocumentCB2.prototype.ele = function() {
        return this.element.apply(this, arguments);
      };
      XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.txt = function(value) {
        return this.text(value);
      };
      XMLDocumentCB2.prototype.dat = function(value) {
        return this.cdata(value);
      };
      XMLDocumentCB2.prototype.com = function(value) {
        return this.comment(value);
      };
      XMLDocumentCB2.prototype.ins = function(target, value) {
        return this.instruction(target, value);
      };
      XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
        return this.declaration(version, encoding, standalone);
      };
      XMLDocumentCB2.prototype.dtd = function(root2, pubID, sysID) {
        return this.doctype(root2, pubID, sysID);
      };
      XMLDocumentCB2.prototype.e = function(name, attributes, text) {
        return this.element(name, attributes, text);
      };
      XMLDocumentCB2.prototype.n = function(name, attributes, text) {
        return this.node(name, attributes, text);
      };
      XMLDocumentCB2.prototype.t = function(value) {
        return this.text(value);
      };
      XMLDocumentCB2.prototype.d = function(value) {
        return this.cdata(value);
      };
      XMLDocumentCB2.prototype.c = function(value) {
        return this.comment(value);
      };
      XMLDocumentCB2.prototype.r = function(value) {
        return this.raw(value);
      };
      XMLDocumentCB2.prototype.i = function(target, value) {
        return this.instruction(target, value);
      };
      XMLDocumentCB2.prototype.att = function() {
        if (this.currentNode && this.currentNode instanceof XMLDocType2) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.a = function() {
        if (this.currentNode && this.currentNode instanceof XMLDocType2) {
          return this.attList.apply(this, arguments);
        } else {
          return this.attribute.apply(this, arguments);
        }
      };
      XMLDocumentCB2.prototype.ent = function(name, value) {
        return this.entity(name, value);
      };
      XMLDocumentCB2.prototype.pent = function(name, value) {
        return this.pEntity(name, value);
      };
      XMLDocumentCB2.prototype.not = function(name, value) {
        return this.notation(name, value);
      };
      return XMLDocumentCB2;
    })();
  }).call(XMLDocumentCB);
  return XMLDocumentCB$1.exports;
}
var XMLStreamWriter$1 = { exports: {} };
var XMLStreamWriter = XMLStreamWriter$1.exports;
var hasRequiredXMLStreamWriter;
function requireXMLStreamWriter() {
  if (hasRequiredXMLStreamWriter) return XMLStreamWriter$1.exports;
  hasRequiredXMLStreamWriter = 1;
  (function() {
    var XMLCData2, XMLComment2, XMLDTDAttList2, XMLDTDElement2, XMLDTDEntity2, XMLDTDNotation2, XMLDeclaration2, XMLDocType2, XMLDummy2, XMLElement2, XMLProcessingInstruction2, XMLRaw2, XMLText2, XMLWriterBase2, extend2 = function(child, parent) {
      for (var key in parent) {
        if (hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor2() {
        this.constructor = child;
      }
      ctor2.prototype = parent.prototype;
      child.prototype = new ctor2();
      child.__super__ = parent.prototype;
      return child;
    }, hasProp = {}.hasOwnProperty;
    XMLDeclaration2 = requireXMLDeclaration();
    XMLDocType2 = requireXMLDocType();
    XMLCData2 = requireXMLCData();
    XMLComment2 = requireXMLComment();
    XMLElement2 = requireXMLElement();
    XMLRaw2 = requireXMLRaw();
    XMLText2 = requireXMLText();
    XMLProcessingInstruction2 = requireXMLProcessingInstruction();
    XMLDummy2 = requireXMLDummy();
    XMLDTDAttList2 = requireXMLDTDAttList();
    XMLDTDElement2 = requireXMLDTDElement();
    XMLDTDEntity2 = requireXMLDTDEntity();
    XMLDTDNotation2 = requireXMLDTDNotation();
    XMLWriterBase2 = requireXMLWriterBase();
    XMLStreamWriter$1.exports = (function(superClass) {
      extend2(XMLStreamWriter2, superClass);
      function XMLStreamWriter2(stream, options2) {
        XMLStreamWriter2.__super__.constructor.call(this, options2);
        this.stream = stream;
      }
      XMLStreamWriter2.prototype.document = function(doc2) {
        var child, i, j, len, len1, ref2, ref1, results2;
        ref2 = doc2.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          child.isLastRootNode = false;
        }
        doc2.children[doc2.children.length - 1].isLastRootNode = true;
        ref1 = doc2.children;
        results2 = [];
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          child = ref1[j];
          if (child instanceof XMLDummy2) {
            continue;
          }
          switch (false) {
            case !(child instanceof XMLDeclaration2):
              results2.push(this.declaration(child));
              break;
            case !(child instanceof XMLDocType2):
              results2.push(this.docType(child));
              break;
            case !(child instanceof XMLComment2):
              results2.push(this.comment(child));
              break;
            case !(child instanceof XMLProcessingInstruction2):
              results2.push(this.processingInstruction(child));
              break;
            default:
              results2.push(this.element(child));
          }
        }
        return results2;
      };
      XMLStreamWriter2.prototype.attribute = function(att) {
        return this.stream.write(" " + att.name + '="' + att.value + '"');
      };
      XMLStreamWriter2.prototype.cdata = function(node, level) {
        return this.stream.write(this.space(level) + "<![CDATA[" + node.text + "]]>" + this.endline(node));
      };
      XMLStreamWriter2.prototype.comment = function(node, level) {
        return this.stream.write(this.space(level) + "<!-- " + node.text + " -->" + this.endline(node));
      };
      XMLStreamWriter2.prototype.declaration = function(node, level) {
        this.stream.write(this.space(level));
        this.stream.write('<?xml version="' + node.version + '"');
        if (node.encoding != null) {
          this.stream.write(' encoding="' + node.encoding + '"');
        }
        if (node.standalone != null) {
          this.stream.write(' standalone="' + node.standalone + '"');
        }
        this.stream.write(this.spacebeforeslash + "?>");
        return this.stream.write(this.endline(node));
      };
      XMLStreamWriter2.prototype.docType = function(node, level) {
        var child, i, len, ref2;
        level || (level = 0);
        this.stream.write(this.space(level));
        this.stream.write("<!DOCTYPE " + node.root().name);
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.children.length > 0) {
          this.stream.write(" [");
          this.stream.write(this.endline(node));
          ref2 = node.children;
          for (i = 0, len = ref2.length; i < len; i++) {
            child = ref2[i];
            switch (false) {
              case !(child instanceof XMLDTDAttList2):
                this.dtdAttList(child, level + 1);
                break;
              case !(child instanceof XMLDTDElement2):
                this.dtdElement(child, level + 1);
                break;
              case !(child instanceof XMLDTDEntity2):
                this.dtdEntity(child, level + 1);
                break;
              case !(child instanceof XMLDTDNotation2):
                this.dtdNotation(child, level + 1);
                break;
              case !(child instanceof XMLCData2):
                this.cdata(child, level + 1);
                break;
              case !(child instanceof XMLComment2):
                this.comment(child, level + 1);
                break;
              case !(child instanceof XMLProcessingInstruction2):
                this.processingInstruction(child, level + 1);
                break;
              default:
                throw new Error("Unknown DTD node type: " + child.constructor.name);
            }
          }
          this.stream.write("]");
        }
        this.stream.write(this.spacebeforeslash + ">");
        return this.stream.write(this.endline(node));
      };
      XMLStreamWriter2.prototype.element = function(node, level) {
        var att, child, i, len, name, ref2, ref1, space;
        level || (level = 0);
        space = this.space(level);
        this.stream.write(space + "<" + node.name);
        ref2 = node.attributes;
        for (name in ref2) {
          if (!hasProp.call(ref2, name)) continue;
          att = ref2[name];
          this.attribute(att);
        }
        if (node.children.length === 0 || node.children.every(function(e) {
          return e.value === "";
        })) {
          if (this.allowEmpty) {
            this.stream.write("></" + node.name + ">");
          } else {
            this.stream.write(this.spacebeforeslash + "/>");
          }
        } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
          this.stream.write(">");
          this.stream.write(node.children[0].value);
          this.stream.write("</" + node.name + ">");
        } else {
          this.stream.write(">" + this.newline);
          ref1 = node.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            switch (false) {
              case !(child instanceof XMLCData2):
                this.cdata(child, level + 1);
                break;
              case !(child instanceof XMLComment2):
                this.comment(child, level + 1);
                break;
              case !(child instanceof XMLElement2):
                this.element(child, level + 1);
                break;
              case !(child instanceof XMLRaw2):
                this.raw(child, level + 1);
                break;
              case !(child instanceof XMLText2):
                this.text(child, level + 1);
                break;
              case !(child instanceof XMLProcessingInstruction2):
                this.processingInstruction(child, level + 1);
                break;
              case !(child instanceof XMLDummy2):
                break;
              default:
                throw new Error("Unknown XML node type: " + child.constructor.name);
            }
          }
          this.stream.write(space + "</" + node.name + ">");
        }
        return this.stream.write(this.endline(node));
      };
      XMLStreamWriter2.prototype.processingInstruction = function(node, level) {
        this.stream.write(this.space(level) + "<?" + node.target);
        if (node.value) {
          this.stream.write(" " + node.value);
        }
        return this.stream.write(this.spacebeforeslash + "?>" + this.endline(node));
      };
      XMLStreamWriter2.prototype.raw = function(node, level) {
        return this.stream.write(this.space(level) + node.value + this.endline(node));
      };
      XMLStreamWriter2.prototype.text = function(node, level) {
        return this.stream.write(this.space(level) + node.value + this.endline(node));
      };
      XMLStreamWriter2.prototype.dtdAttList = function(node, level) {
        this.stream.write(this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType);
        if (node.defaultValueType !== "#DEFAULT") {
          this.stream.write(" " + node.defaultValueType);
        }
        if (node.defaultValue) {
          this.stream.write(' "' + node.defaultValue + '"');
        }
        return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
      };
      XMLStreamWriter2.prototype.dtdElement = function(node, level) {
        this.stream.write(this.space(level) + "<!ELEMENT " + node.name + " " + node.value);
        return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
      };
      XMLStreamWriter2.prototype.dtdEntity = function(node, level) {
        this.stream.write(this.space(level) + "<!ENTITY");
        if (node.pe) {
          this.stream.write(" %");
        }
        this.stream.write(" " + node.name);
        if (node.value) {
          this.stream.write(' "' + node.value + '"');
        } else {
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.nData) {
            this.stream.write(" NDATA " + node.nData);
          }
        }
        return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
      };
      XMLStreamWriter2.prototype.dtdNotation = function(node, level) {
        this.stream.write(this.space(level) + "<!NOTATION " + node.name);
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.pubID) {
          this.stream.write(' PUBLIC "' + node.pubID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
      };
      XMLStreamWriter2.prototype.endline = function(node) {
        if (!node.isLastRootNode) {
          return this.newline;
        } else {
          return "";
        }
      };
      return XMLStreamWriter2;
    })(XMLWriterBase2);
  }).call(XMLStreamWriter);
  return XMLStreamWriter$1.exports;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  (function() {
    var XMLDocument2, XMLDocumentCB2, XMLStreamWriter2, XMLStringWriter2, assign, isFunction2, ref2;
    ref2 = requireUtility(), assign = ref2.assign, isFunction2 = ref2.isFunction;
    XMLDocument2 = requireXMLDocument();
    XMLDocumentCB2 = requireXMLDocumentCB();
    XMLStringWriter2 = requireXMLStringWriter();
    XMLStreamWriter2 = requireXMLStreamWriter();
    lib.create = function(name, xmldec, doctype, options2) {
      var doc2, root2;
      if (name == null) {
        throw new Error("Root element needs a name.");
      }
      options2 = assign({}, xmldec, doctype, options2);
      doc2 = new XMLDocument2(options2);
      root2 = doc2.element(name);
      if (!options2.headless) {
        doc2.declaration(options2);
        if (options2.pubID != null || options2.sysID != null) {
          doc2.doctype(options2);
        }
      }
      return root2;
    };
    lib.begin = function(options2, onData, onEnd) {
      var ref1;
      if (isFunction2(options2)) {
        ref1 = [options2, onData], onData = ref1[0], onEnd = ref1[1];
        options2 = {};
      }
      if (onData) {
        return new XMLDocumentCB2(options2, onData, onEnd);
      } else {
        return new XMLDocument2(options2);
      }
    };
    lib.stringWriter = function(options2) {
      return new XMLStringWriter2(options2);
    };
    lib.streamWriter = function(stream, options2) {
      return new XMLStreamWriter2(stream, options2);
    };
  }).call(lib);
  return lib;
}
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  var _2 = require$$0;
  var xmlbuilder = requireLib$1();
  writer.writeString = writeString;
  function writeString(root2, namespaces) {
    var uriToPrefix = _2.invert(namespaces);
    var nodeWriters = {
      element: writeElement,
      text: writeTextNode
    };
    function writeNode(builder, node) {
      return nodeWriters[node.type](builder, node);
    }
    function writeElement(builder, element) {
      var elementBuilder = builder.element(mapElementName(element.name), element.attributes);
      element.children.forEach(function(child) {
        writeNode(elementBuilder, child);
      });
    }
    function mapElementName(name) {
      var longFormMatch = /^\{(.*)\}(.*)$/.exec(name);
      if (longFormMatch) {
        var prefix = uriToPrefix[longFormMatch[1]];
        return prefix + (prefix === "" ? "" : ":") + longFormMatch[2];
      } else {
        return name;
      }
    }
    function writeDocument(root3) {
      var builder = xmlbuilder.create(mapElementName(root3.name), {
        version: "1.0",
        encoding: "UTF-8",
        standalone: true
      });
      _2.forEach(namespaces, function(uri, prefix) {
        var key = "xmlns" + (prefix === "" ? "" : ":" + prefix);
        builder.attribute(key, uri);
      });
      root3.children.forEach(function(child) {
        writeNode(builder, child);
      });
      return builder.end();
    }
    return writeDocument(root2);
  }
  function writeTextNode(builder, node) {
    builder.text(node.value);
  }
  return writer;
}
var hasRequiredXml;
function requireXml() {
  if (hasRequiredXml) return xml;
  hasRequiredXml = 1;
  var nodes2 = requireNodes();
  xml.Element = nodes2.Element;
  xml.element = nodes2.element;
  xml.emptyElement = nodes2.emptyElement;
  xml.text = nodes2.text;
  xml.readString = requireReader().readString;
  xml.writeString = requireWriter().writeString;
  return xml;
}
var hasRequiredOfficeXmlReader;
function requireOfficeXmlReader() {
  if (hasRequiredOfficeXmlReader) return officeXmlReader;
  hasRequiredOfficeXmlReader = 1;
  var _2 = require$$0;
  var promises2 = requirePromises();
  var xml2 = requireXml();
  officeXmlReader.read = read;
  officeXmlReader.readXmlFromZipFile = readXmlFromZipFile;
  var xmlNamespaceMap = {
    // Transitional format
    "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
    "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
    "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
    "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
    // Strict format
    "http://purl.oclc.org/ooxml/wordprocessingml/main": "w",
    "http://purl.oclc.org/ooxml/officeDocument/relationships": "r",
    "http://purl.oclc.org/ooxml/drawingml/wordprocessingDrawing": "wp",
    "http://purl.oclc.org/ooxml/drawingml/main": "a",
    "http://purl.oclc.org/ooxml/drawingml/picture": "pic",
    // Common
    "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
    "http://schemas.openxmlformats.org/package/2006/relationships": "relationships",
    "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
    "urn:schemas-microsoft-com:vml": "v",
    "urn:schemas-microsoft-com:office:word": "office-word",
    // [MS-DOCX]: Word Extensions to the Office Open XML (.docx) File Format
    // https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b839fe1f-e1ca-4fa6-8c26-5954d0abbccd
    "http://schemas.microsoft.com/office/word/2010/wordml": "wordml"
  };
  function read(xmlString) {
    return xml2.readString(xmlString, xmlNamespaceMap).then(function(document2) {
      return collapseAlternateContent(document2)[0];
    });
  }
  function readXmlFromZipFile(docxFile, path) {
    if (docxFile.exists(path)) {
      return docxFile.read(path, "utf-8").then(stripUtf8Bom).then(read);
    } else {
      return promises2.resolve(null);
    }
  }
  function stripUtf8Bom(xmlString) {
    return xmlString.replace(/^\uFEFF/g, "");
  }
  function collapseAlternateContent(node) {
    if (node.type === "element") {
      if (node.name === "mc:AlternateContent") {
        return node.firstOrEmpty("mc:Fallback").children;
      } else {
        node.children = _2.flatten(node.children.map(collapseAlternateContent, true));
        return [node];
      }
    } else {
      return [node];
    }
  }
  return officeXmlReader;
}
var bodyReader = {};
var dist = {};
var dingbats = {};
var hasRequiredDingbats;
function requireDingbats() {
  if (hasRequiredDingbats) return dingbats;
  hasRequiredDingbats = 1;
  Object.defineProperty(dingbats, "__esModule", { value: true });
  var dingbats$1 = [
    { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
    { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
    { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
    { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
    { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
    { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
    { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
    { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
    { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
    { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
    { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
    { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
    { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
    { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
    { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
    { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
    { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
    { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
    { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
    { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
    { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
    { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
    { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
    { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
    { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
    { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
    { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
    { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
    { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
    { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
    { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
    { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
    { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
    { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
    { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
    { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
    { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
    { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
    { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
    { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
    { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
    { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
    { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
    { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
    { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
    { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
    { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
    { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
    { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
    { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
    { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
    { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
    { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
    { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
    { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
    { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
    { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
    { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
    { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
    { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
    { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
    { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
    { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
    { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
    { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
    { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
    { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
    { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
    { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
    { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
    { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
    { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
    { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
    { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
    { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
    { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
    { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
    { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
    { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
    { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
    { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
    { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
    { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
    { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
    { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
    { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
    { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
    { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
    { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
    { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
    { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
    { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
    { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
    { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
    { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
    { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
    { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
    { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
    { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
    { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
    { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
    { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
    { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
    { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
    { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
    { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
    { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
    { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
    { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
    { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
    { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
    { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
    { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
    { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
    { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
    { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
    { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
    { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
    { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
    { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
    { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
    { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
    { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
    { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
    { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
    { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
    { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
    { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
    { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
    { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
    { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
    { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
    { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
    { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
    { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
    { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
    { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
    { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
    { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
    { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
    { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
    { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
    { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
    { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
    { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
    { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
    { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
    { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
    { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
    { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
    { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
    { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
    { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
    { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
    { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
    { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
    { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
    { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
    { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
    { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
    { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
    { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
    { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
    { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
    { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
    { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
    { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
    { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
    { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
    { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
    { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
    { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
    { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
    { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
    { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
    { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
    { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
    { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
    { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
    { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
    { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
    { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
    { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
    { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
    { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
    { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
    { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
    { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
    { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
    { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
    { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
    { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
    { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
    { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
    { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
    { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
    { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
    { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
    { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
    { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
    { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
    { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
    { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
    { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
    { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
    { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
    { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
    { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
    { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
    { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
    { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
    { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
    { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
    { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
    { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
    { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
    { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
    { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
    { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
    { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
    { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
    { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
    { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
    { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
    { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
    { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
    { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
    { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
    { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
    { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
    { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
    { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
    { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
    { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
    { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
    { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
    { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
    { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
    { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
    { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
    { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
    { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
    { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
    { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
    { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
    { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
    { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
    { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
    { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
    { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
    { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
    { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
    { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
    { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
    { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
    { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
    { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
    { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
    { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
    { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
    { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
    { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
    { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
    { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
    { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
    { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
    { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
    { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
    { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
    { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
    { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
    { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
    { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
    { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
    { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
    { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
    { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
    { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
    { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
    { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
    { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
    { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
    { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
    { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
    { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
    { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
    { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
    { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
    { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
    { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
    { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
    { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
    { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
    { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
    { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
    { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
    { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
    { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
    { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
    { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
    { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
    { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
    { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
    { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
    { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
    { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
    { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
    { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
    { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
    { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
    { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
    { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
    { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
    { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
    { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
    { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
    { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
    { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
    { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
    { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
    { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
    { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
    { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
    { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
    { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
    { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
    { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
    { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
    { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
    { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
    { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
    { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
    { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
    { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
    { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
    { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
    { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
    { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
    { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
    { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
    { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
    { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
    { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
    { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
    { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
    { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
    { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
    { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
    { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
    { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
    { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
    { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
    { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
    { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
    { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
    { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
    { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
    { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
    { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
    { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
    { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
    { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
    { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
    { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
    { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
    { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
    { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
    { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
    { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
    { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
    { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
    { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
    { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
    { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
    { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
    { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
    { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
    { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
    { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
    { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
    { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
    { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
    { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
    { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
    { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
    { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
    { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
    { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
    { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
    { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
    { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
    { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
    { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
    { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
    { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
    { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
    { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
    { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
    { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
    { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
    { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
    { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
    { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
    { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
    { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
    { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
    { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
    { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
    { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
    { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
    { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
    { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
    { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
    { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
    { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
    { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
    { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
    { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
    { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
    { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
    { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
    { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
    { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
    { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
    { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
    { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
    { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
    { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
    { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
    { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
    { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
    { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
    { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
    { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
    { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
    { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
    { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
    { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
    { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
    { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
    { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
    { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
    { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
    { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
    { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
    { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
    { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
    { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
    { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
    { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
    { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
    { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
    { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
    { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
    { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
    { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
    { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
    { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
    { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
    { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
    { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
    { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
    { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
    { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
    { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
    { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
    { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
    { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
    { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
    { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
    { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
    { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
    { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
    { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
    { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
    { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
    { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
    { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
    { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
    { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
    { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
    { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
    { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
    { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
    { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
    { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
    { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
    { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
    { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
    { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
    { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
    { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
    { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
    { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
    { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
    { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
    { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
    { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
    { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
    { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
  ];
  dingbats.default = dingbats$1;
  return dingbats;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  var __importDefault = dist && dist.__importDefault || function(mod2) {
    return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
  };
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.hex = dist.dec = dist.codePoint = void 0;
  var dingbats_1 = __importDefault(requireDingbats());
  var dingbatsByCodePoint = {};
  var fromCodePoint = String.fromCodePoint ? String.fromCodePoint : fromCodePointPolyfill;
  for (var _i = 0, dingbats_2 = dingbats_1.default; _i < dingbats_2.length; _i++) {
    var dingbat = dingbats_2[_i];
    var codePoint_1 = parseInt(dingbat["Unicode dec"], 10);
    var scalarValue = {
      codePoint: codePoint_1,
      string: fromCodePoint(codePoint_1)
    };
    dingbatsByCodePoint[dingbat["Typeface name"].toUpperCase() + "_" + dingbat["Dingbat dec"]] = scalarValue;
  }
  function codePoint(typeface, codePoint2) {
    return dingbatsByCodePoint[typeface.toUpperCase() + "_" + codePoint2];
  }
  dist.codePoint = codePoint;
  function dec(typeface, dec2) {
    return codePoint(typeface, parseInt(dec2, 10));
  }
  dist.dec = dec;
  function hex(typeface, hex2) {
    return codePoint(typeface, parseInt(hex2, 16));
  }
  dist.hex = hex;
  function fromCodePointPolyfill(codePoint2) {
    if (codePoint2 <= 65535) {
      return String.fromCharCode(codePoint2);
    } else {
      var highSurrogate = Math.floor((codePoint2 - 65536) / 1024) + 55296;
      var lowSurrogate = (codePoint2 - 65536) % 1024 + 56320;
      return String.fromCharCode(highSurrogate, lowSurrogate);
    }
  }
  return dist;
}
var transforms = {};
var hasRequiredTransforms;
function requireTransforms() {
  if (hasRequiredTransforms) return transforms;
  hasRequiredTransforms = 1;
  var _2 = require$$0;
  transforms.paragraph = paragraph;
  transforms.run = run3;
  transforms._elements = elements;
  transforms._elementsOfType = elementsOfType;
  transforms.getDescendantsOfType = getDescendantsOfType;
  transforms.getDescendants = getDescendants;
  function paragraph(transform) {
    return elementsOfType("paragraph", transform);
  }
  function run3(transform) {
    return elementsOfType("run", transform);
  }
  function elementsOfType(elementType, transform) {
    return elements(function(element) {
      if (element.type === elementType) {
        return transform(element);
      } else {
        return element;
      }
    });
  }
  function elements(transform) {
    return function transformElement(element) {
      if (element.children) {
        var children = _2.map(element.children, transformElement);
        element = _2.extend(element, { children });
      }
      return transform(element);
    };
  }
  function getDescendantsOfType(element, type) {
    return getDescendants(element).filter(function(descendant) {
      return descendant.type === type;
    });
  }
  function getDescendants(element) {
    var descendants = [];
    visitDescendants(element, function(descendant) {
      descendants.push(descendant);
    });
    return descendants;
  }
  function visitDescendants(element, visit) {
    if (element.children) {
      element.children.forEach(function(child) {
        visitDescendants(child, visit);
        visit(child);
      });
    }
  }
  return transforms;
}
var uris = {};
var hasRequiredUris;
function requireUris() {
  if (hasRequiredUris) return uris;
  hasRequiredUris = 1;
  uris.uriToZipEntryName = uriToZipEntryName;
  uris.replaceFragment = replaceFragment;
  function uriToZipEntryName(base2, uri) {
    if (uri.charAt(0) === "/") {
      return uri.substr(1);
    } else {
      return base2 + "/" + uri;
    }
  }
  function replaceFragment(uri, fragment) {
    var hashIndex = uri.indexOf("#");
    if (hashIndex !== -1) {
      uri = uri.substring(0, hashIndex);
    }
    return uri + "#" + fragment;
  }
  return uris;
}
var hasRequiredBodyReader;
function requireBodyReader() {
  if (hasRequiredBodyReader) return bodyReader;
  hasRequiredBodyReader = 1;
  bodyReader.createBodyReader = createBodyReader;
  bodyReader._readNumberingProperties = readNumberingProperties;
  var dingbatToUnicode = requireDist();
  var _2 = require$$0;
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  var warning = requireResults().warning;
  var xml2 = requireXml();
  var transforms2 = requireTransforms();
  var uris2 = requireUris();
  function createBodyReader(options2) {
    return {
      readXmlElement: function(element) {
        return new BodyReader(options2).readXmlElement(element);
      },
      readXmlElements: function(elements) {
        return new BodyReader(options2).readXmlElements(elements);
      }
    };
  }
  function BodyReader(options2) {
    var complexFieldStack = [];
    var currentInstrText = [];
    var deletedParagraphContents = [];
    var relationships = options2.relationships;
    var contentTypes = options2.contentTypes;
    var docxFile = options2.docxFile;
    var files2 = options2.files;
    var numbering = options2.numbering;
    var styles = options2.styles;
    function readXmlElements(elements) {
      var results2 = elements.map(readXmlElement);
      return combineResults(results2);
    }
    function readXmlElement(element) {
      if (element.type === "element") {
        var handler = xmlElementReaders[element.name];
        if (handler) {
          return handler(element);
        } else if (!Object.prototype.hasOwnProperty.call(ignoreElements, element.name)) {
          var message = warning("An unrecognised element was ignored: " + element.name);
          return emptyResultWithMessages([message]);
        }
      }
      return emptyResult();
    }
    function readParagraphProperties(element) {
      return readParagraphStyle(element).map(function(style2) {
        return {
          type: "paragraphProperties",
          styleId: style2.styleId,
          styleName: style2.name,
          alignment: element.firstOrEmpty("w:jc").attributes["w:val"],
          numbering: readNumberingProperties(style2.styleId, element.firstOrEmpty("w:numPr"), numbering),
          indent: readParagraphIndent(element.firstOrEmpty("w:ind"))
        };
      });
    }
    function readParagraphIndent(element) {
      return {
        start: element.attributes["w:start"] || element.attributes["w:left"],
        end: element.attributes["w:end"] || element.attributes["w:right"],
        firstLine: element.attributes["w:firstLine"],
        hanging: element.attributes["w:hanging"]
      };
    }
    function readRunProperties(element) {
      return readRunStyle(element).map(function(style2) {
        var fontSizeString = element.firstOrEmpty("w:sz").attributes["w:val"];
        var fontSize = /^[0-9]+$/.test(fontSizeString) ? parseInt(fontSizeString, 10) / 2 : null;
        return {
          type: "runProperties",
          styleId: style2.styleId,
          styleName: style2.name,
          verticalAlignment: element.firstOrEmpty("w:vertAlign").attributes["w:val"],
          font: element.firstOrEmpty("w:rFonts").attributes["w:ascii"],
          fontSize,
          isBold: readBooleanElement(element.first("w:b")),
          isUnderline: readUnderline(element.first("w:u")),
          isItalic: readBooleanElement(element.first("w:i")),
          isStrikethrough: readBooleanElement(element.first("w:strike")),
          isAllCaps: readBooleanElement(element.first("w:caps")),
          isSmallCaps: readBooleanElement(element.first("w:smallCaps")),
          highlight: readHighlightValue(element.firstOrEmpty("w:highlight").attributes["w:val"])
        };
      });
    }
    function readUnderline(element) {
      if (element) {
        var value = element.attributes["w:val"];
        return value !== void 0 && value !== "false" && value !== "0" && value !== "none";
      } else {
        return false;
      }
    }
    function readBooleanElement(element) {
      if (element) {
        var value = element.attributes["w:val"];
        return value !== "false" && value !== "0";
      } else {
        return false;
      }
    }
    function readBooleanAttributeValue(value) {
      return value !== "false" && value !== "0";
    }
    function readHighlightValue(value) {
      if (!value || value === "none") {
        return null;
      } else {
        return value;
      }
    }
    function readParagraphStyle(element) {
      return readStyle(element, "w:pStyle", "Paragraph", styles.findParagraphStyleById);
    }
    function readRunStyle(element) {
      return readStyle(element, "w:rStyle", "Run", styles.findCharacterStyleById);
    }
    function readTableStyle(element) {
      return readStyle(element, "w:tblStyle", "Table", styles.findTableStyleById);
    }
    function readStyle(element, styleTagName, styleType, findStyleById) {
      var messages = [];
      var styleElement = element.first(styleTagName);
      var styleId = null;
      var name = null;
      if (styleElement) {
        styleId = styleElement.attributes["w:val"];
        if (styleId) {
          var style2 = findStyleById(styleId);
          if (style2) {
            name = style2.name;
          } else {
            messages.push(undefinedStyleWarning(styleType, styleId));
          }
        }
      }
      return elementResultWithMessages({ styleId, name }, messages);
    }
    function readFldChar(element) {
      var type = element.attributes["w:fldCharType"];
      if (type === "begin") {
        complexFieldStack.push({ type: "begin", fldChar: element });
        currentInstrText = [];
      } else if (type === "end") {
        var complexFieldEnd = complexFieldStack.pop();
        if (complexFieldEnd.type === "begin") {
          complexFieldEnd = parseCurrentInstrText(complexFieldEnd);
        }
        if (complexFieldEnd.type === "checkbox") {
          return elementResult(documents2.checkbox({
            checked: complexFieldEnd.checked
          }));
        }
      } else if (type === "separate") {
        var complexFieldSeparate = complexFieldStack.pop();
        var complexField = parseCurrentInstrText(complexFieldSeparate);
        complexFieldStack.push(complexField);
      }
      return emptyResult();
    }
    function currentHyperlinkOptions() {
      var topHyperlink = _2.last(complexFieldStack.filter(function(complexField) {
        return complexField.type === "hyperlink";
      }));
      return topHyperlink ? topHyperlink.options : null;
    }
    function parseCurrentInstrText(complexField) {
      return parseInstrText(
        currentInstrText.join(""),
        complexField.type === "begin" ? complexField.fldChar : xml2.emptyElement
      );
    }
    function parseInstrText(instrText, fldChar) {
      var externalLinkResult = /\s*HYPERLINK "(.*)"/.exec(instrText);
      if (externalLinkResult) {
        return { type: "hyperlink", options: { href: externalLinkResult[1] } };
      }
      var internalLinkResult = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(instrText);
      if (internalLinkResult) {
        return { type: "hyperlink", options: { anchor: internalLinkResult[1] } };
      }
      var checkboxResult = /\s*FORMCHECKBOX\s*/.exec(instrText);
      if (checkboxResult) {
        var checkboxElement = fldChar.firstOrEmpty("w:ffData").firstOrEmpty("w:checkBox");
        var checkedElement = checkboxElement.first("w:checked");
        var checked = checkedElement == null ? readBooleanElement(checkboxElement.first("w:default")) : readBooleanElement(checkedElement);
        return { type: "checkbox", checked };
      }
      return { type: "unknown" };
    }
    function readInstrText(element) {
      currentInstrText.push(element.text());
      return emptyResult();
    }
    function readSymbol(element) {
      var font = element.attributes["w:font"];
      var char = element.attributes["w:char"];
      var unicodeCharacter = dingbatToUnicode.hex(font, char);
      if (unicodeCharacter == null && /^F0..$/.test(char)) {
        unicodeCharacter = dingbatToUnicode.hex(font, char.substring(2));
      }
      if (unicodeCharacter == null) {
        return emptyResultWithMessages([warning(
          "A w:sym element with an unsupported character was ignored: char " + char + " in font " + font
        )]);
      } else {
        return elementResult(new documents2.Text(unicodeCharacter.string));
      }
    }
    function noteReferenceReader(noteType) {
      return function(element) {
        var noteId = element.attributes["w:id"];
        return elementResult(new documents2.NoteReference({
          noteType,
          noteId
        }));
      };
    }
    function readCommentReference(element) {
      return elementResult(documents2.commentReference({
        commentId: element.attributes["w:id"]
      }));
    }
    function readChildElements(element) {
      return readXmlElements(element.children);
    }
    var xmlElementReaders = {
      "w:p": function(element) {
        var paragraphPropertiesElement = element.firstOrEmpty("w:pPr");
        var isDeleted = !!paragraphPropertiesElement.firstOrEmpty("w:rPr").first("w:del");
        if (isDeleted) {
          element.children.forEach(function(child) {
            deletedParagraphContents.push(child);
          });
          return emptyResult();
        } else {
          var childrenXml = element.children;
          if (deletedParagraphContents.length > 0) {
            childrenXml = deletedParagraphContents.concat(childrenXml);
            deletedParagraphContents = [];
          }
          return ReadResult.map(
            readParagraphProperties(paragraphPropertiesElement),
            readXmlElements(childrenXml),
            function(properties, children) {
              return new documents2.Paragraph(children, properties);
            }
          ).insertExtra();
        }
      },
      "w:r": function(element) {
        return ReadResult.map(
          readRunProperties(element.firstOrEmpty("w:rPr")),
          readXmlElements(element.children),
          function(properties, children) {
            var hyperlinkOptions = currentHyperlinkOptions();
            if (hyperlinkOptions !== null) {
              children = [new documents2.Hyperlink(children, hyperlinkOptions)];
            }
            return new documents2.Run(children, properties);
          }
        );
      },
      "w:fldChar": readFldChar,
      "w:instrText": readInstrText,
      "w:t": function(element) {
        return elementResult(new documents2.Text(element.text()));
      },
      "w:tab": function(element) {
        return elementResult(new documents2.Tab());
      },
      "w:noBreakHyphen": function() {
        return elementResult(new documents2.Text("â"));
      },
      "w:softHyphen": function(element) {
        return elementResult(new documents2.Text("Â­"));
      },
      "w:sym": readSymbol,
      "w:hyperlink": function(element) {
        var relationshipId = element.attributes["r:id"];
        var anchor = element.attributes["w:anchor"];
        return readXmlElements(element.children).map(function(children) {
          function create2(options3) {
            var targetFrame = element.attributes["w:tgtFrame"] || null;
            return new documents2.Hyperlink(
              children,
              _2.extend({ targetFrame }, options3)
            );
          }
          if (relationshipId) {
            var href = relationships.findTargetByRelationshipId(relationshipId);
            if (anchor) {
              href = uris2.replaceFragment(href, anchor);
            }
            return create2({ href });
          } else if (anchor) {
            return create2({ anchor });
          } else {
            return children;
          }
        });
      },
      "w:tbl": readTable,
      "w:tr": readTableRow,
      "w:tc": readTableCell,
      "w:footnoteReference": noteReferenceReader("footnote"),
      "w:endnoteReference": noteReferenceReader("endnote"),
      "w:commentReference": readCommentReference,
      "w:br": function(element) {
        var breakType = element.attributes["w:type"];
        if (breakType == null || breakType === "textWrapping") {
          return elementResult(documents2.lineBreak);
        } else if (breakType === "page") {
          return elementResult(documents2.pageBreak);
        } else if (breakType === "column") {
          return elementResult(documents2.columnBreak);
        } else {
          return emptyResultWithMessages([warning("Unsupported break type: " + breakType)]);
        }
      },
      "w:bookmarkStart": function(element) {
        var name = element.attributes["w:name"];
        if (name === "_GoBack") {
          return emptyResult();
        } else {
          return elementResult(new documents2.BookmarkStart({ name }));
        }
      },
      "mc:AlternateContent": function(element) {
        return readChildElements(element.firstOrEmpty("mc:Fallback"));
      },
      "w:sdt": function(element) {
        var contentResult = readXmlElements(element.firstOrEmpty("w:sdtContent").children);
        return contentResult.map(function(content) {
          var checkbox = element.firstOrEmpty("w:sdtPr").first("wordml:checkbox");
          if (checkbox) {
            var checkedElement = checkbox.first("wordml:checked");
            var isChecked = !!checkedElement && readBooleanAttributeValue(
              checkedElement.attributes["wordml:val"]
            );
            var documentCheckbox = documents2.checkbox({
              checked: isChecked
            });
            var hasCheckbox = false;
            var replacedContent = content.map(transforms2._elementsOfType(
              documents2.types.text,
              function(text) {
                if (text.value.length > 0 && !hasCheckbox) {
                  hasCheckbox = true;
                  return documentCheckbox;
                } else {
                  return text;
                }
              }
            ));
            if (hasCheckbox) {
              return replacedContent;
            } else {
              return documentCheckbox;
            }
          } else {
            return content;
          }
        });
      },
      "w:ins": readChildElements,
      "w:object": readChildElements,
      "w:smartTag": readChildElements,
      "w:drawing": readChildElements,
      "w:pict": function(element) {
        return readChildElements(element).toExtra();
      },
      "v:roundrect": readChildElements,
      "v:shape": readChildElements,
      "v:textbox": readChildElements,
      "w:txbxContent": readChildElements,
      "wp:inline": readDrawingElement,
      "wp:anchor": readDrawingElement,
      "v:imagedata": readImageData,
      "v:group": readChildElements,
      "v:rect": readChildElements
    };
    return {
      readXmlElement,
      readXmlElements
    };
    function readTable(element) {
      var propertiesResult = readTableProperties(element.firstOrEmpty("w:tblPr"));
      return readXmlElements(element.children).flatMap(calculateRowSpans).flatMap(function(children) {
        return propertiesResult.map(function(properties) {
          return documents2.Table(children, properties);
        });
      });
    }
    function readTableProperties(element) {
      return readTableStyle(element).map(function(style2) {
        return {
          styleId: style2.styleId,
          styleName: style2.name
        };
      });
    }
    function readTableRow(element) {
      var properties = element.firstOrEmpty("w:trPr");
      var isDeleted = !!properties.first("w:del");
      if (isDeleted) {
        return emptyResult();
      }
      var isHeader = !!properties.first("w:tblHeader");
      return readXmlElements(element.children).map(function(children) {
        return documents2.TableRow(children, { isHeader });
      });
    }
    function readTableCell(element) {
      return readXmlElements(element.children).map(function(children) {
        var properties = element.firstOrEmpty("w:tcPr");
        var gridSpan = properties.firstOrEmpty("w:gridSpan").attributes["w:val"];
        var colSpan = gridSpan ? parseInt(gridSpan, 10) : 1;
        var cell = documents2.TableCell(children, { colSpan });
        cell._vMerge = readVMerge(properties);
        return cell;
      });
    }
    function readVMerge(properties) {
      var element = properties.first("w:vMerge");
      if (element) {
        var val = element.attributes["w:val"];
        return val === "continue" || !val;
      } else {
        return null;
      }
    }
    function calculateRowSpans(rows) {
      var unexpectedNonRows = _2.any(rows, function(row) {
        return row.type !== documents2.types.tableRow;
      });
      if (unexpectedNonRows) {
        return elementResultWithMessages(rows, [warning(
          "unexpected non-row element in table, cell merging may be incorrect"
        )]);
      }
      var unexpectedNonCells = _2.any(rows, function(row) {
        return _2.any(row.children, function(cell) {
          return cell.type !== documents2.types.tableCell;
        });
      });
      if (unexpectedNonCells) {
        return elementResultWithMessages(rows, [warning(
          "unexpected non-cell element in table row, cell merging may be incorrect"
        )]);
      }
      var columns = {};
      rows.forEach(function(row) {
        var cellIndex = 0;
        row.children.forEach(function(cell) {
          if (cell._vMerge && columns[cellIndex]) {
            columns[cellIndex].rowSpan++;
          } else {
            columns[cellIndex] = cell;
            cell._vMerge = false;
          }
          cellIndex += cell.colSpan;
        });
      });
      rows.forEach(function(row) {
        row.children = row.children.filter(function(cell) {
          return !cell._vMerge;
        });
        row.children.forEach(function(cell) {
          delete cell._vMerge;
        });
      });
      return elementResult(rows);
    }
    function readDrawingElement(element) {
      var blips = element.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
      return combineResults(blips.map(readBlip.bind(null, element)));
    }
    function readBlip(element, blip) {
      var properties = element.first("wp:docPr").attributes;
      var altText = isBlank(properties.descr) ? properties.title : properties.descr;
      var blipImageFile = findBlipImageFile(blip);
      if (blipImageFile === null) {
        return emptyResultWithMessages([warning("Could not find image file for a:blip element")]);
      } else {
        return readImage(blipImageFile, altText);
      }
    }
    function isBlank(value) {
      return value == null || /^\s*$/.test(value);
    }
    function findBlipImageFile(blip) {
      var embedRelationshipId = blip.attributes["r:embed"];
      var linkRelationshipId = blip.attributes["r:link"];
      if (embedRelationshipId) {
        return findEmbeddedImageFile(embedRelationshipId);
      } else if (linkRelationshipId) {
        var imagePath = relationships.findTargetByRelationshipId(linkRelationshipId);
        return {
          path: imagePath,
          read: files2.read.bind(files2, imagePath)
        };
      } else {
        return null;
      }
    }
    function readImageData(element) {
      var relationshipId = element.attributes["r:id"];
      if (relationshipId) {
        return readImage(
          findEmbeddedImageFile(relationshipId),
          element.attributes["o:title"]
        );
      } else {
        return emptyResultWithMessages([warning("A v:imagedata element without a relationship ID was ignored")]);
      }
    }
    function findEmbeddedImageFile(relationshipId) {
      var path = uris2.uriToZipEntryName("word", relationships.findTargetByRelationshipId(relationshipId));
      return {
        path,
        read: docxFile.read.bind(docxFile, path)
      };
    }
    function readImage(imageFile, altText) {
      var contentType = contentTypes.findContentType(imageFile.path);
      var image = documents2.Image({
        readImage: imageFile.read,
        altText,
        contentType
      });
      var warnings = supportedImageTypes[contentType] ? [] : warning("Image of type " + contentType + " is unlikely to display in web browsers");
      return elementResultWithMessages(image, warnings);
    }
    function undefinedStyleWarning(type, styleId) {
      return warning(
        type + " style with ID " + styleId + " was referenced but not defined in the document"
      );
    }
  }
  function readNumberingProperties(styleId, element, numbering) {
    var level = element.firstOrEmpty("w:ilvl").attributes["w:val"];
    var numId = element.firstOrEmpty("w:numId").attributes["w:val"];
    if (level !== void 0 && numId !== void 0) {
      return numbering.findLevel(numId, level);
    }
    if (styleId != null) {
      var levelByStyleId = numbering.findLevelByParagraphStyleId(styleId);
      if (levelByStyleId != null) {
        return levelByStyleId;
      }
    }
    return null;
  }
  var supportedImageTypes = {
    "image/png": true,
    "image/gif": true,
    "image/jpeg": true,
    "image/svg+xml": true,
    "image/tiff": true
  };
  var ignoreElements = {
    "office-word:wrap": true,
    "v:shadow": true,
    "v:shapetype": true,
    "w:annotationRef": true,
    "w:bookmarkEnd": true,
    "w:sectPr": true,
    "w:proofErr": true,
    "w:lastRenderedPageBreak": true,
    "w:commentRangeStart": true,
    "w:commentRangeEnd": true,
    "w:del": true,
    "w:footnoteRef": true,
    "w:endnoteRef": true,
    "w:pPr": true,
    "w:rPr": true,
    "w:tblPr": true,
    "w:tblGrid": true,
    "w:trPr": true,
    "w:tcPr": true
  };
  function emptyResultWithMessages(messages) {
    return new ReadResult(null, null, messages);
  }
  function emptyResult() {
    return new ReadResult(null);
  }
  function elementResult(element) {
    return new ReadResult(element);
  }
  function elementResultWithMessages(element, messages) {
    return new ReadResult(element, null, messages);
  }
  function ReadResult(element, extra, messages) {
    this.value = element || [];
    this.extra = extra || [];
    this._result = new Result({
      element: this.value,
      extra
    }, messages);
    this.messages = this._result.messages;
  }
  ReadResult.prototype.toExtra = function() {
    return new ReadResult(null, joinElements(this.extra, this.value), this.messages);
  };
  ReadResult.prototype.insertExtra = function() {
    var extra = this.extra;
    if (extra && extra.length) {
      return new ReadResult(joinElements(this.value, extra), null, this.messages);
    } else {
      return this;
    }
  };
  ReadResult.prototype.map = function(func) {
    var result2 = this._result.map(function(value) {
      return func(value.element);
    });
    return new ReadResult(result2.value, this.extra, result2.messages);
  };
  ReadResult.prototype.flatMap = function(func) {
    var result2 = this._result.flatMap(function(value) {
      return func(value.element)._result;
    });
    return new ReadResult(result2.value.element, joinElements(this.extra, result2.value.extra), result2.messages);
  };
  ReadResult.map = function(first2, second, func) {
    return new ReadResult(
      func(first2.value, second.value),
      joinElements(first2.extra, second.extra),
      first2.messages.concat(second.messages)
    );
  };
  function combineResults(results2) {
    var result2 = Result.combine(_2.pluck(results2, "_result"));
    return new ReadResult(
      _2.flatten(_2.pluck(result2.value, "element")),
      _2.filter(_2.flatten(_2.pluck(result2.value, "extra")), identity2),
      result2.messages
    );
  }
  function joinElements(first2, second) {
    return _2.flatten([first2, second]);
  }
  function identity2(value) {
    return value;
  }
  return bodyReader;
}
var documentXmlReader = {};
var hasRequiredDocumentXmlReader;
function requireDocumentXmlReader() {
  if (hasRequiredDocumentXmlReader) return documentXmlReader;
  hasRequiredDocumentXmlReader = 1;
  documentXmlReader.DocumentXmlReader = DocumentXmlReader;
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  function DocumentXmlReader(options2) {
    var bodyReader2 = options2.bodyReader;
    function convertXmlToDocument(element) {
      var body = element.first("w:body");
      if (body == null) {
        throw new Error("Could not find the body element: are you sure this is a docx file?");
      }
      var result2 = bodyReader2.readXmlElements(body.children).map(function(children) {
        return new documents2.Document(children, {
          notes: options2.notes,
          comments: options2.comments
        });
      });
      return new Result(result2.value, result2.messages);
    }
    return {
      convertXmlToDocument
    };
  }
  return documentXmlReader;
}
var relationshipsReader = {};
var hasRequiredRelationshipsReader;
function requireRelationshipsReader() {
  if (hasRequiredRelationshipsReader) return relationshipsReader;
  hasRequiredRelationshipsReader = 1;
  relationshipsReader.readRelationships = readRelationships;
  relationshipsReader.defaultValue = new Relationships([]);
  relationshipsReader.Relationships = Relationships;
  function readRelationships(element) {
    var relationships = [];
    element.children.forEach(function(child) {
      if (child.name === "relationships:Relationship") {
        var relationship = {
          relationshipId: child.attributes.Id,
          target: child.attributes.Target,
          type: child.attributes.Type
        };
        relationships.push(relationship);
      }
    });
    return new Relationships(relationships);
  }
  function Relationships(relationships) {
    var targetsByRelationshipId = {};
    relationships.forEach(function(relationship) {
      targetsByRelationshipId[relationship.relationshipId] = relationship.target;
    });
    var targetsByType = {};
    relationships.forEach(function(relationship) {
      if (!targetsByType[relationship.type]) {
        targetsByType[relationship.type] = [];
      }
      targetsByType[relationship.type].push(relationship.target);
    });
    return {
      findTargetByRelationshipId: function(relationshipId) {
        return targetsByRelationshipId[relationshipId];
      },
      findTargetsByType: function(type) {
        return targetsByType[type] || [];
      }
    };
  }
  return relationshipsReader;
}
var contentTypesReader = {};
var hasRequiredContentTypesReader;
function requireContentTypesReader() {
  if (hasRequiredContentTypesReader) return contentTypesReader;
  hasRequiredContentTypesReader = 1;
  contentTypesReader.readContentTypesFromXml = readContentTypesFromXml;
  var fallbackContentTypes = {
    "png": "png",
    "gif": "gif",
    "jpeg": "jpeg",
    "jpg": "jpeg",
    "tif": "tiff",
    "tiff": "tiff",
    "bmp": "bmp"
  };
  contentTypesReader.defaultContentTypes = contentTypes({}, {});
  function readContentTypesFromXml(element) {
    var extensionDefaults = {};
    var overrides = {};
    element.children.forEach(function(child) {
      if (child.name === "content-types:Default") {
        extensionDefaults[child.attributes.Extension] = child.attributes.ContentType;
      }
      if (child.name === "content-types:Override") {
        var name = child.attributes.PartName;
        if (name.charAt(0) === "/") {
          name = name.substring(1);
        }
        overrides[name] = child.attributes.ContentType;
      }
    });
    return contentTypes(overrides, extensionDefaults);
  }
  function contentTypes(overrides, extensionDefaults) {
    return {
      findContentType: function(path) {
        var overrideContentType = overrides[path];
        if (overrideContentType) {
          return overrideContentType;
        } else {
          var pathParts = path.split(".");
          var extension = pathParts[pathParts.length - 1];
          if (extensionDefaults.hasOwnProperty(extension)) {
            return extensionDefaults[extension];
          } else {
            var fallback = fallbackContentTypes[extension.toLowerCase()];
            if (fallback) {
              return "image/" + fallback;
            } else {
              return null;
            }
          }
        }
      }
    };
  }
  return contentTypesReader;
}
var numberingXml = {};
var hasRequiredNumberingXml;
function requireNumberingXml() {
  if (hasRequiredNumberingXml) return numberingXml;
  hasRequiredNumberingXml = 1;
  var _2 = require$$0;
  numberingXml.readNumberingXml = readNumberingXml;
  numberingXml.Numbering = Numbering;
  numberingXml.defaultNumbering = new Numbering({}, {});
  function Numbering(nums, abstractNums, styles) {
    var allLevels = _2.flatten(_2.values(abstractNums).map(function(abstractNum) {
      return _2.values(abstractNum.levels);
    }));
    var levelsByParagraphStyleId = _2.indexBy(
      allLevels.filter(function(level) {
        return level.paragraphStyleId != null;
      }),
      "paragraphStyleId"
    );
    function findLevel(numId, level) {
      var num = nums[numId];
      if (num) {
        var abstractNum = abstractNums[num.abstractNumId];
        if (!abstractNum) {
          return null;
        } else if (abstractNum.numStyleLink == null) {
          return abstractNums[num.abstractNumId].levels[level];
        } else {
          var style2 = styles.findNumberingStyleById(abstractNum.numStyleLink);
          return findLevel(style2.numId, level);
        }
      } else {
        return null;
      }
    }
    function findLevelByParagraphStyleId(styleId) {
      return levelsByParagraphStyleId[styleId] || null;
    }
    return {
      findLevel,
      findLevelByParagraphStyleId
    };
  }
  function readNumberingXml(root2, options2) {
    if (!options2 || !options2.styles) {
      throw new Error("styles is missing");
    }
    var abstractNums = readAbstractNums(root2);
    var nums = readNums(root2);
    return new Numbering(nums, abstractNums, options2.styles);
  }
  function readAbstractNums(root2) {
    var abstractNums = {};
    root2.getElementsByTagName("w:abstractNum").forEach(function(element) {
      var id = element.attributes["w:abstractNumId"];
      abstractNums[id] = readAbstractNum(element);
    });
    return abstractNums;
  }
  function readAbstractNum(element) {
    var levels = {};
    element.getElementsByTagName("w:lvl").forEach(function(levelElement) {
      var levelIndex = levelElement.attributes["w:ilvl"];
      var numFmt = levelElement.firstOrEmpty("w:numFmt").attributes["w:val"];
      var paragraphStyleId = levelElement.firstOrEmpty("w:pStyle").attributes["w:val"];
      levels[levelIndex] = {
        isOrdered: numFmt !== "bullet",
        level: levelIndex,
        paragraphStyleId
      };
    });
    var numStyleLink = element.firstOrEmpty("w:numStyleLink").attributes["w:val"];
    return { levels, numStyleLink };
  }
  function readNums(root2) {
    var nums = {};
    root2.getElementsByTagName("w:num").forEach(function(element) {
      var numId = element.attributes["w:numId"];
      var abstractNumId = element.first("w:abstractNumId").attributes["w:val"];
      nums[numId] = { abstractNumId };
    });
    return nums;
  }
  return numberingXml;
}
var stylesReader = {};
var hasRequiredStylesReader;
function requireStylesReader() {
  if (hasRequiredStylesReader) return stylesReader;
  hasRequiredStylesReader = 1;
  stylesReader.readStylesXml = readStylesXml;
  stylesReader.Styles = Styles;
  stylesReader.defaultStyles = new Styles({}, {});
  function Styles(paragraphStyles, characterStyles, tableStyles, numberingStyles) {
    return {
      findParagraphStyleById: function(styleId) {
        return paragraphStyles[styleId];
      },
      findCharacterStyleById: function(styleId) {
        return characterStyles[styleId];
      },
      findTableStyleById: function(styleId) {
        return tableStyles[styleId];
      },
      findNumberingStyleById: function(styleId) {
        return numberingStyles[styleId];
      }
    };
  }
  Styles.EMPTY = new Styles({}, {}, {}, {});
  function readStylesXml(root2) {
    var paragraphStyles = {};
    var characterStyles = {};
    var tableStyles = {};
    var numberingStyles = {};
    var styles = {
      "paragraph": paragraphStyles,
      "character": characterStyles,
      "table": tableStyles
    };
    root2.getElementsByTagName("w:style").forEach(function(styleElement) {
      var style2 = readStyleElement(styleElement);
      if (style2.type === "numbering") {
        numberingStyles[style2.styleId] = readNumberingStyleElement(styleElement);
      } else {
        var styleSet = styles[style2.type];
        if (styleSet) {
          styleSet[style2.styleId] = style2;
        }
      }
    });
    return new Styles(paragraphStyles, characterStyles, tableStyles, numberingStyles);
  }
  function readStyleElement(styleElement) {
    var type = styleElement.attributes["w:type"];
    var styleId = styleElement.attributes["w:styleId"];
    var name = styleName(styleElement);
    return { type, styleId, name };
  }
  function styleName(styleElement) {
    var nameElement = styleElement.first("w:name");
    return nameElement ? nameElement.attributes["w:val"] : null;
  }
  function readNumberingStyleElement(styleElement) {
    var numId = styleElement.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
    return { numId };
  }
  return stylesReader;
}
var notesReader = {};
var hasRequiredNotesReader;
function requireNotesReader() {
  if (hasRequiredNotesReader) return notesReader;
  hasRequiredNotesReader = 1;
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  notesReader.createFootnotesReader = createReader.bind(notesReader, "footnote");
  notesReader.createEndnotesReader = createReader.bind(notesReader, "endnote");
  function createReader(noteType, bodyReader2) {
    function readNotesXml(element) {
      return Result.combine(element.getElementsByTagName("w:" + noteType).filter(isFootnoteElement).map(readFootnoteElement));
    }
    function isFootnoteElement(element) {
      var type = element.attributes["w:type"];
      return type !== "continuationSeparator" && type !== "separator";
    }
    function readFootnoteElement(footnoteElement) {
      var id = footnoteElement.attributes["w:id"];
      return bodyReader2.readXmlElements(footnoteElement.children).map(function(body) {
        return documents2.Note({ noteType, noteId: id, body });
      });
    }
    return readNotesXml;
  }
  return notesReader;
}
var commentsReader = {};
var hasRequiredCommentsReader;
function requireCommentsReader() {
  if (hasRequiredCommentsReader) return commentsReader;
  hasRequiredCommentsReader = 1;
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  function createCommentsReader(bodyReader2) {
    function readCommentsXml(element) {
      return Result.combine(element.getElementsByTagName("w:comment").map(readCommentElement));
    }
    function readCommentElement(element) {
      var id = element.attributes["w:id"];
      function readOptionalAttribute(name) {
        return (element.attributes[name] || "").trim() || null;
      }
      return bodyReader2.readXmlElements(element.children).map(function(body) {
        return documents2.comment({
          commentId: id,
          body,
          authorName: readOptionalAttribute("w:author"),
          authorInitials: readOptionalAttribute("w:initials")
        });
      });
    }
    return readCommentsXml;
  }
  commentsReader.createCommentsReader = createCommentsReader;
  return commentsReader;
}
var files = {};
var hasRequiredFiles;
function requireFiles() {
  if (hasRequiredFiles) return files;
  hasRequiredFiles = 1;
  var promises2 = requirePromises();
  files.Files = Files;
  function Files() {
    function read(uri) {
      return promises2.reject(new Error("could not open external image: '" + uri + "'\ncannot open linked files from a web browser"));
    }
    return {
      read
    };
  }
  return files;
}
var hasRequiredDocxReader;
function requireDocxReader() {
  if (hasRequiredDocxReader) return docxReader;
  hasRequiredDocxReader = 1;
  docxReader.read = read;
  docxReader._findPartPaths = findPartPaths;
  var promises2 = requirePromises();
  var documents2 = requireDocuments();
  var Result = requireResults().Result;
  var zipfile2 = requireZipfile();
  var readXmlFromZipFile = requireOfficeXmlReader().readXmlFromZipFile;
  var createBodyReader = requireBodyReader().createBodyReader;
  var DocumentXmlReader = requireDocumentXmlReader().DocumentXmlReader;
  var relationshipsReader2 = requireRelationshipsReader();
  var contentTypesReader2 = requireContentTypesReader();
  var numberingXml2 = requireNumberingXml();
  var stylesReader2 = requireStylesReader();
  var notesReader2 = requireNotesReader();
  var commentsReader2 = requireCommentsReader();
  var Files = requireFiles().Files;
  function read(docxFile, input) {
    input = input || {};
    return promises2.props({
      contentTypes: readContentTypesFromZipFile(docxFile),
      partPaths: findPartPaths(docxFile),
      docxFile,
      files: input.path ? Files.relativeToFile(input.path) : new Files(null)
    }).also(function(result2) {
      return {
        styles: readStylesFromZipFile(docxFile, result2.partPaths.styles)
      };
    }).also(function(result2) {
      return {
        numbering: readNumberingFromZipFile(docxFile, result2.partPaths.numbering, result2.styles)
      };
    }).also(function(result2) {
      return {
        footnotes: readXmlFileWithBody(result2.partPaths.footnotes, result2, function(bodyReader2, xml2) {
          if (xml2) {
            return notesReader2.createFootnotesReader(bodyReader2)(xml2);
          } else {
            return new Result([]);
          }
        }),
        endnotes: readXmlFileWithBody(result2.partPaths.endnotes, result2, function(bodyReader2, xml2) {
          if (xml2) {
            return notesReader2.createEndnotesReader(bodyReader2)(xml2);
          } else {
            return new Result([]);
          }
        }),
        comments: readXmlFileWithBody(result2.partPaths.comments, result2, function(bodyReader2, xml2) {
          if (xml2) {
            return commentsReader2.createCommentsReader(bodyReader2)(xml2);
          } else {
            return new Result([]);
          }
        })
      };
    }).also(function(result2) {
      return {
        notes: result2.footnotes.flatMap(function(footnotes) {
          return result2.endnotes.map(function(endnotes) {
            return new documents2.Notes(footnotes.concat(endnotes));
          });
        })
      };
    }).then(function(result2) {
      return readXmlFileWithBody(result2.partPaths.mainDocument, result2, function(bodyReader2, xml2) {
        return result2.notes.flatMap(function(notes) {
          return result2.comments.flatMap(function(comments) {
            var reader2 = new DocumentXmlReader({
              bodyReader: bodyReader2,
              notes,
              comments
            });
            return reader2.convertXmlToDocument(xml2);
          });
        });
      });
    });
  }
  function findPartPaths(docxFile) {
    return readPackageRelationships(docxFile).then(function(packageRelationships) {
      var mainDocumentPath = findPartPath({
        docxFile,
        relationships: packageRelationships,
        relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
        basePath: "",
        fallbackPath: "word/document.xml"
      });
      if (!docxFile.exists(mainDocumentPath)) {
        throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
      }
      return xmlFileReader({
        filename: relationshipsFilename(mainDocumentPath),
        readElement: relationshipsReader2.readRelationships,
        defaultValue: relationshipsReader2.defaultValue
      })(docxFile).then(function(documentRelationships) {
        function findPartRelatedToMainDocument(name) {
          return findPartPath({
            docxFile,
            relationships: documentRelationships,
            relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + name,
            basePath: zipfile2.splitPath(mainDocumentPath).dirname,
            fallbackPath: "word/" + name + ".xml"
          });
        }
        return {
          mainDocument: mainDocumentPath,
          comments: findPartRelatedToMainDocument("comments"),
          endnotes: findPartRelatedToMainDocument("endnotes"),
          footnotes: findPartRelatedToMainDocument("footnotes"),
          numbering: findPartRelatedToMainDocument("numbering"),
          styles: findPartRelatedToMainDocument("styles")
        };
      });
    });
  }
  function findPartPath(options2) {
    var docxFile = options2.docxFile;
    var relationships = options2.relationships;
    var relationshipType = options2.relationshipType;
    var basePath = options2.basePath;
    var fallbackPath = options2.fallbackPath;
    var targets = relationships.findTargetsByType(relationshipType);
    var normalisedTargets = targets.map(function(target) {
      return stripPrefix(zipfile2.joinPath(basePath, target), "/");
    });
    var validTargets = normalisedTargets.filter(function(target) {
      return docxFile.exists(target);
    });
    if (validTargets.length === 0) {
      return fallbackPath;
    } else {
      return validTargets[0];
    }
  }
  function stripPrefix(value, prefix) {
    if (value.substring(0, prefix.length) === prefix) {
      return value.substring(prefix.length);
    } else {
      return value;
    }
  }
  function xmlFileReader(options2) {
    return function(zipFile) {
      return readXmlFromZipFile(zipFile, options2.filename).then(function(element) {
        return element ? options2.readElement(element) : options2.defaultValue;
      });
    };
  }
  function readXmlFileWithBody(filename, options2, func) {
    var readRelationshipsFromZipFile = xmlFileReader({
      filename: relationshipsFilename(filename),
      readElement: relationshipsReader2.readRelationships,
      defaultValue: relationshipsReader2.defaultValue
    });
    return readRelationshipsFromZipFile(options2.docxFile).then(function(relationships) {
      var bodyReader2 = new createBodyReader({
        relationships,
        contentTypes: options2.contentTypes,
        docxFile: options2.docxFile,
        numbering: options2.numbering,
        styles: options2.styles,
        files: options2.files
      });
      return readXmlFromZipFile(options2.docxFile, filename).then(function(xml2) {
        return func(bodyReader2, xml2);
      });
    });
  }
  function relationshipsFilename(filename) {
    var split2 = zipfile2.splitPath(filename);
    return zipfile2.joinPath(split2.dirname, "_rels", split2.basename + ".rels");
  }
  var readContentTypesFromZipFile = xmlFileReader({
    filename: "[Content_Types].xml",
    readElement: contentTypesReader2.readContentTypesFromXml,
    defaultValue: contentTypesReader2.defaultContentTypes
  });
  function readNumberingFromZipFile(zipFile, path, styles) {
    return xmlFileReader({
      filename: path,
      readElement: function(element) {
        return numberingXml2.readNumberingXml(element, { styles });
      },
      defaultValue: numberingXml2.defaultNumbering
    })(zipFile);
  }
  function readStylesFromZipFile(zipFile, path) {
    return xmlFileReader({
      filename: path,
      readElement: stylesReader2.readStylesXml,
      defaultValue: stylesReader2.defaultStyles
    })(zipFile);
  }
  var readPackageRelationships = xmlFileReader({
    filename: "_rels/.rels",
    readElement: relationshipsReader2.readRelationships,
    defaultValue: relationshipsReader2.defaultValue
  });
  return docxReader;
}
var styleMap = {};
var hasRequiredStyleMap;
function requireStyleMap() {
  if (hasRequiredStyleMap) return styleMap;
  hasRequiredStyleMap = 1;
  var _2 = require$$0;
  var promises2 = requirePromises();
  var xml2 = requireXml();
  styleMap.writeStyleMap = writeStyleMap;
  styleMap.readStyleMap = readStyleMap;
  var schema = "http://schemas.zwobble.org/mammoth/style-map";
  var styleMapPath = "mammoth/style-map";
  var styleMapAbsolutePath = "/" + styleMapPath;
  function writeStyleMap(docxFile, styleMap2) {
    docxFile.write(styleMapPath, styleMap2);
    return updateRelationships(docxFile).then(function() {
      return updateContentTypes(docxFile);
    });
  }
  function updateRelationships(docxFile) {
    var path = "word/_rels/document.xml.rels";
    var relationshipsUri = "http://schemas.openxmlformats.org/package/2006/relationships";
    var relationshipElementName = "{" + relationshipsUri + "}Relationship";
    return docxFile.read(path, "utf8").then(xml2.readString).then(function(relationshipsContainer) {
      var relationships = relationshipsContainer.children;
      addOrUpdateElement(relationships, relationshipElementName, "Id", {
        "Id": "rMammothStyleMap",
        "Type": schema,
        "Target": styleMapAbsolutePath
      });
      var namespaces = { "": relationshipsUri };
      return docxFile.write(path, xml2.writeString(relationshipsContainer, namespaces));
    });
  }
  function updateContentTypes(docxFile) {
    var path = "[Content_Types].xml";
    var contentTypesUri = "http://schemas.openxmlformats.org/package/2006/content-types";
    var overrideName = "{" + contentTypesUri + "}Override";
    return docxFile.read(path, "utf8").then(xml2.readString).then(function(typesElement) {
      var children = typesElement.children;
      addOrUpdateElement(children, overrideName, "PartName", {
        "PartName": styleMapAbsolutePath,
        "ContentType": "text/prs.mammoth.style-map"
      });
      var namespaces = { "": contentTypesUri };
      return docxFile.write(path, xml2.writeString(typesElement, namespaces));
    });
  }
  function addOrUpdateElement(elements, name, identifyingAttribute, attributes) {
    var existingElement = _2.find(elements, function(element) {
      return element.name === name && element.attributes[identifyingAttribute] === attributes[identifyingAttribute];
    });
    if (existingElement) {
      existingElement.attributes = attributes;
    } else {
      elements.push(xml2.element(name, attributes));
    }
  }
  function readStyleMap(docxFile) {
    if (docxFile.exists(styleMapPath)) {
      return docxFile.read(styleMapPath, "utf8");
    } else {
      return promises2.resolve(null);
    }
  }
  return styleMap;
}
var documentToHtml = {};
var htmlPaths = {};
var html = {};
var ast = {};
var hasRequiredAst;
function requireAst() {
  if (hasRequiredAst) return ast;
  hasRequiredAst = 1;
  var htmlPaths2 = requireHtmlPaths();
  function nonFreshElement(tagName, attributes, children) {
    return elementWithTag(
      htmlPaths2.element(tagName, attributes, { fresh: false }),
      children
    );
  }
  function freshElement(tagName, attributes, children) {
    var tag = htmlPaths2.element(tagName, attributes, { fresh: true });
    return elementWithTag(tag, children);
  }
  function elementWithTag(tag, children) {
    return {
      type: "element",
      tag,
      children: children || []
    };
  }
  function text(value) {
    return {
      type: "text",
      value
    };
  }
  var forceWrite = {
    type: "forceWrite"
  };
  ast.freshElement = freshElement;
  ast.nonFreshElement = nonFreshElement;
  ast.elementWithTag = elementWithTag;
  ast.text = text;
  ast.forceWrite = forceWrite;
  var voidTagNames = {
    "br": true,
    "hr": true,
    "img": true,
    "input": true
  };
  function isVoidElement(node) {
    return node.children.length === 0 && voidTagNames[node.tag.tagName];
  }
  ast.isVoidElement = isVoidElement;
  return ast;
}
var simplify_1;
var hasRequiredSimplify;
function requireSimplify() {
  if (hasRequiredSimplify) return simplify_1;
  hasRequiredSimplify = 1;
  var _2 = require$$0;
  var ast2 = requireAst();
  function simplify(nodes2) {
    return collapse(removeEmpty(nodes2));
  }
  function collapse(nodes2) {
    var children = [];
    nodes2.map(collapseNode).forEach(function(child) {
      appendChild(children, child);
    });
    return children;
  }
  function collapseNode(node) {
    return collapsers[node.type](node);
  }
  var collapsers = {
    element: collapseElement,
    text: identity2,
    forceWrite: identity2
  };
  function collapseElement(node) {
    return ast2.elementWithTag(node.tag, collapse(node.children));
  }
  function identity2(value) {
    return value;
  }
  function appendChild(children, child) {
    var lastChild = children[children.length - 1];
    if (child.type === "element" && !child.tag.fresh && lastChild && lastChild.type === "element" && child.tag.matchesElement(lastChild.tag)) {
      if (child.tag.separator) {
        appendChild(lastChild.children, ast2.text(child.tag.separator));
      }
      child.children.forEach(function(grandChild) {
        appendChild(lastChild.children, grandChild);
      });
    } else {
      children.push(child);
    }
  }
  function removeEmpty(nodes2) {
    return flatMap(nodes2, function(node) {
      return emptiers[node.type](node);
    });
  }
  function flatMap(values2, func) {
    return _2.flatten(_2.map(values2, func), true);
  }
  var emptiers = {
    element: elementEmptier,
    text: textEmptier,
    forceWrite: neverEmpty
  };
  function neverEmpty(node) {
    return [node];
  }
  function elementEmptier(element) {
    var children = removeEmpty(element.children);
    if (children.length === 0 && !ast2.isVoidElement(element)) {
      return [];
    } else {
      return [ast2.elementWithTag(element.tag, children)];
    }
  }
  function textEmptier(node) {
    if (node.value.length === 0) {
      return [];
    } else {
      return [node];
    }
  }
  simplify_1 = simplify;
  return simplify_1;
}
var hasRequiredHtml;
function requireHtml() {
  if (hasRequiredHtml) return html;
  hasRequiredHtml = 1;
  var ast2 = requireAst();
  html.freshElement = ast2.freshElement;
  html.nonFreshElement = ast2.nonFreshElement;
  html.elementWithTag = ast2.elementWithTag;
  html.text = ast2.text;
  html.forceWrite = ast2.forceWrite;
  html.simplify = requireSimplify();
  function write(writer2, nodes2) {
    nodes2.forEach(function(node) {
      writeNode(writer2, node);
    });
  }
  function writeNode(writer2, node) {
    toStrings[node.type](writer2, node);
  }
  var toStrings = {
    element: generateElementString,
    text: generateTextString,
    forceWrite: function() {
    }
  };
  function generateElementString(writer2, node) {
    if (ast2.isVoidElement(node)) {
      writer2.selfClosing(node.tag.tagName, node.tag.attributes);
    } else {
      writer2.open(node.tag.tagName, node.tag.attributes);
      write(writer2, node.children);
      writer2.close(node.tag.tagName);
    }
  }
  function generateTextString(writer2, node) {
    writer2.text(node.value);
  }
  html.write = write;
  return html;
}
var hasRequiredHtmlPaths;
function requireHtmlPaths() {
  if (hasRequiredHtmlPaths) return htmlPaths;
  hasRequiredHtmlPaths = 1;
  var _2 = require$$0;
  var html2 = requireHtml();
  htmlPaths.topLevelElement = topLevelElement;
  htmlPaths.elements = elements;
  htmlPaths.element = element;
  function topLevelElement(tagName, attributes) {
    return elements([element(tagName, attributes, { fresh: true })]);
  }
  function elements(elementStyles) {
    return new HtmlPath(elementStyles.map(function(elementStyle) {
      if (_2.isString(elementStyle)) {
        return element(elementStyle);
      } else {
        return elementStyle;
      }
    }));
  }
  function HtmlPath(elements2) {
    this._elements = elements2;
  }
  HtmlPath.prototype.wrap = function wrap2(children) {
    var result2 = children();
    for (var index = this._elements.length - 1; index >= 0; index--) {
      result2 = this._elements[index].wrapNodes(result2);
    }
    return result2;
  };
  function element(tagName, attributes, options2) {
    options2 = options2 || {};
    return new Element(tagName, attributes, options2);
  }
  function Element(tagName, attributes, options2) {
    var tagNames = {};
    if (_2.isArray(tagName)) {
      tagName.forEach(function(tagName2) {
        tagNames[tagName2] = true;
      });
      tagName = tagName[0];
    } else {
      tagNames[tagName] = true;
    }
    this.tagName = tagName;
    this.tagNames = tagNames;
    this.attributes = attributes || {};
    this.fresh = options2.fresh;
    this.separator = options2.separator;
  }
  Element.prototype.matchesElement = function(element2) {
    return this.tagNames[element2.tagName] && _2.isEqual(this.attributes || {}, element2.attributes || {});
  };
  Element.prototype.wrap = function wrap2(generateNodes) {
    return this.wrapNodes(generateNodes());
  };
  Element.prototype.wrapNodes = function wrapNodes(nodes2) {
    return [html2.elementWithTag(this, nodes2)];
  };
  htmlPaths.empty = elements([]);
  htmlPaths.ignore = {
    wrap: function() {
      return [];
    }
  };
  return htmlPaths;
}
var images = {};
var hasRequiredImages;
function requireImages() {
  if (hasRequiredImages) return images;
  hasRequiredImages = 1;
  (function(exports) {
    var _2 = require$$0;
    var promises2 = requirePromises();
    var Html = requireHtml();
    exports.imgElement = imgElement;
    function imgElement(func) {
      return function(element, messages) {
        return promises2.when(func(element)).then(function(result2) {
          var attributes = {};
          if (element.altText) {
            attributes.alt = element.altText;
          }
          _2.extend(attributes, result2);
          return [Html.freshElement("img", attributes)];
        });
      };
    }
    exports.inline = exports.imgElement;
    exports.dataUri = imgElement(function(element) {
      return element.readAsBase64String().then(function(imageBuffer) {
        return {
          src: "data:" + element.contentType + ";base64," + imageBuffer
        };
      });
    });
  })(images);
  return images;
}
var writers = {};
var htmlWriter = {};
var hasRequiredHtmlWriter;
function requireHtmlWriter() {
  if (hasRequiredHtmlWriter) return htmlWriter;
  hasRequiredHtmlWriter = 1;
  var _2 = require$$0;
  htmlWriter.writer = writer2;
  function writer2(options2) {
    options2 = options2 || {};
    if (options2.prettyPrint) {
      return prettyWriter();
    } else {
      return simpleWriter();
    }
  }
  var indentedElements = {
    div: true,
    p: true,
    ul: true,
    li: true
  };
  function prettyWriter() {
    var indentationLevel = 0;
    var indentation = "  ";
    var stack = [];
    var start = true;
    var inText = false;
    var writer3 = simpleWriter();
    function open(tagName, attributes) {
      if (indentedElements[tagName]) {
        indent();
      }
      stack.push(tagName);
      writer3.open(tagName, attributes);
      if (indentedElements[tagName]) {
        indentationLevel++;
      }
      start = false;
    }
    function close2(tagName) {
      if (indentedElements[tagName]) {
        indentationLevel--;
        indent();
      }
      stack.pop();
      writer3.close(tagName);
    }
    function text(value) {
      startText();
      var text2 = isInPre() ? value : value.replace("\n", "\n" + indentation);
      writer3.text(text2);
    }
    function selfClosing(tagName, attributes) {
      indent();
      writer3.selfClosing(tagName, attributes);
    }
    function insideIndentedElement() {
      return stack.length === 0 || indentedElements[stack[stack.length - 1]];
    }
    function startText() {
      if (!inText) {
        indent();
        inText = true;
      }
    }
    function indent() {
      inText = false;
      if (!start && insideIndentedElement() && !isInPre()) {
        writer3._append("\n");
        for (var i = 0; i < indentationLevel; i++) {
          writer3._append(indentation);
        }
      }
    }
    function isInPre() {
      return _2.some(stack, function(tagName) {
        return tagName === "pre";
      });
    }
    return {
      asString: writer3.asString,
      open,
      close: close2,
      text,
      selfClosing
    };
  }
  function simpleWriter() {
    var fragments = [];
    function open(tagName, attributes) {
      var attributeString = generateAttributeString(attributes);
      fragments.push("<" + tagName + attributeString + ">");
    }
    function close2(tagName) {
      fragments.push("</" + tagName + ">");
    }
    function selfClosing(tagName, attributes) {
      var attributeString = generateAttributeString(attributes);
      fragments.push("<" + tagName + attributeString + " />");
    }
    function generateAttributeString(attributes) {
      return _2.map(attributes, function(value, key) {
        return " " + key + '="' + escapeHtmlAttribute(value) + '"';
      }).join("");
    }
    function text(value) {
      fragments.push(escapeHtmlText(value));
    }
    function append2(html2) {
      fragments.push(html2);
    }
    function asString() {
      return fragments.join("");
    }
    return {
      asString,
      open,
      close: close2,
      text,
      selfClosing,
      _append: append2
    };
  }
  function escapeHtmlText(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function escapeHtmlAttribute(value) {
    return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  return htmlWriter;
}
var markdownWriter = {};
var hasRequiredMarkdownWriter;
function requireMarkdownWriter() {
  if (hasRequiredMarkdownWriter) return markdownWriter;
  hasRequiredMarkdownWriter = 1;
  var _2 = require$$0;
  function symmetricMarkdownElement(end) {
    return markdownElement(end, end);
  }
  function markdownElement(start, end) {
    return function() {
      return { start, end };
    };
  }
  function markdownLink(attributes) {
    var href = attributes.href || "";
    if (href) {
      return {
        start: "[",
        end: "](" + href + ")",
        anchorPosition: "before"
      };
    } else {
      return {};
    }
  }
  function markdownImage(attributes) {
    var src = attributes.src || "";
    var altText = attributes.alt || "";
    if (src || altText) {
      return { start: "![" + altText + "](" + src + ")" };
    } else {
      return {};
    }
  }
  function markdownList(options2) {
    return function(attributes, list) {
      return {
        start: list ? "\n" : "",
        end: list ? "" : "\n",
        list: {
          isOrdered: options2.isOrdered,
          indent: list ? list.indent + 1 : 0,
          count: 0
        }
      };
    };
  }
  function markdownListItem(attributes, list, listItem) {
    list = list || { indent: 0, isOrdered: false, count: 0 };
    list.count++;
    listItem.hasClosed = false;
    var bullet = list.isOrdered ? list.count + "." : "-";
    var start = repeatString("	", list.indent) + bullet + " ";
    return {
      start,
      end: function() {
        if (!listItem.hasClosed) {
          listItem.hasClosed = true;
          return "\n";
        }
      }
    };
  }
  var htmlToMarkdown = {
    "p": markdownElement("", "\n\n"),
    "br": markdownElement("", "  \n"),
    "ul": markdownList({ isOrdered: false }),
    "ol": markdownList({ isOrdered: true }),
    "li": markdownListItem,
    "strong": symmetricMarkdownElement("__"),
    "em": symmetricMarkdownElement("*"),
    "a": markdownLink,
    "img": markdownImage
  };
  (function() {
    for (var i = 1; i <= 6; i++) {
      htmlToMarkdown["h" + i] = markdownElement(repeatString("#", i) + " ", "\n\n");
    }
  })();
  function repeatString(value, count) {
    return new Array(count + 1).join(value);
  }
  function markdownWriter$1() {
    var fragments = [];
    var elementStack = [];
    var list = null;
    var listItem = {};
    function open(tagName, attributes) {
      attributes = attributes || {};
      var createElement = htmlToMarkdown[tagName] || function() {
        return {};
      };
      var element = createElement(attributes, list, listItem);
      elementStack.push({ end: element.end, list });
      if (element.list) {
        list = element.list;
      }
      var anchorBeforeStart = element.anchorPosition === "before";
      if (anchorBeforeStart) {
        writeAnchor(attributes);
      }
      fragments.push(element.start || "");
      if (!anchorBeforeStart) {
        writeAnchor(attributes);
      }
    }
    function writeAnchor(attributes) {
      if (attributes.id) {
        fragments.push('<a id="' + attributes.id + '"></a>');
      }
    }
    function close2(tagName) {
      var element = elementStack.pop();
      list = element.list;
      var end = _2.isFunction(element.end) ? element.end() : element.end;
      fragments.push(end || "");
    }
    function selfClosing(tagName, attributes) {
      open(tagName, attributes);
      close2();
    }
    function text(value) {
      fragments.push(escapeMarkdown(value));
    }
    function asString() {
      return fragments.join("");
    }
    return {
      asString,
      open,
      close: close2,
      text,
      selfClosing
    };
  }
  markdownWriter.writer = markdownWriter$1;
  function escapeMarkdown(value) {
    return value.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
  }
  return markdownWriter;
}
var hasRequiredWriters;
function requireWriters() {
  if (hasRequiredWriters) return writers;
  hasRequiredWriters = 1;
  var htmlWriter2 = requireHtmlWriter();
  var markdownWriter2 = requireMarkdownWriter();
  writers.writer = writer2;
  function writer2(options2) {
    options2 = options2 || {};
    if (options2.outputFormat === "markdown") {
      return markdownWriter2.writer();
    } else {
      return htmlWriter2.writer(options2);
    }
  }
  return writers;
}
var hasRequiredDocumentToHtml;
function requireDocumentToHtml() {
  if (hasRequiredDocumentToHtml) return documentToHtml;
  hasRequiredDocumentToHtml = 1;
  var _2 = require$$0;
  var promises2 = requirePromises();
  var documents2 = requireDocuments();
  var htmlPaths2 = requireHtmlPaths();
  var results2 = requireResults();
  var images2 = requireImages();
  var Html = requireHtml();
  var writers2 = requireWriters();
  documentToHtml.DocumentConverter = DocumentConverter;
  function DocumentConverter(options2) {
    return {
      convertToHtml: function(element) {
        var comments = _2.indexBy(
          element.type === documents2.types.document ? element.comments : [],
          "commentId"
        );
        var conversion = new DocumentConversion(options2, comments);
        return conversion.convertToHtml(element);
      }
    };
  }
  function DocumentConversion(options2, comments) {
    var noteNumber = 1;
    var noteReferences = [];
    var referencedComments = [];
    options2 = _2.extend({ ignoreEmptyParagraphs: true }, options2);
    var idPrefix = options2.idPrefix === void 0 ? "" : options2.idPrefix;
    var ignoreEmptyParagraphs = options2.ignoreEmptyParagraphs;
    var defaultParagraphStyle = htmlPaths2.topLevelElement("p");
    var styleMap2 = options2.styleMap || [];
    function convertToHtml(document2) {
      var messages = [];
      var html2 = elementToHtml(document2, messages, {});
      var deferredNodes = [];
      walkHtml(html2, function(node) {
        if (node.type === "deferred") {
          deferredNodes.push(node);
        }
      });
      var deferredValues = {};
      return promises2.mapSeries(deferredNodes, function(deferred) {
        return deferred.value().then(function(value) {
          deferredValues[deferred.id] = value;
        });
      }).then(function() {
        function replaceDeferred(nodes2) {
          return flatMap(nodes2, function(node) {
            if (node.type === "deferred") {
              return deferredValues[node.id];
            } else if (node.children) {
              return [
                _2.extend({}, node, {
                  children: replaceDeferred(node.children)
                })
              ];
            } else {
              return [node];
            }
          });
        }
        var writer2 = writers2.writer({
          prettyPrint: options2.prettyPrint,
          outputFormat: options2.outputFormat
        });
        Html.write(writer2, Html.simplify(replaceDeferred(html2)));
        return new results2.Result(writer2.asString(), messages);
      });
    }
    function convertElements(elements, messages, options3) {
      return flatMap(elements, function(element) {
        return elementToHtml(element, messages, options3);
      });
    }
    function elementToHtml(element, messages, options3) {
      if (!options3) {
        throw new Error("options not set");
      }
      var handler = elementConverters[element.type];
      if (handler) {
        return handler(element, messages, options3);
      } else {
        return [];
      }
    }
    function convertParagraph(element, messages, options3) {
      return htmlPathForParagraph(element, messages).wrap(function() {
        var content = convertElements(element.children, messages, options3);
        if (ignoreEmptyParagraphs) {
          return content;
        } else {
          return [Html.forceWrite].concat(content);
        }
      });
    }
    function htmlPathForParagraph(element, messages) {
      var style2 = findStyle(element);
      if (style2) {
        return style2.to;
      } else {
        if (element.styleId) {
          messages.push(unrecognisedStyleWarning("paragraph", element));
        }
        return defaultParagraphStyle;
      }
    }
    function convertRun(run3, messages, options3) {
      var nodes2 = function() {
        return convertElements(run3.children, messages, options3);
      };
      var paths = [];
      if (run3.highlight !== null) {
        var path = findHtmlPath({ type: "highlight", color: run3.highlight });
        if (path) {
          paths.push(path);
        }
      }
      if (run3.isSmallCaps) {
        paths.push(findHtmlPathForRunProperty("smallCaps"));
      }
      if (run3.isAllCaps) {
        paths.push(findHtmlPathForRunProperty("allCaps"));
      }
      if (run3.isStrikethrough) {
        paths.push(findHtmlPathForRunProperty("strikethrough", "s"));
      }
      if (run3.isUnderline) {
        paths.push(findHtmlPathForRunProperty("underline"));
      }
      if (run3.verticalAlignment === documents2.verticalAlignment.subscript) {
        paths.push(htmlPaths2.element("sub", {}, { fresh: false }));
      }
      if (run3.verticalAlignment === documents2.verticalAlignment.superscript) {
        paths.push(htmlPaths2.element("sup", {}, { fresh: false }));
      }
      if (run3.isItalic) {
        paths.push(findHtmlPathForRunProperty("italic", "em"));
      }
      if (run3.isBold) {
        paths.push(findHtmlPathForRunProperty("bold", "strong"));
      }
      var stylePath = htmlPaths2.empty;
      var style2 = findStyle(run3);
      if (style2) {
        stylePath = style2.to;
      } else if (run3.styleId) {
        messages.push(unrecognisedStyleWarning("run", run3));
      }
      paths.push(stylePath);
      paths.forEach(function(path2) {
        nodes2 = path2.wrap.bind(path2, nodes2);
      });
      return nodes2();
    }
    function findHtmlPathForRunProperty(elementType, defaultTagName) {
      var path = findHtmlPath({ type: elementType });
      if (path) {
        return path;
      } else if (defaultTagName) {
        return htmlPaths2.element(defaultTagName, {}, { fresh: false });
      } else {
        return htmlPaths2.empty;
      }
    }
    function findHtmlPath(element, defaultPath) {
      var style2 = findStyle(element);
      return style2 ? style2.to : defaultPath;
    }
    function findStyle(element) {
      for (var i = 0; i < styleMap2.length; i++) {
        if (styleMap2[i].from.matches(element)) {
          return styleMap2[i];
        }
      }
    }
    function recoveringConvertImage(convertImage) {
      return function(image, messages) {
        return promises2.attempt(function() {
          return convertImage(image, messages);
        }).caught(function(error) {
          messages.push(results2.error(error));
          return [];
        });
      };
    }
    function noteHtmlId(note) {
      return referentHtmlId(note.noteType, note.noteId);
    }
    function noteRefHtmlId(note) {
      return referenceHtmlId(note.noteType, note.noteId);
    }
    function referentHtmlId(referenceType, referenceId) {
      return htmlId(referenceType + "-" + referenceId);
    }
    function referenceHtmlId(referenceType, referenceId) {
      return htmlId(referenceType + "-ref-" + referenceId);
    }
    function htmlId(suffix) {
      return idPrefix + suffix;
    }
    var defaultTablePath = htmlPaths2.elements([
      htmlPaths2.element("table", {}, { fresh: true })
    ]);
    function convertTable(element, messages, options3) {
      return findHtmlPath(element, defaultTablePath).wrap(function() {
        return convertTableChildren(element, messages, options3);
      });
    }
    function convertTableChildren(element, messages, options3) {
      var bodyIndex = _2.findIndex(element.children, function(child) {
        return !child.type === documents2.types.tableRow || !child.isHeader;
      });
      if (bodyIndex === -1) {
        bodyIndex = element.children.length;
      }
      var children;
      if (bodyIndex === 0) {
        children = convertElements(
          element.children,
          messages,
          _2.extend({}, options3, { isTableHeader: false })
        );
      } else {
        var headRows = convertElements(
          element.children.slice(0, bodyIndex),
          messages,
          _2.extend({}, options3, { isTableHeader: true })
        );
        var bodyRows = convertElements(
          element.children.slice(bodyIndex),
          messages,
          _2.extend({}, options3, { isTableHeader: false })
        );
        children = [
          Html.freshElement("thead", {}, headRows),
          Html.freshElement("tbody", {}, bodyRows)
        ];
      }
      return [Html.forceWrite].concat(children);
    }
    function convertTableRow(element, messages, options3) {
      var children = convertElements(element.children, messages, options3);
      return [
        Html.freshElement("tr", {}, [Html.forceWrite].concat(children))
      ];
    }
    function convertTableCell(element, messages, options3) {
      var tagName = options3.isTableHeader ? "th" : "td";
      var children = convertElements(element.children, messages, options3);
      var attributes = {};
      if (element.colSpan !== 1) {
        attributes.colspan = element.colSpan.toString();
      }
      if (element.rowSpan !== 1) {
        attributes.rowspan = element.rowSpan.toString();
      }
      return [
        Html.freshElement(tagName, attributes, [Html.forceWrite].concat(children))
      ];
    }
    function convertCommentReference(reference, messages, options3) {
      return findHtmlPath(reference, htmlPaths2.ignore).wrap(function() {
        var comment = comments[reference.commentId];
        var count = referencedComments.length + 1;
        var label = "[" + commentAuthorLabel(comment) + count + "]";
        referencedComments.push({ label, comment });
        return [
          Html.freshElement("a", {
            href: "#" + referentHtmlId("comment", reference.commentId),
            id: referenceHtmlId("comment", reference.commentId)
          }, [Html.text(label)])
        ];
      });
    }
    function convertComment(referencedComment, messages, options3) {
      var label = referencedComment.label;
      var comment = referencedComment.comment;
      var body = convertElements(comment.body, messages, options3).concat([
        Html.nonFreshElement("p", {}, [
          Html.text(" "),
          Html.freshElement("a", { "href": "#" + referenceHtmlId("comment", comment.commentId) }, [
            Html.text("â")
          ])
        ])
      ]);
      return [
        Html.freshElement(
          "dt",
          { "id": referentHtmlId("comment", comment.commentId) },
          [Html.text("Comment " + label)]
        ),
        Html.freshElement("dd", {}, body)
      ];
    }
    function convertBreak(element, messages, options3) {
      return htmlPathForBreak(element).wrap(function() {
        return [];
      });
    }
    function htmlPathForBreak(element) {
      var style2 = findStyle(element);
      if (style2) {
        return style2.to;
      } else if (element.breakType === "line") {
        return htmlPaths2.topLevelElement("br");
      } else {
        return htmlPaths2.empty;
      }
    }
    var elementConverters = {
      "document": function(document2, messages, options3) {
        var children = convertElements(document2.children, messages, options3);
        var notes = noteReferences.map(function(noteReference) {
          return document2.notes.resolve(noteReference);
        });
        var notesNodes = convertElements(notes, messages, options3);
        return children.concat([
          Html.freshElement("ol", {}, notesNodes),
          Html.freshElement("dl", {}, flatMap(referencedComments, function(referencedComment) {
            return convertComment(referencedComment, messages, options3);
          }))
        ]);
      },
      "paragraph": convertParagraph,
      "run": convertRun,
      "text": function(element, messages, options3) {
        return [Html.text(element.value)];
      },
      "tab": function(element, messages, options3) {
        return [Html.text("	")];
      },
      "hyperlink": function(element, messages, options3) {
        var href = element.anchor ? "#" + htmlId(element.anchor) : element.href;
        var attributes = { href };
        if (element.targetFrame != null) {
          attributes.target = element.targetFrame;
        }
        var children = convertElements(element.children, messages, options3);
        return [Html.nonFreshElement("a", attributes, children)];
      },
      "checkbox": function(element) {
        var attributes = { type: "checkbox" };
        if (element.checked) {
          attributes["checked"] = "checked";
        }
        return [Html.freshElement("input", attributes)];
      },
      "bookmarkStart": function(element, messages, options3) {
        var anchor = Html.freshElement("a", {
          id: htmlId(element.name)
        }, [Html.forceWrite]);
        return [anchor];
      },
      "noteReference": function(element, messages, options3) {
        noteReferences.push(element);
        var anchor = Html.freshElement("a", {
          href: "#" + noteHtmlId(element),
          id: noteRefHtmlId(element)
        }, [Html.text("[" + noteNumber++ + "]")]);
        return [Html.freshElement("sup", {}, [anchor])];
      },
      "note": function(element, messages, options3) {
        var children = convertElements(element.body, messages, options3);
        var backLink = Html.elementWithTag(htmlPaths2.element("p", {}, { fresh: false }), [
          Html.text(" "),
          Html.freshElement("a", { href: "#" + noteRefHtmlId(element) }, [Html.text("â")])
        ]);
        var body = children.concat([backLink]);
        return Html.freshElement("li", { id: noteHtmlId(element) }, body);
      },
      "commentReference": convertCommentReference,
      "comment": convertComment,
      "image": deferredConversion(recoveringConvertImage(options2.convertImage || images2.dataUri)),
      "table": convertTable,
      "tableRow": convertTableRow,
      "tableCell": convertTableCell,
      "break": convertBreak
    };
    return {
      convertToHtml
    };
  }
  var deferredId = 1;
  function deferredConversion(func) {
    return function(element, messages, options2) {
      return [
        {
          type: "deferred",
          id: deferredId++,
          value: function() {
            return func(element, messages, options2);
          }
        }
      ];
    };
  }
  function unrecognisedStyleWarning(type, element) {
    return results2.warning(
      "Unrecognised " + type + " style: '" + element.styleName + "' (Style ID: " + element.styleId + ")"
    );
  }
  function flatMap(values2, func) {
    return _2.flatten(values2.map(func), true);
  }
  function walkHtml(nodes2, callback) {
    nodes2.forEach(function(node) {
      callback(node);
      if (node.children) {
        walkHtml(node.children, callback);
      }
    });
  }
  var commentAuthorLabel = documentToHtml.commentAuthorLabel = function commentAuthorLabel2(comment) {
    return comment.authorInitials || "";
  };
  return documentToHtml;
}
var rawText = {};
var hasRequiredRawText;
function requireRawText() {
  if (hasRequiredRawText) return rawText;
  hasRequiredRawText = 1;
  var documents2 = requireDocuments();
  function convertElementToRawText(element) {
    if (element.type === "text") {
      return element.value;
    } else if (element.type === documents2.types.tab) {
      return "	";
    } else {
      var tail = element.type === "paragraph" ? "\n\n" : "";
      return (element.children || []).map(convertElementToRawText).join("") + tail;
    }
  }
  rawText.convertElementToRawText = convertElementToRawText;
  return rawText;
}
var styleReader = {};
var lop = {};
var parser = {};
var TokenIterator = { exports: {} };
var hasRequiredTokenIterator;
function requireTokenIterator() {
  if (hasRequiredTokenIterator) return TokenIterator.exports;
  hasRequiredTokenIterator = 1;
  var TokenIterator$1 = TokenIterator.exports = function(tokens2, startIndex) {
    this._tokens = tokens2;
    this._startIndex = startIndex || 0;
  };
  TokenIterator$1.prototype.head = function() {
    return this._tokens[this._startIndex];
  };
  TokenIterator$1.prototype.tail = function(startIndex) {
    return new TokenIterator$1(this._tokens, this._startIndex + 1);
  };
  TokenIterator$1.prototype.toArray = function() {
    return this._tokens.slice(this._startIndex);
  };
  TokenIterator$1.prototype.end = function() {
    return this._tokens[this._tokens.length - 1];
  };
  TokenIterator$1.prototype.to = function(end) {
    var start = this.head().source;
    var endToken = end.head() || end.end();
    return start.to(endToken.source);
  };
  return TokenIterator.exports;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  var TokenIterator2 = requireTokenIterator();
  parser.Parser = function(options2) {
    var parseTokens = function(parser2, tokens2) {
      return parser2(new TokenIterator2(tokens2));
    };
    return {
      parseTokens
    };
  };
  return parser;
}
var rules = {};
var option = {};
var hasRequiredOption;
function requireOption() {
  if (hasRequiredOption) return option;
  hasRequiredOption = 1;
  (function(exports) {
    exports.none = /* @__PURE__ */ Object.create({
      value: function() {
        throw new Error("Called value on none");
      },
      isNone: function() {
        return true;
      },
      isSome: function() {
        return false;
      },
      map: function() {
        return exports.none;
      },
      flatMap: function() {
        return exports.none;
      },
      filter: function() {
        return exports.none;
      },
      toArray: function() {
        return [];
      },
      orElse: callOrReturn2,
      valueOrElse: callOrReturn2
    });
    function callOrReturn2(value) {
      if (typeof value == "function") {
        return value();
      } else {
        return value;
      }
    }
    exports.some = function(value) {
      return new Some(value);
    };
    var Some = function(value) {
      this._value = value;
    };
    Some.prototype.value = function() {
      return this._value;
    };
    Some.prototype.isNone = function() {
      return false;
    };
    Some.prototype.isSome = function() {
      return true;
    };
    Some.prototype.map = function(func) {
      return new Some(func(this._value));
    };
    Some.prototype.flatMap = function(func) {
      return func(this._value);
    };
    Some.prototype.filter = function(predicate) {
      return predicate(this._value) ? this : exports.none;
    };
    Some.prototype.toArray = function() {
      return [this._value];
    };
    Some.prototype.orElse = function(value) {
      return this;
    };
    Some.prototype.valueOrElse = function(value) {
      return this._value;
    };
    exports.isOption = function(value) {
      return value === exports.none || value instanceof Some;
    };
    exports.fromNullable = function(value) {
      if (value == null) {
        return exports.none;
      }
      return new Some(value);
    };
  })(option);
  return option;
}
var parsingResults;
var hasRequiredParsingResults;
function requireParsingResults() {
  if (hasRequiredParsingResults) return parsingResults;
  hasRequiredParsingResults = 1;
  parsingResults = {
    failure: function(errors2, remaining) {
      if (errors2.length < 1) {
        throw new Error("Failure must have errors");
      }
      return new Result({
        status: "failure",
        remaining,
        errors: errors2
      });
    },
    error: function(errors2, remaining) {
      if (errors2.length < 1) {
        throw new Error("Failure must have errors");
      }
      return new Result({
        status: "error",
        remaining,
        errors: errors2
      });
    },
    success: function(value, remaining, source) {
      return new Result({
        status: "success",
        value,
        source,
        remaining,
        errors: []
      });
    },
    cut: function(remaining) {
      return new Result({
        status: "cut",
        remaining,
        errors: []
      });
    }
  };
  var Result = function(options2) {
    this._value = options2.value;
    this._status = options2.status;
    this._hasValue = options2.value !== void 0;
    this._remaining = options2.remaining;
    this._source = options2.source;
    this._errors = options2.errors;
  };
  Result.prototype.map = function(func) {
    if (this._hasValue) {
      return new Result({
        value: func(this._value, this._source),
        status: this._status,
        remaining: this._remaining,
        source: this._source,
        errors: this._errors
      });
    } else {
      return this;
    }
  };
  Result.prototype.changeRemaining = function(remaining) {
    return new Result({
      value: this._value,
      status: this._status,
      remaining,
      source: this._source,
      errors: this._errors
    });
  };
  Result.prototype.isSuccess = function() {
    return this._status === "success" || this._status === "cut";
  };
  Result.prototype.isFailure = function() {
    return this._status === "failure";
  };
  Result.prototype.isError = function() {
    return this._status === "error";
  };
  Result.prototype.isCut = function() {
    return this._status === "cut";
  };
  Result.prototype.value = function() {
    return this._value;
  };
  Result.prototype.remaining = function() {
    return this._remaining;
  };
  Result.prototype.source = function() {
    return this._source;
  };
  Result.prototype.errors = function() {
    return this._errors;
  };
  return parsingResults;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  errors.error = function(options2) {
    return new Error2(options2);
  };
  var Error2 = function(options2) {
    this.expected = options2.expected;
    this.actual = options2.actual;
    this._location = options2.location;
  };
  Error2.prototype.describe = function() {
    var locationDescription = this._location ? this._location.describe() + ":\n" : "";
    return locationDescription + "Expected " + this.expected + "\nbut got " + this.actual;
  };
  Error2.prototype.lineNumber = function() {
    return this._location.lineNumber();
  };
  Error2.prototype.characterNumber = function() {
    return this._location.characterNumber();
  };
  return errors;
}
var lazyIterators = {};
var hasRequiredLazyIterators;
function requireLazyIterators() {
  if (hasRequiredLazyIterators) return lazyIterators;
  hasRequiredLazyIterators = 1;
  lazyIterators.fromArray = function(array) {
    var index = 0;
    var hasNext = function() {
      return index < array.length;
    };
    return new LazyIterator({
      hasNext,
      next: function() {
        if (!hasNext()) {
          throw new Error("No more elements");
        } else {
          return array[index++];
        }
      }
    });
  };
  var LazyIterator = function(iterator) {
    this._iterator = iterator;
  };
  LazyIterator.prototype.map = function(func) {
    var iterator = this._iterator;
    return new LazyIterator({
      hasNext: function() {
        return iterator.hasNext();
      },
      next: function() {
        return func(iterator.next());
      }
    });
  };
  LazyIterator.prototype.filter = function(condition) {
    var iterator = this._iterator;
    var moved = false;
    var hasNext = false;
    var next;
    var moveIfNecessary = function() {
      if (moved) {
        return;
      }
      moved = true;
      hasNext = false;
      while (iterator.hasNext() && !hasNext) {
        next = iterator.next();
        hasNext = condition(next);
      }
    };
    return new LazyIterator({
      hasNext: function() {
        moveIfNecessary();
        return hasNext;
      },
      next: function() {
        moveIfNecessary();
        var toReturn = next;
        moved = false;
        return toReturn;
      }
    });
  };
  LazyIterator.prototype.first = function() {
    var iterator = this._iterator;
    if (this._iterator.hasNext()) {
      return iterator.next();
    } else {
      return null;
    }
  };
  LazyIterator.prototype.toArray = function() {
    var result2 = [];
    while (this._iterator.hasNext()) {
      result2.push(this._iterator.next());
    }
    return result2;
  };
  return lazyIterators;
}
var hasRequiredRules;
function requireRules() {
  if (hasRequiredRules) return rules;
  hasRequiredRules = 1;
  (function(exports) {
    var _2 = require$$0;
    var options2 = requireOption();
    var results2 = requireParsingResults();
    var errors2 = requireErrors();
    var lazyIterators2 = requireLazyIterators();
    exports.token = function(tokenType, value) {
      var matchValue = value !== void 0;
      return function(input) {
        var token2 = input.head();
        if (token2 && token2.name === tokenType && (!matchValue || token2.value === value)) {
          return results2.success(token2.value, input.tail(), token2.source);
        } else {
          var expected = describeToken({ name: tokenType, value });
          return describeTokenMismatch(input, expected);
        }
      };
    };
    exports.tokenOfType = function(tokenType) {
      return exports.token(tokenType);
    };
    exports.firstOf = function(name, parsers) {
      if (!_2.isArray(parsers)) {
        parsers = Array.prototype.slice.call(arguments, 1);
      }
      return function(input) {
        return lazyIterators2.fromArray(parsers).map(function(parser2) {
          return parser2(input);
        }).filter(function(result2) {
          return result2.isSuccess() || result2.isError();
        }).first() || describeTokenMismatch(input, name);
      };
    };
    exports.then = function(parser2, func) {
      return function(input) {
        var result2 = parser2(input);
        if (!result2.map) {
          console.log(result2);
        }
        return result2.map(func);
      };
    };
    exports.sequence = function() {
      var parsers = Array.prototype.slice.call(arguments, 0);
      var rule = function(input) {
        var result2 = _2.foldl(parsers, function(memo, parser2) {
          var result3 = memo.result;
          var hasCut = memo.hasCut;
          if (!result3.isSuccess()) {
            return { result: result3, hasCut };
          }
          var subResult = parser2(result3.remaining());
          if (subResult.isCut()) {
            return { result: result3, hasCut: true };
          } else if (subResult.isSuccess()) {
            var values2;
            if (parser2.isCaptured) {
              values2 = result3.value().withValue(parser2, subResult.value());
            } else {
              values2 = result3.value();
            }
            var remaining = subResult.remaining();
            var source2 = input.to(remaining);
            return {
              result: results2.success(values2, remaining, source2),
              hasCut
            };
          } else if (hasCut) {
            return { result: results2.error(subResult.errors(), subResult.remaining()), hasCut };
          } else {
            return { result: subResult, hasCut };
          }
        }, { result: results2.success(new SequenceValues(), input), hasCut: false }).result;
        var source = input.to(result2.remaining());
        return result2.map(function(values2) {
          return values2.withValue(exports.sequence.source, source);
        });
      };
      rule.head = function() {
        var firstCapture = _2.find(parsers, isCapturedRule);
        return exports.then(
          rule,
          exports.sequence.extract(firstCapture)
        );
      };
      rule.map = function(func) {
        return exports.then(
          rule,
          function(result2) {
            return func.apply(this, result2.toArray());
          }
        );
      };
      function isCapturedRule(subRule) {
        return subRule.isCaptured;
      }
      return rule;
    };
    var SequenceValues = function(values2, valuesArray) {
      this._values = values2 || {};
      this._valuesArray = valuesArray || [];
    };
    SequenceValues.prototype.withValue = function(rule, value) {
      if (rule.captureName && rule.captureName in this._values) {
        throw new Error('Cannot add second value for capture "' + rule.captureName + '"');
      } else {
        var newValues = _2.clone(this._values);
        newValues[rule.captureName] = value;
        var newValuesArray = this._valuesArray.concat([value]);
        return new SequenceValues(newValues, newValuesArray);
      }
    };
    SequenceValues.prototype.get = function(rule) {
      if (rule.captureName in this._values) {
        return this._values[rule.captureName];
      } else {
        throw new Error('No value for capture "' + rule.captureName + '"');
      }
    };
    SequenceValues.prototype.toArray = function() {
      return this._valuesArray;
    };
    exports.sequence.capture = function(rule, name) {
      var captureRule = function() {
        return rule.apply(this, arguments);
      };
      captureRule.captureName = name;
      captureRule.isCaptured = true;
      return captureRule;
    };
    exports.sequence.extract = function(rule) {
      return function(result2) {
        return result2.get(rule);
      };
    };
    exports.sequence.applyValues = function(func) {
      var rules2 = Array.prototype.slice.call(arguments, 1);
      return function(result2) {
        var values2 = rules2.map(function(rule) {
          return result2.get(rule);
        });
        return func.apply(this, values2);
      };
    };
    exports.sequence.source = {
      captureName: "âsourceâ"
    };
    exports.sequence.cut = function() {
      return function(input) {
        return results2.cut(input);
      };
    };
    exports.optional = function(rule) {
      return function(input) {
        var result2 = rule(input);
        if (result2.isSuccess()) {
          return result2.map(options2.some);
        } else if (result2.isFailure()) {
          return results2.success(options2.none, input);
        } else {
          return result2;
        }
      };
    };
    exports.zeroOrMoreWithSeparator = function(rule, separator) {
      return repeatedWithSeparator(rule, separator, false);
    };
    exports.oneOrMoreWithSeparator = function(rule, separator) {
      return repeatedWithSeparator(rule, separator, true);
    };
    var zeroOrMore = exports.zeroOrMore = function(rule) {
      return function(input) {
        var values2 = [];
        var result2;
        while ((result2 = rule(input)) && result2.isSuccess()) {
          input = result2.remaining();
          values2.push(result2.value());
        }
        if (result2.isError()) {
          return result2;
        } else {
          return results2.success(values2, input);
        }
      };
    };
    exports.oneOrMore = function(rule) {
      return exports.oneOrMoreWithSeparator(rule, noOpRule);
    };
    function noOpRule(input) {
      return results2.success(null, input);
    }
    var repeatedWithSeparator = function(rule, separator, isOneOrMore) {
      return function(input) {
        var result2 = rule(input);
        if (result2.isSuccess()) {
          var mainRule = exports.sequence.capture(rule, "main");
          var remainingRule = zeroOrMore(exports.then(
            exports.sequence(separator, mainRule),
            exports.sequence.extract(mainRule)
          ));
          var remainingResult = remainingRule(result2.remaining());
          return results2.success([result2.value()].concat(remainingResult.value()), remainingResult.remaining());
        } else if (isOneOrMore || result2.isError()) {
          return result2;
        } else {
          return results2.success([], input);
        }
      };
    };
    exports.leftAssociative = function(leftRule, rightRule, func) {
      var rights;
      if (func) {
        rights = [{ func, rule: rightRule }];
      } else {
        rights = rightRule;
      }
      rights = rights.map(function(right) {
        return exports.then(right.rule, function(rightValue) {
          return function(leftValue, source) {
            return right.func(leftValue, rightValue, source);
          };
        });
      });
      var repeatedRule = exports.firstOf.apply(null, ["rules"].concat(rights));
      return function(input) {
        var start = input;
        var leftResult = leftRule(input);
        if (!leftResult.isSuccess()) {
          return leftResult;
        }
        var repeatedResult = repeatedRule(leftResult.remaining());
        while (repeatedResult.isSuccess()) {
          var remaining = repeatedResult.remaining();
          var source = start.to(repeatedResult.remaining());
          var right = repeatedResult.value();
          leftResult = results2.success(
            right(leftResult.value(), source),
            remaining,
            source
          );
          repeatedResult = repeatedRule(leftResult.remaining());
        }
        if (repeatedResult.isError()) {
          return repeatedResult;
        }
        return leftResult;
      };
    };
    exports.leftAssociative.firstOf = function() {
      return Array.prototype.slice.call(arguments, 0);
    };
    exports.nonConsuming = function(rule) {
      return function(input) {
        return rule(input).changeRemaining(input);
      };
    };
    var describeToken = function(token2) {
      if (token2.value) {
        return token2.name + ' "' + token2.value + '"';
      } else {
        return token2.name;
      }
    };
    function describeTokenMismatch(input, expected) {
      var error;
      var token2 = input.head();
      if (token2) {
        error = errors2.error({
          expected,
          actual: describeToken(token2),
          location: token2.source
        });
      } else {
        error = errors2.error({
          expected,
          actual: "end of tokens"
        });
      }
      return results2.failure([error], input);
    }
  })(rules);
  return rules;
}
var StringSource = { exports: {} };
var hasRequiredStringSource;
function requireStringSource() {
  if (hasRequiredStringSource) return StringSource.exports;
  hasRequiredStringSource = 1;
  StringSource.exports = function(string, description) {
    var self2 = {
      asString: function() {
        return string;
      },
      range: function(startIndex, endIndex) {
        return new StringSourceRange(string, description, startIndex, endIndex);
      }
    };
    return self2;
  };
  var StringSourceRange = function(string, description, startIndex, endIndex) {
    this._string = string;
    this._description = description;
    this._startIndex = startIndex;
    this._endIndex = endIndex;
  };
  StringSourceRange.prototype.to = function(otherRange) {
    return new StringSourceRange(this._string, this._description, this._startIndex, otherRange._endIndex);
  };
  StringSourceRange.prototype.describe = function() {
    var position = this._position();
    var description = this._description ? this._description + "\n" : "";
    return description + "Line number: " + position.lineNumber + "\nCharacter number: " + position.characterNumber;
  };
  StringSourceRange.prototype.lineNumber = function() {
    return this._position().lineNumber;
  };
  StringSourceRange.prototype.characterNumber = function() {
    return this._position().characterNumber;
  };
  StringSourceRange.prototype._position = function() {
    var self2 = this;
    var index = 0;
    var nextNewLine = function() {
      return self2._string.indexOf("\n", index);
    };
    var lineNumber = 1;
    while (nextNewLine() !== -1 && nextNewLine() < this._startIndex) {
      index = nextNewLine() + 1;
      lineNumber += 1;
    }
    var characterNumber = this._startIndex - index + 1;
    return { lineNumber, characterNumber };
  };
  return StringSource.exports;
}
var Token;
var hasRequiredToken;
function requireToken() {
  if (hasRequiredToken) return Token;
  hasRequiredToken = 1;
  Token = function(name, value, source) {
    this.name = name;
    this.value = value;
    if (source) {
      this.source = source;
    }
  };
  return Token;
}
var bottomUp = {};
var hasRequiredBottomUp;
function requireBottomUp() {
  if (hasRequiredBottomUp) return bottomUp;
  hasRequiredBottomUp = 1;
  (function(exports) {
    var rules2 = requireRules();
    var results2 = requireParsingResults();
    exports.parser = function(name, prefixRules, infixRuleBuilders) {
      var self2 = {
        rule,
        leftAssociative,
        rightAssociative
      };
      var infixRules = new InfixRules(infixRuleBuilders.map(createInfixRule));
      var prefixRule = rules2.firstOf(name, prefixRules);
      function createInfixRule(infixRuleBuilder) {
        return {
          name: infixRuleBuilder.name,
          rule: lazyRule(infixRuleBuilder.ruleBuilder.bind(null, self2))
        };
      }
      function rule() {
        return createRule(infixRules);
      }
      function leftAssociative(name2) {
        return createRule(infixRules.untilExclusive(name2));
      }
      function rightAssociative(name2) {
        return createRule(infixRules.untilInclusive(name2));
      }
      function createRule(infixRules2) {
        return apply2.bind(null, infixRules2);
      }
      function apply2(infixRules2, tokens2) {
        var leftResult = prefixRule(tokens2);
        if (leftResult.isSuccess()) {
          return infixRules2.apply(leftResult);
        } else {
          return leftResult;
        }
      }
      return self2;
    };
    function InfixRules(infixRules) {
      function untilExclusive(name) {
        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name)));
      }
      function untilInclusive(name) {
        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name) + 1));
      }
      function ruleNames() {
        return infixRules.map(function(rule) {
          return rule.name;
        });
      }
      function apply2(leftResult) {
        var currentResult;
        var source;
        while (true) {
          currentResult = applyToTokens(leftResult.remaining());
          if (currentResult.isSuccess()) {
            source = leftResult.source().to(currentResult.source());
            leftResult = results2.success(
              currentResult.value()(leftResult.value(), source),
              currentResult.remaining(),
              source
            );
          } else if (currentResult.isFailure()) {
            return leftResult;
          } else {
            return currentResult;
          }
        }
      }
      function applyToTokens(tokens2) {
        return rules2.firstOf("infix", infixRules.map(function(infix) {
          return infix.rule;
        }))(tokens2);
      }
      return {
        apply: apply2,
        untilExclusive,
        untilInclusive
      };
    }
    exports.infix = function(name, ruleBuilder) {
      function map3(func) {
        return exports.infix(name, function(parser2) {
          var rule = ruleBuilder(parser2);
          return function(tokens2) {
            var result2 = rule(tokens2);
            return result2.map(function(right) {
              return function(left, source) {
                return func(left, right, source);
              };
            });
          };
        });
      }
      return {
        name,
        ruleBuilder,
        map: map3
      };
    };
    var lazyRule = function(ruleBuilder) {
      var rule;
      return function(input) {
        if (!rule) {
          rule = ruleBuilder();
        }
        return rule(input);
      };
    };
  })(bottomUp);
  return bottomUp;
}
var regexTokeniser = {};
var hasRequiredRegexTokeniser;
function requireRegexTokeniser() {
  if (hasRequiredRegexTokeniser) return regexTokeniser;
  hasRequiredRegexTokeniser = 1;
  var Token2 = requireToken();
  var StringSource2 = requireStringSource();
  regexTokeniser.RegexTokeniser = RegexTokeniser;
  function RegexTokeniser(rules2) {
    rules2 = rules2.map(function(rule) {
      return {
        name: rule.name,
        regex: new RegExp(rule.regex.source, "g")
      };
    });
    function tokenise(input, description) {
      var source = new StringSource2(input, description);
      var index = 0;
      var tokens2 = [];
      while (index < input.length) {
        var result2 = readNextToken(input, index, source);
        index = result2.endIndex;
        tokens2.push(result2.token);
      }
      tokens2.push(endToken(input, source));
      return tokens2;
    }
    function readNextToken(string, startIndex, source) {
      for (var i = 0; i < rules2.length; i++) {
        var regex = rules2[i].regex;
        regex.lastIndex = startIndex;
        var result2 = regex.exec(string);
        if (result2) {
          var endIndex = startIndex + result2[0].length;
          if (result2.index === startIndex && endIndex > startIndex) {
            var value = result2[1];
            var token2 = new Token2(
              rules2[i].name,
              value,
              source.range(startIndex, endIndex)
            );
            return { token: token2, endIndex };
          }
        }
      }
      var endIndex = startIndex + 1;
      var token2 = new Token2(
        "unrecognisedCharacter",
        string.substring(startIndex, endIndex),
        source.range(startIndex, endIndex)
      );
      return { token: token2, endIndex };
    }
    function endToken(input, source) {
      return new Token2(
        "end",
        null,
        source.range(input.length, input.length)
      );
    }
    return {
      tokenise
    };
  }
  return regexTokeniser;
}
var hasRequiredLop;
function requireLop() {
  if (hasRequiredLop) return lop;
  hasRequiredLop = 1;
  lop.Parser = requireParser().Parser;
  lop.rules = requireRules();
  lop.errors = requireErrors();
  lop.results = requireParsingResults();
  lop.StringSource = requireStringSource();
  lop.Token = requireToken();
  lop.bottomUp = requireBottomUp();
  lop.RegexTokeniser = requireRegexTokeniser().RegexTokeniser;
  lop.rule = function(ruleBuilder) {
    var rule;
    return function(input) {
      if (!rule) {
        rule = ruleBuilder();
      }
      return rule(input);
    };
  };
  return lop;
}
var documentMatchers = {};
var hasRequiredDocumentMatchers;
function requireDocumentMatchers() {
  if (hasRequiredDocumentMatchers) return documentMatchers;
  hasRequiredDocumentMatchers = 1;
  documentMatchers.paragraph = paragraph;
  documentMatchers.run = run3;
  documentMatchers.table = table;
  documentMatchers.bold = new Matcher("bold");
  documentMatchers.italic = new Matcher("italic");
  documentMatchers.underline = new Matcher("underline");
  documentMatchers.strikethrough = new Matcher("strikethrough");
  documentMatchers.allCaps = new Matcher("allCaps");
  documentMatchers.smallCaps = new Matcher("smallCaps");
  documentMatchers.highlight = highlight;
  documentMatchers.commentReference = new Matcher("commentReference");
  documentMatchers.lineBreak = new BreakMatcher({ breakType: "line" });
  documentMatchers.pageBreak = new BreakMatcher({ breakType: "page" });
  documentMatchers.columnBreak = new BreakMatcher({ breakType: "column" });
  documentMatchers.equalTo = equalTo;
  documentMatchers.startsWith = startsWith;
  function paragraph(options2) {
    return new Matcher("paragraph", options2);
  }
  function run3(options2) {
    return new Matcher("run", options2);
  }
  function table(options2) {
    return new Matcher("table", options2);
  }
  function highlight(options2) {
    return new HighlightMatcher(options2);
  }
  function Matcher(elementType, options2) {
    options2 = options2 || {};
    this._elementType = elementType;
    this._styleId = options2.styleId;
    this._styleName = options2.styleName;
    if (options2.list) {
      this._listIndex = options2.list.levelIndex;
      this._listIsOrdered = options2.list.isOrdered;
    }
  }
  Matcher.prototype.matches = function(element) {
    return element.type === this._elementType && (this._styleId === void 0 || element.styleId === this._styleId) && (this._styleName === void 0 || element.styleName && this._styleName.operator(this._styleName.operand, element.styleName)) && (this._listIndex === void 0 || isList2(element, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === element.breakType);
  };
  function HighlightMatcher(options2) {
    options2 = options2 || {};
    this._color = options2.color;
  }
  HighlightMatcher.prototype.matches = function(element) {
    return element.type === "highlight" && (this._color === void 0 || element.color === this._color);
  };
  function BreakMatcher(options2) {
    options2 = options2 || {};
    this._breakType = options2.breakType;
  }
  BreakMatcher.prototype.matches = function(element) {
    return element.type === "break" && (this._breakType === void 0 || element.breakType === this._breakType);
  };
  function isList2(element, levelIndex, isOrdered) {
    return element.numbering && element.numbering.level == levelIndex && element.numbering.isOrdered == isOrdered;
  }
  function equalTo(value) {
    return {
      operator: operatorEqualTo,
      operand: value
    };
  }
  function startsWith(value) {
    return {
      operator: operatorStartsWith,
      operand: value
    };
  }
  function operatorEqualTo(first2, second) {
    return first2.toUpperCase() === second.toUpperCase();
  }
  function operatorStartsWith(first2, second) {
    return second.toUpperCase().indexOf(first2.toUpperCase()) === 0;
  }
  return documentMatchers;
}
var tokeniser = {};
var hasRequiredTokeniser;
function requireTokeniser() {
  if (hasRequiredTokeniser) return tokeniser;
  hasRequiredTokeniser = 1;
  var lop2 = requireLop();
  var RegexTokeniser = lop2.RegexTokeniser;
  tokeniser.tokenise = tokenise;
  var stringPrefix = "'((?:\\\\.|[^'])*)";
  function tokenise(string) {
    var identifierCharacter = "(?:[a-zA-Z\\-_]|\\\\.)";
    var tokeniser2 = new RegexTokeniser([
      { name: "identifier", regex: new RegExp("(" + identifierCharacter + "(?:" + identifierCharacter + "|[0-9])*)") },
      { name: "dot", regex: /\./ },
      { name: "colon", regex: /:/ },
      { name: "gt", regex: />/ },
      { name: "whitespace", regex: /\s+/ },
      { name: "arrow", regex: /=>/ },
      { name: "equals", regex: /=/ },
      { name: "startsWith", regex: /\^=/ },
      { name: "open-paren", regex: /\(/ },
      { name: "close-paren", regex: /\)/ },
      { name: "open-square-bracket", regex: /\[/ },
      { name: "close-square-bracket", regex: /\]/ },
      { name: "string", regex: new RegExp(stringPrefix + "'") },
      { name: "unterminated-string", regex: new RegExp(stringPrefix) },
      { name: "integer", regex: /([0-9]+)/ },
      { name: "choice", regex: /\|/ },
      { name: "bang", regex: /(!)/ }
    ]);
    return tokeniser2.tokenise(string);
  }
  return tokeniser;
}
var hasRequiredStyleReader;
function requireStyleReader() {
  if (hasRequiredStyleReader) return styleReader;
  hasRequiredStyleReader = 1;
  var _2 = require$$0;
  var lop2 = requireLop();
  var documentMatchers2 = requireDocumentMatchers();
  var htmlPaths2 = requireHtmlPaths();
  var tokenise = requireTokeniser().tokenise;
  var results2 = requireResults();
  styleReader.readHtmlPath = readHtmlPath;
  styleReader.readDocumentMatcher = readDocumentMatcher;
  styleReader.readStyle = readStyle;
  function readStyle(string) {
    return parseString(styleRule, string);
  }
  function createStyleRule() {
    return lop2.rules.sequence(
      lop2.rules.sequence.capture(documentMatcherRule()),
      lop2.rules.tokenOfType("whitespace"),
      lop2.rules.tokenOfType("arrow"),
      lop2.rules.sequence.capture(lop2.rules.optional(lop2.rules.sequence(
        lop2.rules.tokenOfType("whitespace"),
        lop2.rules.sequence.capture(htmlPathRule())
      ).head())),
      lop2.rules.tokenOfType("end")
    ).map(function(documentMatcher, htmlPath) {
      return {
        from: documentMatcher,
        to: htmlPath.valueOrElse(htmlPaths2.empty)
      };
    });
  }
  function readDocumentMatcher(string) {
    return parseString(documentMatcherRule(), string);
  }
  function documentMatcherRule() {
    var sequence = lop2.rules.sequence;
    var identifierToConstant = function(identifier, constant2) {
      return lop2.rules.then(
        lop2.rules.token("identifier", identifier),
        function() {
          return constant2;
        }
      );
    };
    var paragraphRule = identifierToConstant("p", documentMatchers2.paragraph);
    var runRule = identifierToConstant("r", documentMatchers2.run);
    var elementTypeRule = lop2.rules.firstOf(
      "p or r or table",
      paragraphRule,
      runRule
    );
    var styleIdRule = lop2.rules.sequence(
      lop2.rules.tokenOfType("dot"),
      lop2.rules.sequence.cut(),
      lop2.rules.sequence.capture(identifierRule)
    ).map(function(styleId) {
      return { styleId };
    });
    var styleNameMatcherRule = lop2.rules.firstOf(
      "style name matcher",
      lop2.rules.then(
        lop2.rules.sequence(
          lop2.rules.tokenOfType("equals"),
          lop2.rules.sequence.cut(),
          lop2.rules.sequence.capture(stringRule)
        ).head(),
        function(styleName) {
          return { styleName: documentMatchers2.equalTo(styleName) };
        }
      ),
      lop2.rules.then(
        lop2.rules.sequence(
          lop2.rules.tokenOfType("startsWith"),
          lop2.rules.sequence.cut(),
          lop2.rules.sequence.capture(stringRule)
        ).head(),
        function(styleName) {
          return { styleName: documentMatchers2.startsWith(styleName) };
        }
      )
    );
    var styleNameRule = lop2.rules.sequence(
      lop2.rules.tokenOfType("open-square-bracket"),
      lop2.rules.sequence.cut(),
      lop2.rules.token("identifier", "style-name"),
      lop2.rules.sequence.capture(styleNameMatcherRule),
      lop2.rules.tokenOfType("close-square-bracket")
    ).head();
    var listTypeRule = lop2.rules.firstOf(
      "list type",
      identifierToConstant("ordered-list", { isOrdered: true }),
      identifierToConstant("unordered-list", { isOrdered: false })
    );
    var listRule = sequence(
      lop2.rules.tokenOfType("colon"),
      sequence.capture(listTypeRule),
      sequence.cut(),
      lop2.rules.tokenOfType("open-paren"),
      sequence.capture(integerRule),
      lop2.rules.tokenOfType("close-paren")
    ).map(function(listType, levelNumber) {
      return {
        list: {
          isOrdered: listType.isOrdered,
          levelIndex: levelNumber - 1
        }
      };
    });
    function createMatcherSuffixesRule(rules2) {
      var matcherSuffix = lop2.rules.firstOf.apply(
        lop2.rules.firstOf,
        ["matcher suffix"].concat(rules2)
      );
      var matcherSuffixes = lop2.rules.zeroOrMore(matcherSuffix);
      return lop2.rules.then(matcherSuffixes, function(suffixes) {
        var matcherOptions = {};
        suffixes.forEach(function(suffix) {
          _2.extend(matcherOptions, suffix);
        });
        return matcherOptions;
      });
    }
    var paragraphOrRun = sequence(
      sequence.capture(elementTypeRule),
      sequence.capture(createMatcherSuffixesRule([
        styleIdRule,
        styleNameRule,
        listRule
      ]))
    ).map(function(createMatcher, matcherOptions) {
      return createMatcher(matcherOptions);
    });
    var table = sequence(
      lop2.rules.token("identifier", "table"),
      sequence.capture(createMatcherSuffixesRule([
        styleIdRule,
        styleNameRule
      ]))
    ).map(function(options2) {
      return documentMatchers2.table(options2);
    });
    var bold = identifierToConstant("b", documentMatchers2.bold);
    var italic = identifierToConstant("i", documentMatchers2.italic);
    var underline2 = identifierToConstant("u", documentMatchers2.underline);
    var strikethrough = identifierToConstant("strike", documentMatchers2.strikethrough);
    var allCaps = identifierToConstant("all-caps", documentMatchers2.allCaps);
    var smallCaps = identifierToConstant("small-caps", documentMatchers2.smallCaps);
    var highlight = sequence(
      lop2.rules.token("identifier", "highlight"),
      lop2.rules.sequence.capture(lop2.rules.optional(lop2.rules.sequence(
        lop2.rules.tokenOfType("open-square-bracket"),
        lop2.rules.sequence.cut(),
        lop2.rules.token("identifier", "color"),
        lop2.rules.tokenOfType("equals"),
        lop2.rules.sequence.capture(stringRule),
        lop2.rules.tokenOfType("close-square-bracket")
      ).head()))
    ).map(function(color) {
      return documentMatchers2.highlight({
        color: color.valueOrElse(void 0)
      });
    });
    var commentReference = identifierToConstant("comment-reference", documentMatchers2.commentReference);
    var breakMatcher = sequence(
      lop2.rules.token("identifier", "br"),
      sequence.cut(),
      lop2.rules.tokenOfType("open-square-bracket"),
      lop2.rules.token("identifier", "type"),
      lop2.rules.tokenOfType("equals"),
      sequence.capture(stringRule),
      lop2.rules.tokenOfType("close-square-bracket")
    ).map(function(breakType) {
      switch (breakType) {
        case "line":
          return documentMatchers2.lineBreak;
        case "page":
          return documentMatchers2.pageBreak;
        case "column":
          return documentMatchers2.columnBreak;
      }
    });
    return lop2.rules.firstOf(
      "element type",
      paragraphOrRun,
      table,
      bold,
      italic,
      underline2,
      strikethrough,
      allCaps,
      smallCaps,
      highlight,
      commentReference,
      breakMatcher
    );
  }
  function readHtmlPath(string) {
    return parseString(htmlPathRule(), string);
  }
  function htmlPathRule() {
    var capture = lop2.rules.sequence.capture;
    var whitespaceRule = lop2.rules.tokenOfType("whitespace");
    var freshRule = lop2.rules.then(
      lop2.rules.optional(lop2.rules.sequence(
        lop2.rules.tokenOfType("colon"),
        lop2.rules.token("identifier", "fresh")
      )),
      function(option2) {
        return option2.map(function() {
          return true;
        }).valueOrElse(false);
      }
    );
    var separatorRule = lop2.rules.then(
      lop2.rules.optional(lop2.rules.sequence(
        lop2.rules.tokenOfType("colon"),
        lop2.rules.token("identifier", "separator"),
        lop2.rules.tokenOfType("open-paren"),
        capture(stringRule),
        lop2.rules.tokenOfType("close-paren")
      ).head()),
      function(option2) {
        return option2.valueOrElse("");
      }
    );
    var tagNamesRule = lop2.rules.oneOrMoreWithSeparator(
      identifierRule,
      lop2.rules.tokenOfType("choice")
    );
    var styleElementRule = lop2.rules.sequence(
      capture(tagNamesRule),
      capture(lop2.rules.zeroOrMore(attributeOrClassRule)),
      capture(freshRule),
      capture(separatorRule)
    ).map(function(tagName, attributesList, fresh, separator) {
      var attributes = {};
      var options2 = {};
      attributesList.forEach(function(attribute) {
        if (attribute.append && attributes[attribute.name]) {
          attributes[attribute.name] += " " + attribute.value;
        } else {
          attributes[attribute.name] = attribute.value;
        }
      });
      if (fresh) {
        options2.fresh = true;
      }
      if (separator) {
        options2.separator = separator;
      }
      return htmlPaths2.element(tagName, attributes, options2);
    });
    return lop2.rules.firstOf(
      "html path",
      lop2.rules.then(lop2.rules.tokenOfType("bang"), function() {
        return htmlPaths2.ignore;
      }),
      lop2.rules.then(
        lop2.rules.zeroOrMoreWithSeparator(
          styleElementRule,
          lop2.rules.sequence(
            whitespaceRule,
            lop2.rules.tokenOfType("gt"),
            whitespaceRule
          )
        ),
        htmlPaths2.elements
      )
    );
  }
  var identifierRule = lop2.rules.then(
    lop2.rules.tokenOfType("identifier"),
    decodeEscapeSequences
  );
  var integerRule = lop2.rules.tokenOfType("integer");
  var stringRule = lop2.rules.then(
    lop2.rules.tokenOfType("string"),
    decodeEscapeSequences
  );
  var escapeSequences = {
    "n": "\n",
    "r": "\r",
    "t": "	"
  };
  function decodeEscapeSequences(value) {
    return value.replace(/\\(.)/g, function(match, code) {
      return escapeSequences[code] || code;
    });
  }
  var attributeRule = lop2.rules.sequence(
    lop2.rules.tokenOfType("open-square-bracket"),
    lop2.rules.sequence.cut(),
    lop2.rules.sequence.capture(identifierRule),
    lop2.rules.tokenOfType("equals"),
    lop2.rules.sequence.capture(stringRule),
    lop2.rules.tokenOfType("close-square-bracket")
  ).map(function(name, value) {
    return { name, value, append: false };
  });
  var classRule = lop2.rules.sequence(
    lop2.rules.tokenOfType("dot"),
    lop2.rules.sequence.cut(),
    lop2.rules.sequence.capture(identifierRule)
  ).map(function(className) {
    return { name: "class", value: className, append: true };
  });
  var attributeOrClassRule = lop2.rules.firstOf(
    "attribute or class",
    attributeRule,
    classRule
  );
  function parseString(rule, string) {
    var tokens2 = tokenise(string);
    var parser2 = lop2.Parser();
    var parseResult = parser2.parseTokens(rule, tokens2);
    if (parseResult.isSuccess()) {
      return results2.success(parseResult.value());
    } else {
      return new results2.Result(null, [results2.warning(describeFailure(string, parseResult))]);
    }
  }
  function describeFailure(input, parseResult) {
    return "Did not understand this style mapping, so ignored it: " + input + "\n" + parseResult.errors().map(describeError).join("\n");
  }
  function describeError(error) {
    return "Error was at character number " + error.characterNumber() + ": Expected " + error.expected + " but got " + error.actual;
  }
  var styleRule = createStyleRule();
  return styleReader;
}
var optionsReader = {};
var hasRequiredOptionsReader;
function requireOptionsReader() {
  if (hasRequiredOptionsReader) return optionsReader;
  hasRequiredOptionsReader = 1;
  optionsReader.readOptions = readOptions;
  var _2 = require$$0;
  var defaultStyleMap = optionsReader._defaultStyleMap = [
    "p.Heading1 => h1:fresh",
    "p.Heading2 => h2:fresh",
    "p.Heading3 => h3:fresh",
    "p.Heading4 => h4:fresh",
    "p.Heading5 => h5:fresh",
    "p.Heading6 => h6:fresh",
    "p[style-name='Heading 1'] => h1:fresh",
    "p[style-name='Heading 2'] => h2:fresh",
    "p[style-name='Heading 3'] => h3:fresh",
    "p[style-name='Heading 4'] => h4:fresh",
    "p[style-name='Heading 5'] => h5:fresh",
    "p[style-name='Heading 6'] => h6:fresh",
    "p[style-name='heading 1'] => h1:fresh",
    "p[style-name='heading 2'] => h2:fresh",
    "p[style-name='heading 3'] => h3:fresh",
    "p[style-name='heading 4'] => h4:fresh",
    "p[style-name='heading 5'] => h5:fresh",
    "p[style-name='heading 6'] => h6:fresh",
    // Apple Pages
    "p.Heading => h1:fresh",
    "p[style-name='Heading'] => h1:fresh",
    "r[style-name='Strong'] => strong",
    "p[style-name='footnote text'] => p:fresh",
    "r[style-name='footnote reference'] =>",
    "p[style-name='endnote text'] => p:fresh",
    "r[style-name='endnote reference'] =>",
    "p[style-name='annotation text'] => p:fresh",
    "r[style-name='annotation reference'] =>",
    // LibreOffice
    "p[style-name='Footnote'] => p:fresh",
    "r[style-name='Footnote anchor'] =>",
    "p[style-name='Endnote'] => p:fresh",
    "r[style-name='Endnote anchor'] =>",
    "p:unordered-list(1) => ul > li:fresh",
    "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
    "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
    "p:ordered-list(1) => ol > li:fresh",
    "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
    "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
    "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
    "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
    "r[style-name='Hyperlink'] =>",
    "p[style-name='Normal'] => p:fresh",
    // Apple Pages
    "p.Body => p:fresh",
    "p[style-name='Body'] => p:fresh"
  ];
  var standardOptions = optionsReader._standardOptions = {
    transformDocument: identity2,
    includeDefaultStyleMap: true,
    includeEmbeddedStyleMap: true
  };
  function readOptions(options2) {
    options2 = options2 || {};
    return _2.extend({}, standardOptions, options2, {
      customStyleMap: readStyleMap(options2.styleMap),
      readStyleMap: function() {
        var styleMap2 = this.customStyleMap;
        if (this.includeEmbeddedStyleMap) {
          styleMap2 = styleMap2.concat(readStyleMap(this.embeddedStyleMap));
        }
        if (this.includeDefaultStyleMap) {
          styleMap2 = styleMap2.concat(defaultStyleMap);
        }
        return styleMap2;
      }
    });
  }
  function readStyleMap(styleMap2) {
    if (!styleMap2) {
      return [];
    } else if (_2.isString(styleMap2)) {
      return styleMap2.split("\n").map(function(line) {
        return line.trim();
      }).filter(function(line) {
        return line !== "" && line.charAt(0) !== "#";
      });
    } else {
      return styleMap2;
    }
  }
  function identity2(value) {
    return value;
  }
  return optionsReader;
}
var unzip = {};
var hasRequiredUnzip;
function requireUnzip() {
  if (hasRequiredUnzip) return unzip;
  hasRequiredUnzip = 1;
  var promises2 = requirePromises();
  var zipfile2 = requireZipfile();
  unzip.openZip = openZip;
  function openZip(options2) {
    if (options2.arrayBuffer) {
      return promises2.resolve(zipfile2.openArrayBuffer(options2.arrayBuffer));
    } else {
      return promises2.reject(new Error("Could not find file in options"));
    }
  }
  return unzip;
}
var underline = {};
var hasRequiredUnderline;
function requireUnderline() {
  if (hasRequiredUnderline) return underline;
  hasRequiredUnderline = 1;
  var htmlPaths2 = requireHtmlPaths();
  var Html = requireHtml();
  underline.element = element;
  function element(name) {
    return function(html2) {
      return Html.elementWithTag(htmlPaths2.element(name), [html2]);
    };
  }
  return underline;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$2;
  hasRequiredLib = 1;
  var _2 = require$$0;
  var docxReader2 = requireDocxReader();
  var docxStyleMap = requireStyleMap();
  var DocumentConverter = requireDocumentToHtml().DocumentConverter;
  var convertElementToRawText = requireRawText().convertElementToRawText;
  var readStyle = requireStyleReader().readStyle;
  var readOptions = requireOptionsReader().readOptions;
  var unzip2 = requireUnzip();
  var Result = requireResults().Result;
  lib$2.convertToHtml = convertToHtml;
  lib$2.convertToMarkdown = convertToMarkdown;
  lib$2.convert = convert;
  lib$2.extractRawText = extractRawText;
  lib$2.images = requireImages();
  lib$2.transforms = requireTransforms();
  lib$2.underline = requireUnderline();
  lib$2.embedStyleMap = embedStyleMap;
  lib$2.readEmbeddedStyleMap = readEmbeddedStyleMap;
  function convertToHtml(input, options2) {
    return convert(input, options2);
  }
  function convertToMarkdown(input, options2) {
    var markdownOptions = Object.create(options2 || {});
    markdownOptions.outputFormat = "markdown";
    return convert(input, markdownOptions);
  }
  function convert(input, options2) {
    options2 = readOptions(options2);
    return unzip2.openZip(input).tap(function(docxFile) {
      return docxStyleMap.readStyleMap(docxFile).then(function(styleMap2) {
        options2.embeddedStyleMap = styleMap2;
      });
    }).then(function(docxFile) {
      return docxReader2.read(docxFile, input).then(function(documentResult) {
        return documentResult.map(options2.transformDocument);
      }).then(function(documentResult) {
        return convertDocumentToHtml(documentResult, options2);
      });
    });
  }
  function readEmbeddedStyleMap(input) {
    return unzip2.openZip(input).then(docxStyleMap.readStyleMap);
  }
  function convertDocumentToHtml(documentResult, options2) {
    var styleMapResult = parseStyleMap(options2.readStyleMap());
    var parsedOptions = _2.extend({}, options2, {
      styleMap: styleMapResult.value
    });
    var documentConverter = new DocumentConverter(parsedOptions);
    return documentResult.flatMapThen(function(document2) {
      return styleMapResult.flatMapThen(function(styleMap2) {
        return documentConverter.convertToHtml(document2);
      });
    });
  }
  function parseStyleMap(styleMap2) {
    return Result.combine((styleMap2 || []).map(readStyle)).map(function(styleMap3) {
      return styleMap3.filter(function(styleMapping) {
        return !!styleMapping;
      });
    });
  }
  function extractRawText(input) {
    return unzip2.openZip(input).then(docxReader2.read).then(function(documentResult) {
      return documentResult.map(convertElementToRawText);
    });
  }
  function embedStyleMap(input, styleMap2) {
    return unzip2.openZip(input).tap(function(docxFile) {
      return docxStyleMap.writeStyleMap(docxFile, styleMap2);
    }).then(function(docxFile) {
      return docxFile.toArrayBuffer();
    }).then(function(arrayBuffer) {
      return {
        toArrayBuffer: function() {
          return arrayBuffer;
        },
        toBuffer: function() {
          return Buffer.from(arrayBuffer);
        }
      };
    });
  }
  lib$2.styleMapping = function() {
    throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
  };
  return lib$2;
}
var libExports = requireLib();
const mammoth = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
const _sfc_main$S = {
  __name: "InquiryEditor",
  props: {
    readonly: {
      type: Boolean,
      default: false
    }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const props2 = __props;
    const editor = useEditor({
      editable: !props2.readonly,
      content: inquiryStore.description,
      extensions: [
        index_default$6.configure({
          heading: {
            levels: [1, 2, 3]
          }
        }),
        index_default$7,
        index_default$8.configure({
          openOnClick: false
        }),
        index_default$5,
        index_default$3,
        index_default$4.configure({
          nested: true
        }),
        index_default$2.configure({
          types: ["heading", "paragraph"]
        }),
        index_default$1.configure({ multicolor: true }),
        index_default,
        Table.configure({
          resizable: true
        }),
        TableRow,
        TableHeader,
        TableCell
      ],
      editorProps: {
        attributes: {
          class: "tiptap-editor-content",
          style: "height:100%; width: 100%",
          spellcheck: "true"
        }
      },
      onUpdate: ({ editor: editor2 }) => {
        const currentHtml = editor2.getHTML();
        if (currentHtml !== inquiryStore.description) {
          inquiryStore.description = currentHtml;
        }
      }
    });
    watch(
      () => inquiryStore.description,
      (newVal) => {
        if (editor.value && newVal !== editor.value.getHTML()) {
          nextTick(() => {
            editor.value.commands.setContent(newVal || "<p></p>");
          });
        }
      },
      { immediate: true }
    );
    const selectedHeading = ref("paragraph");
    const setHeading = () => {
      if (selectedHeading.value === "paragraph") {
        editor.value.chain().focus().setParagraph().run();
      } else {
        const level = parseInt(selectedHeading.value.replace("h", ""));
        editor.value.chain().focus().toggleHeading({ level }).run();
      }
    };
    const setLink = () => {
      const previousUrl = editor.value.getAttributes("link").href;
      const url = window.prompt("URL", previousUrl);
      if (url === null) return;
      if (url === "") {
        editor.value.chain().focus().extendMarkRange("link").unsetLink().run();
        return;
      }
      editor.value.chain().focus().extendMarkRange("link").setLink({ href: url }).run();
    };
    const addImage = () => {
      const url = window.prompt("Enter the URL of the image:");
      if (url) {
        editor.value.chain().focus().setImage({ src: url }).run();
      }
    };
    const wordFileInput = ref(null);
    const importWord = () => {
      wordFileInput.value.click();
    };
    const handleWordImport = async (event) => {
      const file = event.target.files[0];
      if (!file) return;
      try {
        const arrayBuffer = await file.arrayBuffer();
        const { value: html2 } = await mammoth.convertToHtml({ arrayBuffer });
        editor.value.commands.setContent(html2);
        inquiryStore.description = html2;
      } catch (error) {
        console.error("Error importing Word document:", error);
        alert("Failed to import Word document");
      }
    };
    const generateWithAI = async () => {
      try {
        const prompt = `Generate professional inquiry content about: ${editor.value.getText() || "general business inquiry"}`;
        const generatedText = await mockAICall(prompt);
        editor.value.commands.insertContent(generatedText);
        inquiryStore.description = editor.value.getHTML();
      } catch (error) {
        console.error("AI generation failed:", error);
        alert("AI generation failed. Please try again.");
      }
    };
    const mockAICall = async () => new Promise((resolve) => {
      setTimeout(() => {
        resolve(`
        <p>Here is some generated content based on your request:</p>
        <ul>
          <li>Professional introduction</li>
          <li>Detailed inquiry points</li>
          <li>Call to action</li>
        </ul>
      `);
      }, 1e3);
    });
    onMounted(() => {
      nextTick(() => {
        if (editor.value && inquiryStore.description) {
          editor.value.commands.setContent(inquiryStore.description);
        }
      });
    });
    onUnmounted(() => {
      if (editor) editor.value.destroy();
    });
    onBeforeUnmount(() => {
      if (editor) editor.value.destroy();
    });
    const __returned__ = { inquiryStore, props: props2, editor, selectedHeading, setHeading, setLink, addImage, wordFileInput, importWord, handleWordImport, generateWithAI, mockAICall, ref, onMounted, onUnmounted, onBeforeUnmount, watch, nextTick, get useEditor() {
      return useEditor;
    }, get EditorContent() {
      return EditorContent;
    }, get StarterKit() {
      return index_default$6;
    }, get Underline() {
      return index_default$7;
    }, get Link() {
      return index_default$8;
    }, get Image() {
      return index_default$5;
    }, get TaskItem() {
      return index_default$4;
    }, get TaskList() {
      return index_default$3;
    }, get TextAlign() {
      return index_default$2;
    }, get Highlight() {
      return index_default$1;
    }, get CharacterCount() {
      return index_default;
    }, get Table() {
      return Table;
    }, get TableRow() {
      return TableRow;
    }, get TableHeader() {
      return TableHeader;
    }, get TableCell() {
      return TableCell;
    }, get mammoth() {
      return mammoth;
    }, get useInquiryStore() {
      return useInquiryStore;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
};
const _hoisted_1$z = {
  ref: "editorContainer",
  class: "editor-container"
};
const _hoisted_2$m = { key: 0 };
const _hoisted_3$l = {
  key: 0,
  class: "editor-toolbar"
};
const _hoisted_4$h = ["disabled"];
const _hoisted_5$5 = ["disabled"];
const _hoisted_6$4 = { class: "editor-content-wrapper" };
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment$1,
    null,
    [
      createCommentVNode(" Main editor container that fills its parent "),
      createBaseVNode(
        "div",
        _hoisted_1$z,
        [
          createCommentVNode(" Toolbar with all major formatting options "),
          !$setup.props.readonly ? (openBlock(), createElementBlock("div", _hoisted_2$m, [
            $setup.editor ? (openBlock(), createElementBlock("div", _hoisted_3$l, [
              createCommentVNode(" Text formatting "),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("bold") }),
                  "aria-label": "Bold",
                  onClick: _cache[0] || (_cache[0] = ($event) => $setup.editor.chain().focus().toggleBold().run())
                },
                [..._cache[18] || (_cache[18] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "B",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("italic") }),
                  "aria-label": "Italic",
                  onClick: _cache[1] || (_cache[1] = ($event) => $setup.editor.chain().focus().toggleItalic().run())
                },
                [..._cache[19] || (_cache[19] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "I",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("underline") }),
                  "aria-label": "Underline",
                  onClick: _cache[2] || (_cache[2] = ($event) => $setup.editor.chain().focus().toggleUnderline().run())
                },
                [..._cache[20] || (_cache[20] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "U",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("strike") }),
                  "aria-label": "Strikethrough",
                  onClick: _cache[3] || (_cache[3] = ($event) => $setup.editor.chain().focus().toggleStrike().run())
                },
                [..._cache[21] || (_cache[21] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "S",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createCommentVNode(" Headings "),
              withDirectives(createBaseVNode(
                "select",
                {
                  "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $setup.selectedHeading = $event),
                  "aria-label": "Text heading",
                  onChange: $setup.setHeading
                },
                [..._cache[22] || (_cache[22] = [
                  createBaseVNode(
                    "option",
                    { value: "paragraph" },
                    "Paragraph",
                    -1
                    /* CACHED */
                  ),
                  createBaseVNode(
                    "option",
                    { value: "h1" },
                    "Heading 1",
                    -1
                    /* CACHED */
                  ),
                  createBaseVNode(
                    "option",
                    { value: "h2" },
                    "Heading 2",
                    -1
                    /* CACHED */
                  ),
                  createBaseVNode(
                    "option",
                    { value: "h3" },
                    "Heading 3",
                    -1
                    /* CACHED */
                  )
                ])],
                544
                /* NEED_HYDRATION, NEED_PATCH */
              ), [
                [vModelSelect, $setup.selectedHeading]
              ]),
              createCommentVNode(" Lists "),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("bulletList") }),
                  "aria-label": "Bullet list",
                  onClick: _cache[5] || (_cache[5] = ($event) => $setup.editor.chain().focus().toggleBulletList().run())
                },
                [..._cache[23] || (_cache[23] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "â¢",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("orderedList") }),
                  "aria-label": "Numbered list",
                  onClick: _cache[6] || (_cache[6] = ($event) => $setup.editor.chain().focus().toggleOrderedList().run())
                },
                [..._cache[24] || (_cache[24] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "1.",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("taskList") }),
                  "aria-label": "Task list",
                  onClick: _cache[7] || (_cache[7] = ($event) => $setup.editor.chain().focus().toggleTaskList().run())
                },
                [..._cache[25] || (_cache[25] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "â",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createCommentVNode(" Text alignment "),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive({ textAlign: "left" }) }),
                  "aria-label": "Align left",
                  onClick: _cache[8] || (_cache[8] = ($event) => $setup.editor.chain().focus().setTextAlign("left").run())
                },
                [..._cache[26] || (_cache[26] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "â",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({
                    "is-active": $setup.editor.isActive({ textAlign: "center" })
                  }),
                  "aria-label": "Align center",
                  onClick: _cache[9] || (_cache[9] = ($event) => $setup.editor.chain().focus().setTextAlign("center").run())
                },
                [..._cache[27] || (_cache[27] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "â",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive({ textAlign: "right" }) }),
                  "aria-label": "Align right",
                  onClick: _cache[10] || (_cache[10] = ($event) => $setup.editor.chain().focus().setTextAlign("right").run())
                },
                [..._cache[28] || (_cache[28] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "â",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createCommentVNode(" Advanced formatting "),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("blockquote") }),
                  "aria-label": "Blockquote",
                  onClick: _cache[11] || (_cache[11] = ($event) => $setup.editor.chain().focus().toggleBlockquote().run())
                },
                [..._cache[29] || (_cache[29] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "â",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode("button", {
                "aria-label": "Horizontal rule",
                onClick: _cache[12] || (_cache[12] = ($event) => $setup.editor.chain().focus().setHorizontalRule().run())
              }, [..._cache[30] || (_cache[30] = [
                createBaseVNode(
                  "span",
                  { class: "icon" },
                  "â",
                  -1
                  /* CACHED */
                )
              ])]),
              createBaseVNode("button", {
                "aria-label": "Hard break",
                onClick: _cache[13] || (_cache[13] = ($event) => $setup.editor.chain().focus().setHardBreak().run())
              }, [..._cache[31] || (_cache[31] = [
                createBaseVNode(
                  "span",
                  { class: "icon" },
                  "âµ",
                  -1
                  /* CACHED */
                )
              ])]),
              createCommentVNode(" Links and media "),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("link") }),
                  "aria-label": "Link",
                  onClick: $setup.setLink
                },
                [..._cache[32] || (_cache[32] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "ð",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode("button", {
                "aria-label": "Insert image",
                onClick: $setup.addImage
              }, [..._cache[33] || (_cache[33] = [
                createBaseVNode(
                  "span",
                  { class: "icon" },
                  "ð¼ï¸",
                  -1
                  /* CACHED */
                )
              ])]),
              createCommentVNode(" Code and special formatting "),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("code") }),
                  "aria-label": "Code",
                  onClick: _cache[14] || (_cache[14] = ($event) => $setup.editor.chain().focus().toggleCode().run())
                },
                [..._cache[34] || (_cache[34] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "{}",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createBaseVNode(
                "button",
                {
                  class: normalizeClass({ "is-active": $setup.editor.isActive("codeBlock") }),
                  "aria-label": "Code block",
                  onClick: _cache[15] || (_cache[15] = ($event) => $setup.editor.chain().focus().toggleCodeBlock().run())
                },
                [..._cache[35] || (_cache[35] = [
                  createBaseVNode(
                    "span",
                    { class: "icon" },
                    "â",
                    -1
                    /* CACHED */
                  )
                ])],
                2
                /* CLASS */
              ),
              createCommentVNode(" Undo/redo "),
              createBaseVNode("button", {
                disabled: !$setup.editor.can().undo(),
                "aria-label": "Undo",
                onClick: _cache[16] || (_cache[16] = ($event) => $setup.editor.chain().focus().undo().run())
              }, [..._cache[36] || (_cache[36] = [
                createBaseVNode(
                  "span",
                  { class: "icon" },
                  "â©",
                  -1
                  /* CACHED */
                )
              ])], 8, _hoisted_4$h),
              createBaseVNode("button", {
                disabled: !$setup.editor.can().redo(),
                "aria-label": "Redo",
                onClick: _cache[17] || (_cache[17] = ($event) => $setup.editor.chain().focus().redo().run())
              }, [..._cache[37] || (_cache[37] = [
                createBaseVNode(
                  "span",
                  { class: "icon" },
                  "âª",
                  -1
                  /* CACHED */
                )
              ])], 8, _hoisted_5$5),
              createCommentVNode(" Word import "),
              createBaseVNode("button", {
                "aria-label": "Import Word document",
                onClick: $setup.importWord
              }, [..._cache[38] || (_cache[38] = [
                createBaseVNode(
                  "span",
                  { class: "icon" },
                  "ð",
                  -1
                  /* CACHED */
                )
              ])]),
              createBaseVNode(
                "input",
                {
                  ref: "wordFileInput",
                  type: "file",
                  accept: ".docx",
                  style: { "display": "none" },
                  onChange: $setup.handleWordImport
                },
                null,
                544
                /* NEED_HYDRATION, NEED_PATCH */
              ),
              createCommentVNode(" AI integration "),
              createBaseVNode("button", {
                "aria-label": "Generate with AI",
                onClick: $setup.generateWithAI
              }, [..._cache[39] || (_cache[39] = [
                createBaseVNode(
                  "span",
                  { class: "icon" },
                  "ð¤",
                  -1
                  /* CACHED */
                )
              ])])
            ])) : createCommentVNode("v-if", true)
          ])) : createCommentVNode("v-if", true),
          createBaseVNode("div", _hoisted_6$4, [
            createCommentVNode(" The actual editor content "),
            createVNode($setup["EditorContent"], {
              editor: $setup.editor,
              class: "editor-content"
            }, null, 8, ["editor"])
          ])
        ],
        512
        /* NEED_PATCH */
      )
    ],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const InquiryEditor = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["render", _sfc_render$S], ["__scopeId", "data-v-0d9f3682"], ["__file", "/var/www/nextcloud/apps/agora/src/components/Editor/InquiryEditor.vue"]]);
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "InquiryEditViewForm",
  setup(__props, { expose: __expose }) {
    __expose();
    const sessionStore = useSessionStore();
    const commentsStore = useCommentsStore();
    const supportsStore = useSupportsStore();
    const inquiryStore = useInquiryStore();
    const inquiriesStore = useInquiriesStore();
    const router2 = useRouter();
    const context2 = computed(() => createPermissionContextForContent(
      ContentType.Inquiry,
      inquiryStore.owner.id,
      inquiryStore.configuration.access === "public",
      inquiryStore.status.isLocked,
      inquiryStore.status.isExpired,
      inquiryStore.status.deletionDate > 0,
      inquiryStore.status.isArchived,
      inquiryStore.inquiryGroups.length > 0,
      inquiryStore.inquiryGroups,
      inquiryStore.type
    ));
    const titleLabel = ref("");
    const selectedCategory = ref(inquiryStore.categoryId || 0);
    const selectedLocation = ref(inquiryStore.locationId || 0);
    const isSaving = ref(false);
    const isLoaded = ref(false);
    const hasSupported = computed(() => inquiryStore.currentUserStatus.hasSupported);
    const isReadonlyDescription = ref(true);
    function getHierarchyPath(items, targetId) {
      const itemMap = {};
      items.forEach((item) => {
        itemMap[item.id] = item;
      });
      if (!itemMap[targetId]) {
        return "ID not found";
      }
      function buildPath(item) {
        if (item.parentId === 0) {
          return item.name;
        }
        const parent = itemMap[item.parentId];
        if (parent) {
          return `${buildPath(parent)} -> ${item.name}`;
        }
        return item.name;
      }
      return buildPath(itemMap[targetId]);
    }
    watch(
      selectedLocation,
      (newVal) => {
        const rawValue = toRaw(newVal);
        if (rawValue) {
          inquiryStore.locationId = rawValue.value;
        }
      },
      { deep: true }
    );
    watch(
      selectedCategory,
      (newVal) => {
        const rawValue = toRaw(newVal);
        if (rawValue) {
          inquiryStore.categoryId = rawValue.value;
        }
      },
      { deep: true }
    );
    function buildHierarchy(list, parentId = 0, depth = 0) {
      if (!Array.isArray(list)) return [];
      return list.filter((item) => item?.parentId === parentId).map((item) => {
        const children = buildHierarchy(list, item.id, depth + 1);
        return {
          ...item,
          depth,
          children
        };
      }).flatMap((item) => [item, ...item.children]);
    }
    const hierarchicalLocation = computed(() => {
      if (!Array.isArray(sessionStore.appSettings.locationTab)) return [];
      return buildHierarchy(sessionStore.appSettings.locationTab).map((item) => ({
        value: item.id,
        label: `${"â ".repeat(item.depth ?? 0)}${item.name ?? "[no name]"}`,
        original: item
      }));
    });
    watch(
      hierarchicalLocation,
      (locations) => {
        if (!locations.length) return;
        if (inquiryStore.locationId === 0) {
          selectedLocation.value = locations[0];
          inquiryStore.locationId = locations[0].value;
        } else {
          const selected = locations.find((loc) => loc.value === inquiryStore.locationId);
          selectedLocation.value = selected || locations[0];
          inquiryStore.locationId = selected?.value || locations[0].value;
        }
      },
      { immediate: true }
    );
    const hierarchicalCategory = computed(() => {
      if (!Array.isArray(sessionStore.appSettings.categoryTab)) return [];
      return buildHierarchy(sessionStore.appSettings.categoryTab).map((item) => ({
        value: item.id,
        label: `${"â ".repeat(item.depth ?? 0)}${item.name ?? "[no name]"}`,
        original: item
      }));
    });
    watch(
      hierarchicalCategory,
      (categories) => {
        if (!categories.length) return;
        if (inquiryStore.categoryId === 0) {
          selectedCategory.value = categories[0];
          inquiryStore.categoryId = categories[0].value;
        } else {
          const selected = categories.find((loc) => loc.value === inquiryStore.categoryId);
          selectedCategory.value = selected || categories[0];
          inquiryStore.categoryId = selected?.value || categories[0].value;
        }
      },
      { immediate: true }
    );
    const isReadonly = computed(() => {
      const user = sessionStore.currentUser;
      if (!user) return true;
      const ronly = !canEdit(context2.value);
      return ronly;
    });
    watch(
      () => inquiryStore.type,
      (newType) => {
        if (newType === "debate") {
          isReadonlyDescription.value = false;
        } else {
          isReadonlyDescription.value = isReadonly.value;
        }
      },
      { immediate: true }
    );
    const onToggleSupport = async () => {
      const supported = supportsStore.toggleSupport(
        inquiryStore.id,
        sessionStore.currentUser.id,
        inquiryStore,
        inquiriesStore
      );
      if (inquiryStore.currentUserStatus.hasSupported) {
        showSuccess(translate("agora", "Thank for your support !"), { timeout: 2e3 });
      } else {
        showSuccess(translate("agora", "Inquiry support removed !"), { timeout: 2e3 });
      }
      return supported;
    };
    onMounted(() => {
      subscribe(Event$1.UpdateComments, () => commentsStore.load());
      isLoaded.value = true;
    });
    onUnmounted(() => {
      isLoaded.value = false;
      unsubscribe(Event$1.UpdateComments, () => commentsStore.load());
    });
    const saveChanges = async () => {
      if (isSaving.value) return;
      if (!inquiryStore.title || inquiryStore.title.trim() === "") {
        showError(translate("agora", "Title mandatory"), { timeout: 2e3 });
        return;
      }
      isSaving.value = true;
      try {
        await inquiryStore.update({
          id: inquiryStore.id,
          type: inquiryStore.type,
          title: inquiryStore.title,
          description: inquiryStore.description,
          categoryId: inquiryStore.categoryId,
          locationId: inquiryStore.locationId,
          parentId: inquiryStore.parentId
        });
        showSuccess(translate("agora", "The inquiry has been saved"), { timeout: 2e3 });
      } catch {
        showError(translate("agora", "Inquiry error during save !"), { timeout: 2e3 });
      } finally {
        isSaving.value = false;
      }
    };
    const showCategoryAsLabel = computed(() => {
      if (inquiryStore.parentId !== 0) return true;
      if (isReadonly.value) return true;
      return false;
    });
    const showLocationAsLabel = computed(() => {
      if (inquiryStore.parentId !== 0) return true;
      if (isReadonly.value) return true;
      return false;
    });
    const createChildInquiry = async (type) => {
      if (isSaving.value) return;
      titleLabel.value = ``;
      const confirmed = await confirmAction(
        `Do you really want to reply to this inquiry with a ${type} ?`
      );
      if (!confirmed) return;
      isSaving.value = true;
      if (type === "official")
        titleLabel.value = `${translate("agora", "Official response for ")}: ${inquiryStore.title.trim()}`;
      else titleLabel.value = `${translate("agora", "Response for ")}: ${inquiryStore.title.trim()}`;
      try {
        const inquiry = await inquiryStore.add({
          type,
          title: titleLabel.value,
          categoryId: inquiryStore.categoryId,
          locationId: inquiryStore.locationId,
          parentId: inquiryStore.id
        });
        if (inquiry) {
          showSuccess(translate("agora", "Inquiry {title} added", { title: inquiry.title }));
          router2.push({
            name: "inquiry",
            params: { id: inquiry.id }
          });
        }
      } catch (error) {
        console.error("Create child inquiry error:", error);
        showError(translate("agora", error instanceof Error ? error.message : "Inquiry error during save!"), {
          timeout: 2e3
        });
      } finally {
        isSaving.value = false;
      }
    };
    const allowedTypesForActions = computed(() => [
      InquiryTypeValues.PROJECT,
      InquiryTypeValues.PROPOSAL,
      InquiryTypeValues.GRIEVANCE
    ]);
    const showActionsMenu = computed(
      () => isReadonly.value && allowedTypesForActions.value.includes(inquiryStore.type)
    );
    const showResponseButton = computed(
      () => sessionStore.currentUser?.isOfficial && inquiryStore.type !== InquiryTypeValues.OFFICIAL
    );
    const showSaveButton = computed(() => !isReadonlyDescription.value);
    const __returned__ = { sessionStore, commentsStore, supportsStore, inquiryStore, inquiriesStore, router: router2, context: context2, titleLabel, selectedCategory, selectedLocation, isSaving, isLoaded, hasSupported, isReadonlyDescription, getHierarchyPath, buildHierarchy, hierarchicalLocation, hierarchicalCategory, isReadonly, onToggleSupport, saveChanges, showCategoryAsLabel, showLocationAsLabel, createChildInquiry, allowedTypesForActions, showActionsMenu, showResponseButton, showSaveButton, get t() {
      return translate;
    }, get InquiryTypesUI() {
      return InquiryTypesUI;
    }, get InquiryTypeValues() {
      return InquiryTypeValues;
    }, get NcSelect() {
      return NcSelect;
    }, get NcButton() {
      return NcButton;
    }, InquiryItemActions, get InputDiv() {
      return InputDiv;
    }, get ThumbIcon() {
      return ThumbIcon;
    }, InquiryEditor, get NcTextArea() {
      return NcTextArea;
    }, get NcRichText() {
      return NcRichText;
    }, get InquiryGeneralIcons() {
      return InquiryGeneralIcons;
    }, get canSupport() {
      return canSupport;
    }, get canComment() {
      return canComment;
    }, get canViewToggle() {
      return canViewToggle;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$y = {
  key: 0,
  class: "finalize-form-container"
};
const _hoisted_2$l = { class: "action-buttons" };
const _hoisted_3$k = { key: 2 };
const _hoisted_4$g = ["title"];
const _hoisted_5$4 = ["title"];
const _hoisted_6$3 = ["title"];
const _hoisted_7$3 = ["title"];
const _hoisted_8$3 = ["title"];
const _hoisted_9$2 = {
  key: 3,
  style: { display: "inline-block", position: "relative", marginLeft: "auto" }
};
const _hoisted_10$2 = { class: "inquiry-form" };
const _hoisted_11$2 = { class: "form-section" };
const _hoisted_12$1 = { class: "section-header" };
const _hoisted_13$1 = { class: "title-section" };
const _hoisted_14$1 = { class: "section-title" };
const _hoisted_15$1 = {
  key: 0,
  class: "title-content"
};
const _hoisted_16 = { class: "type-field inline" };
const _hoisted_17 = {
  key: 1,
  class: "title-content"
};
const _hoisted_18 = { class: "counters" };
const _hoisted_19 = {
  key: 0,
  class: "counter-item"
};
const _hoisted_20 = { class: "form-row double-columns" };
const _hoisted_21 = { class: "form-field" };
const _hoisted_22 = { class: "type-label" };
const _hoisted_23 = {
  key: 1,
  class: "readonly-value"
};
const _hoisted_24 = { class: "form-field" };
const _hoisted_25 = { class: "type-label" };
const _hoisted_26 = {
  key: 1,
  class: "readonly-value"
};
const _hoisted_27 = { key: 0 };
const _hoisted_28 = { class: "form-section" };
const _hoisted_29 = {
  class: "form-container",
  style: { "height": "500px" }
};
const _hoisted_30 = { class: "section-title" };
const _hoisted_31 = { key: 1 };
const _hoisted_32 = { class: "form-section" };
const _hoisted_33 = { class: "form-container" };
const _hoisted_34 = { class: "section-title" };
const _hoisted_35 = { key: 2 };
const _hoisted_36 = { class: "form-section" };
const _hoisted_37 = {
  class: "form-container",
  style: { "height": "500px" }
};
const _hoisted_38 = { class: "section-title" };
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return $setup.isLoaded ? (openBlock(), createElementBlock("div", _hoisted_1$y, [
    createBaseVNode("div", _hoisted_2$l, [
      createCommentVNode(" Save button moved to top right "),
      $setup.showSaveButton ? (openBlock(), createBlock($setup["NcButton"], {
        key: 0,
        disabled: $setup.isSaving,
        type: "button",
        color: "primary",
        class: "save-button",
        onClick: withModifiers($setup.saveChanges, ["prevent"])
      }, {
        default: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.t("agora", "Save")),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }, 8, ["disabled"])) : createCommentVNode("v-if", true),
      $setup.showResponseButton ? (openBlock(), createBlock($setup["NcButton"], {
        key: 1,
        class: "response-button",
        onClick: _cache[0] || (_cache[0] = ($event) => $setup.createChildInquiry($setup.InquiryTypeValues.OFFICIAL))
      }, {
        default: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.t("agora", "Official")),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      })) : createCommentVNode("v-if", true),
      $setup.showActionsMenu ? (openBlock(), createElementBlock("div", _hoisted_3$k, [
        $setup.inquiryStore.type === $setup.InquiryTypeValues.PROJECT ? (openBlock(), createElementBlock(
          Fragment$1,
          { key: 0 },
          [
            createBaseVNode("button", {
              class: "icon-button",
              title: $setup.t("agora", "Create Proposal"),
              onClick: _cache[1] || (_cache[1] = ($event) => $setup.createChildInquiry($setup.InquiryTypeValues.PROPOSAL))
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$setup.InquiryTypeValues.PROPOSAL].icon), { class: "icon" }))
            ], 8, _hoisted_4$g),
            createBaseVNode("button", {
              class: "icon-button",
              title: $setup.t("agora", "Create Grievance"),
              onClick: _cache[2] || (_cache[2] = ($event) => $setup.createChildInquiry($setup.InquiryTypeValues.GRIEVANCE))
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$setup.InquiryTypeValues.GRIEVANCE].icon), { class: "icon" }))
            ], 8, _hoisted_5$4)
          ],
          64
          /* STABLE_FRAGMENT */
        )) : $setup.inquiryStore.type === $setup.InquiryTypeValues.PROPOSAL ? (openBlock(), createElementBlock(
          Fragment$1,
          { key: 1 },
          [
            createBaseVNode("button", {
              class: "icon-button",
              title: $setup.t("agora", "Create Suggestion"),
              onClick: _cache[3] || (_cache[3] = ($event) => $setup.createChildInquiry($setup.InquiryTypeValues.SUGGESTION))
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$setup.InquiryTypeValues.SUGGESTION].icon), { class: "icon" }))
            ], 8, _hoisted_6$3),
            createBaseVNode("button", {
              class: "icon-button",
              title: $setup.t("agora", "Create Grievance"),
              onClick: _cache[4] || (_cache[4] = ($event) => $setup.createChildInquiry($setup.InquiryTypeValues.GRIEVANCE))
            }, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$setup.InquiryTypeValues.GRIEVANCE].icon), { class: "icon" }))
            ], 8, _hoisted_7$3)
          ],
          64
          /* STABLE_FRAGMENT */
        )) : $setup.inquiryStore.type === $setup.InquiryTypeValues.GRIEVANCE ? (openBlock(), createElementBlock("button", {
          key: 2,
          class: "icon-button",
          title: $setup.t("agora", "Create Suggestion"),
          onClick: _cache[5] || (_cache[5] = ($event) => $setup.createChildInquiry($setup.InquiryTypeValues.SUGGESTION))
        }, [
          (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryTypesUI[$setup.InquiryTypeValues.SUGGESTION].icon), { class: "icon" }))
        ], 8, _hoisted_8$3)) : createCommentVNode("v-if", true)
      ])) : createCommentVNode("v-if", true),
      $setup.canViewToggle($setup.context) ? (openBlock(), createElementBlock("div", _hoisted_9$2, [
        (openBlock(), createBlock($setup["InquiryItemActions"], {
          key: `actions-${$setup.inquiryStore.id}`,
          inquiry: $setup.inquiryStore
        }, null, 8, ["inquiry"]))
      ])) : createCommentVNode("v-if", true)
    ]),
    createBaseVNode("form", _hoisted_10$2, [
      createCommentVNode(" BLOCK: Basic Information "),
      createBaseVNode("div", _hoisted_11$2, [
        createBaseVNode("div", _hoisted_12$1, [
          createBaseVNode("div", _hoisted_13$1, [
            createBaseVNode(
              "span",
              _hoisted_14$1,
              toDisplayString($setup.t("agora", "Title")) + " :",
              1
              /* TEXT */
            ),
            $setup.isReadonly ? (openBlock(), createElementBlock("div", _hoisted_15$1, [
              createBaseVNode(
                "span",
                _hoisted_16,
                toDisplayString($setup.inquiryStore.title),
                1
                /* TEXT */
              )
            ])) : (openBlock(), createElementBlock("div", _hoisted_17, [
              createVNode($setup["InputDiv"], {
                modelValue: $setup.inquiryStore.title,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $setup.inquiryStore.title = $event),
                type: "text",
                disabled: $setup.isReadonly,
                readonly: $setup.isReadonly,
                class: "form-input"
              }, null, 8, ["modelValue", "disabled", "readonly"])
            ]))
          ]),
          createBaseVNode("div", _hoisted_18, [
            $setup.canComment($setup.context) ? (openBlock(), createElementBlock("div", _hoisted_19, [
              (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.comment), { size: 24 })),
              createBaseVNode(
                "span",
                null,
                toDisplayString($setup.commentsStore.comments.length || 0),
                1
                /* TEXT */
              )
            ])) : createCommentVNode("v-if", true),
            $setup.canSupport($setup.context) ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: "counter-item",
              onClick: $setup.onToggleSupport
            }, [
              createVNode($setup["ThumbIcon"], { supported: $setup.hasSupported }, null, 8, ["supported"]),
              createBaseVNode(
                "span",
                null,
                toDisplayString($setup.inquiryStore.status.countSupports || 0),
                1
                /* TEXT */
              )
            ])) : createCommentVNode("v-if", true)
          ])
        ]),
        createBaseVNode("div", _hoisted_20, [
          createBaseVNode("div", _hoisted_21, [
            createBaseVNode(
              "label",
              _hoisted_22,
              toDisplayString($setup.t("agora", "Location")) + " :",
              1
              /* TEXT */
            ),
            !$setup.showLocationAsLabel ? (openBlock(), createBlock($setup["NcSelect"], {
              key: 0,
              modelValue: $setup.selectedLocation,
              "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $setup.selectedLocation = $event),
              options: $setup.hierarchicalLocation,
              clearable: false,
              class: "select-field location-select narrow-select",
              required: ""
            }, null, 8, ["modelValue", "options"])) : (openBlock(), createElementBlock(
              "div",
              _hoisted_23,
              toDisplayString($setup.getHierarchyPath($setup.sessionStore.appSettings.locationTab, $setup.inquiryStore.locationId) || $setup.t("agora", "Inherited from parent")),
              1
              /* TEXT */
            ))
          ]),
          createBaseVNode("div", _hoisted_24, [
            createBaseVNode(
              "label",
              _hoisted_25,
              toDisplayString($setup.t("agora", "Category")) + " :",
              1
              /* TEXT */
            ),
            !$setup.showCategoryAsLabel ? (openBlock(), createBlock($setup["NcSelect"], {
              key: 0,
              modelValue: $setup.selectedCategory,
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $setup.selectedCategory = $event),
              options: $setup.hierarchicalCategory,
              clearable: false,
              class: "select-field category-select narrow-select",
              required: ""
            }, null, 8, ["modelValue", "options"])) : (openBlock(), createElementBlock(
              "div",
              _hoisted_26,
              toDisplayString($setup.getHierarchyPath($setup.sessionStore.appSettings.categoryTab, $setup.inquiryStore.categoryId) || $setup.t("agora", "Inherited from parent")),
              1
              /* TEXT */
            ))
          ])
        ])
      ]),
      createCommentVNode(" BLOCK: Editor/Description "),
      $setup.sessionStore.appSettings.inquiryTypeRights[$setup.inquiryStore.type].editorType === "wysiwyg" ? (openBlock(), createElementBlock("div", _hoisted_27, [
        createBaseVNode("div", _hoisted_28, [
          createBaseVNode("div", _hoisted_29, [
            createBaseVNode(
              "span",
              _hoisted_30,
              toDisplayString($setup.t("agora", "Detailed Description")),
              1
              /* TEXT */
            ),
            createVNode($setup["InquiryEditor"], {
              modelValue: $setup.inquiryStore.description,
              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $setup.inquiryStore.description = $event),
              readonly: $setup.isReadonlyDescription
            }, null, 8, ["modelValue", "readonly"])
          ])
        ])
      ])) : $setup.sessionStore.appSettings.inquiryTypeRights[$setup.inquiryStore.type].editorType === "texteditor" ? (openBlock(), createElementBlock("div", _hoisted_31, [
        createBaseVNode("div", _hoisted_32, [
          createBaseVNode("div", _hoisted_33, [
            createBaseVNode(
              "span",
              _hoisted_34,
              toDisplayString($setup.t("agora", "Detailed Description")),
              1
              /* TEXT */
            ),
            createVNode($setup["NcRichText"], {
              modelValue: $setup.inquiryStore.description,
              "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $setup.inquiryStore.description = $event),
              autolink: _ctx.autolink,
              arguments: _ctx.userMentions,
              "use-markdown": _ctx.useMarkdown,
              "use-extended-markdown": _ctx.useExtendedMarkdown,
              disabled: $setup.isReadonlyDescription,
              class: "w-full",
              style: { "min-height": "400px", "max-height": "500px" }
            }, null, 8, ["modelValue", "autolink", "arguments", "use-markdown", "use-extended-markdown", "disabled"])
          ])
        ])
      ])) : (openBlock(), createElementBlock("div", _hoisted_35, [
        createBaseVNode("div", _hoisted_36, [
          createBaseVNode("div", _hoisted_37, [
            createBaseVNode(
              "span",
              _hoisted_38,
              toDisplayString($setup.t("agora", "Detailed Description")),
              1
              /* TEXT */
            ),
            createVNode($setup["NcTextArea"], {
              modelValue: $setup.inquiryStore.description,
              "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => $setup.inquiryStore.description = $event),
              disabled: $setup.isReadonlyDescription,
              class: "w-full",
              style: { "min-height": "200px", "max-height": "300px" }
            }, null, 8, ["modelValue", "disabled"])
          ])
        ])
      ]))
    ])
  ])) : createCommentVNode("v-if", true);
}
const InquiryEditViewForm = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["render", _sfc_render$R], ["__scopeId", "data-v-9e316df6"], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/InquiryEditViewForm.vue"]]);
const _sfc_main$Q = {
  name: "HomeIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$x = ["aria-hidden", "aria-label"];
const _hoisted_2$k = ["fill", "width", "height"];
const _hoisted_3$j = { d: "M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z" };
const _hoisted_4$f = { key: 0 };
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon home-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$j, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$f,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$k))
  ], 16, _hoisted_1$x);
}
const HomeIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["render", _sfc_render$Q], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Home.vue"]]);
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "InquiryTransition",
  props: {
    isLoadedParent: {
      type: Boolean,
      required: true
    }
  },
  emits: ["editParent", "routeChild"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const props2 = __props;
    const inquiryParent = ref({
      id: null,
      title: "",
      type: "",
      created: null,
      lastInteraction: null,
      owner: "",
      inquiryGroups: [],
      participatedCount: 0,
      commentCount: 0,
      supportCount: 0
    });
    const router2 = useRouter();
    const inquiryStore = useInquiryStore();
    const commentsStore = useCommentsStore();
    const preferencesStore = usePreferencesStore();
    const isLoadedLocal = ref(false);
    const inquiry = ref(null);
    const hoveredInquiry = ref(null);
    const suggestions = ref([]);
    const grievances = ref([]);
    const proposals = ref([]);
    const officials = ref([]);
    const isMobile = ref(window.innerWidth < 768);
    const isGridView = computed(() => preferencesStore.user.defaultViewInquiry === "table-view");
    const emit2 = __emit;
    const editParent = () => {
      emit2("editParent");
    };
    const routeChild = (inquiryId) => {
      emit2("routeChild", inquiryId);
    };
    onMounted(async () => {
      if (props2.isLoadedParent) {
        try {
          isLoadedLocal.value = false;
          await loadInquiryData();
        } catch (error) {
          showError("Failed to load inquiry:", error);
        } finally {
          inquiryParent.value.id = inquiryStore.id;
          inquiryParent.value.parentId = inquiryStore.parentId;
          inquiryParent.value.title = inquiryStore.title;
          inquiryParent.value.type = inquiryStore.type;
          inquiryParent.value.owner = inquiryStore.owner;
          inquiryParent.value.moderationStatus = inquiryStore.moderationStatus;
          inquiryParent.value.status = inquiryStore.status;
          inquiryParent.value.configuration = inquiryStore.configuration;
          inquiryParent.value.currentUserStatus = inquiryStore.currentUserStatus;
          inquiryParent.value.commentCount = commentsStore.comments.length;
          inquiryParent.value.supportCount = inquiryStore.status.countSupports;
          inquiryParent.value.inquiryGroups = inquiryStore.inquiryGroups;
          isLoadedLocal.value = true;
        }
      }
      window.addEventListener("resize", handleResize);
    });
    const handleResize = () => {
      isMobile.value = window.innerWidth < 768;
    };
    function transformOwner(obj) {
      if (obj.owner && typeof obj.owner === "string") {
        obj.owner = {
          id: obj.owner,
          displayName: obj.owner
        };
      }
      return obj;
    }
    const loadInquiryData = async () => {
      suggestions.value = inquiryStore.childs.filter((c) => c.type === InquiryTypeValues.SUGGESTION).map(transformOwner);
      grievances.value = inquiryStore.childs.filter((c) => c.type === InquiryTypeValues.GRIEVANCE).map(transformOwner);
      proposals.value = inquiryStore.childs.filter((c) => c.type === InquiryTypeValues.PROPOSAL).map(transformOwner);
      officials.value = inquiryStore.childs.filter((c) => c.type === InquiryTypeValues.OFFICIAL).map(transformOwner);
      if (shouldRedirect.value) {
        router2.replace({ name: "inquiry", params: { id: inquiryStore.id } });
      }
      return true;
    };
    const shouldRedirect = computed(() => {
      if (!inquiryStore) return false;
      const simpleTypes = [
        InquiryTypeValues.SUGGESTION,
        InquiryTypeValues.DEBATE,
        InquiryTypeValues.PETITION
      ];
      return inquiryStore.participated === 0 && simpleTypes.includes(inquiryStore.type);
    });
    const navigateToRoot = () => {
      router2.push({ name: "root" });
    };
    const __returned__ = { props: props2, inquiryParent, router: router2, inquiryStore, commentsStore, preferencesStore, isLoadedLocal, inquiry, hoveredInquiry, suggestions, grievances, proposals, officials, isMobile, isGridView, emit: emit2, editParent, routeChild, handleResize, transformOwner, loadInquiryData, shouldRedirect, navigateToRoot, get t() {
      return translate;
    }, InquiryItem, get NcButton() {
      return NcButton;
    }, HomeIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$w = {
  key: 0,
  class: "loading-container"
};
const _hoisted_2$j = {
  key: 1,
  class: "transition-form-container"
};
const _hoisted_3$i = { class: "navigation-controls" };
const _hoisted_4$e = { key: 0 };
const _hoisted_5$3 = {
  key: 0,
  class: "parent-block"
};
const _hoisted_6$2 = { class: "block-title" };
const _hoisted_7$2 = { class: "parent-inquiry-container" };
const _hoisted_8$2 = {
  key: "suggestions",
  class: "block-container"
};
const _hoisted_9$1 = { class: "block-title" };
const _hoisted_10$1 = {
  key: "grievances",
  class: "block-container"
};
const _hoisted_11$1 = { class: "block-title" };
const _hoisted_12 = {
  key: "proposals",
  class: "block-container"
};
const _hoisted_13 = { class: "block-title" };
const _hoisted_14 = {
  key: 0,
  class: "official-block"
};
const _hoisted_15 = { class: "block-title" };
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return !$setup.isLoadedLocal ? (openBlock(), createElementBlock("div", _hoisted_1$w, [
    _cache[1] || (_cache[1] = createBaseVNode(
      "div",
      { class: "loading-spinner" },
      null,
      -1
      /* CACHED */
    )),
    createBaseVNode(
      "p",
      null,
      toDisplayString($setup.t("agora", "Loading inquiry...")),
      1
      /* TEXT */
    )
  ])) : (openBlock(), createElementBlock("div", _hoisted_2$j, [
    createCommentVNode(" Navigation "),
    createBaseVNode("div", _hoisted_3$i, [
      createVNode($setup["NcButton"], { onClick: $setup.navigateToRoot }, {
        default: withCtx(() => [
          createVNode($setup["HomeIcon"]),
          !$setup.isMobile ? (openBlock(), createElementBlock(
            "span",
            _hoisted_4$e,
            toDisplayString($setup.t("agora", "Home")),
            1
            /* TEXT */
          )) : createCommentVNode("v-if", true)
        ]),
        _: 1
        /* STABLE */
      })
    ]),
    createCommentVNode(" Parent Inquiry "),
    createVNode(Transition, { name: "fade" }, {
      default: withCtx(() => [
        $setup.isLoadedLocal ? (openBlock(), createElementBlock("div", _hoisted_5$3, [
          _cache[2] || (_cache[2] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createBaseVNode(
            "h3",
            _hoisted_6$2,
            toDisplayString($setup.t("agora", "Main Inquiry")),
            1
            /* TEXT */
          ),
          _cache[3] || (_cache[3] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createBaseVNode("div", _hoisted_7$2, [
            (openBlock(), createBlock($setup["InquiryItem"], {
              key: $setup.inquiryParent.id,
              inquiry: $setup.inquiryParent,
              "no-link": false,
              "grid-view": false,
              onClick: $setup.editParent,
              onMouseover: _cache[0] || (_cache[0] = ($event) => $setup.hoveredInquiry = $setup.inquiry)
            }, null, 8, ["inquiry"]))
          ])
        ])) : createCommentVNode("v-if", true)
      ]),
      _: 1
      /* STABLE */
    }),
    createCommentVNode(" Children Blocks "),
    createVNode(TransitionGroup, {
      name: "list",
      tag: "div",
      class: "children-blocks"
    }, {
      default: withCtx(() => [
        createCommentVNode(" Suggestions "),
        $setup.suggestions.length ? (openBlock(), createElementBlock("div", _hoisted_8$2, [
          _cache[4] || (_cache[4] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createBaseVNode(
            "h3",
            _hoisted_9$1,
            toDisplayString($setup.t("agora", "Suggestions")),
            1
            /* TEXT */
          ),
          _cache[5] || (_cache[5] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createVNode(TransitionGroup, {
            name: "list-inner",
            tag: "div",
            class: normalizeClass($setup.isGridView ? "inquiry-list__grid" : "inquiry-list__list")
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.suggestions, (child) => {
                  return openBlock(), createBlock($setup["InquiryItem"], {
                    key: child.id,
                    inquiry: child,
                    "no-link": false,
                    "grid-view": $setup.isGridView,
                    onClick: ($event) => $setup.routeChild(child.id)
                  }, null, 8, ["inquiry", "grid-view", "onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["class"])
        ])) : createCommentVNode("v-if", true),
        createCommentVNode(" Grievances "),
        $setup.grievances.length ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
          _cache[6] || (_cache[6] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createBaseVNode(
            "h3",
            _hoisted_11$1,
            toDisplayString($setup.t("agora", "Grievance")),
            1
            /* TEXT */
          ),
          _cache[7] || (_cache[7] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createVNode(TransitionGroup, {
            name: "list-inner",
            tag: "div",
            class: normalizeClass($setup.isGridView ? "inquiry-list__grid" : "inquiry-list__list")
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.grievances, (child) => {
                  return openBlock(), createBlock($setup["InquiryItem"], {
                    key: child.id,
                    inquiry: child,
                    "no-link": false,
                    "grid-view": $setup.isGridView,
                    onClick: ($event) => $setup.routeChild(child.id)
                  }, null, 8, ["inquiry", "grid-view", "onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["class"])
        ])) : createCommentVNode("v-if", true),
        createCommentVNode(" Proposals "),
        $setup.proposals.length ? (openBlock(), createElementBlock("div", _hoisted_12, [
          _cache[8] || (_cache[8] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createBaseVNode(
            "h3",
            _hoisted_13,
            toDisplayString($setup.t("agora", "Proposals")),
            1
            /* TEXT */
          ),
          _cache[9] || (_cache[9] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createVNode(TransitionGroup, {
            name: "list-inner",
            tag: "div",
            class: normalizeClass($setup.isGridView ? "inquiry-list__grid" : "inquiry-list__list")
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.proposals, (child) => {
                  return openBlock(), createBlock($setup["InquiryItem"], {
                    key: child.id,
                    inquiry: child,
                    "no-link": false,
                    "grid-view": $setup.isGridView,
                    onClick: ($event) => $setup.routeChild(child.id)
                  }, null, 8, ["inquiry", "grid-view", "onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["class"])
        ])) : createCommentVNode("v-if", true)
      ]),
      _: 1
      /* STABLE */
    }),
    createCommentVNode(" Official Block "),
    createVNode(Transition, { name: "fade" }, {
      default: withCtx(() => [
        $setup.officials.length ? (openBlock(), createElementBlock("div", _hoisted_14, [
          _cache[10] || (_cache[10] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createBaseVNode(
            "h3",
            _hoisted_15,
            toDisplayString($setup.t("agora", "Official Response")),
            1
            /* TEXT */
          ),
          _cache[11] || (_cache[11] = createBaseVNode(
            "div",
            { class: "divider" },
            null,
            -1
            /* CACHED */
          )),
          createVNode(TransitionGroup, {
            name: "list-inner",
            tag: "div",
            class: normalizeClass($setup.isGridView ? "inquiry-list__grid" : "inquiry-list__list")
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.officials, (child) => {
                  return openBlock(), createBlock($setup["InquiryItem"], {
                    key: child.id,
                    inquiry: child,
                    "no-link": false,
                    "grid-view": false,
                    onClick: ($event) => $setup.routeChild(child.id)
                  }, null, 8, ["inquiry", "onClick"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            _: 1
            /* STABLE */
          }, 8, ["class"])
        ])) : createCommentVNode("v-if", true)
      ]),
      _: 1
      /* STABLE */
    })
  ]));
}
const InquiryTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$P, [["render", _sfc_render$P], ["__scopeId", "data-v-9857c039"], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/InquiryTransition.vue"]]);
const _sfc_main$O = {
  name: "CalendarPlusIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$v = ["aria-hidden", "aria-label"];
const _hoisted_2$i = ["fill", "width", "height"];
const _hoisted_3$h = { d: "M19 19V8H5V19H19M16 1H18V3H19C20.11 3 21 3.9 21 5V19C21 20.11 20.11 21 19 21H5C3.89 21 3 20.1 3 19V5C3 3.89 3.89 3 5 3H6V1H8V3H16V1M11 9.5H13V12.5H16V14.5H13V17.5H11V14.5H8V12.5H11V9.5Z" };
const _hoisted_4$d = { key: 0 };
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon calendar-plus-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$h, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$d,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$i))
  ], 16, _hoisted_1$v);
}
const AddDateIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$O, [["render", _sfc_render$O], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/CalendarPlus.vue"]]);
const _sfc_main$N = /* @__PURE__ */ defineComponent({
  __name: "ActionAddOption",
  props: {
    caption: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const buttonAriaLabel = computed(() => __props.caption ?? translate("agora", "Add option"));
    async function clickAction() {
      emit(Event$1.AddDate, null);
    }
    const __returned__ = { buttonAriaLabel, clickAction, get NcButton() {
      return NcButton;
    }, AddDateIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$u = { class: "action option-date-add" };
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$u, [
    createVNode($setup["NcButton"], {
      variant: "primary",
      "aria-label": $setup.buttonAriaLabel,
      onClick: $setup.clickAction
    }, {
      icon: withCtx(() => [
        createVNode($setup["AddDateIcon"])
      ]),
      default: withCtx(() => [
        createTextVNode(
          toDisplayString($props.caption),
          1
          /* TEXT */
        )
      ]),
      _: 1
      /* STABLE */
    }, 8, ["aria-label"])
  ]);
}
const ActionAddOption = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["render", _sfc_render$N], ["__file", "/var/www/nextcloud/apps/agora/src/components/Actions/modules/ActionAddOption.vue"]]);
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "OptionsTextAdd",
  props: {
    placeholder: { type: String, required: false, default: () => translate("agora", "Add option") }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const optionsStore = useOptionsStore();
    const newInquiryText = ref("");
    async function addOption() {
      if (newInquiryText.value) {
        try {
          await optionsStore.add({ text: newInquiryText.value });
          showSuccess(
            translate("agora", "{optionText} added", {
              optionText: newInquiryText.value
            })
          );
          newInquiryText.value = "";
        } catch (error) {
          if (error.response?.status === 409) {
            showError(
              translate("agora", "{optionText} already exists", {
                optionText: newInquiryText.value
              })
            );
          } else {
            showError(
              translate("agora", "Error adding {optionText}", {
                optionText: newInquiryText.value
              })
            );
          }
        }
      }
    }
    const __returned__ = { optionsStore, newInquiryText, addOption, get InputDiv() {
      return InputDiv;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["InputDiv"], {
    modelValue: $setup.newInquiryText,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.newInquiryText = $event),
    placeholder: $props.placeholder,
    submit: "",
    onSubmit: _cache[1] || (_cache[1] = ($event) => $setup.addOption())
  }, null, 8, ["modelValue", "placeholder"]);
}
const OptionsTextAdd = /* @__PURE__ */ _export_sfc$1(_sfc_main$M, [["render", _sfc_render$M], ["__file", "/var/www/nextcloud/apps/agora/src/components/Options/OptionsTextAdd.vue"]]);
const cardType$4 = "info";
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "CardAddSuggestions",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const optionAddDatesModalProps = {
      caption: translate("agora", "Add"),
      showCaption: true,
      primary: true
    };
    const __returned__ = { inquiryStore, cardType: cardType$4, optionAddDatesModalProps, get CardDiv() {
      return CardDiv;
    }, get t() {
      return translate;
    }, ActionAddOption, OptionsTextAdd };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$t = { key: 0 };
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    $setup["CardDiv"],
    { type: $setup.cardType },
    createSlots({
      default: withCtx(() => [
        createTextVNode(
          toDisplayString($setup.t("agora", "You are asked to propose more options.")) + " ",
          1
          /* TEXT */
        ),
        $setup.inquiryStore.isSuggestionExpirySet && !$setup.inquiryStore.isSuggestionExpired ? (openBlock(), createElementBlock(
          "p",
          _hoisted_1$t,
          toDisplayString($setup.t("agora", "The suggestion period ends {timeRelative}.", {
            timeRelative: $setup.inquiryStore.suggestionsExpireRelative
          })),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true),
        $setup.inquiryStore.type === "textInquiry" ? (openBlock(), createBlock($setup["OptionsTextAdd"], {
          key: 1,
          placeholder: $setup.t("agora", "Propose an option")
        }, null, 8, ["placeholder"])) : createCommentVNode("v-if", true)
      ]),
      _: 2
      /* DYNAMIC */
    }, [
      $setup.inquiryStore.type === "dateInquiry" ? {
        name: "button",
        fn: withCtx(() => [
          createVNode(
            $setup["ActionAddOption"],
            normalizeProps(guardReactiveProps($setup.optionAddDatesModalProps)),
            null,
            16
            /* FULL_PROPS */
          )
        ]),
        key: "0"
      } : void 0
    ]),
    1024
    /* DYNAMIC_SLOTS */
  );
}
const CardAddSuggestions = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["render", _sfc_render$L], ["__file", "/var/www/nextcloud/apps/agora/src/components/Cards/modules/CardAddSuggestions.vue"]]);
const cardType$3 = "warning";
const _sfc_main$K = /* @__PURE__ */ defineComponent({
  __name: "CardClosedInquiry",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const __returned__ = { inquiryStore, cardType: cardType$3, get CardDiv() {
      return CardDiv;
    }, get t() {
      return translate;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$s = { key: 0 };
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["CardDiv"], { type: $setup.cardType }, {
    default: withCtx(() => [
      createTextVNode(
        toDisplayString($setup.t("agora", "This inquiry is closed.")) + " ",
        1
        /* TEXT */
      ),
      !$setup.inquiryStore.permissions.edit ? (openBlock(), createElementBlock(
        "span",
        _hoisted_1$s,
        toDisplayString($setup.t("agora", "No further action is possible.")),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  });
}
const CardClosedInquiry = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["render", _sfc_render$K], ["__file", "/var/www/nextcloud/apps/agora/src/components/Cards/modules/CardClosedInquiry.vue"]]);
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "CardLimitedInquiries",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const optionsStore = useOptionsStore();
    const orphanedInquiriesText = computed(
      () => translatePlural(
        "inquiries",
        "%n orphaned inquiry reduces your inquiry quota.",
        "%n orphaned inquiries reduce your inquiry quota.",
        inquiryStore.currentUserStatus.orphanedInquiries
      )
    );
    const inquiriesLeft = computed(
      () => inquiryStore.configuration.maxInquiriesPerUser - inquiryStore.currentUserStatus.yesInquiries > 0 ? inquiryStore.configuration.maxInquiriesPerUser - inquiryStore.currentUserStatus.yesInquiries : 0
    );
    const optionsAvailableText = computed(() => {
      if (optionsStore.countOptionsLeft === 0) {
        return translate("agora", "No more voting options are available.");
      }
      return translatePlural(
        "inquiries",
        "%n voting option is available.",
        "%n voting options are available.",
        optionsStore.countOptionsLeft
      );
    });
    const inquiriesLeftText = computed(() => {
      if (!inquiriesLeft.value) {
        return translate("agora", "You have no inquiries left.");
      }
      return translatePlural(
        "inquiries",
        "You have %n inquiry left out of {maxInquiries}.",
        "You have %n inquiries left out of {maxInquiries}.",
        inquiriesLeft.value,
        {
          maxInquiries: inquiryStore.configuration.maxInquiriesPerUser
        }
      );
    });
    const cardType2 = computed(
      () => inquiryStore.configuration.maxInquiriesPerUser && inquiriesLeft.value < 1 ? "error" : "info"
    );
    const __returned__ = { inquiryStore, optionsStore, orphanedInquiriesText, inquiriesLeft, optionsAvailableText, inquiriesLeftText, cardType: cardType2, get CardDiv() {
      return CardDiv;
    }, ActionDeleteOrphanedInquiries, get t() {
      return translate;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$r = { key: 0 };
const _hoisted_2$h = { key: 1 };
const _hoisted_3$g = { key: 2 };
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["CardDiv"], {
    heading: $setup.t("agora", "Limited inquiries."),
    type: $setup.cardType
  }, createSlots({
    default: withCtx(() => [
      $setup.inquiryStore.configuration.maxInquiriesPerOption ? (openBlock(), createElementBlock(
        "span",
        _hoisted_1$r,
        toDisplayString($setup.optionsAvailableText),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      $setup.inquiryStore.configuration.maxInquiriesPerUser ? (openBlock(), createElementBlock(
        "span",
        _hoisted_2$h,
        toDisplayString($setup.inquiriesLeftText),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      $setup.inquiryStore.currentUserStatus.orphanedInquiries && $setup.inquiryStore.configuration.maxInquiriesPerUser ? (openBlock(), createElementBlock("div", _hoisted_3$g, [
        createBaseVNode(
          "b",
          null,
          toDisplayString($setup.orphanedInquiriesText),
          1
          /* TEXT */
        )
      ])) : createCommentVNode("v-if", true)
    ]),
    _: 2
    /* DYNAMIC */
  }, [
    $setup.inquiryStore.currentUserStatus.orphanedInquiries && $setup.inquiryStore.configuration.maxInquiriesPerUser ? {
      name: "button",
      fn: withCtx(() => [
        createVNode($setup["ActionDeleteOrphanedInquiries"])
      ]),
      key: "0"
    } : void 0
  ]), 1032, ["heading", "type"]);
}
const CardLimitedInquiries = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["render", _sfc_render$J], ["__scopeId", "data-v-9dcb7d86"], ["__file", "/var/www/nextcloud/apps/agora/src/components/Cards/modules/CardLimitedInquiries.vue"]]);
const cardType$2 = "warning";
const _sfc_main$I = /* @__PURE__ */ defineComponent({
  __name: "CardLocked",
  setup(__props, { expose: __expose }) {
    __expose();
    const sessionStore = useSessionStore();
    const cardText = computed(
      () => sessionStore.route.name === "publicInquiry" ? translate(
        "inquiries",
        "This share is locked and allows only read access. Registering is not possible."
      ) : translate("agora", "Voting is locked and you have just read access to this inquiry.")
    );
    const __returned__ = { sessionStore, cardType: cardType$2, cardText, get CardDiv() {
      return CardDiv;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["CardDiv"], { type: $setup.cardType }, {
    default: withCtx(() => [
      createTextVNode(
        toDisplayString($setup.cardText),
        1
        /* TEXT */
      )
    ]),
    _: 1
    /* STABLE */
  });
}
const CardLocked = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["render", _sfc_render$I], ["__file", "/var/www/nextcloud/apps/agora/src/components/Cards/modules/CardLocked.vue"]]);
const cardType$1 = "info";
const _sfc_main$H = /* @__PURE__ */ defineComponent({
  __name: "CardRegister",
  setup(__props, { expose: __expose }) {
    __expose();
    const sessionStore = useSessionStore();
    const registrationInvitationText = computed(() => {
      if (sessionStore.share?.publicInquiryEmail === "mandatory") {
        return translate("inquiries", "To participate, register with your email address and a name.");
      }
      if (sessionStore.share?.publicInquiryEmail === "optional") {
        return translate("inquiries", "To participate, register a name and optionally with your email address.");
      }
      return translate("agora", "To participate, register with a name.");
    });
    const __returned__ = { sessionStore, cardType: cardType$1, registrationInvitationText, get CardDiv() {
      return CardDiv;
    }, ActionRegister };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["CardDiv"], { type: $setup.cardType }, {
    button: withCtx(() => [
      createVNode($setup["ActionRegister"])
    ]),
    default: withCtx(() => [
      createTextVNode(
        toDisplayString($setup.registrationInvitationText) + " ",
        1
        /* TEXT */
      )
    ]),
    _: 1
    /* STABLE */
  });
}
const CardRegister = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["render", _sfc_render$H], ["__file", "/var/www/nextcloud/apps/agora/src/components/Cards/modules/CardRegister.vue"]]);
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "CardSendConfirmations",
  emits: ["sendConfirmationSuccess", "sendConfirmationError"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const cardType2 = ref("info");
    const confirmationSendMessage = ref(
      translate("inquiries", "You have confirmed options. Inform your participants about the result via email.")
    );
    function confirmationSendError() {
      cardType2.value = "error";
      confirmationSendMessage.value = translate("inquiries", "Some confirmation messages could not been sent.");
      emit2("sendConfirmationSuccess");
    }
    function confirmationSendSuccess() {
      cardType2.value = "success";
      confirmationSendMessage.value = translate("agora", "Messages sent.");
      emit2("sendConfirmationError");
    }
    const __returned__ = { emit: emit2, cardType: cardType2, confirmationSendMessage, confirmationSendError, confirmationSendSuccess, get CardDiv() {
      return CardDiv;
    }, ActionSendConfirmed };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["CardDiv"], { type: $setup.cardType }, {
    button: withCtx(() => [
      createVNode($setup["ActionSendConfirmed"], {
        onError: _cache[0] || (_cache[0] = ($event) => $setup.confirmationSendError()),
        onSuccess: _cache[1] || (_cache[1] = ($event) => $setup.confirmationSendSuccess())
      })
    ]),
    default: withCtx(() => [
      createTextVNode(
        toDisplayString($setup.confirmationSendMessage) + " ",
        1
        /* TEXT */
      )
    ]),
    _: 1
    /* STABLE */
  }, 8, ["type"]);
}
const CardSendConfirmations = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["render", _sfc_render$G], ["__file", "/var/www/nextcloud/apps/agora/src/components/Cards/modules/CardSendConfirmations.vue"]]);
const cardType = "warning";
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  __name: "CardUnpublishedInquiry",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiriesStore = useInquiriesStore();
    const __returned__ = { inquiriesStore, cardType, get CardDiv() {
      return CardDiv;
    }, ActionOpenSharesSidebar, get t() {
      return translate;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$q = { key: 0 };
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["CardDiv"], { type: $setup.cardType }, {
    button: withCtx(() => [
      createVNode($setup["ActionOpenSharesSidebar"])
    ]),
    default: withCtx(() => [
      createTextVNode(
        toDisplayString($setup.t("agora", "This inquiry is unpublished.")) + " ",
        1
        /* TEXT */
      ),
      $setup.inquiriesStore.inquiries.length ? (openBlock(), createElementBlock(
        "span",
        _hoisted_1$q,
        toDisplayString($setup.t("agora", "Existing participants will still have access.")),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      createTextVNode(
        " " + toDisplayString($setup.t("agora", "Invite users or allow internal access for all site users.")) + " ",
        1
        /* TEXT */
      )
    ]),
    _: 1
    /* STABLE */
  });
}
const CardUnpublishedInquiry = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["render", _sfc_render$F], ["__file", "/var/www/nextcloud/apps/agora/src/components/Cards/modules/CardUnpublishedInquiry.vue"]]);
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "InquiryInfoCards",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const optionsStore = useOptionsStore();
    const sharesStore = useSharesStore();
    const sessionStore = useSessionStore();
    const showUnpublishedInquiryCard = computed(
      () => inquiryStore.configuration.access === "private" && !sharesStore.hasShares && inquiryStore.permissions.edit && optionsStore.options.length
    );
    const showAddSuggestionsCard = computed(
      () => inquiryStore.permissions.addOptions && inquiryStore.isSuggestionOpen && !inquiryStore.isClosed
    );
    const showClosedCard = computed(() => inquiryStore.isClosed && !showSendConfirmationsCard.value);
    const showSendConfirmationsCard = computed(
      () => inquiryStore.permissions.edit && inquiryStore.isClosed && optionsStore.confirmed.length > 0
    );
    const showLimitCard = computed(
      () => inquiryStore.permissions.inquiry && !inquiryStore.isClosed && (inquiryStore.configuration.maxInquiriesPerOption || inquiryStore.configuration.maxInquiriesPerUser)
    );
    const showRegisterCard = computed(
      () => sessionStore.route.name === "publicInquiry" && ["public", "email", "contact"].includes(inquiryStore.currentUserStatus.userRole) && !inquiryStore.isClosed && !inquiryStore.currentUserStatus.isLocked && !!inquiryStore.id
    );
    const __returned__ = { inquiryStore, optionsStore, sharesStore, sessionStore, showUnpublishedInquiryCard, showAddSuggestionsCard, showClosedCard, showSendConfirmationsCard, showLimitCard, showRegisterCard, get CardAddSuggestions() {
      return CardAddSuggestions;
    }, get CardClosedInquiry() {
      return CardClosedInquiry;
    }, get CardLimitedInquiries() {
      return CardLimitedInquiries;
    }, get CardLocked() {
      return CardLocked;
    }, get CardRegister() {
      return CardRegister;
    }, get CardSendConfirmations() {
      return CardSendConfirmations;
    }, get CardUnpublishedInquiry() {
      return CardUnpublishedInquiry;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(TransitionGroup, {
    tag: "div",
    class: "inquiry-info-cards"
  }, {
    default: withCtx(() => [
      $setup.showLimitCard ? (openBlock(), createBlock($setup["CardLimitedInquiries"], { key: 2 })) : createCommentVNode("v-if", true),
      $setup.showUnpublishedInquiryCard ? (openBlock(), createBlock($setup["CardUnpublishedInquiry"], { key: 0 })) : createCommentVNode("v-if", true),
      $setup.showClosedCard ? (openBlock(), createBlock($setup["CardClosedInquiry"], { key: 3 })) : createCommentVNode("v-if", true),
      $setup.inquiryStore.currentUserStatus.isLocked ? (openBlock(), createBlock($setup["CardLocked"], { key: 5 })) : createCommentVNode("v-if", true),
      $setup.showAddSuggestionsCard ? (openBlock(), createBlock($setup["CardAddSuggestions"], { key: 1 })) : createCommentVNode("v-if", true),
      $setup.showSendConfirmationsCard ? (openBlock(), createBlock($setup["CardSendConfirmations"], { key: 4 })) : createCommentVNode("v-if", true),
      $setup.showRegisterCard ? (openBlock(), createBlock($setup["CardRegister"], { key: 6 })) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  });
}
const InquiryInfoCards = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["render", _sfc_render$E], ["__scopeId", "data-v-e010057f"], ["__file", "/var/www/nextcloud/apps/agora/src/components/Cards/InquiryInfoCards.vue"]]);
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "InquiryView",
  setup(__props, { expose: __expose }) {
    __expose();
    const forceRenderKey = ref(0);
    const route = useRoute();
    const router2 = useRouter();
    const inquiryStore = useInquiryStore();
    const inquiriesStore = useInquiriesStore();
    const tableSticky = ref(false);
    const editMode = ref(false);
    const isAppLoaded = ref(false);
    const showMore = computed(
      () => inquiriesStore.chunkedList.length < inquiriesStore.inquiriesFilteredSorted.length && inquiriesStore.meta.status !== "loading"
    );
    const formatDate = (timestamp) => DateTime.fromMillis(timestamp * 1e3).toLocaleString(DateTime.DATE_SHORT);
    const countLoadedInquiries = computed(
      () => Math.min(inquiriesStore.chunkedList.length, inquiriesStore.inquiriesFilteredSorted.length)
    );
    const closeToClosing = computed(() => {
      if (!inquiryStore.configuration.expire) return false;
      const expireTime = inquiryStore.configuration.expire * 1e3;
      const timeUntilExpire = expireTime - Date.now();
      return timeUntilExpire < 864e5 && timeUntilExpire > 0;
    });
    const timeExpirationRelative = computed(() => {
      if (inquiryStore.configuration.expire) {
        return hooks.unix(inquiryStore.configuration.expire).fromNow();
      }
      return translate("agora", "never");
    });
    const infoLoaded = computed(
      () => translatePlural(
        "agora",
        "{loadedInquiries} of {countInquiries} inquiry loaded.",
        "{loadedInquiries} of {countInquiries} inquiries loaded.",
        inquiriesStore.inquiriesFilteredSorted.length,
        {
          loadedInquiries: countLoadedInquiries.value,
          countInquiries: inquiriesStore.inquiriesFilteredSorted.length
        }
      )
    );
    async function routeChild(childId) {
      router2.push({ name: "inquiry", params: { id: childId } });
    }
    async function loadInquiry(id) {
      try {
        const response = await inquiryStore.load(id);
        const result2 = inquiriesStore.inquiries.filter(
          (i) => i.parentId === Number(id) && i.configuration.access !== "private"
        );
        inquiryStore.childs = result2;
        if (inquiryStore.childs.length === 0) {
          inquiryStore.status.forceEditMode = true;
          editMode.value = true;
        } else {
          inquiryStore.status.forceEditMode = false;
          editMode.value = false;
        }
        await nextTick();
        forceRenderKey.value += 1;
      } catch (error) {
        console.error("Loading error:", error);
        showError(translate("agora", "Failed to load inquiry"));
      } finally {
        isAppLoaded.value = true;
      }
    }
    function loadMore() {
    }
    watch(
      () => route.params.id,
      async (newId) => {
        isAppLoaded.value = false;
        await loadInquiry(newId);
      },
      { immediate: true }
    );
    const enableEditMode = () => {
      editMode.value = true;
      inquiryStore.status.forceEditMode = true;
    };
    onBeforeRouteUpdate(async (to2, from3, next) => {
      if (to2.params.id) {
        inquiryStore.reset();
      }
      next();
      emit("transitions-off", 500);
    });
    onUnmounted(() => {
      inquiryStore.reset();
      unsubscribe("load-inquiry", () => {
      });
    });
    const loadingOverlayProps = {
      name: translate("agora", "Loading inquiryâ¦"),
      teleportTo: "#content-vue",
      loadingTexts: [
        translate("agora", "Fetching configurationâ¦"),
        translate("agora", "Collecting elementsâ¦"),
        translate("agora", "Checking accessâ¦"),
        translate("agora", "Almost readyâ¦"),
        translate("agora", "Do not go awayâ¦"),
        translate("agora", "This seems to be a huge inquiry, please be patientâ¦")
      ]
    };
    const isShortDescription = computed(() => {
      if (!inquiryStore.description) return true;
      return inquiryStore.description.split(" ").length < 20 && inquiryStore.description.split(/\r\n|\r|\n/).length < 5;
    });
    const collapsibleProps = computed(() => ({
      noCollapse: !inquiryStore.configuration.collapseDescription || isShortDescription.value,
      initialState: inquiryStore.currentUserStatus.countInquiries === 0 ? "max" : "min"
    }));
    const __returned__ = { forceRenderKey, route, router: router2, inquiryStore, inquiriesStore, tableSticky, editMode, isAppLoaded, showMore, formatDate, countLoadedInquiries, closeToClosing, timeExpirationRelative, infoLoaded, routeChild, loadInquiry, loadMore, enableEditMode, loadingOverlayProps, isShortDescription, collapsibleProps, get t() {
      return translate;
    }, get NcAppContent() {
      return NcAppContent;
    }, get NcUserBubble() {
      return NcUserBubble;
    }, InquiryInfoLine, InquiryHeaderButtons, LoadingOverlay, HeaderBar, InquiryEditViewForm, InquiryTransition, Collapsible, IntersectionObserver: IntersectionObserver$1, InquiryInfoCards, get StatusIcons() {
      return StatusIcons;
    }, get InquiryGeneralIcons() {
      return InquiryGeneralIcons;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$p = { class: "header-left-content" };
const _hoisted_2$g = { class: "header-right-content" };
const _hoisted_3$f = { class: "dates-container" };
const _hoisted_4$c = ["title"];
const _hoisted_5$2 = { class: "date-label" };
const _hoisted_6$1 = ["title"];
const _hoisted_7$1 = { class: "date-label" };
const _hoisted_8$1 = ["title"];
const _hoisted_9 = { class: "date-label" };
const _hoisted_10 = { class: "area__main" };
const _hoisted_11 = { class: "view-content" };
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return $setup.isAppLoaded ? (openBlock(), createBlock($setup["NcAppContent"], {
    key: $setup.forceRenderKey,
    class: "inquiry-list"
  }, {
    default: withCtx(() => [
      $setup.editMode ? (openBlock(), createBlock($setup["HeaderBar"], { key: 0 }, {
        avatar: withCtx(() => [
          createBaseVNode("div", _hoisted_1$p, [
            (openBlock(), createBlock(resolveDynamicComponent($setup.NcUserBubble), {
              user: $setup.inquiryStore.owner.id,
              "display-name": $setup.inquiryStore.owner.displayName,
              size: 32
            }, null, 8, ["user", "display-name"]))
          ])
        ]),
        right: withCtx(() => [
          createBaseVNode("div", _hoisted_2$g, [
            createBaseVNode("div", _hoisted_3$f, [
              $setup.inquiryStore.status?.created ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "metadata-item",
                title: $setup.t("agora", "Created on {date}", {
                  date: $setup.formatDate($setup.inquiryStore.status.created)
                })
              }, [
                (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.Calendar), { size: 16 })),
                createBaseVNode(
                  "span",
                  _hoisted_5$2,
                  toDisplayString($setup.formatDate($setup.inquiryStore.status.created)),
                  1
                  /* TEXT */
                )
              ], 8, _hoisted_4$c)) : createCommentVNode("v-if", true),
              $setup.inquiryStore.status?.lastInteraction ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: "metadata-item",
                title: $setup.t("agora", "Last interaction on {date}", {
                  date: $setup.formatDate($setup.inquiryStore.status.lastInteraction)
                })
              }, [
                (openBlock(), createBlock(resolveDynamicComponent($setup.StatusIcons.Updated), { size: 16 })),
                createBaseVNode(
                  "span",
                  _hoisted_7$1,
                  toDisplayString($setup.formatDate($setup.inquiryStore.status.lastInteraction)),
                  1
                  /* TEXT */
                )
              ], 8, _hoisted_6$1)) : createCommentVNode("v-if", true),
              createBaseVNode("div", {
                id: "expiring",
                class: normalizeClass(["metadata-item", $setup.closeToClosing ? "closing" : "open"]),
                title: $setup.t("agora", "Closing {relativeExpirationTime}", {
                  relativeExpirationTime: $setup.timeExpirationRelative
                })
              }, [
                (openBlock(), createBlock(resolveDynamicComponent($setup.InquiryGeneralIcons.expiration), { size: 16 })),
                createBaseVNode(
                  "span",
                  _hoisted_9,
                  toDisplayString($setup.t("agora", "Closing {relativeExpirationTime}", {
                    relativeExpirationTime: $setup.timeExpirationRelative
                  })),
                  1
                  /* TEXT */
                )
              ], 10, _hoisted_8$1)
            ])
          ]),
          createVNode($setup["InquiryHeaderButtons"])
        ]),
        _: 1
        /* STABLE */
      })) : createCommentVNode("v-if", true),
      $setup.editMode ? (openBlock(), createBlock($setup["InquiryInfoLine"], { key: 1 })) : createCommentVNode("v-if", true),
      createBaseVNode("div", _hoisted_10, [
        $setup.inquiryStore.viewMode === "table-view" ? (openBlock(), createBlock($setup["IntersectionObserver"], {
          key: 0,
          id: "table-observer",
          modelValue: $setup.tableSticky,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.tableSticky = $event)
        }, null, 8, ["modelValue"])) : createCommentVNode("v-if", true),
        $setup.inquiryStore.description ? (openBlock(), createBlock(
          $setup["Collapsible"],
          mergeProps({
            key: 1,
            class: "sticky-left"
          }, $setup.collapsibleProps),
          null,
          16
          /* FULL_PROPS */
        )) : createCommentVNode("v-if", true),
        createBaseVNode("div", _hoisted_11, [
          $setup.editMode ? (openBlock(), createBlock($setup["InquiryEditViewForm"], { key: 0 })) : (openBlock(), createBlock($setup["InquiryTransition"], {
            key: 1,
            "is-loaded-parent": $setup.isAppLoaded,
            onRouteChild: $setup.routeChild,
            onEditParent: $setup.enableEditMode
          }, null, 8, ["is-loaded-parent"]))
        ]),
        createVNode($setup["InquiryInfoCards"], { class: "sticky-left" }),
        $setup.showMore ? (openBlock(), createBlock($setup["IntersectionObserver"], {
          key: "observer",
          class: "observer_section",
          onVisible: $setup.loadMore
        }, {
          default: withCtx(() => [
            createBaseVNode(
              "div",
              {
                class: "clickable_load_more",
                onClick: $setup.loadMore
              },
              toDisplayString($setup.infoLoaded) + " " + toDisplayString($setup.t("agora", "Click here to load more")),
              1
              /* TEXT */
            )
          ]),
          _: 1
          /* STABLE */
        })) : createCommentVNode("v-if", true)
      ]),
      createVNode($setup["LoadingOverlay"], mergeProps({
        show: $setup.inquiryStore.meta.status === "loading"
      }, $setup.loadingOverlayProps), null, 16, ["show"])
    ]),
    _: 1
    /* STABLE */
  })) : createCommentVNode("v-if", true);
}
const InquiryView = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["render", _sfc_render$D], ["__file", "/var/www/nextcloud/apps/agora/src/views/InquiryView.vue"]]);
const _sfc_main$C = {
  name: "ShareVariantIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$o = ["aria-hidden", "aria-label"];
const _hoisted_2$f = ["fill", "width", "height"];
const _hoisted_3$e = { d: "M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L15.96,7.19C16.5,7.69 17.21,8 18,8A3,3 0 0,0 21,5A3,3 0 0,0 18,2A3,3 0 0,0 15,5C15,5.24 15.04,5.47 15.09,5.7L8.04,9.81C7.5,9.31 6.79,9 6,9A3,3 0 0,0 3,12A3,3 0 0,0 6,15C6.79,15 7.5,14.69 8.04,14.19L15.16,18.34C15.11,18.55 15.08,18.77 15.08,19C15.08,20.61 16.39,21.91 18,21.91C19.61,21.91 20.92,20.61 20.92,19A2.92,2.92 0 0,0 18,16.08Z" };
const _hoisted_4$b = { key: 0 };
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon share-variant-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$e, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$b,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$f))
  ], 16, _hoisted_1$o);
}
const SidebarShareIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$C, [["render", _sfc_render$C], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/ShareVariant.vue"]]);
const _sfc_main$B = {
  name: "CommentProcessingIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$n = ["aria-hidden", "aria-label"];
const _hoisted_2$e = ["fill", "width", "height"];
const _hoisted_3$d = { d: "M9,22A1,1 0 0,1 8,21V18H4A2,2 0 0,1 2,16V4C2,2.89 2.9,2 4,2H20A2,2 0 0,1 22,4V16A2,2 0 0,1 20,18H13.9L10.2,21.71C10,21.9 9.75,22 9.5,22V22H9M17,11V9H15V11H17M13,11V9H11V11H13M9,11V9H7V11H9Z" };
const _hoisted_4$a = { key: 0 };
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon comment-processing-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$d, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$a,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$e))
  ], 16, _hoisted_1$n);
}
const SidebarCommentsIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$B], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/CommentProcessing.vue"]]);
const _sfc_main$A = {
  name: "LightningBoltIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$m = ["aria-hidden", "aria-label"];
const _hoisted_2$d = ["fill", "width", "height"];
const _hoisted_3$c = { d: "M11 15H6L13 1V9H18L11 23V15Z" };
const _hoisted_4$9 = { key: 0 };
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon lightning-bolt-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$c, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$9,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$d))
  ], 16, _hoisted_1$m);
}
const SidebarActivityIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$A], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/LightningBolt.vue"]]);
const _sfc_main$z = {
  name: "FileDocumentIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$l = ["aria-hidden", "aria-label"];
const _hoisted_2$c = ["fill", "width", "height"];
const _hoisted_3$b = { d: "M13,9H18.5L13,3.5V9M6,2H14L20,8V20A2,2 0 0,1 18,22H6C4.89,22 4,21.1 4,20V4C4,2.89 4.89,2 6,2M15,18V16H6V18H15M18,14V12H6V14H18Z" };
const _hoisted_4$8 = { key: 0 };
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon file-document-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$b, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$8,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$c))
  ], 16, _hoisted_1$l);
}
const SidebarAttachmentsIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["render", _sfc_render$z], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/FileDocument.vue"]]);
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "ActivityItem",
  props: {
    activity: {
      type: Object,
      default: null
    }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const props2 = __props;
    const dateActivityRelative = computed(() => moment(props2.activity.datetime).fromNow());
    const message = computed(() => {
      const subject = props2.activity.subject_rich[0];
      const parameters = JSON.parse(JSON.stringify(props2.activity.subject_rich[1]));
      if (parameters.after && typeof parameters.after.id === "string" && parameters.after.id.startsWith("dt:")) {
        const dateTime = parameters.after.id.slice(3);
        parameters.after.name = moment(dateTime).format("L LTS");
      }
      Object.keys(parameters).forEach(function(key) {
        const { type } = parameters[key];
        switch (type) {
          case "highlight":
            parameters[key] = parameters[key].link ? {
              component: SimpleLink,
              props: {
                href: parameters[key].link,
                name: parameters[key].name
              }
            } : `${parameters[key].name}`;
            break;
          case "user":
            parameters[key] = {
              component: NcUserBubble,
              props: {
                user: parameters[key].id,
                displayName: parameters[key].name
              }
            };
            break;
          case "circle":
            parameters[key] = {
              component: SimpleLink,
              props: {
                href: parameters[key].link,
                name: parameters[key].name
              }
            };
            break;
          case "addressbook-contact":
          case "email":
          case "guest":
            parameters[key] = {
              component: GuestBubble,
              props: {
                user: parameters[key].id,
                displayName: parameters[key].name
              }
            };
            break;
          default:
            parameters[key] = `{${key}}`;
        }
      });
      return {
        subject,
        parameters
      };
    });
    const __returned__ = { props: props2, dateActivityRelative, message, get NcRichText() {
      return NcRichText;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$k = { class: "activity-item" };
const _hoisted_2$b = { class: "activity-item__content" };
const _hoisted_3$a = { class: "activity-item__date" };
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$k, [
    createBaseVNode("div", _hoisted_2$b, [
      createBaseVNode(
        "span",
        _hoisted_3$a,
        toDisplayString($setup.dateActivityRelative),
        1
        /* TEXT */
      ),
      createVNode($setup["NcRichText"], {
        text: $setup.message.subject,
        arguments: $setup.message.parameters
      }, null, 8, ["text", "arguments"])
    ])
  ]);
}
const ActivityItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["render", _sfc_render$y], ["__file", "/var/www/nextcloud/apps/agora/src/components/Activity/ActivityItem.vue"]]);
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "Activities",
  setup(__props, { expose: __expose }) {
    __expose();
    const activityStore = useActivityStore();
    const __returned__ = { activityStore, ActivityItem };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(TransitionGroup, {
    name: "list",
    class: "activities",
    tag: "ul"
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(
        Fragment$1,
        null,
        renderList($setup.activityStore.getActivitiesForInquiry, (item) => {
          return openBlock(), createBlock($setup["ActivityItem"], {
            key: item.activity_id,
            activity: item,
            tag: "li"
          }, null, 8, ["activity"]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]),
    _: 1
    /* STABLE */
  });
}
const Activities = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["render", _sfc_render$x], ["__file", "/var/www/nextcloud/apps/agora/src/components/Activity/Activities.vue"]]);
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "SideBarTabActivity",
  setup(__props, { expose: __expose }) {
    __expose();
    const activityStore = useActivityStore();
    const emptyContentProps = {
      name: translate("agora", "No activity yet")
    };
    const showEmptyContent = computed(() => activityStore.getActivitiesForInquiry.length === 0);
    onMounted(() => {
      subscribe(Event$1.UpdateActivity, () => activityStore.load());
    });
    onUnmounted(() => {
      unsubscribe(Event$1.UpdateActivity, () => activityStore.load());
    });
    const __returned__ = { activityStore, emptyContentProps, showEmptyContent, get NcEmptyContent() {
      return NcEmptyContent;
    }, ActivityIcon: SidebarActivityIcon, Activities };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$j = { class: "comments" };
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$j, [
    !$setup.showEmptyContent ? (openBlock(), createBlock($setup["Activities"], { key: 0 })) : (openBlock(), createBlock(
      $setup["NcEmptyContent"],
      normalizeProps(mergeProps({ key: 1 }, $setup.emptyContentProps)),
      {
        icon: withCtx(() => [
          createVNode($setup["ActivityIcon"])
        ]),
        _: 1
        /* STABLE */
      },
      16
      /* FULL_PROPS */
    ))
  ]);
}
const SideBarTabActivity = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["render", _sfc_render$w], ["__file", "/var/www/nextcloud/apps/agora/src/components/SideBar/SideBarTabActivity.vue"]]);
const _sfc_main$v = {
  name: "CloseIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$i = ["aria-hidden", "aria-label"];
const _hoisted_2$a = ["fill", "width", "height"];
const _hoisted_3$9 = { d: "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" };
const _hoisted_4$7 = { key: 0 };
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon close-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$9, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$7,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$a))
  ], 16, _hoisted_1$i);
}
const Close = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["render", _sfc_render$v], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Close.vue"]]);
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "SideBarTabAttachments",
  setup(__props, { expose: __expose }) {
    __expose();
    const attachmentsStore = useAttachmentsStore();
    const inquiryStore = useInquiryStore();
    const fileInput = ref(null);
    const handleFileUpload = async (event) => {
      const target = event.target;
      const files2 = target.files;
      if (!files2 || files2.length === 0) return;
      target.value = "";
      const filesArray = Array.from(files2);
      for (const file of filesArray) {
        try {
          const response = await attachmentsStore.upload(inquiryStore.id, file);
          const attachment = {
            id: response.id ?? `temp-${Date.now()}-${file.name}`,
            name: response.name ?? file.name,
            size: response.size ?? file.size,
            url: response.url ?? void 0
          };
          attachmentsStore.attachments = [...attachmentsStore.attachments, attachment];
          showSuccess(translate("agora", "{file} uploaded", { file: response.name ?? file.name }));
        } catch (error) {
          console.error("Upload failed:", error);
          showError(translate("agora", "Failed to upload {file}", { file: file.name }));
        }
      }
    };
    const removeAttachment = async (index) => {
      const attachment = attachmentsStore.attachments[index];
      if (!attachment) return;
      try {
        if (attachment.id) {
          await attachmentsStore.delete(attachment.id);
        }
        attachmentsStore.attachments.splice(index, 1);
        showSuccess(translate("agora", "File has been removed !"));
      } catch (e) {
        console.error("Delete failed", e);
      }
    };
    const attachments = computed({
      get: () => attachmentsStore.attachments,
      set: (value) => {
        attachmentsStore.attachments = value;
      }
    });
    const triggerFileInput = () => {
      fileInput.value?.click();
    };
    const formatFileSize = (bytes) => {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const unitIndex = Math.floor(Math.log(bytes) / Math.log(k));
      return `${parseFloat((bytes / Math.pow(k, unitIndex)).toFixed(2))} ${sizes[unitIndex]}`;
    };
    const __returned__ = { attachmentsStore, inquiryStore, fileInput, handleFileUpload, removeAttachment, attachments, triggerFileInput, formatFileSize, get t() {
      return translate;
    }, get NcButton() {
      return NcButton;
    }, Plus: PlusIcon, Close, FileDocument: SidebarAttachmentsIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$h = { class: "sidebar-attachments" };
const _hoisted_2$9 = { class: "attachment-upload" };
const _hoisted_3$8 = { class: "attachments-list" };
const _hoisted_4$6 = {
  key: 0,
  class: "empty-state"
};
const _hoisted_5$1 = { class: "attachment-info" };
const _hoisted_6 = ["href"];
const _hoisted_7 = {
  key: 1,
  class: "attachment-name"
};
const _hoisted_8 = { class: "attachment-size" };
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$h, [
    _cache[1] || (_cache[1] = createBaseVNode(
      "div",
      { class: "sidebar-header" },
      [
        createBaseVNode("h2", null, "Attachments Manager")
      ],
      -1
      /* CACHED */
    )),
    createBaseVNode("div", _hoisted_2$9, [
      createBaseVNode(
        "input",
        {
          id: "attachment-upload-input",
          ref: "fileInput",
          type: "file",
          multiple: "",
          class: "hidden",
          onChange: $setup.handleFileUpload
        },
        null,
        544
        /* NEED_HYDRATION, NEED_PATCH */
      ),
      $setup.inquiryStore.currentUserStatus.isOwner ? (openBlock(), createBlock($setup["NcButton"], {
        key: 0,
        type: "primary",
        onClick: $setup.triggerFileInput
      }, {
        icon: withCtx(() => [
          createVNode($setup["Plus"], { size: 20 })
        ]),
        default: withCtx(() => [
          _cache[0] || (_cache[0] = createTextVNode(
            " Add files ",
            -1
            /* CACHED */
          ))
        ]),
        _: 1
        /* STABLE */
      })) : createCommentVNode("v-if", true)
    ]),
    createBaseVNode("div", _hoisted_3$8, [
      $setup.attachments.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_4$6, "No attachments")) : createCommentVNode("v-if", true),
      (openBlock(true), createElementBlock(
        Fragment$1,
        null,
        renderList($setup.attachments, (attachment, index) => {
          return openBlock(), createElementBlock("div", {
            key: attachment.id ?? index,
            class: "attachment-item"
          }, [
            createBaseVNode("div", _hoisted_5$1, [
              createVNode($setup["FileDocument"], {
                size: 20,
                class: "file-icon"
              }),
              attachment.url ? (openBlock(), createElementBlock("a", {
                key: 0,
                class: "attachment-link",
                href: attachment.url,
                target: "_blank",
                rel: "noopener noreferrer"
              }, toDisplayString(attachment.name), 9, _hoisted_6)) : (openBlock(), createElementBlock(
                "span",
                _hoisted_7,
                toDisplayString(attachment.name),
                1
                /* TEXT */
              )),
              createBaseVNode(
                "span",
                _hoisted_8,
                toDisplayString($setup.formatFileSize(attachment.size)),
                1
                /* TEXT */
              )
            ]),
            $setup.inquiryStore.currentUserStatus.isOwner ? (openBlock(), createBlock($setup["NcButton"], {
              key: 0,
              type: "error",
              "aria-label": $setup.t("agora", "Delete attachment"),
              onClick: ($event) => $setup.removeAttachment(index)
            }, {
              icon: withCtx(() => [
                createVNode($setup["Close"], { size: 20 })
              ]),
              _: 2
              /* DYNAMIC */
            }, 1032, ["aria-label", "onClick"])) : createCommentVNode("v-if", true)
          ]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ])
  ]);
}
const SideBarTabAttachments = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["render", _sfc_render$u], ["__scopeId", "data-v-e8872216"], ["__file", "/var/www/nextcloud/apps/agora/src/components/SideBar/SideBarTabAttachments.vue"]]);
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "CommentAdd",
  setup(__props, { expose: __expose }) {
    __expose();
    const commentsStore = useCommentsStore();
    const sessionStore = useSessionStore();
    const inquiryStore = useInquiryStore();
    const comment = ref("");
    const confidantial = ref(false);
    const confidentialText = inquiryStore.owner.id === sessionStore.currentUser.id ? translate("agora", "Only visible to me") : translate("agora", "Only visible to {displayName}", {
      displayName: inquiryStore.owner.displayName
    });
    async function writeComment() {
      if (comment.value) {
        try {
          await commentsStore.add({
            message: comment.value,
            confidential: confidantial.value
          });
          comment.value = "";
        } catch {
          showError(translate("agora", "Error while saving comment"));
        }
      }
    }
    const __returned__ = { commentsStore, sessionStore, inquiryStore, comment, confidantial, confidentialText, writeComment, get InputDiv() {
      return InputDiv;
    }, get t() {
      return translate;
    }, UserItem, get NcCheckboxRadioSwitch() {
      return NcCheckboxRadioSwitch;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$g = { class: "comment-add" };
const _hoisted_2$8 = { class: "comment-add__input" };
const _hoisted_3$7 = { key: 1 };
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$g, [
    createVNode($setup["UserItem"], {
      user: $setup.sessionStore.currentUser,
      "hide-names": ""
    }, null, 8, ["user"]),
    createBaseVNode("div", _hoisted_2$8, [
      createVNode($setup["InputDiv"], {
        modelValue: $setup.comment,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.comment = $event),
        placeholder: $setup.t("agora", "New comment â¦"),
        submit: "",
        onSubmit: _cache[1] || (_cache[1] = ($event) => $setup.writeComment())
      }, null, 8, ["modelValue", "placeholder"]),
      !$setup.inquiryStore.configuration.forceConfidentialComments ? (openBlock(), createBlock($setup["NcCheckboxRadioSwitch"], {
        key: 0,
        modelValue: $setup.confidantial,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.confidantial = $event),
        type: "switch"
      }, {
        default: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.confidentialText),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }, 8, ["modelValue"])) : (openBlock(), createElementBlock(
        "div",
        _hoisted_3$7,
        toDisplayString($setup.confidentialText),
        1
        /* TEXT */
      ))
    ])
  ]);
}
const CommentAdd = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["render", _sfc_render$t], ["__file", "/var/www/nextcloud/apps/agora/src/components/Comments/CommentAdd.vue"]]);
function escapeText(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function escapeAttr(href) {
  return href.replace(/"/g, "&quot;");
}
function attributesToString(attributes) {
  const result2 = [];
  for (const attr in attributes) {
    let val = attributes[attr] + "";
    result2.push(`${attr}="${escapeAttr(val)}"`);
  }
  return result2.join(" ");
}
function defaultRender({
  tagName,
  attributes,
  content
}) {
  return `<${tagName} ${attributesToString(attributes)}>${escapeText(content)}</${tagName}>`;
}
function linkifyStr(str, opts = {}) {
  opts = new Options(opts, defaultRender);
  const tokens2 = tokenize(str);
  const result2 = [];
  for (let i = 0; i < tokens2.length; i++) {
    const token2 = tokens2[i];
    if (token2.t === "nl" && opts.get("nl2br")) {
      result2.push("<br>\n");
    } else if (!token2.isLink || !opts.check(token2)) {
      result2.push(escapeText(token2.toString()));
    } else {
      result2.push(opts.render(token2));
    }
  }
  return result2.join("");
}
if (!String.prototype.linkify) {
  Object.defineProperty(String.prototype, "linkify", {
    writable: false,
    value: function linkify(options2) {
      return linkifyStr(this, options2);
    }
  });
}
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "CommentItem",
  props: {
    comment: { type: Object, required: true }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const sessionStore = useSessionStore();
    const inquiryStore = useInquiryStore();
    const commentsStore = useCommentsStore();
    const dateCommentedRelative = computed(() => moment.unix(__props.comment.timestamp).fromNow());
    const isCurrentUser = computed(() => sessionStore.currentUser?.id === __props.comment.user.id);
    const isConfidential = computed(() => __props.comment.confidential > 0);
    const confidentialRecipient = computed(() => {
      if (!isConfidential.value) {
        return "";
      }
      if (__props.comment.recipient && __props.comment.recipient.id !== sessionStore.currentUser.id) {
        return translate("agora", "Confidential with {displayName}", {
          displayName: __props.comment.recipient.displayName
        });
      }
      return translate("agora", "Confidential");
    });
    function linkify(subComment) {
      return linkifyStr(subComment);
    }
    async function deleteComment(comment) {
      try {
        await commentsStore.delete({ comment });
      } catch {
        showError(translate("agora", "Error while deleting the comment"));
      }
    }
    async function restoreComment(comment) {
      try {
        await commentsStore.restore({ comment });
      } catch {
        showError(translate("agora", "Error while restoring the comment"));
      }
    }
    const __returned__ = { sessionStore, inquiryStore, commentsStore, dateCommentedRelative, isCurrentUser, isConfidential, confidentialRecipient, linkify, deleteComment, restoreComment, get ActionDelete() {
      return ActionDelete;
    }, get t() {
      return translate;
    }, UserItem };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$f = { class: "comment-item__content" };
const _hoisted_2$7 = { class: "comment-item__user" };
const _hoisted_3$6 = { class: "comment-item__date" };
const _hoisted_4$5 = {
  key: 0,
  class: "comment-item__confidential"
};
const _hoisted_5 = ["innerHTML"];
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["comment-item", { "current-user": $setup.isCurrentUser }])
    },
    [
      createVNode($setup["UserItem"], {
        user: $props.comment.user,
        "hide-names": ""
      }, null, 8, ["user"]),
      createBaseVNode("div", _hoisted_1$f, [
        createBaseVNode(
          "span",
          _hoisted_2$7,
          toDisplayString($props.comment.user.displayName),
          1
          /* TEXT */
        ),
        createBaseVNode(
          "span",
          _hoisted_3$6,
          toDisplayString($setup.dateCommentedRelative),
          1
          /* TEXT */
        ),
        $setup.isConfidential ? (openBlock(), createElementBlock(
          "span",
          _hoisted_4$5,
          toDisplayString($setup.confidentialRecipient),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true),
        (openBlock(true), createElementBlock(
          Fragment$1,
          null,
          renderList($props.comment.comments, (subComment) => {
            return openBlock(), createElementBlock(
              "div",
              {
                key: subComment.id,
                class: normalizeClass(["comment-item__sub-comment", { deleted: subComment.deleted }])
              },
              [
                createCommentVNode(" eslint-disable vue/no-v-html "),
                createBaseVNode("span", {
                  innerHTML: $setup.linkify(subComment.comment)
                }, null, 8, _hoisted_5),
                createCommentVNode(" eslint-enable vue/no-v-html "),
                $props.comment.user.id === $setup.sessionStore.currentUser?.id || $setup.inquiryStore.currentUserStatus.isOwner ? (openBlock(), createBlock($setup["ActionDelete"], {
                  key: 0,
                  name: subComment.deleted ? $setup.t("agora", "Restore comment") : $setup.t("agora", "Delete comment"),
                  restore: !!subComment.deleted,
                  timeout: 0,
                  onRestore: ($event) => $setup.restoreComment(subComment),
                  onDelete: ($event) => $setup.deleteComment(subComment)
                }, null, 8, ["name", "restore", "onRestore", "onDelete"])) : createCommentVNode("v-if", true)
              ],
              2
              /* CLASS */
            );
          }),
          128
          /* KEYED_FRAGMENT */
        ))
      ])
    ],
    2
    /* CLASS */
  );
}
const CommentItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["render", _sfc_render$s], ["__file", "/var/www/nextcloud/apps/agora/src/components/Comments/CommentItem.vue"]]);
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "Comments",
  setup(__props, { expose: __expose }) {
    __expose();
    const commentsStore = useCommentsStore();
    const preferencesStore = usePreferencesStore();
    const cssVar = {
      "--content-deleted": `"(${translate("agora", "deleted")})"`
    };
    const alternativestyle = preferencesStore.user.useCommentsAlternativeStyling;
    const __returned__ = { commentsStore, preferencesStore, cssVar, alternativestyle, CommentItem };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(TransitionGroup, {
    tag: "ul",
    name: "list",
    class: normalizeClass(["comments", { alternativestyle: $setup.alternativestyle }]),
    style: $setup.cssVar
  }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(
        Fragment$1,
        null,
        renderList($setup.commentsStore.groupedComments, (comment) => {
          return openBlock(), createBlock($setup["CommentItem"], {
            key: comment.id,
            comment,
            tag: "li"
          }, null, 8, ["comment"]);
        }),
        128
        /* KEYED_FRAGMENT */
      ))
    ]),
    _: 1
    /* STABLE */
  }, 8, ["class"]);
}
const Comments = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["render", _sfc_render$r], ["__file", "/var/www/nextcloud/apps/agora/src/components/Comments/Comments.vue"]]);
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "SideBarTabComments",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const commentsStore = useCommentsStore();
    const sessionStore = useSessionStore();
    const emptyContentProps = {
      name: translate("agora", "No comments"),
      description: translate("agora", "Be the first.")
    };
    const showEmptyContent = computed(() => commentsStore.comments.length === 0);
    onMounted(() => {
      subscribe(Event$1.UpdateComments, () => commentsStore.load());
    });
    onUnmounted(() => {
      unsubscribe(Event$1.UpdateComments, () => commentsStore.load());
    });
    const __returned__ = { inquiryStore, commentsStore, sessionStore, emptyContentProps, showEmptyContent, get NcEmptyContent() {
      return NcEmptyContent;
    }, CommentAdd, Comments, CommentsIcon: SidebarCommentsIcon };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$e = { class: "comments" };
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$e, [
    $setup.sessionStore.appSettings.inquiryTypeRights[$setup.inquiryStore.type].commentInquiry ? (openBlock(), createBlock($setup["CommentAdd"], { key: 0 })) : createCommentVNode("v-if", true),
    !$setup.showEmptyContent ? (openBlock(), createBlock($setup["Comments"], { key: 1 })) : (openBlock(), createBlock(
      $setup["NcEmptyContent"],
      normalizeProps(mergeProps({ key: 2 }, $setup.emptyContentProps)),
      {
        icon: withCtx(() => [
          createVNode($setup["CommentsIcon"])
        ]),
        _: 1
        /* STABLE */
      },
      16
      /* FULL_PROPS */
    ))
  ]);
}
const SideBarTabComments = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$q], ["__file", "/var/www/nextcloud/apps/agora/src/components/SideBar/SideBarTabComments.vue"]]);
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "ShareMenu",
  props: {
    share: { type: Object, required: true }
  },
  emits: ["showQrCode"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const sharesStore = useSharesStore();
    const inquiryGroupsStore = useInquiryGroupsStore();
    const inquiryStore = useInquiryStore();
    const isDirectShare = computed(
      () => __props.share.groupId === inquiryGroupsStore.currentInquiryGroup?.id || __props.share.inquiryId === inquiryStore.id
    );
    const resolving = ref(false);
    const label = ref({
      inputValue: "",
      inputProps: {
        success: false,
        error: false,
        showTrailingButton: true,
        labelOutside: false,
        label: translate("agora", "Share label")
      }
    });
    const isActivePublicShare = computed(() => !__props.share.deleted && __props.share.type === "public");
    const resendInvitation = computed(() => ({
      activate: !__props.share.groupId && !__props.share.deleted && (!!__props.share.user.emailAddress || __props.share.type === "group"),
      name: __props.share.invitationSent ? translate("agora", "Resend invitation mail") : translate("agora", "Send invitation mail"),
      action: async () => {
        try {
          const result2 = await sharesStore.sendInvitation({ share: __props.share });
          if (result2?.sentResult) {
            handleInvitationResults(result2.sentResult);
          }
        } catch {
          showError(translate("agora", "Error sending invitation"));
        }
      }
    }));
    function handleInvitationResults(sentResult) {
      if (sentResult?.sentMails) {
        sentResult.sentMails.forEach((item) => {
          showSuccess(
            translate("agora", "Invitation sent to {displayName} ({emailAddress})", {
              emailAddress: item.emailAddress,
              displayName: item.displayName
            })
          );
        });
      }
      if (sentResult?.abortedMails) {
        sentResult.abortedMails.forEach((item) => {
          showError(
            translate("agora", "Error sending invitation to {displayName} ({emailAddress})", {
              emailAddress: item.emailAddress,
              displayName: item.displayName
            })
          );
        });
      }
    }
    const resolveGroups = computed(() => ({
      activate: !__props.share.groupId && !resolving.value && !__props.share.deleted && ["contactGroup", "circle"].includes(__props.share.type),
      name: translate("agora", "Resolve group into individual invitations"),
      action: async () => {
        if (resolving.value) return;
        try {
          resolving.value = true;
          await sharesStore.resolveGroup({ share: __props.share });
        } catch (error) {
          if (error.response?.status === 409) {
            const message = error.response?.data;
            resolveGroupResolveError(message);
            return;
          }
        } finally {
          resolving.value = false;
        }
      }
    }));
    function resolveGroupResolveError(message) {
      switch (message) {
        case "Contacts is not enabled":
          return translate("agora", "Resolving of {name} is not possible. The contacts app is not enabled.", {
            name: __props.share.user.displayName
          });
        case "Circles is not enabled for this user":
          return translate("agora", "Resolving of {name} is not possible. The circles app is not enabled.", {
            name: __props.share.user.displayName
          });
        default:
          return translate("agora", "Error resolving {name}.", {
            name: __props.share.user.displayName
          });
      }
    }
    const switchAdmin = computed(() => ({
      activate: !__props.share.groupId && !__props.share.deleted && (__props.share.type === "user" || __props.share.type === "admin"),
      name: __props.share.type === "user" ? translate("agora", "Grant administrative inquiry access") : translate("agora", "Withdraw administrative inquiry access"),
      action: () => {
        sharesStore.switchAdmin({ share: __props.share });
      }
    }));
    const copyLinkButton = computed(() => ({
      activate: !__props.share.groupId && !__props.share.deleted && !!__props.share.URL,
      name: translate("agora", "Copy link to clipboard"),
      action: () => {
        try {
          navigator.clipboard.writeText(__props.share.URL);
          showSuccess(translate("agora", "Link copied to clipboard"));
        } catch {
          showError(translate("agora", "Error while copying link to clipboard"));
        }
      }
    }));
    const showQrCodeButton = computed(() => ({
      activate: !__props.share.groupId && !__props.share.deleted && !!__props.share.URL,
      name: translate("agora", "Show QR code"),
      action: () => {
        emit2("showQrCode");
      }
    }));
    const lockShareButton = computed(() => ({
      activate: !__props.share.groupId && !__props.share.deleted,
      name: __props.share.locked ? translate("agora", "Unlock share") : translate("agora", "Lock share"),
      action: () => {
        try {
          if (__props.share.locked) {
            sharesStore.unlock({ share: __props.share });
          } else {
            sharesStore.lock({ share: __props.share });
          }
        } catch {
          showError(
            translate("agora", "Error while changing lock status of share {displayName}", {
              displayName: __props.share.user.displayName
            })
          );
        }
      }
    }));
    const deleteShareButton = computed(() => ({
      activate: isDirectShare.value,
      name: __props.share.deleted ? translate("agora", "Restore share") : translate("agora", "Delete share"),
      action: () => {
        try {
          if (__props.share.deleted) {
            sharesStore.restore({ share: __props.share });
          } else {
            sharesStore.delete({ share: __props.share });
          }
        } catch {
          showError(
            translate("agora", "Error while changing deleted status of share {displayName}", {
              displayName: __props.share.user.displayName
            })
          );
        }
      }
    }));
    onMounted(() => {
      label.value.inputValue = __props.share.label;
    });
    async function submitLabel() {
      sharesStore.writeLabel({
        token: __props.share.token,
        label: label.value.inputValue
      });
    }
    const __returned__ = { emit: emit2, sharesStore, inquiryGroupsStore, inquiryStore, isDirectShare, resolving, label, isActivePublicShare, resendInvitation, handleInvitationResults, resolveGroups, resolveGroupResolveError, switchAdmin, copyLinkButton, showQrCodeButton, lockShareButton, deleteShareButton, submitLabel, get t() {
      return translate;
    }, get NcActionCaption() {
      return NcActionCaption;
    }, get NcActionInput() {
      return NcActionInput;
    }, get NcActionRadio() {
      return NcActionRadio;
    }, get NcActions() {
      return NcActions;
    }, get NcActionButton() {
      return NcActionButton;
    }, get ShareIcons() {
      return ShareIcons;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcActions"], null, {
    default: withCtx(() => [
      $setup.isActivePublicShare ? (openBlock(), createBlock($setup["NcActionInput"], mergeProps({ key: 0 }, $setup.label.inputProps, {
        modelValue: $setup.label.inputValue,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.label.inputValue = $event),
        onSubmit: _cache[1] || (_cache[1] = ($event) => $setup.submitLabel())
      }), {
        icon: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.edit)))
        ]),
        _: 1
        /* STABLE */
      }, 16, ["modelValue"])) : createCommentVNode("v-if", true),
      $setup.resendInvitation.activate ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 1,
        "close-after-click": "",
        name: $setup.resendInvitation.name,
        "aria-label": $setup.resendInvitation.name,
        onClick: $setup.resendInvitation.action
      }, {
        icon: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.sendByMail)))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
      $setup.resolveGroups.activate ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 2,
        "close-after-click": "",
        disabled: $setup.resolving,
        name: $setup.resolveGroups.name,
        "aria-label": $setup.resolveGroups.name,
        onClick: $setup.resolveGroups.action
      }, {
        icon: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.restore)))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["disabled", "name", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
      $setup.switchAdmin.activate ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 3,
        "close-after-click": "",
        name: $setup.switchAdmin.name,
        "aria-label": $setup.switchAdmin.name,
        onClick: $setup.switchAdmin.action
      }, {
        icon: withCtx(() => [
          $props.share.type === "user" ? (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.adminGrant), { key: 0 })) : (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.adminRevoke), { key: 1 }))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
      $setup.copyLinkButton.activate ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 4,
        "close-after-click": "",
        name: $setup.copyLinkButton.name,
        "aria-label": $setup.copyLinkButton.name,
        onClick: $setup.copyLinkButton.action
      }, {
        icon: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.copyLink)))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
      $setup.showQrCodeButton.activate ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 5,
        "close-after-click": "",
        name: $setup.showQrCodeButton.name,
        "aria-label": $setup.showQrCodeButton.name,
        onClick: $setup.showQrCodeButton.action
      }, {
        icon: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.qrCode)))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
      $setup.isActivePublicShare ? (openBlock(), createBlock($setup["NcActionCaption"], {
        key: 6,
        name: $setup.t("agora", "Options for the registration dialog")
      }, null, 8, ["name"])) : createCommentVNode("v-if", true),
      $setup.isActivePublicShare ? (openBlock(), createBlock($setup["NcActionRadio"], {
        key: 7,
        name: "publicInquiryEmail",
        value: "optional",
        "model-value": $props.share.publicInquiryEmail,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $setup.sharesStore.setPublicInquiryEmail({
          share: $props.share,
          value: "optional"
        }))
      }, {
        default: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.t("agora", "Email address is optional")),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }, 8, ["model-value"])) : createCommentVNode("v-if", true),
      $setup.isActivePublicShare ? (openBlock(), createBlock($setup["NcActionRadio"], {
        key: 8,
        name: "publicInquiryEmail",
        value: "mandatory",
        "model-value": $props.share.publicInquiryEmail,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $setup.sharesStore.setPublicInquiryEmail({
          share: $props.share,
          value: "mandatory"
        }))
      }, {
        default: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.t("agora", "Email address is mandatory")),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }, 8, ["model-value"])) : createCommentVNode("v-if", true),
      $setup.isActivePublicShare ? (openBlock(), createBlock($setup["NcActionRadio"], {
        key: 9,
        name: "publicInquiryEmail",
        value: "disabled",
        "model-value": $props.share.publicInquiryEmail,
        "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $setup.sharesStore.setPublicInquiryEmail({
          share: $props.share,
          value: "disabled"
        }))
      }, {
        default: withCtx(() => [
          createTextVNode(
            toDisplayString($setup.t("agora", "Do not ask for an email address")),
            1
            /* TEXT */
          )
        ]),
        _: 1
        /* STABLE */
      }, 8, ["model-value"])) : createCommentVNode("v-if", true),
      $setup.lockShareButton.activate ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 10,
        "close-after-click": "",
        name: $setup.lockShareButton.name,
        "aria-label": $setup.lockShareButton.name,
        onClick: $setup.lockShareButton.action
      }, {
        icon: withCtx(() => [
          $props.share.locked ? (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.unlock), { key: 0 })) : (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.lock), { key: 1 }))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
      $setup.deleteShareButton.activate ? (openBlock(), createBlock($setup["NcActionButton"], {
        key: 11,
        "close-after-click": "",
        name: $setup.deleteShareButton.name,
        "aria-label": $setup.deleteShareButton.name,
        onClick: $setup.deleteShareButton.action
      }, {
        icon: withCtx(() => [
          $props.share.deleted ? (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.restore), { key: 0 })) : (openBlock(), createBlock(resolveDynamicComponent($setup.ShareIcons.delete), { key: 1 }))
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name", "aria-label", "onClick"])) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  });
}
const ShareMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$p], ["__file", "/var/www/nextcloud/apps/agora/src/components/Shares/ShareMenu.vue"]]);
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "ShareItem",
  props: {
    share: { type: Object, required: true }
  },
  emits: ["showQrCode"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const label = ref({
      inputValue: "",
      inputProps: {
        success: false,
        error: false,
        showTrailingButton: true,
        labelOutside: false,
        label: translate("agora", "Share label")
      }
    });
    const userItemProps = computed(() => ({
      user: __props.share.user,
      label: __props.share.label,
      showEmail: true,
      resolveInfo: true,
      forcedDescription: __props.share.deleted ? `(${translate("agora", "deleted")})` : null,
      showTypeIcon: true,
      icon: true
    }));
    onMounted(() => {
      label.value.inputValue = __props.share.label;
    });
    const __returned__ = { emit: emit2, label, userItemProps, get t() {
      return translate;
    }, get ThumbIcon() {
      return ThumbIcon;
    }, UserItem, ShareMenu };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$d = { key: 0 };
const _hoisted_2$6 = { key: 1 };
const _hoisted_3$5 = { key: 2 };
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass({ deleted: $props.share.deleted })
    },
    [
      createVNode($setup["UserItem"], mergeProps($setup.userItemProps, {
        "delegated-from-group": !$props.share.inquiryId,
        "deleted-state": $props.share.deleted,
        "locked-state": $props.share.locked
      }), {
        status: withCtx(() => [
          $props.share.supported ? (openBlock(), createElementBlock("div", _hoisted_1$d, [
            createVNode($setup["ThumbIcon"], {
              supported: true,
              class: "support-status supported",
              name: $setup.t("agora", "Has been supported")
            }, null, 8, ["name"])
          ])) : $props.share.groupId || ["public", "group"].includes($props.share.type) ? (openBlock(), createElementBlock("div", _hoisted_2$6, [..._cache[1] || (_cache[1] = [
            createBaseVNode(
              "div",
              { class: "support-status empty" },
              null,
              -1
              /* CACHED */
            )
          ])])) : (openBlock(), createElementBlock("div", _hoisted_3$5, [
            createVNode($setup["ThumbIcon"], {
              supported: false,
              class: "support-status unsupported",
              name: $setup.t("agora", "Has not supported")
            }, null, 8, ["name"])
          ]))
        ]),
        default: withCtx(() => [
          createVNode($setup["ShareMenu"], {
            share: $props.share,
            onShowQrCode: _cache[0] || (_cache[0] = ($event) => $setup.emit("showQrCode"))
          }, null, 8, ["share"])
        ]),
        _: 1
        /* STABLE */
      }, 16, ["delegated-from-group", "deleted-state", "locked-state"])
    ],
    2
    /* CLASS */
  );
}
const ShareItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$o], ["__file", "/var/www/nextcloud/apps/agora/src/components/Shares/ShareItem.vue"]]);
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  __name: "SharesListInquiryGroup",
  props: {
    info: { type: String, required: false }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const sharesStore = useSharesStore();
    const configBoxProps = {
      sharesList: {
        name: translate("agora", "Shares")
      }
    };
    async function addShare(user) {
      try {
        await sharesStore.add(user, "inquiryGroup");
      } catch {
        showError(translate("agora", "Error while adding share"));
      }
    }
    const __returned__ = { sharesStore, configBoxProps, addShare, get t() {
      return translate;
    }, ShareIcon: SidebarShareIcon, get ConfigBox() {
      return ConfigBox;
    }, ShareItem, UserSearch };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$c = {
  key: 0,
  class: "shares-list shared"
};
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["ConfigBox"], mergeProps($setup.configBoxProps.sharesList, { info: $props.info }), {
    icon: withCtx(() => [
      createVNode($setup["ShareIcon"])
    ]),
    default: withCtx(() => [
      createVNode($setup["UserSearch"], {
        class: "add-share",
        "aria-label": $setup.t("agora", "Add shares"),
        placeholder: $setup.t("agora", "Type to add an individual share"),
        "search-types": [0],
        onUserSelected: _cache[0] || (_cache[0] = (user) => $setup.addShare(user))
      }, null, 8, ["aria-label", "placeholder"]),
      $setup.sharesStore.shares ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
        createVNode(TransitionGroup, {
          tag: "div",
          name: "list",
          css: false
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(
              Fragment$1,
              null,
              renderList($setup.sharesStore.active, (share) => {
                return openBlock(), createBlock($setup["ShareItem"], {
                  key: share.id,
                  share
                }, null, 8, ["share"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        })
      ])) : createCommentVNode("v-if", true)
    ]),
    _: 1
    /* STABLE */
  }, 16, ["info"]);
}
const SharesList$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["render", _sfc_render$n], ["__file", "/var/www/nextcloud/apps/agora/src/components/Shares/SharesListInquiryGroup.vue"]]);
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "SideBarTabShareInquiryGroup",
  setup(__props, { expose: __expose }) {
    __expose();
    const sharesStore = useSharesStore();
    const infoText = translate(
      "inquiries",
      "Shares for a inquiry group grant voting access to the inquiries contained in the inquiry group."
    );
    onMounted(() => {
      sharesStore.load("inquiryGroup");
    });
    onBeforeRouteUpdate(async () => {
      sharesStore.load("inquiryGroup");
    });
    const __returned__ = { sharesStore, infoText, SharesList: SharesList$1, get t() {
      return translate;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$b = { class: "sidebar-share" };
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    createBaseVNode(
      "div",
      null,
      toDisplayString($setup.t(
        "inquiries",
        "Shares for a inquiry group grant voting access to the inquiries contained in the inquiry group."
      )),
      1
      /* TEXT */
    ),
    createVNode($setup["SharesList"], {
      class: "shares effective",
      info: $setup.infoText
    }, null, 8, ["info"])
  ]);
}
const SideBarTabInquiryGroupShare = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$m], ["__file", "/var/www/nextcloud/apps/agora/src/components/SideBar/SideBarTabShareInquiryGroup.vue"]]);
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "SharePublicAdd",
  setup(__props, { expose: __expose }) {
    __expose();
    const sharesStore = useSharesStore();
    const userItemProps = {
      label: translate("agora", "Add a new public link"),
      type: "addPublicLink"
    };
    async function addPublicShare() {
      try {
        await sharesStore.addPublicShare();
      } catch {
        showError(translate("agora", "Error adding public link"));
      }
    }
    const __returned__ = { sharesStore, userItemProps, addPublicShare, get t() {
      return translate;
    }, get NcActions() {
      return NcActions;
    }, get NcActionButton() {
      return NcActionButton;
    }, PlusIcon, UserItem };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    $setup["UserItem"],
    mergeProps($setup.userItemProps, { class: "add-public" }),
    {
      status: withCtx(() => [..._cache[1] || (_cache[1] = [
        createBaseVNode(
          "div",
          { class: "inquiry-status" },
          null,
          -1
          /* CACHED */
        )
      ])]),
      default: withCtx(() => [
        createVNode($setup["NcActions"], null, {
          default: withCtx(() => [
            createVNode($setup["NcActionButton"], {
              name: $setup.t("agora", "Add a new public link"),
              "aria-label": $setup.t("agora", "Add a new public link"),
              onClick: _cache[0] || (_cache[0] = ($event) => $setup.addPublicShare())
            }, {
              icon: withCtx(() => [
                createVNode($setup["PlusIcon"])
              ]),
              default: withCtx(() => [
                createTextVNode(
                  " " + toDisplayString($setup.t("agora", "Add a new public link")),
                  1
                  /* TEXT */
                )
              ]),
              _: 1
              /* STABLE */
            }, 8, ["name", "aria-label"])
          ]),
          _: 1
          /* STABLE */
        })
      ]),
      _: 1
      /* STABLE */
    },
    16
    /* FULL_PROPS */
  );
}
const SharePublicAdd = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["render", _sfc_render$l], ["__file", "/var/www/nextcloud/apps/agora/src/components/Shares/SharePublicAdd.vue"]]);
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "ShareItemAllUsers",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const userItemProps = computed(() => ({
      label: translate("agora", "Internal access"),
      type: "internalAccess",
      disabled: inquiryStore.configuration.access === "private",
      description: inquiryStore.configuration.access === "private" ? translate("agora", "This inquiry is private") : translate("agora", "This is an openly accessible inquiry")
    }));
    const inquiryAccess = computed({
      get() {
        return inquiryStore.configuration.access === "open";
      },
      set(value) {
        inquiryStore.configuration.access = value ? "open" : "private";
        inquiryStore.write();
      }
    });
    const __returned__ = { inquiryStore, userItemProps, inquiryAccess, get NcCheckboxRadioSwitch() {
      return NcCheckboxRadioSwitch;
    }, UserItem };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    $setup["UserItem"],
    normalizeProps(guardReactiveProps($setup.userItemProps)),
    {
      status: withCtx(() => [..._cache[1] || (_cache[1] = [
        createBaseVNode(
          "div",
          { class: "inquir-status" },
          null,
          -1
          /* CACHED */
        )
      ])]),
      default: withCtx(() => [
        createVNode($setup["NcCheckboxRadioSwitch"], {
          modelValue: $setup.inquiryAccess,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inquiryAccess = $event),
          type: "switch"
        }, null, 8, ["modelValue"])
      ]),
      _: 1
      /* STABLE */
    },
    16
    /* FULL_PROPS */
  );
}
const ShareItemAllUsers = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$k], ["__file", "/var/www/nextcloud/apps/agora/src/components/Shares/ShareItemAllUsers.vue"]]);
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "MarkDownDescription",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const __returned__ = { inquiryStore };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$a = ["innerHTML"];
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment$1,
    null,
    [
      createCommentVNode(" eslint-disable vue/no-v-html "),
      createBaseVNode("div", {
        ref: "desc",
        class: "markdown-description",
        innerHTML: $setup.inquiryStore.descriptionMarkDown
      }, null, 8, _hoisted_1$a),
      createCommentVNode(" eslint-enable vue/no-v-html ")
    ],
    2112
    /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */
  );
}
const MarkDownDescription = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$j], ["__file", "/var/www/nextcloud/apps/agora/src/components/Inquiry/MarkDownDescription.vue"]]);
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "SharesList",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const sharesStore = useSharesStore();
    const sessionStore = useSessionStore();
    const qrModal = ref(false);
    const qrText = ref("");
    const configBoxProps = {
      sharesList: {
        name: translate("agora", "Shares")
      }
    };
    function openQrModal(share) {
      qrText.value = share.URL;
      qrModal.value = true;
    }
    async function addShare(user) {
      try {
        await sharesStore.add(user);
      } catch {
        showError(translate("agora", "Error while adding share"));
      }
    }
    const __returned__ = { inquiryStore, sharesStore, sessionStore, qrModal, qrText, configBoxProps, openQrModal, addShare, get t() {
      return translate;
    }, get NcModal() {
      return NcModal;
    }, ShareIcon: SidebarShareIcon, get ConfigBox() {
      return ConfigBox;
    }, get QrModal() {
      return QrModal;
    }, ShareItem, UserSearch, SharePublicAdd, ShareItemAllUsers, MarkDownDescription };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$9 = {
  key: 3,
  class: "shares-list shared"
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    $setup["ConfigBox"],
    normalizeProps(guardReactiveProps($setup.configBoxProps.sharesList)),
    {
      icon: withCtx(() => [
        createVNode($setup["ShareIcon"])
      ]),
      default: withCtx(() => [
        $setup.sessionStore.appPermissions.addShares ? (openBlock(), createBlock($setup["UserSearch"], {
          key: 0,
          class: "add-share",
          "aria-label": $setup.t("agora", "Add shares"),
          placeholder: $setup.t("agora", "Type to add an individual share"),
          onUserSelected: _cache[0] || (_cache[0] = (user) => $setup.addShare(user))
        }, null, 8, ["aria-label", "placeholder"])) : createCommentVNode("v-if", true),
        $setup.sessionStore.appPermissions.allAccess ? (openBlock(), createBlock($setup["ShareItemAllUsers"], { key: 1 })) : createCommentVNode("v-if", true),
        $setup.sessionStore.appPermissions.publicShares && $setup.sessionStore.appPermissions.addShares && $setup.sessionStore.appPermissions.addSharesExternal ? (openBlock(), createBlock($setup["SharePublicAdd"], { key: 2 })) : createCommentVNode("v-if", true),
        $setup.sharesStore.active.length ? (openBlock(), createElementBlock("div", _hoisted_1$9, [
          createVNode(TransitionGroup, {
            tag: "div",
            name: "list",
            css: false
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(
                Fragment$1,
                null,
                renderList($setup.sharesStore.active, (share) => {
                  return openBlock(), createBlock($setup["ShareItem"], {
                    key: share.id,
                    share,
                    onShowQrCode: ($event) => $setup.openQrModal(share)
                  }, null, 8, ["share", "onShowQrCode"]);
                }),
                128
                /* KEYED_FRAGMENT */
              ))
            ]),
            _: 1
            /* STABLE */
          })
        ])) : createCommentVNode("v-if", true),
        $setup.qrModal ? (openBlock(), createBlock($setup["NcModal"], {
          key: 4,
          size: "small",
          onClose: _cache[1] || (_cache[1] = ($event) => $setup.qrModal = false)
        }, {
          default: withCtx(() => [
            createVNode($setup["QrModal"], {
              name: $setup.inquiryStore.title,
              description: $setup.inquiryStore.description,
              "encode-text": $setup.qrText,
              class: "modal__content"
            }, {
              description: withCtx(() => [
                createVNode($setup["MarkDownDescription"])
              ]),
              _: 1
              /* STABLE */
            }, 8, ["name", "description", "encode-text"])
          ]),
          _: 1
          /* STABLE */
        })) : createCommentVNode("v-if", true)
      ]),
      _: 1
      /* STABLE */
    },
    16
    /* FULL_PROPS */
  );
}
const SharesList = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["render", _sfc_render$i], ["__file", "/var/www/nextcloud/apps/agora/src/components/Shares/SharesList.vue"]]);
const _sfc_main$h = {
  name: "EmailAlertIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$8 = ["aria-hidden", "aria-label"];
const _hoisted_2$5 = ["fill", "width", "height"];
const _hoisted_3$4 = { d: "M18 8L10 13L2 8V6L10 11L18 6M18 4H2C.9 4 0 4.9 0 6V18C0 19.1 .9 20 2 20H18C19.1 20 20 19.1 20 18V6C20 4.9 19.1 4 18 4M24 7H22V13H24V7M24 15H22V17H24V15Z" };
const _hoisted_4$4 = { key: 0 };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon email-alert-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$4, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$4,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$5))
  ], 16, _hoisted_1$8);
}
const EmailAlertIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["render", _sfc_render$h], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/EmailAlert.vue"]]);
const _sfc_main$g = {
  name: "EmailMultipleOutlineIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$7 = ["aria-hidden", "aria-label"];
const _hoisted_2$4 = ["fill", "width", "height"];
const _hoisted_3$3 = { d: "M2 6V20H20V22H2C.895 22 0 21.11 0 20V6H2M24 4C24 2.9 23.1 2 22 2H6C4.9 2 4 2.9 4 4V16C4 17.1 4.9 18 6 18H22C23.1 18 24 17.1 24 16V4M22 4L14 9L6 4H22M22 16H6V6L14 11L22 6V16Z" };
const _hoisted_4$3 = { key: 0 };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon email-multiple-outline-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$3, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$3,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$4))
  ], 16, _hoisted_1$7);
}
const BulkMailIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["render", _sfc_render$g], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/EmailMultipleOutline.vue"]]);
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "SharesListUnsent",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const sharesStore = useSharesStore();
    async function sendAllInvitations() {
      const response = await sharesStore.inviteAll({ inquiryId: inquiryStore.id });
      if (response.data.sentResult?.sentMails) {
        response.data.sentResult.sentMails.forEach((item) => {
          showSuccess(
            translate("agora", "Invitation sent to {displayName} ({emailAddress})", {
              emailAddress: item.emailAddress,
              displayName: item.displayName
            })
          );
        });
      }
      if (response.data.sentResult?.abortedMails) {
        response.data.sentResult.abortedMails.forEach((item) => {
          Logger.error("Mail could not be sent!", { recipient: item });
          showError(
            translate("inquiries", "Error sending invitation to {displayName} ({emailAddress})", {
              emailAddress: item.emailAddress,
              displayName: item.displayName
            })
          );
        });
      }
    }
    const __returned__ = { inquiryStore, sharesStore, sendAllInvitations, get t() {
      return translate;
    }, get NcButton() {
      return NcButton;
    }, EmailAlertIcon, ShareItem, BulkMailIcon, get ConfigBox() {
      return ConfigBox;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return $setup.sharesStore.unsentInvitations.length ? (openBlock(), createBlock($setup["ConfigBox"], {
    key: 0,
    name: $setup.t("agora", "Unsent invitations")
  }, {
    icon: withCtx(() => [
      createVNode($setup["EmailAlertIcon"])
    ]),
    actions: withCtx(() => [
      createVNode($setup["NcButton"], {
        title: $setup.t("agora", "Resolve and send all invitations"),
        "aria-label": $setup.t("agora", "Resolve and send all invitations"),
        variant: "tertiary",
        onClick: _cache[0] || (_cache[0] = ($event) => $setup.sendAllInvitations())
      }, {
        icon: withCtx(() => [
          createVNode($setup["BulkMailIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["title", "aria-label"])
    ]),
    default: withCtx(() => [
      createVNode(TransitionGroup, {
        tag: "div",
        name: "list",
        css: false,
        class: "shares-list"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(
            Fragment$1,
            null,
            renderList($setup.sharesStore.unsentInvitations, (share) => {
              return openBlock(), createBlock($setup["ShareItem"], {
                key: share.id,
                share
              }, null, 8, ["share"]);
            }),
            128
            /* KEYED_FRAGMENT */
          ))
        ]),
        _: 1
        /* STABLE */
      })
    ]),
    _: 1
    /* STABLE */
  }, 8, ["name"])) : createCommentVNode("v-if", true);
}
const SharesListUnsent = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["render", _sfc_render$f], ["__file", "/var/www/nextcloud/apps/agora/src/components/Shares/SharesListUnsent.vue"]]);
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "SharesListLocked",
  setup(__props, { expose: __expose }) {
    __expose();
    const sharesStore = useSharesStore();
    const configBoxProps = {
      lockedShares: {
        name: translate("agora", "Locked shares (read only access)")
      }
    };
    const __returned__ = { sharesStore, configBoxProps, get ConfigBox() {
      return ConfigBox;
    }, LockedIcon, ShareItem };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return $setup.sharesStore.locked.length ? (openBlock(), createBlock(
    $setup["ConfigBox"],
    normalizeProps(mergeProps({ key: 0 }, $setup.configBoxProps.lockedShares)),
    {
      icon: withCtx(() => [
        createVNode($setup["LockedIcon"])
      ]),
      default: withCtx(() => [
        createVNode(TransitionGroup, {
          tag: "div",
          name: "list",
          css: false,
          class: "shares-list"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(
              Fragment$1,
              null,
              renderList($setup.sharesStore.locked, (share) => {
                return openBlock(), createBlock($setup["ShareItem"], {
                  key: share.id,
                  share
                }, null, 8, ["share"]);
              }),
              128
              /* KEYED_FRAGMENT */
            ))
          ]),
          _: 1
          /* STABLE */
        })
      ]),
      _: 1
      /* STABLE */
    },
    16
    /* FULL_PROPS */
  )) : createCommentVNode("v-if", true);
}
const SharesListLocked = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["render", _sfc_render$e], ["__file", "/var/www/nextcloud/apps/agora/src/components/Shares/SharesListLocked.vue"]]);
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "SideBarTabShare",
  setup(__props, { expose: __expose }) {
    __expose();
    const sharesStore = useSharesStore();
    const sessionStore = useSessionStore();
    onMounted(() => {
      subscribe(Event$1.ChangeShares, () => sharesStore.load());
    });
    onUnmounted(() => {
      unsubscribe(Event$1.ChangeShares, () => sharesStore.load());
    });
    const __returned__ = { sharesStore, sessionStore, SharesList, SharesListUnsent, SharesListLocked };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$6 = { class: "sidebar-share" };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    $setup.sessionStore.appPermissions.addShares ? (openBlock(), createBlock($setup["SharesListUnsent"], {
      key: 0,
      class: "shares unsent"
    })) : createCommentVNode("v-if", true),
    createVNode($setup["SharesList"], { class: "shares effective" }),
    $setup.sessionStore.appPermissions.addShares ? (openBlock(), createBlock($setup["SharesListLocked"], {
      key: 1,
      class: "shares"
    })) : createCommentVNode("v-if", true)
  ]);
}
const SideBarTabShare = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["render", _sfc_render$d], ["__file", "/var/www/nextcloud/apps/agora/src/components/SideBar/SideBarTabShare.vue"]]);
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "SideBar",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryStore = useInquiryStore();
    const sessionStore = useSessionStore();
    const showSidebar = ref(window.innerWidth > 920);
    const activeTab = ref(translate("agora", "Comments").toLowerCase());
    const shouldDisplay = computed(() => inquiryStore.status.forceEditMode);
    onMounted(() => {
      subscribe(Event$1.SidebarToggle, (payload) => {
        showSidebar.value = payload?.open ?? !showSidebar.value;
        activeTab.value = payload?.activeTab ?? activeTab.value;
      });
      subscribe(Event$1.SidebarChangeTab, (payload) => {
        activeTab.value = payload?.activeTab ?? activeTab.value;
      });
    });
    onUnmounted(() => {
      unsubscribe(Event$1.SidebarToggle, () => {
        activeTab.value = "comments";
      });
      unsubscribe(Event$1.SidebarChangeTab, () => {
        showSidebar.value = false;
      });
    });
    function closeSideBar() {
      emit(Event$1.SidebarToggle, { open: false });
    }
    const __returned__ = { inquiryStore, sessionStore, showSidebar, activeTab, shouldDisplay, closeSideBar, get t() {
      return translate;
    }, get NcAppSidebar() {
      return NcAppSidebar;
    }, get NcAppSidebarTab() {
      return NcAppSidebarTab;
    }, SidebarShareIcon, SidebarCommentsIcon, SidebarActivityIcon, SidebarAttachmentsIcon, get SideBarTabComments() {
      return SideBarTabComments;
    }, get SideBarTabShare() {
      return SideBarTabShare;
    }, get SideBarTabAttachments() {
      return SideBarTabAttachments;
    }, get SideBarTabActivity() {
      return SideBarTabActivity;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$5 = { key: 0 };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return $setup.shouldDisplay ? (openBlock(), createElementBlock("aside", _hoisted_1$5, [
    withDirectives(createVNode($setup["NcAppSidebar"], {
      modelValue: $setup.activeTab,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.activeTab = $event),
      name: $setup.t("agora", "Details"),
      onClose: _cache[1] || (_cache[1] = ($event) => $setup.closeSideBar())
    }, {
      default: withCtx(() => [
        $setup.sessionStore.appSettings.inquiryTypeRights[$setup.inquiryStore.type].commentInquiry ? (openBlock(), createBlock($setup["NcAppSidebarTab"], {
          key: 0,
          id: "comments",
          order: 1,
          name: $setup.t("agora", "Comments")
        }, {
          icon: withCtx(() => [
            createVNode($setup["SidebarCommentsIcon"])
          ]),
          default: withCtx(() => [
            createVNode($setup["SideBarTabComments"])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"])) : createCommentVNode("v-if", true),
        $setup.sessionStore.appSettings.inquiryTypeRights[$setup.inquiryStore.type].attachFileInquiry ? (openBlock(), createBlock($setup["NcAppSidebarTab"], {
          key: 1,
          id: "attachments",
          order: 2,
          name: $setup.t("agora", "Attachments")
        }, {
          icon: withCtx(() => [
            createVNode($setup["SidebarAttachmentsIcon"])
          ]),
          default: withCtx(() => [
            createVNode($setup["SideBarTabAttachments"])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"])) : createCommentVNode("v-if", true),
        $setup.inquiryStore.permissions.edit ? (openBlock(), createBlock($setup["NcAppSidebarTab"], {
          key: 2,
          id: "sharing",
          order: 3,
          name: $setup.t("agora", "Sharing")
        }, {
          icon: withCtx(() => [
            createVNode($setup["SidebarShareIcon"])
          ]),
          default: withCtx(() => [
            createVNode($setup["SideBarTabShare"])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"])) : createCommentVNode("v-if", true),
        $setup.inquiryStore.permissions.edit && $setup.sessionStore.appSettings.useActivity ? (openBlock(), createBlock($setup["NcAppSidebarTab"], {
          key: 3,
          id: "activity",
          order: 4,
          name: $setup.t("agora", "Activity")
        }, {
          icon: withCtx(() => [
            createVNode($setup["SidebarActivityIcon"])
          ]),
          default: withCtx(() => [
            createVNode($setup["SideBarTabActivity"])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["name"])) : createCommentVNode("v-if", true)
      ]),
      _: 1
      /* STABLE */
    }, 8, ["modelValue", "name"]), [
      [vShow, $setup.showSidebar]
    ])
  ])) : createCommentVNode("v-if", true);
}
const SideBar = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["render", _sfc_render$c], ["__file", "/var/www/nextcloud/apps/agora/src/views/SideBar.vue"]]);
const _sfc_main$b = {
  name: "WrenchIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$4 = ["aria-hidden", "aria-label"];
const _hoisted_2$3 = ["fill", "width", "height"];
const _hoisted_3$2 = { d: "M22.7,19L13.6,9.9C14.5,7.6 14,4.9 12.1,3C10.1,1 7.1,0.6 4.7,1.7L9,6L6,9L1.6,4.7C0.4,7.1 0.9,10.1 2.9,12.1C4.8,14 7.5,14.5 9.8,13.6L18.9,22.7C19.3,23.1 19.9,23.1 20.3,22.7L22.6,20.4C23.1,20 23.1,19.3 22.7,19Z" };
const _hoisted_4$2 = { key: 0 };
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon wrench-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$2, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$2,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$3))
  ], 16, _hoisted_1$4);
}
const SidebarConfigurationIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["render", _sfc_render$b], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Wrench.vue"]]);
const _sfc_main$a = {
  name: "BullhornVariantIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$3 = ["aria-hidden", "aria-label"];
const _hoisted_2$2 = ["fill", "width", "height"];
const _hoisted_3$1 = { d: "M20 2V4L4 8V6H2V18H4V16L6 16.5V18.5C6 20.4 7.6 22 9.5 22S13 20.4 13 18.5V18.3L20 20V22H22V2H20M11 18.5C11 19.3 10.3 20 9.5 20S8 19.3 8 18.5V17L11 17.8V18.5Z" };
const _hoisted_4$1 = { key: 0 };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon bullhorn-variant-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$1, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$1,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$2))
  ], 16, _hoisted_1$3);
}
const SpeakerBigIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["render", _sfc_render$a], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/BullhornVariant.vue"]]);
const _sfc_main$9 = {
  name: "TextBoxIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$2 = ["aria-hidden", "aria-label"];
const _hoisted_2$1 = ["fill", "width", "height"];
const _hoisted_3 = { d: "M14,17H7V15H14M17,13H7V11H17M17,9H7V7H17M19,3H5C3.89,3 3,3.89 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3Z" };
const _hoisted_4 = { key: 0 };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon text-box-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$1))
  ], 16, _hoisted_1$2);
}
const DescriptionIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$9], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/TextBox.vue"]]);
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "ConfigNameInquiryGroup",
  emits: ["change"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const inquiryGroupsStore = useInquiryGroupsStore();
    const inquiryGroupName = computed({
      get() {
        return inquiryGroupsStore.currentInquiryGroup?.name || "";
      },
      set(value) {
        inquiryGroupsStore.setCurrentInquiryGroup({
          ...inquiryGroupsStore.currentInquiryGroup,
          name: value
        });
      }
    });
    const checkName = computed(() => inquiryGroupsStore.currentInquiryGroup?.name ? "" : "error");
    const inputProps = {
      placeholder: translate("agora", "Enter title"),
      helperText: translate("inquiries", "Choose a brief title for the navigation bar and the slug")
    };
    const __returned__ = { emit: emit2, inquiryGroupsStore, inquiryGroupName, checkName, inputProps, get InputDiv() {
      return InputDiv;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["InputDiv"], mergeProps({
    modelValue: $setup.inquiryGroupName,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inquiryGroupName = $event)
  }, $setup.inputProps, {
    "signaling-class": $setup.checkName,
    type: "text",
    onChange: _cache[1] || (_cache[1] = ($event) => $setup.emit("change"))
  }), null, 16, ["modelValue", "signaling-class"]);
}
const ConfigTitleInquiryGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$8], ["__file", "/var/www/nextcloud/apps/agora/src/components/InquiryGroup/ConfigNameInquiryGroup.vue"]]);
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "ConfigTitleExtInquiryGroup",
  emits: ["change"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const inquiryGroupsStore = useInquiryGroupsStore();
    const inquiryGroupTitleExt = computed({
      get() {
        return inquiryGroupsStore.currentInquiryGroup?.titleExt || "";
      },
      set(value) {
        inquiryGroupsStore.setCurrentInquiryGroup({
          ...inquiryGroupsStore.currentInquiryGroup,
          titleExt: value
        });
      }
    });
    const inputProps = {
      placeholder: translate("agora", "Enter extended title"),
      helperText: translate("inquiries", "Optionally choose a more meaningful title for the overview page")
    };
    const __returned__ = { emit: emit2, inquiryGroupsStore, inquiryGroupTitleExt, inputProps, get InputDiv() {
      return InputDiv;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["InputDiv"], mergeProps({
    modelValue: $setup.inquiryGroupTitleExt,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inquiryGroupTitleExt = $event)
  }, $setup.inputProps, {
    class: "input-textarea",
    type: "text",
    onChange: _cache[1] || (_cache[1] = ($event) => $setup.emit("change"))
  }), null, 16, ["modelValue"]);
}
const ConfigTitleExtInquiryGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$7], ["__file", "/var/www/nextcloud/apps/agora/src/components/InquiryGroup/ConfigTitleExtInquiryGroup.vue"]]);
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "ConfigDescriptionInquiryGroup",
  emits: ["change"],
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const emit2 = __emit;
    const inquiryGroupsStore = useInquiryGroupsStore();
    const inputProps = {
      placeholder: translate("agora", "Enter a description"),
      helperText: translate("agora", "Choose a description for the overview page")
    };
    const inquiryGroupDescription = computed({
      get() {
        return inquiryGroupsStore.currentInquiryGroup?.description || "";
      },
      set(value) {
        inquiryGroupsStore.setCurrentInquiryGroup({
          ...inquiryGroupsStore.currentInquiryGroup,
          description: value
        });
      }
    });
    const __returned__ = { emit: emit2, inquiryGroupsStore, inputProps, inquiryGroupDescription };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$1 = ["placeholder"];
const _hoisted_2 = { class: "helper" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    Fragment$1,
    null,
    [
      withDirectives(createBaseVNode("textarea", {
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.inquiryGroupDescription = $event),
        class: "input-textarea",
        placeholder: $setup.inputProps.placeholder,
        onChange: _cache[1] || (_cache[1] = ($event) => $setup.emit("change"))
      }, null, 40, _hoisted_1$1), [
        [vModelText, $setup.inquiryGroupDescription]
      ]),
      createBaseVNode(
        "p",
        _hoisted_2,
        toDisplayString($setup.inputProps.helperText),
        1
        /* TEXT */
      )
    ],
    64
    /* STABLE_FRAGMENT */
  );
}
const ConfigDescriptionInquiryGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-ac210d66"], ["__file", "/var/www/nextcloud/apps/agora/src/components/InquiryGroup/ConfigDescriptionInquiryGroup.vue"]]);
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "InquiryGroupEditDlg",
  setup(__props, { expose: __expose }) {
    __expose();
    const inquiryGroupsStore = useInquiryGroupsStore();
    const route = useRoute();
    async function updateInquiryGroup() {
      try {
        inquiryGroupsStore.updating = true;
        const inquiryGroup = await inquiryGroupsStore.writeCurrentInquiryGroup();
        if (inquiryGroup) {
          if (route.name === "group" && inquiryGroup.slug !== route.params.slug) {
            router.push({
              name: "group",
              params: { slug: inquiryGroup.slug }
            });
            showInfo(translate("inquiries", "Note: Based on the name change, the URL has also changed"));
          }
        }
      } catch {
        showError(translate("agora", "Error updating inquiry group"));
      } finally {
        inquiryGroupsStore.updating = false;
      }
    }
    const __returned__ = { inquiryGroupsStore, route, updateInquiryGroup, get t() {
      return translate;
    }, SpeakerIcon, SpeakerBigIcon, DescriptionIcon, get ConfigBox() {
      return ConfigBox;
    }, ConfigTitleInquiryGroup, ConfigTitleExtInquiryGroup, ConfigDescriptionInquiryGroup };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1 = { class: "edit-inquiry-group" };
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createVNode($setup["ConfigBox"], {
      name: $setup.t("agora", "Name")
    }, {
      icon: withCtx(() => [
        createVNode($setup["SpeakerIcon"])
      ]),
      default: withCtx(() => [
        createVNode($setup["ConfigTitleInquiryGroup"], { onChange: $setup.updateInquiryGroup })
      ]),
      _: 1
      /* STABLE */
    }, 8, ["name"]),
    createVNode($setup["ConfigBox"], {
      name: $setup.t("agora", "Extended title")
    }, {
      icon: withCtx(() => [
        createVNode($setup["SpeakerBigIcon"])
      ]),
      default: withCtx(() => [
        createVNode($setup["ConfigTitleExtInquiryGroup"], { onChange: $setup.updateInquiryGroup })
      ]),
      _: 1
      /* STABLE */
    }, 8, ["name"]),
    createVNode($setup["ConfigBox"], {
      name: $setup.t("agora", "Description")
    }, {
      icon: withCtx(() => [
        createVNode($setup["DescriptionIcon"])
      ]),
      default: withCtx(() => [
        createVNode($setup["ConfigDescriptionInquiryGroup"], { onChange: $setup.updateInquiryGroup })
      ]),
      _: 1
      /* STABLE */
    }, 8, ["name"])
  ]);
}
const InquiryGroupEditDlg = /* @__PURE__ */ _export_sfc$1(_sfc_main$5, [["render", _sfc_render$5], ["__file", "/var/www/nextcloud/apps/agora/src/components/InquiryGroup/InquiryGroupEditDlg.vue"]]);
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "SideBarTabConfigurationInquiryGroup",
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = { InquiryGroupEditDlg };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["InquiryGroupEditDlg"]);
}
const SideBarTabConfigurationInquiryGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$4, [["render", _sfc_render$4], ["__file", "/var/www/nextcloud/apps/agora/src/components/SideBar/SideBarTabConfigurationInquiryGroup.vue"]]);
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "SideBarInquiryGroup",
  setup(__props, { expose: __expose }) {
    __expose();
    const showSidebar = ref(window.innerWidth > 920);
    const activeTab = ref(translate("agora", "Shares").toLowerCase());
    onMounted(() => {
      subscribe(Event$1.SidebarToggle, (payload) => {
        showSidebar.value = payload?.open ?? !showSidebar.value;
      });
    });
    onUnmounted(() => {
      unsubscribe(Event$1.SidebarToggle, () => {
        activeTab.value = "sharing";
      });
    });
    function closeSideBar() {
      emit(Event$1.SidebarToggle, { open: false });
    }
    const __returned__ = { showSidebar, activeTab, closeSideBar, get t() {
      return translate;
    }, get NcAppSidebar() {
      return NcAppSidebar;
    }, get NcAppSidebarTab() {
      return NcAppSidebarTab;
    }, SidebarShareIcon, get SideBarTabInquiryGroupShare() {
      return SideBarTabInquiryGroupShare;
    }, SidebarConfigurationIcon, SideBarTabConfigurationInquiryGroup };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createBlock($setup["NcAppSidebar"], {
    modelValue: $setup.activeTab,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.activeTab = $event),
    name: $setup.t("agora", "Details"),
    onClose: _cache[1] || (_cache[1] = ($event) => $setup.closeSideBar())
  }, {
    default: withCtx(() => [
      createVNode($setup["NcAppSidebarTab"], {
        id: "configuration",
        order: 1,
        name: $setup.t("agora", "Configuration")
      }, {
        icon: withCtx(() => [
          createVNode($setup["SidebarConfigurationIcon"])
        ]),
        default: withCtx(() => [
          createVNode($setup["SideBarTabConfigurationInquiryGroup"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name"]),
      createVNode($setup["NcAppSidebarTab"], {
        id: "sharing",
        order: 2,
        name: $setup.t("agora", "Sharing")
      }, {
        icon: withCtx(() => [
          createVNode($setup["SidebarShareIcon"])
        ]),
        default: withCtx(() => [
          createVNode($setup["SideBarTabInquiryGroupShare"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name"])
    ]),
    _: 1
    /* STABLE */
  }, 8, ["modelValue", "name"])), [
    [vShow, $setup.showSidebar]
  ]);
}
const SideBarInquiryGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$3, [["render", _sfc_render$3], ["__file", "/var/www/nextcloud/apps/agora/src/views/SideBarInquiryGroup.vue"]]);
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "SideBarCombo",
  setup(__props, { expose: __expose }) {
    __expose();
    function closeSideBar() {
      emit(Event$1.SidebarToggle, { open: false });
    }
    const __returned__ = { closeSideBar, get t() {
      return translate;
    }, get NcAppSidebar() {
      return NcAppSidebar;
    }, get NcAppSidebarTab() {
      return NcAppSidebarTab;
    }, get AgoraAppIcon() {
      return AgoraAppIcon;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcAppSidebar"], {
    name: $setup.t("agora", "Select inquiries to combine"),
    onClose: _cache[0] || (_cache[0] = ($event) => $setup.closeSideBar())
  }, {
    default: withCtx(() => [
      createVNode($setup["NcAppSidebarTab"], {
        id: "agora",
        order: 1,
        name: $setup.t("agora", "Agora")
      }, {
        icon: withCtx(() => [
          createVNode($setup["AgoraAppIcon"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name"])
    ]),
    _: 1
    /* STABLE */
  }, 8, ["name"]);
}
const SideBarCombo = /* @__PURE__ */ _export_sfc$1(_sfc_main$2, [["render", _sfc_render$2], ["__file", "/var/www/nextcloud/apps/agora/src/views/SideBarCombo.vue"]]);
async function validateToken(to2) {
  const sessionStore = useSessionStore();
  if (to2.name === from.name && sessionStore.isLoaded) {
    return true;
  }
  try {
    await sessionStore.loadShare();
    if (getCurrentUser()) {
      return {
        name: "inquiry",
        params: {
          id: sessionStore.share.inquiryId
        }
      };
    }
  } catch (error) {
    if (getCurrentUser()) {
      if (error.response?.status === 403) {
        return { name: "forbidden" };
      }
      return { name: "notfound" };
    }
    window.location.replace(_$2("login"));
  }
  if (sessionStore.share.type === "public") {
    const personalToken = getCookieValue(to2.params.token);
    if (personalToken) {
      const cookieExpiration = 30 * 24 * 60 * 1e3;
      setCookie(to2.params.token, personalToken, cookieExpiration);
      return {
        name: "publicInquiry",
        params: {
          token: personalToken
        }
      };
    }
  }
  const inquiryStore = useInquiryStore();
  inquiryStore.load();
}
const routes = [
  {
    name: "list",
    path: "/list/:type?",
    components: {
      default: List,
      navigation: Navigation
    },
    props: true,
    meta: {
      listPage: true
    }
  },
  {
    name: "group",
    path: "/group/:slug",
    components: {
      default: List,
      navigation: Navigation,
      sidebar: SideBarInquiryGroup
    },
    props: true,
    meta: {
      groupPage: true,
      listPage: true
    }
  },
  {
    name: "combo",
    path: "/combo",
    components: {
      default: Combo,
      navigation: Navigation,
      sidebar: SideBarCombo
    },
    meta: {
      comboPage: true
    }
  },
  {
    name: "notfound",
    path: "/not-found",
    components: {
      default: NotFound,
      navigation: Navigation
    },
    meta: {
      errorPage: true
    }
  },
  {
    name: "forbidden",
    path: "/forbidden",
    components: {
      default: Forbidden,
      navigation: Navigation
    },
    meta: {
      errorPage: true
    }
  },
  {
    name: "inquiry",
    path: "/inquiry/:id",
    components: {
      default: InquiryView,
      navigation: Navigation,
      sidebar: SideBar,
      params: {
        type: "relevant"
      }
    },
    props: true,
    meta: {
      inquiryPage: true
    }
  },
  {
    name: "publicInquiry",
    path: "/s/:token",
    components: {
      default: InquiryView,
      sidebar: SideBar
    },
    beforeEnter: validateToken,
    props: true,
    meta: {
      publicPage: true,
      inquiryPage: true
    }
  },
  {
    name: "root",
    path: "/",
    redirect: {
      name: "list",
      params: {
        type: "relevant"
      }
    }
  },
  {
    path: "/list",
    redirect: {
      name: "list",
      params: {
        type: "relevant"
      }
    }
  }
];
const router = createRouter({
  history: createWebHistory(_$2("/apps/agora")),
  routes,
  linkActiveClass: "active"
});
router.beforeEach(async (to2, from22) => {
  const sessionStore = useSessionStore();
  let forceReload = false;
  const cheapLoading = to2.name === from22.name && sessionStore.watcher.mode !== "noInquirying" && sessionStore.watcher.status !== "stopped";
  if (to2.name === "login") {
    forceReload = true;
  }
  try {
    await loadContext(to2, cheapLoading, forceReload);
  } catch (error) {
    Logger.error("Could not load context", { error });
    if (!sessionStore.userStatus.isLoggedin) {
      window.location.replace(_$2("login"));
      return false;
    }
    return {
      name: "notfound"
    };
  }
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "UserSettingsDlg",
  setup(__props, { expose: __expose }) {
    __expose();
    const preferencesStore = usePreferencesStore();
    const show = ref(false);
    function loadPreferences() {
      preferencesStore.load();
      preferencesStore.getCalendars();
    }
    onMounted(() => {
      subscribe(Event$1.ShowSettings, () => {
        show.value = true;
        loadPreferences();
      });
    });
    onUnmounted(() => {
      unsubscribe(Event$1.ShowSettings, () => {
      });
    });
    const __returned__ = { preferencesStore, show, loadPreferences, get t() {
      return translate;
    }, get NcAppSettingsDialog() {
      return NcAppSettingsDialog;
    }, get NcAppSettingsSection() {
      return NcAppSettingsSection;
    }, get FeatureSettings() {
      return FeatureSettings;
    }, get StyleSettings() {
      return StyleSettings;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock($setup["NcAppSettingsDialog"], {
    open: $setup.show,
    "onUpdate:open": _cache[0] || (_cache[0] = ($event) => $setup.show = $event),
    "show-navigation": ""
  }, {
    default: withCtx(() => [
      createVNode($setup["NcAppSettingsSection"], {
        id: "div-settings",
        name: $setup.t("agora", "Personal preferences")
      }, {
        default: withCtx(() => [
          createVNode($setup["FeatureSettings"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name"]),
      createVNode($setup["NcAppSettingsSection"], {
        id: "styles",
        name: $setup.t("agora", "Styles")
      }, {
        default: withCtx(() => [
          createVNode($setup["StyleSettings"])
        ]),
        _: 1
        /* STABLE */
      }, 8, ["name"])
    ]),
    _: 1
    /* STABLE */
  }, 8, ["open"]);
}
const UserSettingsDlg = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["render", _sfc_render$1], ["__file", "/var/www/nextcloud/apps/agora/src/components/Settings/UserSettingsDlg.vue"]]);
function WorkerWrapper(options2) {
  return new Worker(
    "" + window.OC.filePath("agora", "", "assets/inquiryWatcher.worker-DuJsppPy.js"),
    {
      name: options2?.name
    }
  );
}
const useInquiryWatcher = (interval = 3e4) => {
  const sessionStore = useSessionStore();
  const inquiryStore = useInquiryStore();
  const inquiriesStore = useInquiriesStore();
  const supportsStore = useSupportsStore();
  const optionsStore = useOptionsStore();
  const commentsStore = useCommentsStore();
  const sharesStore = useSharesStore();
  const baseUrl = _$2("apps/inquiries/");
  let worker = null;
  const startWorker = (inquiryId, mode) => {
    if (worker) {
      worker.terminate();
      worker = null;
    }
    if (sessionStore.appSettings.updateType === "noInquirying") {
      return;
    }
    worker = new WorkerWrapper();
    worker.postMessage({
      inquiryId,
      mode,
      interval,
      baseUrl,
      token: sessionStore.token,
      watcherId: sessionStore.watcher.id,
      lastUpdate: sessionStore.watcher.lastUpdate
    });
    worker.onmessage = (e) => {
      const { type, message, updates, status, mode: mode2, lastUpdate, params } = e.data;
      sessionStore.watcher = {
        ...sessionStore.watcher,
        mode: mode2,
        status,
        interval,
        lastUpdate: lastUpdate ?? sessionStore.watcher.lastUpdate,
        lastMessage: message ?? sessionStore.watcher.lastMessage
      };
      switch (type) {
        case "info":
          Logger.info(`[InquiryWatcher] ${message}`, { params });
          break;
        case "debug":
          Logger.debug(`[InquiryWatcher] ${message}`);
          break;
        case "warning":
          Logger.warn(`[InquiryWatcher] ${message}`);
          break;
        case "error":
          Logger.error(`[InquiryWatcher] ${message}`);
          break;
        case "update":
          Logger.info(`[InquiryWatcher] ${message}`);
          if (Array.isArray(updates)) {
            handleWatcherUpdates(updates);
          }
          break;
        case "status":
          if (message) Logger.info(`[InquiryWatcher] ${message}`, { params });
          if (status === "modeChanged") {
            sessionStore.load();
          }
          break;
        default:
          Logger.warn("[InquiryWatcher] Unknown message type:", { type });
      }
    };
  };
  const stopWorker = () => {
    if (worker) {
      worker.terminate();
      worker = null;
      sessionStore.watcher = {
        ...sessionStore.watcher,
        status: "stopped",
        lastMessage: "Watcher stopped.",
        lastUpdate: Math.floor(Date.now() / 1e3)
      };
      Logger.info("[InquiryWatcher] Worker stopped.");
    }
  };
  const getTasksFromUpdates = (updates, currentInquiryId) => {
    const tasks = /* @__PURE__ */ new Set();
    for (const update of updates) {
      if (update.inquiryId === currentInquiryId) {
        tasks.add(update.table);
      } else if (update.table === "inquiries") {
        if (update.inquiryId === currentInquiryId) {
          tasks.add("inquiry");
        }
        tasks.add("inquiries");
      }
    }
    return Array.from(tasks);
  };
  const handleWatcherTasks = (tasks) => {
    Logger.info("[InquiryWatcher] Tasks to handle:", { tasks });
    tasks.forEach((task) => {
      switch (task) {
        case "shares":
          sharesStore.load();
          break;
        case "inquiries":
          inquiryStore.load();
          inquiriesStore.load();
          break;
        case "supports":
          supportsStore.load();
          break;
        case "options":
          optionsStore.load();
          break;
        case "comments":
          commentsStore.load();
          break;
      }
    });
  };
  const handleWatcherUpdates = (updates) => {
    const tasks = getTasksFromUpdates(updates, inquiryStore.id);
    Logger.info("[InquiryWatcher] Updates received:", { updates });
    handleWatcherTasks(tasks);
  };
  const handleVisibilityChange = () => {
    if (document.visibilityState === "visible") {
      Logger.info("[InquiryWatcher] Window visible â restarting worker");
      startWorker(inquiryStore.id, sessionStore.appSettings.updateType);
    } else {
      Logger.info("[InquiryWatcher] Window hidden â stopping worker");
      stopWorker();
    }
  };
  onMounted(() => {
    document.addEventListener("visibilitychange", handleVisibilityChange);
  });
  onBeforeUnmount(() => {
    document.removeEventListener("visibilitychange", handleVisibilityChange);
    stopWorker();
  });
  watch(
    [() => inquiryStore.id, () => sessionStore.appSettings.updateType],
    ([inquiryIdNew, modeNew], [inquiryIdOld, modeOld]) => {
      Logger.debug("[InquiryWatcher] InquiryWatcher worker restarted:", {
        inquiryId: `${inquiryIdOld} â ${inquiryIdNew}`,
        mode: `${modeOld} â ${modeNew}`
      });
      if (sessionStore.appSettings.updateType !== "noInquirying") {
        startWorker(inquiryIdNew, modeNew);
      }
    },
    { immediate: true }
  );
};
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props, { expose: __expose }) {
    __expose();
    useInquiryWatcher();
    const sessionStore = useSessionStore();
    const inquiryStore = useInquiryStore();
    const inquiryGroupsStore = useInquiryGroupsStore();
    const transitionClass = ref("transitions-active");
    const appClass = computed(() => [
      transitionClass.value,
      {
        edit: inquiryStore.permissions.edit
      }
    ]);
    const useNavigation = computed(() => sessionStore.userStatus.isLoggedin);
    const useSidebar = computed(
      () => inquiryStore.permissions.edit || inquiryStore.permissions.comment || sessionStore.route.name === "combo" || sessionStore.route.name === "group" && inquiryGroupsStore.currentInquiryGroup?.owner.id === sessionStore.currentUser.id
    );
    function transitionsOn() {
      transitionClass.value = "transitions-active";
    }
    function transitionsOff(delay2) {
      transitionClass.value = "";
      if (delay2) {
        setTimeout(() => {
          transitionClass.value = "transitions-active";
        }, delay2);
      }
    }
    function notify(payload) {
      lodashExports.debounce(async function() {
        if (payload.store === "inquiry") {
          showSuccess(payload.message);
        }
      }, 1500);
    }
    watchEffect(() => {
      document.title = sessionStore.windowTitle;
    });
    onMounted(() => {
      subscribe(Event$1.TransitionsOff, (delay2) => {
        transitionsOff(delay2);
      });
      subscribe(Event$1.TransitionsOn, () => {
        transitionsOn();
      });
      subscribe(Event$1.UpdateInquiry, (payload) => {
        notify(payload);
      });
    });
    onUnmounted(() => {
      unsubscribe(Event$1.TransitionsOn, () => {
        transitionsOn();
      });
      unsubscribe(Event$1.TransitionsOff, () => {
      });
      unsubscribe(Event$1.UpdateInquiry, () => {
      });
    });
    const __returned__ = { sessionStore, inquiryStore, inquiryGroupsStore, transitionClass, appClass, useNavigation, useSidebar, transitionsOn, transitionsOff, notify, get NcContent() {
      return NcContent;
    }, UserSettingsDlg };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_router_view = resolveComponent("router-view");
  return openBlock(), createBlock($setup["NcContent"], {
    "app-name": "agora",
    class: normalizeClass($setup.appClass)
  }, {
    default: withCtx(() => [
      $setup.useNavigation ? (openBlock(), createBlock(_component_router_view, {
        key: 0,
        name: "navigation"
      })) : createCommentVNode("v-if", true),
      createVNode(_component_router_view),
      $setup.useSidebar ? (openBlock(), createBlock(_component_router_view, {
        key: 1,
        name: "sidebar"
      })) : createCommentVNode("v-if", true),
      createVNode($setup["UserSettingsDlg"])
    ]),
    _: 1
    /* STABLE */
  }, 8, ["class"]);
}
const App = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render], ["__file", "/var/www/nextcloud/apps/agora/src/App.vue"]]);
const Agora = createApp(App).use(pinia).use(router).directive("focus", {
  mounted: (el) => el.focus()
});
Agora.mount("#content");
//# sourceMappingURL=agora-main.mjs.map
