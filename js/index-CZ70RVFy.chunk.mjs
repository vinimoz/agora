(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode(`@charset "UTF-8";/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-e17a2190] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation-toggle-wrapper[data-v-e17a2190] {
  position: absolute;
  top: var(--app-navigation-padding);
  inset-inline-end: calc(0px - var(--app-navigation-padding));
  margin-inline-end: calc(-1 * var(--default-clickable-area));
}
button.app-navigation-toggle[data-v-e17a2190] {
  background-color: var(--color-main-background);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation,
.app-content {
  /** Distance of the app navigation toggle and the first navigation item to the top edge of the app content container */
  --app-navigation-padding: calc(var(--default-grid-baseline, 4px) * 2);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-0d73a3a1] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation[data-v-0d73a3a1] {
  --color-text-maxcontrast: var(--color-text-maxcontrast-background-blur, var(--color-text-maxcontrast-default));
  transition: transform var(--animation-quick), margin var(--animation-quick);
  width: 300px;
  --app-navigation-max-width: calc(100vw - (var(--app-navigation-padding) + var(--default-clickable-area) + var(--default-grid-baseline)));
  max-width: var(--app-navigation-max-width);
  position: relative;
  top: 0;
  inset-inline-start: 0;
  padding: 0px;
  z-index: 1800;
  height: 100%;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  flex-grow: 0;
  flex-shrink: 0;
  background-color: var(--color-main-background-blur, var(--color-main-background));
  -webkit-backdrop-filter: var(--filter-background-blur, none);
  backdrop-filter: var(--filter-background-blur, none);
}
.app-navigation--closed[data-v-0d73a3a1] {
  margin-inline-start: calc(-1 * min(300px, var(--app-navigation-max-width)));
}
.app-navigation__search[data-v-0d73a3a1] {
  width: 100%;
}
.app-navigation__body[data-v-0d73a3a1] {
  overflow-y: scroll;
}
.app-navigation__content > ul[data-v-0d73a3a1] {
  position: relative;
  width: 100%;
  overflow-x: hidden;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: var(--default-grid-baseline, 4px);
  padding: var(--app-navigation-padding);
}
.app-navigation .app-navigation__list[data-v-0d73a3a1] {
  height: 100%;
}
.app-navigation__body--no-list[data-v-0d73a3a1] {
  flex: 1 1 auto;
  overflow: auto;
  height: 100%;
}
.app-navigation__content[data-v-0d73a3a1] {
  height: 100%;
  display: flex;
  flex-direction: column;
}
[data-themes*=highcontrast] .app-navigation[data-v-0d73a3a1] {
  border-inline-end: 1px solid var(--color-border);
}
@media only screen and (max-width: 1024px) {
.app-navigation[data-v-0d73a3a1] {
    position: absolute;
    border-inline-end: 1px solid var(--color-border);
}
}
@media only screen and (max-width: 512px) {
.app-navigation[data-v-0d73a3a1] {
    z-index: 1400;
}
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-57437e4a] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation-list[data-v-57437e4a] {
  position: relative;
  width: 100%;
  overflow-x: hidden;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: var(--default-grid-baseline, 4px);
  padding: var(--app-navigation-padding);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-08119e68] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/* 'New' button */
.app-navigation-new[data-v-08119e68] {
  display: block;
  padding: calc(var(--default-grid-baseline, 4px) * 2);
}
.app-navigation-new button[data-v-08119e68] {
  width: 100%;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-a21d21e6] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.button-vue.icon-collapse[data-v-a21d21e6] {
  position: relative;
  z-index: 105;
  color: var(--color-main-text);
  inset-inline-end: 0;
}
.button-vue.icon-collapse--open[data-v-a21d21e6] {
  color: var(--color-main-text);
}
.button-vue.icon-collapse--open[data-v-a21d21e6]:hover {
  color: var(--color-primary-element);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-7c1c910e] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/**
 * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
.app-navigation-entry[data-v-7c1c910e] {
  position: relative;
  display: flex;
  flex-shrink: 0;
  flex-wrap: wrap;
  width: 100%;
  min-height: var(--default-clickable-area);
  transition: background-color var(--animation-quick) ease-in-out;
  transition: background-color 200ms ease-in-out;
  border-radius: var(--border-radius-element);
  /* hide deletion/collapse of subitems */
}
.app-navigation-entry-wrapper[data-v-7c1c910e] {
  position: relative;
  display: flex;
  flex-shrink: 0;
  flex-wrap: wrap;
  width: 100%;
}
.app-navigation-entry-wrapper.app-navigation-entry--collapsible:not(.app-navigation-entry--opened) > ul[data-v-7c1c910e] {
  display: none;
}
.app-navigation-entry.active[data-v-7c1c910e] {
  background-color: var(--color-primary-element) !important;
}
.app-navigation-entry.active[data-v-7c1c910e]:hover {
  background-color: var(--color-primary-element-hover) !important;
}
.app-navigation-entry.active .app-navigation-entry-link[data-v-7c1c910e], .app-navigation-entry.active .app-navigation-entry-button[data-v-7c1c910e] {
  color: var(--color-primary-element-text) !important;
}
.app-navigation-entry[data-v-7c1c910e]:focus-within, .app-navigation-entry[data-v-7c1c910e]:hover {
  background-color: var(--color-background-hover);
}
.app-navigation-entry.active .app-navigation-entry__children[data-v-7c1c910e], .app-navigation-entry:focus-within .app-navigation-entry__children[data-v-7c1c910e], .app-navigation-entry:hover .app-navigation-entry__children[data-v-7c1c910e] {
  background-color: var(--color-main-background);
}
.app-navigation-entry.active .app-navigation-entry__utils .app-navigation-entry__actions[data-v-7c1c910e], .app-navigation-entry.app-navigation-entry--deleted .app-navigation-entry__utils .app-navigation-entry__actions[data-v-7c1c910e], .app-navigation-entry:focus .app-navigation-entry__utils .app-navigation-entry__actions[data-v-7c1c910e], .app-navigation-entry:focus-within .app-navigation-entry__utils .app-navigation-entry__actions[data-v-7c1c910e], .app-navigation-entry:hover .app-navigation-entry__utils .app-navigation-entry__actions[data-v-7c1c910e] {
  display: inline-block;
}
.app-navigation-entry.app-navigation-entry--deleted > ul[data-v-7c1c910e] {
  display: none;
}
.app-navigation-entry:not(.app-navigation-entry--editing) .app-navigation-entry-link[data-v-7c1c910e], .app-navigation-entry:not(.app-navigation-entry--editing) .app-navigation-entry-button[data-v-7c1c910e] {
  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2);
}
.app-navigation-entry .app-navigation-entry-link[data-v-7c1c910e], .app-navigation-entry .app-navigation-entry-button[data-v-7c1c910e] {
  z-index: 100; /* above the bullet to allow click*/
  display: flex;
  overflow: hidden;
  flex: 1 1 0;
  min-height: var(--default-clickable-area);
  padding: 0;
  white-space: nowrap;
  color: var(--color-main-text);
  background-repeat: no-repeat;
  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;
  background-size: 16px 16px;
  line-height: var(--default-clickable-area);
}
.app-navigation-entry .app-navigation-entry-link .app-navigation-entry-icon[data-v-7c1c910e], .app-navigation-entry .app-navigation-entry-button .app-navigation-entry-icon[data-v-7c1c910e] {
  display: flex;
  align-items: center;
  flex: 0 0 var(--default-clickable-area);
  justify-content: center;
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  background-size: 16px 16px;
  background-repeat: no-repeat;
  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;
}
.app-navigation-entry .app-navigation-entry-link .app-navigation-entry__name[data-v-7c1c910e], .app-navigation-entry .app-navigation-entry-button .app-navigation-entry__name[data-v-7c1c910e] {
  overflow: hidden;
  max-width: 100%;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.app-navigation-entry .app-navigation-entry-link .editingContainer[data-v-7c1c910e], .app-navigation-entry .app-navigation-entry-button .editingContainer[data-v-7c1c910e] {
  width: calc(100% - var(--default-clickable-area));
  margin: auto;
}
.app-navigation-entry .app-navigation-entry-link[data-v-7c1c910e]:focus-visible, .app-navigation-entry .app-navigation-entry-button[data-v-7c1c910e]:focus-visible {
  box-shadow: 0 0 0 4px var(--color-main-background);
  outline: 2px solid var(--color-main-text);
  border-radius: var(--border-radius-element);
}

/* Second level nesting for lists */
.app-navigation-entry__children[data-v-7c1c910e] {
  --app-navigation-item-child-offset: 10px;
  position: relative;
  display: flex;
  flex: 0 1 auto;
  flex-direction: column;
  width: 100%;
  gap: var(--default-grid-baseline, 4px);
  padding-inline-start: var(--app-navigation-item-child-offset);
}
.app-navigation-entry__children .app-navigation-entry[data-v-7c1c910e] {
  display: inline-flex;
  flex-wrap: wrap;
}
.app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children[data-v-7c1c910e] {
  --app-navigation-item-child-offset: 0;
}

/* Deleted entries */
.app-navigation-entry__deleted[data-v-7c1c910e] {
  display: inline-flex;
  flex: 1 1 0;
  padding-inline-start: calc(var(--default-clickable-area) - (var(--default-clickable-area) - 16px) / 2) !important;
}
.app-navigation-entry__deleted .app-navigation-entry__deleted-description[data-v-7c1c910e] {
  position: relative;
  overflow: hidden;
  flex: 1 1 0;
  white-space: nowrap;
  text-overflow: ellipsis;
  line-height: var(--default-clickable-area);
}

/* counter and actions */
.app-navigation-entry__utils[data-v-7c1c910e] {
  display: flex;
  min-width: var(--default-clickable-area);
  align-items: center;
  flex: 0 1 auto;
  justify-content: flex-end;
  /* counter */
  /* actions */
}
.app-navigation-entry__utils.app-navigation-entry__utils--display-actions .action-item.app-navigation-entry__actions[data-v-7c1c910e] {
  display: inline-block;
}
.app-navigation-entry__utils .app-navigation-entry__counter-wrapper[data-v-7c1c910e] {
  margin-inline-end: calc(var(--default-grid-baseline) * 2);
  display: flex;
  align-items: center;
  flex: 0 1 auto;
}
.app-navigation-entry__utils .action-item.app-navigation-entry__actions[data-v-7c1c910e] {
  display: none;
}

/* editing state */
.app-navigation-entry--editing .app-navigation-entry-edit[data-v-7c1c910e] {
  z-index: 250;
  opacity: 1;
}

/* deleted state */
.app-navigation-entry--deleted .app-navigation-entry-deleted[data-v-7c1c910e] {
  z-index: 250;
  transform: translateX(0);
}

/* pinned state */
.app-navigation-entry--pinned[data-v-7c1c910e] {
  order: 2;
  margin-top: auto;
}
.app-navigation-entry--pinned ~ .app-navigation-entry--pinned[data-v-7c1c910e] {
  margin-top: 0;
}
[data-themes*=highcontrast] .app-navigation-entry[data-v-7c1c910e]:active {
  background-color: var(--color-primary-element-light-hover) !important;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-71f6ed5a] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation-input-confirm[data-v-71f6ed5a] {
  flex: 1 0 100%;
  width: 100%;
}
.app-navigation-input-confirm form[data-v-71f6ed5a] {
  display: flex;
}
.app-navigation-input-confirm__input[data-v-71f6ed5a] {
  height: 34px;
  flex: 1 1 100%;
  font-size: 100% !important;
  margin: 5px !important;
  margin-inline-start: -8px !important;
  padding: 7px !important;
}
.app-navigation-input-confirm__input[data-v-71f6ed5a]:active, .app-navigation-input-confirm__input[data-v-71f6ed5a]:focus, .app-navigation-input-confirm__input[data-v-71f6ed5a]:hover {
  outline: none;
  background-color: var(--color-main-background);
  color: var(--color-main-text);
  border-color: var(--color-primary-element);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-5481b656] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.counter-bubble__counter[data-v-5481b656] {
  --counter-bubble-height: 22px;
  font-size: var(--font-size-small, 13px);
  overflow: hidden;
  width: fit-content;
  min-width: var(--counter-bubble-height);
  text-align: center;
  line-height: var(--counter-bubble-height);
  padding: 0 calc(1.5 * var(--default-grid-baseline));
  border-radius: 0.5lh;
  background-color: var(--color-primary-element-light);
  font-weight: bold;
  color: var(--color-primary-element-light-text);
}
.counter-bubble__counter .active[data-v-5481b656] {
  color: var(--color-main-background);
  background-color: var(--color-primary-element-light);
}
.counter-bubble__counter--highlighted[data-v-5481b656] {
  color: var(--color-primary-element-text);
  background-color: var(--color-primary-element);
}
.counter-bubble__counter--highlighted.active[data-v-5481b656] {
  color: var(--color-primary-element);
  background-color: var(--color-main-background);
}
.counter-bubble__counter--outlined[data-v-5481b656] {
  color: var(--color-primary-element);
  background: transparent;
  box-shadow: inset 0 0 0 2px;
}
.counter-bubble__counter--outlined.active[data-v-5481b656] {
  color: var(--color-main-background);
  box-shadow: inset 0 0 0 2px;
}.badge {
  display: flex;
  align-items: center;
  gap: 5px;
  border-radius: var(--border-radius);
  padding: 5px;
  text-align: center;
  line-height: 1.1em;
  font-size: 0.9em;
  overflow: hidden;
}
.badge span {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
h2 .badge {
  font-size: 0.6em;
}
.badge.error {
  border-color: var(--color-error);
  background-color: var(--color-error);
  color: var(--color-primary-element-text) !important;
}
.badge.success {
  border-color: var(--color-success);
  background-color: var(--color-success);
  color: var(--color-primary-element-text) !important;
}.left-card-side {
  flex: 1 0 180px;
}
.left-card-side ul {
  list-style: initial;
  margin-inline-start: 2rem;
}
.right-card-side {
  flex: 0;
  padding-inline-end: 8px;
}
.notecard > * {
  display: flex;
  flex-direction: column;
}
.notecard .card-content {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  flex: 1;
  column-gap: 8px;
}.config-box__header {
  display: flex;
  align-content: center;
  align-items: center;
  gap: 5px;
  margin: 8px 0 8px 0;
}
.config-box {
  display: flex;
  flex-direction: column;
  padding: 8px 0;
}
.config-box .icon-container {
  width: 20px;
}
.config-box .config-box__title {
  display: flex;
  flex: 1;
  opacity: 0.7;
  font-weight: bold;
  margin: 0;
}
.config-box .config-box__container {
  display: flex;
  flex-direction: column;
  padding-inline-start: 24px;
}
.indented {
  margin-inline-start: 24px !important;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-f356c0a6] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.native-datetime-picker[data-v-f356c0a6] {
  display: flex;
  flex-direction: column;
}
.native-datetime-picker .native-datetime-picker__label[data-v-f356c0a6] {
  margin-block-end: 2px;
}
.native-datetime-picker .native-datetime-picker__input[data-v-f356c0a6] {
  --input-border-width-offset: calc(var(--border-width-input-focused, 2px) - var(--border-width-input, 2px));
  width: 100%;
  flex: 0 0 auto;
  margin: 0;
  padding-inline-start: calc(var(--border-radius-element) + var(--input-border-width-offset));
  padding-inline-end: calc(var(--default-grid-baseline) + var(--input-border-width-offset));
  border: var(--border-width-input, 2px) solid var(--color-border-maxcontrast);
}
.native-datetime-picker .native-datetime-picker__input[data-v-f356c0a6]:active:not([disabled]), .native-datetime-picker .native-datetime-picker__input[data-v-f356c0a6]:hover:not([disabled]), .native-datetime-picker .native-datetime-picker__input[data-v-f356c0a6]:focus:not([disabled]), .native-datetime-picker .native-datetime-picker__input[data-v-f356c0a6]:focus-within:not([disabled]) {
  border-color: var(--color-main-text);
  border-width: var(--border-width-input-focused, 2px);
  box-shadow: 0 0 0 2px var(--color-main-background) !important;
  --input-border-width-offset: 0px;
}
[data-theme-light] .native-datetime-picker__input[data-v-f356c0a6],
[data-themes*=light] .native-datetime-picker__input[data-v-f356c0a6] {
  color-scheme: light;
}
[data-theme-dark] .native-datetime-picker__input[data-v-f356c0a6],
[data-themes*=dark] .native-datetime-picker__input[data-v-f356c0a6] {
  color-scheme: dark;
}
@media (prefers-color-scheme: light) {
[data-theme-default] .native-datetime-picker__input[data-v-f356c0a6],
  [data-themes*=default] .native-datetime-picker__input[data-v-f356c0a6] {
    color-scheme: light;
}
}
@media (prefers-color-scheme: dark) {
[data-theme-default] .native-datetime-picker__input[data-v-f356c0a6],
  [data-themes*=default] .native-datetime-picker__input[data-v-f356c0a6] {
    color-scheme: dark;
}
}.flex_settings {
  display: flex;
  flex-wrap: wrap;
  align-items: stretch;
}
.flex_settings .settings-section {
  flex: 1 0 480px;
  margin-bottom: 0;
  border-bottom: 1px solid var(--color-border);
}
.settings-description {
  margin-top: -0.2em;
  margin-bottom: 1em;
  opacity: 0.7;
}
.user_settings {
  padding-top: 8px;
}
.user_settings textarea {
  width: 99%;
  resize: vertical;
  height: 230px;
}
.settings_details {
  padding-bottom: 16px;
  margin-inline-start: 36px;
}.spacer {
  flex: 1;
}.page--scrolled .header_bar_bottom {
  display: none;
}
.header_bar {
  margin-inline: -8px;
  padding-inline: 56px 8px;
  background-color: var(--color-main-background);
  transition: all var(--animation-slow) linear;
}
.header_bar.sticky-top {
  z-index: 9;
}
.header_bar::after {
  border-top: 1px solid var(--color-border);
}
.header_bar .header_bar_top {
  display: flex;
  flex-wrap: wrap-reverse;
  justify-content: flex-end;
  gap: 8px;
  min-height: 3em;
}
.header_bar .header_bar_top .bar_top_left {
  display: flex;
  flex-direction: column;
  flex: 1 180px;
  justify-content: center;
}
.header_bar .header_bar_top .bar_top_right {
  display: flex;
  flex: 1;
  justify-content: flex-end;
  align-content: center;
  gap: 8px;
  flex-wrap: wrap;
}
.header_bar .header_bar_top .header_avatar {
  font-weight: bold;
  font-size: 1em;
  line-height: 1.5em;
}
.header_bar .header_bar_top .sub {
  display: flex;
  flex-wrap: wrap;
}
.header_bar .header_bar_bottom {
  margin-bottom: 1rem;
}
.header_bar [class*=bar_] {
  flex: 0;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.nc-button-group-base > div {
  text-align: center;
  color: var(--color-text-maxcontrast);
}
.nc-button-group-base ul.nc-button-group-content {
  display: flex;
  gap: 4px;
  justify-content: space-between;
}
.nc-button-group-base ul.nc-button-group-content li {
  flex: 1 1;
}
.nc-button-group-base ul.nc-button-group-content .action-button {
  padding: 0 !important;
  width: 100%;
  display: flex;
  justify-content: center;
}
.nc-button-group-base ul.nc-button-group-content .action-button.action-button--active {
  background-color: var(--color-primary-element);
  border-radius: var(--border-radius-element);
  color: var(--color-primary-element-text);
}
.nc-button-group-base ul.nc-button-group-content .action-button.action-button--active:hover, .nc-button-group-base ul.nc-button-group-content .action-button.action-button--active:focus, .nc-button-group-base ul.nc-button-group-content .action-button.action-button--active:focus-within {
  background-color: var(--color-primary-element-hover);
}
.nc-button-group-base ul.nc-button-group-content .action-button .action-button__pressed-icon {
  display: none;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-1009e96c] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation-caption[data-v-1009e96c] {
  color: var(--color-text-maxcontrast);
  line-height: var(--default-clickable-area);
  white-space: nowrap;
  text-overflow: ellipsis;
  box-shadow: none !important;
  user-select: none;
  pointer-events: none;
  margin-inline-start: 12px;
  padding-inline-end: 14px;
  height: var(--default-clickable-area);
  display: flex;
  align-items: center;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-8e31d57f] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
li.action[data-v-8e31d57f]:hover, li.action.active[data-v-8e31d57f] {
  border-radius: 6px;
  padding: 0;
}
li.action[data-v-8e31d57f]:hover {
  background-color: var(--color-background-hover);
}
.action--disabled[data-v-8e31d57f] {
  pointer-events: none;
  opacity: 0.5;
}
.action--disabled[data-v-8e31d57f]:hover, .action--disabled[data-v-8e31d57f]:focus {
  cursor: default;
  opacity: 0.5;
}
.action--disabled[data-v-8e31d57f] * {
  opacity: 1 !important;
}
.action-checkbox[data-v-8e31d57f] {
  display: flex;
  align-items: flex-start;
  width: 100%;
  height: auto;
  margin: 0;
  padding: 0;
  cursor: pointer;
  white-space: nowrap;
  color: var(--color-main-text);
  border: 0;
  border-radius: 0;
  background-color: transparent;
  box-shadow: none;
  font-weight: normal;
  line-height: var(--default-clickable-area);
  /* checkbox/radio fixes */
}
.action-checkbox__checkbox[data-v-8e31d57f] {
  position: absolute;
  inset-inline-start: 0 !important;
  z-index: -1;
  opacity: 0;
}
.action-checkbox__label[data-v-8e31d57f] {
  display: flex;
  align-items: center;
  width: 100%;
  padding: 0 !important;
  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2) !important;
}
.action-checkbox__label[data-v-8e31d57f]::before {
  margin-block: 0 !important;
  margin-inline: calc((var(--default-clickable-area) - 14px) / 2) !important;
}
.action-checkbox--disabled[data-v-8e31d57f],
.action-checkbox--disabled .action-checkbox__label[data-v-8e31d57f] {
  cursor: pointer;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-7607f0e9] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/* Default global values */
button[data-v-7607f0e9]:not(.button-vue),
input[data-v-7607f0e9]:not([type=range]),
textarea[data-v-7607f0e9] {
  margin: 0;
  padding: 7px 6px;
  cursor: text;
  color: var(--color-main-text);
  border: 1px solid var(--color-border-dark);
  border-radius: var(--border-radius-element);
  outline: none;
  background-color: var(--color-main-background);
  font-size: 13px;
  /* Primary action button, use sparingly */
}
button[data-v-7607f0e9]:not(.button-vue):not(:disabled):not(.primary):hover, button[data-v-7607f0e9]:not(.button-vue):not(:disabled):not(.primary):focus, button:not(.button-vue):not(:disabled):not(.primary).active[data-v-7607f0e9],
input[data-v-7607f0e9]:not([type=range]):not(:disabled):not(.primary):hover,
input[data-v-7607f0e9]:not([type=range]):not(:disabled):not(.primary):focus,
input:not([type=range]):not(:disabled):not(.primary).active[data-v-7607f0e9],
textarea[data-v-7607f0e9]:not(:disabled):not(.primary):hover,
textarea[data-v-7607f0e9]:not(:disabled):not(.primary):focus,
textarea:not(:disabled):not(.primary).active[data-v-7607f0e9] {
  /* active class used for multiselect */
  border-color: var(--color-primary-element);
  outline: none;
}
button[data-v-7607f0e9]:not(.button-vue):not(:disabled):not(.primary):active,
input[data-v-7607f0e9]:not([type=range]):not(:disabled):not(.primary):active,
textarea[data-v-7607f0e9]:not(:disabled):not(.primary):active {
  color: var(--color-main-text);
  outline: none;
  background-color: var(--color-main-background);
}
button[data-v-7607f0e9]:not(.button-vue):disabled,
input[data-v-7607f0e9]:not([type=range]):disabled,
textarea[data-v-7607f0e9]:disabled {
  cursor: default;
  opacity: 0.5;
  color: var(--color-text-maxcontrast);
  background-color: var(--color-background-dark);
}
button[data-v-7607f0e9]:not(.button-vue):required,
input[data-v-7607f0e9]:not([type=range]):required,
textarea[data-v-7607f0e9]:required {
  box-shadow: none;
}
button[data-v-7607f0e9]:not(.button-vue):invalid,
input[data-v-7607f0e9]:not([type=range]):invalid,
textarea[data-v-7607f0e9]:invalid {
  border-color: var(--color-border-error, var(--color-error));
  box-shadow: none !important;
}
button:not(.button-vue).primary[data-v-7607f0e9],
input:not([type=range]).primary[data-v-7607f0e9],
textarea.primary[data-v-7607f0e9] {
  cursor: pointer;
  color: var(--color-primary-element-text);
  border-color: var(--color-primary-element);
  background-color: var(--color-primary-element);
}
button:not(.button-vue).primary[data-v-7607f0e9]:not(:disabled):hover, button:not(.button-vue).primary[data-v-7607f0e9]:not(:disabled):focus, button:not(.button-vue).primary[data-v-7607f0e9]:not(:disabled):active,
input:not([type=range]).primary[data-v-7607f0e9]:not(:disabled):hover,
input:not([type=range]).primary[data-v-7607f0e9]:not(:disabled):focus,
input:not([type=range]).primary[data-v-7607f0e9]:not(:disabled):active,
textarea.primary[data-v-7607f0e9]:not(:disabled):hover,
textarea.primary[data-v-7607f0e9]:not(:disabled):focus,
textarea.primary[data-v-7607f0e9]:not(:disabled):active {
  border-color: var(--color-primary-element-light);
  background-color: var(--color-primary-element-light);
}
button:not(.button-vue).primary[data-v-7607f0e9]:not(:disabled):active,
input:not([type=range]).primary[data-v-7607f0e9]:not(:disabled):active,
textarea.primary[data-v-7607f0e9]:not(:disabled):active {
  color: var(--color-primary-element-text-dark);
}
button:not(.button-vue).primary[data-v-7607f0e9]:disabled,
input:not([type=range]).primary[data-v-7607f0e9]:disabled,
textarea.primary[data-v-7607f0e9]:disabled {
  cursor: default;
  color: var(--color-primary-element-text-dark);
  background-color: var(--color-primary-element);
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
li.action[data-v-7607f0e9]:hover, li.action.active[data-v-7607f0e9] {
  border-radius: 6px;
  padding: 0;
}
li.action[data-v-7607f0e9]:hover {
  background-color: var(--color-background-hover);
}
.action--disabled[data-v-7607f0e9] {
  pointer-events: none;
  opacity: 0.5;
}
.action--disabled[data-v-7607f0e9]:hover, .action--disabled[data-v-7607f0e9]:focus {
  cursor: default;
  opacity: 0.5;
}
.action--disabled[data-v-7607f0e9] * {
  opacity: 1 !important;
}
.action-input[data-v-7607f0e9] {
  display: flex;
  align-items: flex-start;
  width: 100%;
  height: auto;
  margin: 0;
  padding: 0;
  cursor: pointer;
  white-space: nowrap;
  color: var(--color-main-text);
  border: 0;
  border-radius: 0;
  background-color: transparent;
  box-shadow: none;
  font-weight: normal;
}
.action-input__icon-wrapper[data-v-7607f0e9] {
  display: flex;
  align-self: center;
  align-items: center;
  justify-content: center;
}
.action-input__icon-wrapper[data-v-7607f0e9] .material-design-icon {
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  opacity: 1;
}
.action-input__icon-wrapper[data-v-7607f0e9] .material-design-icon .material-design-icon__svg {
  vertical-align: middle;
}
.action-input > span[data-v-7607f0e9] {
  cursor: pointer;
  white-space: nowrap;
}
.action-input__icon[data-v-7607f0e9] {
  min-width: 0; /* Overwrite icons*/
  min-height: 0;
  padding: calc(var(--default-clickable-area) / 2) 0 calc(var(--default-clickable-area) / 2) var(--default-clickable-area);
  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;
  background-size: 16px;
}
.action-input__form[data-v-7607f0e9] {
  display: flex;
  align-items: center;
  flex: 1 1 auto;
  margin: 4px 0;
  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2);
}
.action-input__container[data-v-7607f0e9] {
  position: relative;
  width: 100%;
}
.action-input__input-container[data-v-7607f0e9] {
  display: flex;
}
.action-input__input-container .colorpicker__trigger[data-v-7607f0e9], .action-input__input-container .colorpicker__preview[data-v-7607f0e9] {
  width: 100%;
}
.action-input__input-container .colorpicker__preview[data-v-7607f0e9] {
  width: 100%;
  height: 36px;
  border-radius: var(--border-radius-element);
  border: 2px solid var(--color-border-maxcontrast);
  box-shadow: none !important;
}
.action-input__text-label[data-v-7607f0e9] {
  padding: 4px 0;
  display: block;
}
.action-input__text-label--hidden[data-v-7607f0e9] {
  position: absolute;
  inset-inline-start: 0;
  width: 1px;
  height: 1px;
  overflow: hidden;
  z-index: -1;
  opacity: 0;
}
.action-input__datetimepicker[data-v-7607f0e9] {
  width: 100%;
}
.action-input__datetimepicker[data-v-7607f0e9] .mx-input {
  margin: 0;
}
.action-input__multi[data-v-7607f0e9] {
  width: 100%;
}
li:last-child > .action-input[data-v-7607f0e9] {
  padding-bottom: calc((var(--default-clickable-area) - 16px) / 2 - 4px);
}
li:first-child > .action-input[data-v-7607f0e9]:not(.action-input--visible-label) {
  padding-top: calc((var(--default-clickable-area) - 16px) / 2 - 4px);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-929be55a] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
[data-v-929be55a] .password-field__input--secure-text {
  -webkit-text-security: disc;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-4e9c727c] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
li.action[data-v-4e9c727c]:hover, li.action.active[data-v-4e9c727c] {
  border-radius: 6px;
  padding: 0;
}
li.action[data-v-4e9c727c]:hover {
  background-color: var(--color-background-hover);
}
.action--disabled[data-v-4e9c727c] {
  pointer-events: none;
  opacity: 0.5;
}
.action--disabled[data-v-4e9c727c]:hover, .action--disabled[data-v-4e9c727c]:focus {
  cursor: default;
  opacity: 0.5;
}
.action--disabled[data-v-4e9c727c] * {
  opacity: 1 !important;
}
.action-radio[data-v-4e9c727c] {
  display: flex;
  align-items: flex-start;
  width: 100%;
  height: auto;
  margin: 0;
  padding: 0;
  cursor: pointer;
  white-space: nowrap;
  color: var(--color-main-text);
  border: 0;
  border-radius: 0;
  background-color: transparent;
  box-shadow: none;
  font-weight: normal;
  line-height: var(--default-clickable-area);
  /* checkbox/radio fixes */
}
.action-radio__radio[data-v-4e9c727c] {
  position: absolute;
  inset-inline-start: 0 !important;
  z-index: -1;
  opacity: 0;
}
.action-radio__label[data-v-4e9c727c] {
  display: flex;
  align-items: center;
  width: 100%;
  padding: 0 !important;
  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2) !important;
}
.action-radio__label[data-v-4e9c727c]::before {
  margin: calc((var(--default-clickable-area) - 14px) / 2) !important;
}
.action-radio--disabled[data-v-4e9c727c],
.action-radio--disabled .action-radio__label[data-v-4e9c727c] {
  cursor: pointer;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-3e2324b7] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.action-separator[data-v-3e2324b7] {
  height: 0;
  margin: 5px 10px 5px 15px;
  border-bottom: 1px solid var(--color-border-dark);
  cursor: default;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-df9c1bf0] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/* Default global values */
button[data-v-df9c1bf0]:not(.button-vue),
input[data-v-df9c1bf0]:not([type=range]),
textarea[data-v-df9c1bf0] {
  margin: 0;
  padding: 7px 6px;
  cursor: text;
  color: var(--color-main-text);
  border: 1px solid var(--color-border-dark);
  border-radius: var(--border-radius-element);
  outline: none;
  background-color: var(--color-main-background);
  font-size: 13px;
  /* Primary action button, use sparingly */
}
button[data-v-df9c1bf0]:not(.button-vue):not(:disabled):not(.primary):hover, button[data-v-df9c1bf0]:not(.button-vue):not(:disabled):not(.primary):focus, button:not(.button-vue):not(:disabled):not(.primary).active[data-v-df9c1bf0],
input[data-v-df9c1bf0]:not([type=range]):not(:disabled):not(.primary):hover,
input[data-v-df9c1bf0]:not([type=range]):not(:disabled):not(.primary):focus,
input:not([type=range]):not(:disabled):not(.primary).active[data-v-df9c1bf0],
textarea[data-v-df9c1bf0]:not(:disabled):not(.primary):hover,
textarea[data-v-df9c1bf0]:not(:disabled):not(.primary):focus,
textarea:not(:disabled):not(.primary).active[data-v-df9c1bf0] {
  /* active class used for multiselect */
  border-color: var(--color-primary-element);
  outline: none;
}
button[data-v-df9c1bf0]:not(.button-vue):not(:disabled):not(.primary):active,
input[data-v-df9c1bf0]:not([type=range]):not(:disabled):not(.primary):active,
textarea[data-v-df9c1bf0]:not(:disabled):not(.primary):active {
  color: var(--color-main-text);
  outline: none;
  background-color: var(--color-main-background);
}
button[data-v-df9c1bf0]:not(.button-vue):disabled,
input[data-v-df9c1bf0]:not([type=range]):disabled,
textarea[data-v-df9c1bf0]:disabled {
  cursor: default;
  opacity: 0.5;
  color: var(--color-text-maxcontrast);
  background-color: var(--color-background-dark);
}
button[data-v-df9c1bf0]:not(.button-vue):required,
input[data-v-df9c1bf0]:not([type=range]):required,
textarea[data-v-df9c1bf0]:required {
  box-shadow: none;
}
button[data-v-df9c1bf0]:not(.button-vue):invalid,
input[data-v-df9c1bf0]:not([type=range]):invalid,
textarea[data-v-df9c1bf0]:invalid {
  border-color: var(--color-border-error, var(--color-error));
  box-shadow: none !important;
}
button:not(.button-vue).primary[data-v-df9c1bf0],
input:not([type=range]).primary[data-v-df9c1bf0],
textarea.primary[data-v-df9c1bf0] {
  cursor: pointer;
  color: var(--color-primary-element-text);
  border-color: var(--color-primary-element);
  background-color: var(--color-primary-element);
}
button:not(.button-vue).primary[data-v-df9c1bf0]:not(:disabled):hover, button:not(.button-vue).primary[data-v-df9c1bf0]:not(:disabled):focus, button:not(.button-vue).primary[data-v-df9c1bf0]:not(:disabled):active,
input:not([type=range]).primary[data-v-df9c1bf0]:not(:disabled):hover,
input:not([type=range]).primary[data-v-df9c1bf0]:not(:disabled):focus,
input:not([type=range]).primary[data-v-df9c1bf0]:not(:disabled):active,
textarea.primary[data-v-df9c1bf0]:not(:disabled):hover,
textarea.primary[data-v-df9c1bf0]:not(:disabled):focus,
textarea.primary[data-v-df9c1bf0]:not(:disabled):active {
  border-color: var(--color-primary-element-light);
  background-color: var(--color-primary-element-light);
}
button:not(.button-vue).primary[data-v-df9c1bf0]:not(:disabled):active,
input:not([type=range]).primary[data-v-df9c1bf0]:not(:disabled):active,
textarea.primary[data-v-df9c1bf0]:not(:disabled):active {
  color: var(--color-primary-element-text-dark);
}
button:not(.button-vue).primary[data-v-df9c1bf0]:disabled,
input:not([type=range]).primary[data-v-df9c1bf0]:disabled,
textarea.primary[data-v-df9c1bf0]:disabled {
  cursor: default;
  color: var(--color-primary-element-text-dark);
  background-color: var(--color-primary-element);
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
li.action[data-v-df9c1bf0]:hover, li.action.active[data-v-df9c1bf0] {
  border-radius: 6px;
  padding: 0;
}
li.action[data-v-df9c1bf0]:hover {
  background-color: var(--color-background-hover);
}
.action--disabled[data-v-df9c1bf0] {
  pointer-events: none;
  opacity: 0.5;
}
.action--disabled[data-v-df9c1bf0]:hover, .action--disabled[data-v-df9c1bf0]:focus {
  cursor: default;
  opacity: 0.5;
}
.action--disabled[data-v-df9c1bf0] * {
  opacity: 1 !important;
}
.action-text-editable[data-v-df9c1bf0] {
  display: flex;
  align-items: flex-start;
  width: 100%;
  height: auto;
  margin: 0;
  padding: 0;
  cursor: pointer;
  white-space: nowrap;
  color: var(--color-main-text);
  border: 0;
  border-radius: 0;
  background-color: transparent;
  box-shadow: none;
  font-weight: normal;
  line-height: var(--default-clickable-area);
  /* Inputs inside popover supports text, submit & reset */
}
.action-text-editable > span[data-v-df9c1bf0] {
  cursor: pointer;
  white-space: nowrap;
}
.action-text-editable__icon[data-v-df9c1bf0] {
  min-width: 0; /* Overwrite icons*/
  min-height: 0;
  /* Keep padding to define the width to
  	assure correct position of a possible text */
  padding: calc(var(--default-clickable-area) / 2) 0 calc(var(--default-clickable-area) / 2) var(--default-clickable-area);
  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;
  background-size: 16px;
}
.action-text-editable[data-v-df9c1bf0] .material-design-icon {
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  opacity: 1;
}
.action-text-editable[data-v-df9c1bf0] .material-design-icon .material-design-icon__svg {
  vertical-align: middle;
}
.action-text-editable__form[data-v-df9c1bf0] {
  display: flex;
  flex: 1 1 auto;
  flex-direction: column;
  position: relative;
  margin: 4px 0;
  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2);
}
.action-text-editable__submit[data-v-df9c1bf0] {
  position: absolute;
  inset-inline-start: 0;
  top: auto;
  width: 1px;
  height: 1px;
  overflow: hidden;
  z-index: -1;
  opacity: 0;
}
.action-text-editable__label[data-v-df9c1bf0] {
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  inset-inline-end: calc((var(--default-clickable-area) - 16px) / 2 + 1px);
  bottom: 1px;
  width: calc(var(--default-clickable-area) - 8px);
  height: calc(var(--default-clickable-area) - 8px);
  box-sizing: border-box;
  margin: 0;
  padding: 7px 6px;
  border: 0;
  border-radius: 50%;
  /* Avoid background under border */
  background-color: var(--color-main-background);
  background-clip: padding-box;
}
.action-text-editable__label[data-v-df9c1bf0], .action-text-editable__label[data-v-df9c1bf0] * {
  cursor: pointer;
}
.action-text-editable__textarea[data-v-df9c1bf0] {
  flex: 1 1 auto;
  color: inherit;
  border-color: var(--color-border-maxcontrast);
  min-height: calc(var(--default-clickable-area) * 2 - 8px); /* twice the element margin-y */
  max-height: calc(var(--default-clickable-area) * 3 - 8px); /* twice the element margin-y */
  min-width: calc(var(--default-clickable-area) * 4);
  width: 100% !important;
  margin: 0;
  /* only show confirm borders if input is not focused */
}
.action-text-editable__textarea[data-v-df9c1bf0]:disabled {
  cursor: default;
}
.action-text-editable__textarea:not(:active):not(:hover):not(:focus):invalid + .action-text-editable__label[data-v-df9c1bf0] {
  background-color: var(--color-error);
}
.action-text-editable__textarea:not(:active):not(:hover):not(:focus):not(:disabled) + .action-text-editable__label[data-v-df9c1bf0]:active, .action-text-editable__textarea:not(:active):not(:hover):not(:focus):not(:disabled) + .action-text-editable__label[data-v-df9c1bf0]:hover, .action-text-editable__textarea:not(:active):not(:hover):not(:focus):not(:disabled) + .action-text-editable__label[data-v-df9c1bf0]:focus {
  background-color: var(--color-primary-element);
  color: var(--color-primary-element-text);
}
.action-text-editable__textarea:active:not(:disabled) + .action-text-editable__label[data-v-df9c1bf0], .action-text-editable__textarea:hover:not(:disabled) + .action-text-editable__label[data-v-df9c1bf0], .action-text-editable__textarea:focus:not(:disabled) + .action-text-editable__label[data-v-df9c1bf0] {
  /* above previous input */
  z-index: 2;
  border-color: var(--color-primary-element);
  border-inline-start-color: transparent;
}
li:last-child > .action-text-editable[data-v-df9c1bf0] {
  margin-bottom: calc((var(--default-clickable-area) - 16px) / 2 - 4px);
}
li:first-child > .action-text-editable[data-v-df9c1bf0] {
  margin-top: calc((var(--default-clickable-area) - 16px) / 2 - 4px);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-a5fd2a54] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-details-toggle[data-v-a5fd2a54] {
  position: sticky;
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  padding: calc((var(--default-clickable-area) - 16px) / 2);
  cursor: pointer;
  opacity: 0.6;
  transform: rotate(180deg);
  background-color: var(--color-main-background);
  z-index: 2000;
  top: var(--app-navigation-padding);
  inset-inline-start: calc(var(--default-clickable-area) + var(--app-navigation-padding) * 2);
}
.app-details-toggle--mobile[data-v-a5fd2a54] {
  inset-inline-start: var(--app-navigation-padding);
}
.app-details-toggle[data-v-a5fd2a54]:active, .app-details-toggle[data-v-a5fd2a54]:hover, .app-details-toggle[data-v-a5fd2a54]:focus {
  opacity: 1;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-8d2eca70] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-content[data-v-8d2eca70] {
  position: initial;
  z-index: 1000;
  flex-basis: 100vw;
  height: 100%;
  margin: 0 !important;
  background-color: var(--color-main-background);
  min-width: 0;
}
.app-content[data-v-8d2eca70]:not(.app-content--has-list) {
  overflow: auto;
}
.app-content-wrapper[data-v-8d2eca70] {
  position: relative;
  width: 100%;
  height: 100%;
}
.app-content-wrapper--no-split.app-content-wrapper--show-list[data-v-8d2eca70]  .app-content-list {
  display: flex;
}
.app-content-wrapper--no-split.app-content-wrapper--show-list[data-v-8d2eca70]  .app-content-details {
  display: none;
}
.app-content-wrapper--no-split.app-content-wrapper--show-details[data-v-8d2eca70]  .app-content-list {
  display: none;
}
.app-content-wrapper--no-split.app-content-wrapper--show-details[data-v-8d2eca70]  .app-content-details {
  display: block;
}
[data-v-8d2eca70] .splitpanes.default-theme .app-content-list {
  max-width: none;
  /* Thin scrollbar is hard to catch on resizable columns */
  scrollbar-width: auto;
}
[data-v-8d2eca70] .splitpanes.default-theme .splitpanes__pane {
  background-color: transparent;
  transition: none;
}
[data-v-8d2eca70] .splitpanes.default-theme .splitpanes__pane-list {
  min-width: 300px;
  position: sticky;
}
@media only screen and (width < 1024px) {
[data-v-8d2eca70] .splitpanes.default-theme .splitpanes__pane-list {
    display: none;
}
}
[data-v-8d2eca70] .splitpanes.default-theme .splitpanes__pane-details {
  overflow-y: auto;
}
@media only screen and (width < 1024px) {
[data-v-8d2eca70] .splitpanes.default-theme .splitpanes__pane-details {
    min-width: 100%;
}
}
[data-v-8d2eca70] .splitpanes.default-theme .splitpanes__splitter {
  background-color: var(--color-main-background);
}
[data-v-8d2eca70] .splitpanes.default-theme .splitpanes__splitter::before,[data-v-8d2eca70] .splitpanes.default-theme .splitpanes__splitter::after {
  background-color: var(--color-border);
}
[data-v-8d2eca70] .splitpanes.default-theme.splitpanes--vertical .splitpanes__splitter {
  border-inline-start: 1px solid var(--color-border);
}
[data-v-8d2eca70] .splitpanes.default-theme.splitpanes--horizontal .splitpanes__splitter {
  border-top: 1px solid var(--color-border);
}
.app-content-wrapper--show-list[data-v-8d2eca70] .app-content-list {
  max-width: none;
}.splitpanes{display:flex;width:100%;height:100%}.splitpanes--vertical{flex-direction:row}.splitpanes--horizontal{flex-direction:column}.splitpanes--dragging .splitpanes__pane,*:has(.splitpanes--dragging){-webkit-user-select:none;user-select:none;pointer-events:none}.splitpanes__pane{width:100%;height:100%;overflow:hidden}.splitpanes--vertical .splitpanes__pane{transition:width .2s ease-out;will-change:width}.splitpanes--horizontal .splitpanes__pane{transition:height .2s ease-out;will-change:height}.splitpanes--dragging .splitpanes__pane{transition:none}.splitpanes__splitter{touch-action:none}.splitpanes--vertical>.splitpanes__splitter{min-width:1px;cursor:col-resize}.splitpanes--horizontal>.splitpanes__splitter{min-height:1px;cursor:row-resize}.default-theme.splitpanes .splitpanes__pane{background-color:#f2f2f2}.default-theme.splitpanes .splitpanes__splitter{background-color:#fff;box-sizing:border-box;position:relative;flex-shrink:0}.default-theme.splitpanes .splitpanes__splitter:before,.default-theme.splitpanes .splitpanes__splitter:after{content:"";position:absolute;top:50%;left:50%;background-color:#00000026;transition:background-color .3s}.default-theme.splitpanes .splitpanes__splitter:hover:before,.default-theme.splitpanes .splitpanes__splitter:hover:after{background-color:#00000040}.default-theme.splitpanes .splitpanes__splitter:first-child{cursor:auto}.default-theme.splitpanes .splitpanes .splitpanes__splitter{z-index:1}.default-theme.splitpanes--vertical>.splitpanes__splitter,.default-theme .splitpanes--vertical>.splitpanes__splitter{width:7px;border-left:1px solid #eee;margin-left:-1px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{transform:translateY(-50%);width:1px;height:30px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:before{margin-left:-2px}.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{margin-left:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter,.default-theme .splitpanes--horizontal>.splitpanes__splitter{height:7px;border-top:1px solid #eee;margin-top:-1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{transform:translate(-50%);width:30px;height:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before{margin-top:-2px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{margin-top:1px}
/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-4d22a675] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation-caption[data-v-4d22a675] {
  display: flex;
  justify-content: space-between;
}
.app-navigation-caption--heading[data-v-4d22a675] {
  padding: var(--app-navigation-padding);
}
.app-navigation-caption--heading[data-v-4d22a675]:not(:first-child):not(:last-child) {
  padding: 0 var(--app-navigation-padding);
}
.app-navigation-caption__name[data-v-4d22a675] {
  font-weight: bold;
  color: var(--color-main-text);
  font-size: var(--default-font-size);
  line-height: var(--default-clickable-area);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  box-shadow: none !important;
  flex-shrink: 0;
  padding-block: 0;
  padding-inline: calc(var(--default-grid-baseline, 4px) * 2) 0;
  margin-top: 0px;
  margin-bottom: var(--default-grid-baseline);
}
.app-navigation-caption__actions[data-v-4d22a675] {
  flex: 0 0 var(--default-clickable-area);
}
.app-navigation-caption[data-v-4d22a675]:not(:first-child) {
  margin-top: calc(var(--default-clickable-area) / 2);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-938dadb1] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation-entry__icon-bullet[data-v-938dadb1] {
  display: block;
  padding: calc((var(--default-clickable-area) - 16px) / 2 + 1px);
}
.app-navigation-entry__icon-bullet div[data-v-938dadb1] {
  width: 14px;
  height: 14px;
  cursor: pointer;
  transition: background 100ms ease-in-out;
  border: none;
  border-radius: 50%;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-489f71a9] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/**
 * SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
.app-navigation-entry[data-v-489f71a9] {
  position: relative;
  display: flex;
  flex-shrink: 0;
  flex-wrap: wrap;
  width: 100%;
  min-height: var(--default-clickable-area);
  transition: background-color var(--animation-quick) ease-in-out;
  transition: background-color 200ms ease-in-out;
  border-radius: var(--border-radius-element);
  /* hide deletion/collapse of subitems */
}
.app-navigation-entry-wrapper[data-v-489f71a9] {
  position: relative;
  display: flex;
  flex-shrink: 0;
  flex-wrap: wrap;
  width: 100%;
}
.app-navigation-entry-wrapper.app-navigation-entry--collapsible:not(.app-navigation-entry--opened) > ul[data-v-489f71a9] {
  display: none;
}
.app-navigation-entry.active[data-v-489f71a9] {
  background-color: var(--color-primary-element) !important;
}
.app-navigation-entry.active[data-v-489f71a9]:hover {
  background-color: var(--color-primary-element-hover) !important;
}
.app-navigation-entry.active .app-navigation-entry-link[data-v-489f71a9], .app-navigation-entry.active .app-navigation-entry-button[data-v-489f71a9] {
  color: var(--color-primary-element-text) !important;
}
.app-navigation-entry[data-v-489f71a9]:focus-within, .app-navigation-entry[data-v-489f71a9]:hover {
  background-color: var(--color-background-hover);
}
.app-navigation-entry.active .app-navigation-entry__children[data-v-489f71a9], .app-navigation-entry:focus-within .app-navigation-entry__children[data-v-489f71a9], .app-navigation-entry:hover .app-navigation-entry__children[data-v-489f71a9] {
  background-color: var(--color-main-background);
}
.app-navigation-entry.active .app-navigation-entry__utils .app-navigation-entry__actions[data-v-489f71a9], .app-navigation-entry.app-navigation-entry--deleted .app-navigation-entry__utils .app-navigation-entry__actions[data-v-489f71a9], .app-navigation-entry:focus .app-navigation-entry__utils .app-navigation-entry__actions[data-v-489f71a9], .app-navigation-entry:focus-within .app-navigation-entry__utils .app-navigation-entry__actions[data-v-489f71a9], .app-navigation-entry:hover .app-navigation-entry__utils .app-navigation-entry__actions[data-v-489f71a9] {
  display: inline-block;
}
.app-navigation-entry.app-navigation-entry--deleted > ul[data-v-489f71a9] {
  display: none;
}
.app-navigation-entry:not(.app-navigation-entry--editing) .app-navigation-entry-link[data-v-489f71a9], .app-navigation-entry:not(.app-navigation-entry--editing) .app-navigation-entry-button[data-v-489f71a9] {
  padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2);
}
.app-navigation-entry .app-navigation-entry-link[data-v-489f71a9], .app-navigation-entry .app-navigation-entry-button[data-v-489f71a9] {
  z-index: 100; /* above the bullet to allow click*/
  display: flex;
  overflow: hidden;
  flex: 1 1 0;
  min-height: var(--default-clickable-area);
  padding: 0;
  white-space: nowrap;
  color: var(--color-main-text);
  background-repeat: no-repeat;
  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;
  background-size: 16px 16px;
  line-height: var(--default-clickable-area);
}
.app-navigation-entry .app-navigation-entry-link .app-navigation-entry-icon[data-v-489f71a9], .app-navigation-entry .app-navigation-entry-button .app-navigation-entry-icon[data-v-489f71a9] {
  display: flex;
  align-items: center;
  flex: 0 0 var(--default-clickable-area);
  justify-content: center;
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  background-size: 16px 16px;
  background-repeat: no-repeat;
  background-position: calc((var(--default-clickable-area) - 16px) / 2) center;
}
.app-navigation-entry .app-navigation-entry-link .app-navigation-entry__name[data-v-489f71a9], .app-navigation-entry .app-navigation-entry-button .app-navigation-entry__name[data-v-489f71a9] {
  overflow: hidden;
  max-width: 100%;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.app-navigation-entry .app-navigation-entry-link .editingContainer[data-v-489f71a9], .app-navigation-entry .app-navigation-entry-button .editingContainer[data-v-489f71a9] {
  width: calc(100% - var(--default-clickable-area));
  margin: auto;
}
.app-navigation-entry .app-navigation-entry-link[data-v-489f71a9]:focus-visible, .app-navigation-entry .app-navigation-entry-button[data-v-489f71a9]:focus-visible {
  box-shadow: 0 0 0 4px var(--color-main-background);
  outline: 2px solid var(--color-main-text);
  border-radius: var(--border-radius-element);
}

/* Second level nesting for lists */
.app-navigation-entry__children[data-v-489f71a9] {
  --app-navigation-item-child-offset: 10px;
  position: relative;
  display: flex;
  flex: 0 1 auto;
  flex-direction: column;
  width: 100%;
  gap: var(--default-grid-baseline, 4px);
  padding-inline-start: var(--app-navigation-item-child-offset);
}
.app-navigation-entry__children .app-navigation-entry[data-v-489f71a9] {
  display: inline-flex;
  flex-wrap: wrap;
}
.app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children .app-navigation-entry__children[data-v-489f71a9] {
  --app-navigation-item-child-offset: 0;
}

/* Deleted entries */
.app-navigation-entry__deleted[data-v-489f71a9] {
  display: inline-flex;
  flex: 1 1 0;
  padding-inline-start: calc(var(--default-clickable-area) - (var(--default-clickable-area) - 16px) / 2) !important;
}
.app-navigation-entry__deleted .app-navigation-entry__deleted-description[data-v-489f71a9] {
  position: relative;
  overflow: hidden;
  flex: 1 1 0;
  white-space: nowrap;
  text-overflow: ellipsis;
  line-height: var(--default-clickable-area);
}

/* counter and actions */
.app-navigation-entry__utils[data-v-489f71a9] {
  display: flex;
  min-width: var(--default-clickable-area);
  align-items: center;
  flex: 0 1 auto;
  justify-content: flex-end;
  /* counter */
  /* actions */
}
.app-navigation-entry__utils.app-navigation-entry__utils--display-actions .action-item.app-navigation-entry__actions[data-v-489f71a9] {
  display: inline-block;
}
.app-navigation-entry__utils .app-navigation-entry__counter-wrapper[data-v-489f71a9] {
  margin-inline-end: calc(var(--default-grid-baseline) * 2);
  display: flex;
  align-items: center;
  flex: 0 1 auto;
}
.app-navigation-entry__utils .action-item.app-navigation-entry__actions[data-v-489f71a9] {
  display: none;
}

/* editing state */
.app-navigation-entry--editing .app-navigation-entry-edit[data-v-489f71a9] {
  z-index: 250;
  opacity: 1;
}

/* deleted state */
.app-navigation-entry--deleted .app-navigation-entry-deleted[data-v-489f71a9] {
  z-index: 250;
  transform: translateX(0);
}

/* pinned state */
.app-navigation-entry--pinned[data-v-489f71a9] {
  order: 2;
  margin-top: auto;
}
.app-navigation-entry--pinned ~ .app-navigation-entry--pinned[data-v-489f71a9] {
  margin-top: 0;
}
[data-themes*=highcontrast] .app-navigation-entry[data-v-489f71a9]:active {
  background-color: var(--color-primary-element-light-hover) !important;
}
.app-navigation-new-item__name[data-v-489f71a9] {
  overflow: hidden;
  max-width: 100%;
  white-space: nowrap;
  text-overflow: ellipsis;
  padding-inline-start: 7px;
  font-size: 14px;
}
.newItemContainer[data-v-489f71a9] {
  width: calc(100% - var(--default-clickable-area));
  margin: auto;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-26ea0724] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-navigation-search[data-v-26ea0724] {
  display: flex;
  gap: var(--app-navigation-padding);
  padding: var(--app-navigation-padding);
}
.app-navigation-search--has-actions .app-navigation-search__input[data-v-26ea0724] {
  flex-grow: 1;
  z-index: 3;
}
.app-navigation-search__actions[data-v-26ea0724] {
  display: flex;
  gap: var(--default-grid-baseline);
  margin-inline-start: 0;
  max-width: calc(2 * var(--default-clickable-area) + var(--default-grid-baseline));
  max-height: var(--default-clickable-area);
  transition: margin-inline-start var(--animation-quick);
}
.app-navigation-search__actions--hidden[data-v-26ea0724] {
  margin-inline-start: calc(-1 * var(--default-clickable-area));
}
._container_svdcj_2 {
	margin-top: auto;
	padding: var(--default-grid-baseline);
}
._header_svdcj_7 {
	margin-block: 0 var(--default-grid-baseline);
	margin-inline: var(--default-grid-baseline);
}

/* Overwrite the padding to match NcAppNavigationItem */
._button_svdcj_13 {
	padding-left: 0 !important;
	padding-inline-end: calc((var(--default-clickable-area) - 16px) / 2) !important;
.button-vue__text {
		font-weight: normal;
}
}
._content_svdcj_22 {
	display: block;
	padding: 10px;

	/* prevent scrolled contents from stopping too early */
	margin-bottom: calc(-1 * var(--default-grid-baseline));

	/* restrict height of settings and make scrollable */
	max-height: 300px;
	overflow-y: auto;
}
._animationActive_svdcj_34 {
	transition-duration: var(--animation-slow);
	transition-property: max-height, padding;
	overflow-y: hidden !important;
}
._animationStop_svdcj_40 {
	max-height: 0 !important;
	padding: 0 10px !important;
}

.app-navigation-spacer[data-v-277fa710] {
		flex-shrink: 0;
		height: 22px;
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-92616d32] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
[data-v-92616d32] .app-settings__navigation {
  min-width: 200px;
  margin-inline-end: calc(4 * var(--default-grid-baseline));
  overflow-x: hidden;
  overflow-y: auto;
  position: relative;
}
[data-v-92616d32] .app-settings__content {
  padding-inline: calc(4 * var(--default-grid-baseline));
}
.navigation-list[data-v-92616d32] {
  height: 100%;
  overflow-y: auto;
  padding: calc(3 * var(--default-grid-baseline));
}
.navigation-list__link[data-v-92616d32] {
  display: flex;
  align-content: center;
  font-size: 16px;
  height: var(--default-clickable-area);
  margin: 4px 0;
  line-height: var(--default-clickable-area);
  border-radius: var(--border-radius-element);
  font-weight: bold;
  padding: 0 calc(4 * var(--default-grid-baseline));
  cursor: pointer;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  background-color: transparent;
  border: none;
}
.navigation-list__link[data-v-92616d32]:hover, .navigation-list__link[data-v-92616d32]:focus {
  background-color: var(--color-background-hover);
}
.navigation-list__link--active[data-v-92616d32] {
  background-color: var(--color-primary-element-light) !important;
}
.navigation-list__link--icon[data-v-92616d32] {
  padding-inline-start: calc(2 * var(--default-grid-baseline));
  gap: var(--default-grid-baseline);
}
.navigation-list__link-icon[data-v-92616d32] {
  display: flex;
  justify-content: center;
  align-content: center;
  width: calc(var(--default-clickable-area) - 2 * var(--default-grid-baseline));
  max-width: calc(var(--default-clickable-area) - 2 * var(--default-grid-baseline));
}
@media only screen and (max-width: 512px) {
.app-settings[data-v-92616d32] .dialog__name {
    padding-inline-start: 16px;
}
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-ce8fac13] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-settings-section[data-v-ce8fac13] {
  margin-bottom: 80px;
}
.app-settings-section__name[data-v-ce8fac13] {
  font-size: 1.6em;
  margin: 0;
  padding: 20px 0;
  font-weight: bold;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-9a713930] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-sidebar-tabs[data-v-9a713930] {
  display: flex;
  flex-direction: column;
  min-height: 0;
  flex: 1 1 100%;
}
.app-sidebar-tabs__nav[data-v-9a713930] {
  display: flex;
  justify-content: stretch;
  margin: 10px 8px 0 8px;
  border-bottom: 1px solid var(--color-border);
}
.app-sidebar-tabs__nav[data-v-9a713930] .checkbox-radio-switch--button-variant {
  border: unset !important;
  border-radius: 0 !important;
}
.app-sidebar-tabs__nav[data-v-9a713930] .checkbox-radio-switch--button-variant .checkbox-content {
  padding: var(--default-grid-baseline);
  border-radius: var(--default-grid-baseline) var(--default-grid-baseline) 0 0 !important;
  margin: 0 !important;
  border-bottom: var(--default-grid-baseline) solid transparent !important;
}
.app-sidebar-tabs__nav[data-v-9a713930] .checkbox-radio-switch--button-variant .checkbox-content .checkbox-content__icon > * {
  color: var(--color-main-text) !important;
}
.app-sidebar-tabs__nav[data-v-9a713930] .checkbox-radio-switch--button-variant.checkbox-radio-switch--checked .checkbox-radio-switch__content {
  background: transparent !important;
  color: var(--color-main-text) !important;
  border-bottom: var(--default-grid-baseline) solid var(--color-primary-element) !important;
}
.app-sidebar-tabs__tab[data-v-9a713930] {
  flex: 1 1;
}
.app-sidebar-tabs__tab.active[data-v-9a713930] {
  color: var(--color-primary-element);
}
.app-sidebar-tabs__tab-caption[data-v-9a713930] {
  flex: 0 1 100%;
  width: 100%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  text-align: center;
}
.app-sidebar-tabs__tab-icon[data-v-9a713930] {
  display: flex;
  align-items: center;
  justify-content: center;
  background-size: 20px;
}
.app-sidebar-tabs__tab[data-v-9a713930] .checkbox-radio-switch__content {
  max-width: unset;
}
.app-sidebar-tabs__content[data-v-9a713930] {
  position: relative;
  min-height: 256px;
  height: 100%;
}
.app-sidebar-tabs__content--multiple[data-v-9a713930] > :not(section) {
  display: none;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
@property --app-sidebar-offset {
  syntax: "<length>";
  initial-value: 0;
  inherits: true;
}
body {
  /**
   * The padding between the toggle button and the page border
   */
  --app-sidebar-padding: calc(var(--default-grid-baseline, 4px) * 2);
  /**
   * The minimal offset width required to be reserved for the toggle button.
   * Automatically changes to 0 when there is no toggle button.
   */
  --app-sidebar-offset: 0;
  transition: --app-sidebar-offset 0ms !important;
}
body:has(.app-sidebar.slide-right-enter-active),
body:has(.app-sidebar.slide-right-leave-active) {
  transition: --app-sidebar-offset var(--animation-quick);
}
body:has(.app-sidebar__toggle) {
  --app-sidebar-offset: calc(var(--app-sidebar-padding) + var(--default-clickable-area));
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-75d9d903] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/*
	Sidebar: to be used within #content
	app-content will be shrinked properly
*/
.app-sidebar[data-v-75d9d903] {
  --app-sidebar-width: clamp(300px, 27vw, 500px);
  --app-sidebar-padding: calc(var(--default-grid-baseline, 4px) * 2);
  width: var(--app-sidebar-width);
  z-index: 1500;
  top: 0;
  inset-inline-end: 0;
  display: flex;
  overflow-x: hidden;
  overflow-y: auto;
  flex-direction: column;
  flex-shrink: 0;
  height: 100%;
  border-inline-start: 1px solid var(--color-border);
  background: var(--color-main-background);
  position: relative;
}
.app-sidebar__toggle[data-v-75d9d903] {
  position: absolute !important;
  inset-block-start: var(--app-sidebar-padding);
  inset-inline-end: var(--app-sidebar-padding);
  z-index: 1001;
}
.app-sidebar .app-sidebar-header[data-v-75d9d903] {
  --app-sidebar-close-button-offset: calc(var(--default-clickable-area) + var(--app-sidebar-padding));
}
.app-sidebar .app-sidebar-header > .app-sidebar__close[data-v-75d9d903] {
  position: absolute;
  z-index: 100;
  top: var(--app-sidebar-padding);
  inset-inline-end: var(--app-sidebar-padding);
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
}
.app-sidebar .app-sidebar-header--compact.app-sidebar-header--with-figure .app-sidebar-header__info[data-v-75d9d903] {
  flex-direction: row;
}
.app-sidebar .app-sidebar-header--compact.app-sidebar-header--with-figure .app-sidebar-header__info .app-sidebar-header__figure[data-v-75d9d903] {
  --figure-size: calc($desc-height + var(--app-sidebar-padding));
  z-index: 2;
  width: var(--figure-size);
  height: var(--figure-size);
  margin: calc(var(--app-sidebar-padding) / 2);
  border-radius: 3px;
  flex: 0 0 auto;
}
.app-sidebar .app-sidebar-header--compact.app-sidebar-header--with-figure .app-sidebar-header__info .app-sidebar-header__desc[data-v-75d9d903] {
  padding-inline-start: 0;
  flex: 1 1 auto;
  min-width: 0;
  padding-inline-end: calc(var(--default-clickable-area) + var(--app-sidebar-close-button-offset));
  padding-top: var(--app-sidebar-padding);
}
.app-sidebar .app-sidebar-header--compact.app-sidebar-header--with-figure .app-sidebar-header__info .app-sidebar-header__desc.app-sidebar-header__desc--without-actions[data-v-75d9d903] {
  padding-inline-end: var(--app-sidebar-close-button-offset);
}
.app-sidebar .app-sidebar-header--compact.app-sidebar-header--with-figure .app-sidebar-header__info .app-sidebar-header__desc .app-sidebar-header__tertiary-actions[data-v-75d9d903] {
  z-index: 3;
  position: absolute;
  top: calc(var(--app-sidebar-padding) / 2);
  inset-inline-start: calc(-1 * var(--default-clickable-area));
  gap: 0;
}
.app-sidebar .app-sidebar-header--compact.app-sidebar-header--with-figure .app-sidebar-header__info .app-sidebar-header__desc .app-sidebar-header__menu[data-v-75d9d903] {
  top: var(--app-sidebar-padding);
  inset-inline-end: var(--app-sidebar-close-button-offset);
  position: absolute;
}
.app-sidebar .app-sidebar-header:not(.app-sidebar-header--with-figure) .app-sidebar-header__menu[data-v-75d9d903] {
  position: absolute;
  top: var(--app-sidebar-padding);
  inset-inline-end: var(--app-sidebar-close-button-offset);
}
.app-sidebar .app-sidebar-header:not(.app-sidebar-header--with-figure) .app-sidebar-header__desc[data-v-75d9d903] {
  padding-inline-end: calc(var(--default-clickable-area) + var(--app-sidebar-close-button-offset));
}
.app-sidebar .app-sidebar-header:not(.app-sidebar-header--with-figure) .app-sidebar-header__desc.app-sidebar-header__desc--without-actions[data-v-75d9d903] {
  padding-inline-end: var(--app-sidebar-close-button-offset);
}
.app-sidebar .app-sidebar-header .app-sidebar-header__info[data-v-75d9d903] {
  display: flex;
  flex-direction: column;
}
.app-sidebar .app-sidebar-header__figure[data-v-75d9d903] {
  width: 100%;
  height: 250px;
  max-height: 250px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
}
.app-sidebar .app-sidebar-header__figure--with-action[data-v-75d9d903] {
  cursor: pointer;
}
.app-sidebar .app-sidebar-header__desc[data-v-75d9d903] {
  position: relative;
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: center;
  padding-inline: var(--app-sidebar-padding);
  padding-block: var(--app-sidebar-padding) calc(var(--app-sidebar-padding) / 2);
  gap: 0 4px;
}
.app-sidebar .app-sidebar-header__desc--with-tertiary-action[data-v-75d9d903] {
  padding-inline-start: 6px;
}
.app-sidebar .app-sidebar-header__desc--editable .app-sidebar-header__mainname-form[data-v-75d9d903], .app-sidebar .app-sidebar-header__desc--with-subname--editable .app-sidebar-header__mainname-form[data-v-75d9d903] {
  margin-top: -2px;
  margin-bottom: -2px;
}
.app-sidebar .app-sidebar-header__desc--with-subname--editable .app-sidebar-header__subname[data-v-75d9d903] {
  margin-top: -2px;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__tertiary-actions[data-v-75d9d903] {
  display: flex;
  height: var(--default-clickable-area);
  width: var(--default-clickable-area);
  justify-content: center;
  flex: 0 0 auto;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__tertiary-actions .app-sidebar-header__star[data-v-75d9d903] {
  box-shadow: none;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__tertiary-actions .app-sidebar-header__star[data-v-75d9d903]:not([aria-pressed=true]):hover {
  box-shadow: none;
  background-color: var(--color-background-hover);
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container[data-v-75d9d903] {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  justify-content: center;
  min-width: 0;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__mainname-container[data-v-75d9d903] {
  display: flex;
  align-items: center;
  min-height: var(--default-clickable-area);
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__mainname-container .app-sidebar-header__mainname[data-v-75d9d903] {
  padding: 0;
  min-height: 30px;
  font-size: 20px;
  line-height: 30px;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__mainname-container .app-sidebar-header__mainname[data-v-75d9d903] .linkified {
  cursor: pointer;
  text-decoration: underline;
  margin: 0;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__mainname-container .app-sidebar-header__mainname-form[data-v-75d9d903] {
  display: flex;
  flex: 1 1 auto;
  align-items: center;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__mainname-container .app-sidebar-header__mainname-form input.app-sidebar-header__mainname-input[data-v-75d9d903] {
  flex: 1 1 auto;
  margin: 0;
  padding: 7px;
  font-size: 20px;
  font-weight: bold;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__mainname-container .app-sidebar-header__menu[data-v-75d9d903] {
  margin-inline-start: 5px;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__mainname[data-v-75d9d903],
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__subname[data-v-75d9d903] {
  overflow: hidden;
  width: 100%;
  margin: 0;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__subname[data-v-75d9d903] {
  color: var(--color-text-maxcontrast);
  font-size: var(--default-font-size);
  padding: 0;
}
.app-sidebar .app-sidebar-header__desc .app-sidebar-header__name-container .app-sidebar-header__subname[data-v-75d9d903] * {
  vertical-align: text-bottom;
}
.app-sidebar .app-sidebar-header .app-sidebar-header__mainname--hidden[data-v-75d9d903] {
  position: absolute;
  top: 0;
  inset-inline-start: 0;
  margin: 0;
  width: 1px;
  height: 1px;
  overflow: hidden;
}
.app-sidebar .app-sidebar-header__description[data-v-75d9d903] {
  display: flex;
  align-items: center;
  margin: 0 10px;
}
@media only screen and (max-width: 512px) {
.app-sidebar[data-v-75d9d903] {
    position: absolute;
    --app-sidebar-width: 100vw;
}
}
.slide-right-leave-active[data-v-75d9d903],
.slide-right-enter-active[data-v-75d9d903] {
  transition-duration: var(--animation-quick);
  transition-property: margin-inline-end;
}
.slide-right-enter-to[data-v-75d9d903],
.slide-right-leave[data-v-75d9d903] {
  margin-inline-end: 0;
}
.slide-right-enter-from[data-v-75d9d903],
.slide-right-leave-to[data-v-75d9d903] {
  margin-inline-end: calc(-1 * var(--app-sidebar-width));
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-9d737d13] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.app-sidebar__tab[data-v-9d737d13] {
  display: none;
  padding: 10px;
  min-height: 100%;
  max-height: 100%;
  height: 100%;
  overflow: auto;
}
.app-sidebar__tab[data-v-9d737d13]:focus {
  border-color: var(--color-primary-element);
  box-shadow: 0 0 0.2em var(--color-primary-element);
  outline: 0;
}
.app-sidebar__tab--active[data-v-9d737d13] {
  display: block;
}
._fadeTransition_13rtj_2 {
	transition: all var(--animation-quick) ease;
}
._fadeTransitionActive_13rtj_6 {
	opacity: 0;
	position: absolute;
}
/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-01b9af70] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.vue-crumb[data-v-01b9af70] {
  background-image: none;
  display: inline-flex;
  height: var(--default-clickable-area);
  padding: 0;
}
.vue-crumb[data-v-01b9af70]:last-child {
  min-width: 0;
}
.vue-crumb:last-child .vue-crumb__separator[data-v-01b9af70] {
  display: none;
}
.vue-crumb--hidden[data-v-01b9af70] {
  display: none;
}
.vue-crumb__separator[data-v-01b9af70] {
  padding: 0;
  color: var(--color-text-maxcontrast);
}
.vue-crumb.vue-crumb--hovered[data-v-01b9af70] .button-vue {
  background-color: var(--color-background-dark);
  color: var(--color-main-text);
}
.vue-crumb[data-v-01b9af70]:not(:last-child)  .button-vue {
  color: var(--color-text-maxcontrast);
}
.vue-crumb[data-v-01b9af70]:not(:last-child)  .button-vue:hover, .vue-crumb[data-v-01b9af70]:not(:last-child)  .button-vue:focus {
  background-color: var(--color-background-dark);
  color: var(--color-main-text);
}
.vue-crumb[data-v-01b9af70]:not(:last-child)  .button-vue__text {
  font-weight: normal;
}
.vue-crumb[data-v-01b9af70] .button-vue__text {
  margin: 0;
}
.vue-crumb[data-v-01b9af70]:not(.dropdown) .action-item {
  max-width: 100%;
}
.vue-crumb[data-v-01b9af70]:not(.dropdown) .action-item .button-vue {
  padding: 0 4px 0 16px;
  max-width: 100%;
}
.vue-crumb[data-v-01b9af70]:not(.dropdown) .action-item .button-vue__wrapper {
  flex-direction: row-reverse;
}
.vue-crumb[data-v-01b9af70]:not(.dropdown) .action-item.action-item--open .action-item__menutoggle {
  background-color: var(--color-background-dark);
  color: var(--color-main-text);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-b3c47ad6] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.breadcrumb[data-v-b3c47ad6] {
  width: 100%;
  flex-grow: 1;
  display: inline-flex;
  align-items: center;
}
.breadcrumb--collapsed[data-v-b3c47ad6] .vue-crumb:last-child {
  min-width: 100px;
}
.breadcrumb nav[data-v-b3c47ad6] {
  flex-shrink: 1;
  min-width: 0;
}
.breadcrumb .breadcrumb__crumbs[data-v-b3c47ad6] {
  max-width: 100%;
}
.breadcrumb .breadcrumb__crumbs[data-v-b3c47ad6], .breadcrumb .breadcrumb__actions[data-v-b3c47ad6] {
  display: inline-flex;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-2a555c9b] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.nc-chip[data-v-2a555c9b] {
  --chip-size: 24px;
  --chip-radius: calc(var(--chip-size) / 2);
  height: var(--chip-size);
  max-width: fit-content;
  display: flex;
  flex-direction: row;
  align-items: center;
  border-radius: var(--chip-radius);
  background-color: var(--color-background-hover);
}
.nc-chip--primary[data-v-2a555c9b] {
  background-color: var(--color-primary-element);
  color: var(--color-primary-element-text);
}
.nc-chip--secondary[data-v-2a555c9b] {
  background-color: var(--color-primary-element-light);
  color: var(--color-primary-element-light-text);
}
.nc-chip--no-actions .nc-chip__text[data-v-2a555c9b] {
  padding-inline-end: calc(1.5 * var(--default-grid-baseline));
}
.nc-chip--no-icon .nc-chip__text[data-v-2a555c9b] {
  padding-inline-start: calc(1.5 * var(--default-grid-baseline));
}
.nc-chip__text[data-v-2a555c9b] {
  flex: 1 auto;
  overflow: hidden;
  text-overflow: ellipsis;
  text-wrap: nowrap;
}
.nc-chip__icon[data-v-2a555c9b] {
  flex: 0 0 var(--chip-size);
  margin-inline-end: var(--default-grid-baseline);
  line-height: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  height: var(--chip-size);
  width: var(--chip-size);
}
.nc-chip__actions[data-v-2a555c9b] {
  flex: 0 0 var(--chip-size);
  --default-clickable-area: var(--chip-size);
  --border-radius-element: var(--chip-radius);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-8f8504e3] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.fade-enter-active[data-v-8f8504e3], .fade-leave-active[data-v-8f8504e3] {
  transition: opacity 0.3s ease;
}
.fade-enter[data-v-8f8504e3], .fade-leave-to[data-v-8f8504e3] {
  opacity: 0;
}
.linked-icons[data-v-8f8504e3] {
  display: flex;
}
.linked-icons img[data-v-8f8504e3] {
  padding: 12px;
  height: var(--default-clickable-area);
  display: block;
  background-repeat: no-repeat;
  background-position: center;
  opacity: 0.7;
}
.linked-icons img[data-v-8f8504e3]:hover {
  opacity: 1;
}
.popovermenu[data-v-8f8504e3] {
  display: none;
}
.popovermenu.open[data-v-8f8504e3] {
  display: block;
}
li.collection-list-item[data-v-8f8504e3] {
  flex-wrap: wrap;
  height: auto;
  cursor: pointer;
  margin-bottom: 0 !important;
}
li.collection-list-item .collection-avatar[data-v-8f8504e3] {
  margin-top: 0;
}
li.collection-list-item form[data-v-8f8504e3], li.collection-list-item .collection-item-name[data-v-8f8504e3] {
  flex-basis: 10%;
  flex-grow: 1;
  display: flex;
}
li.collection-list-item .collection-item-name[data-v-8f8504e3] {
  padding: 12px 9px;
}
li.collection-list-item input[data-v-8f8504e3] {
  margin-top: 4px;
  border-color: var(--color-border-maxcontrast);
}
li.collection-list-item input[type=text][data-v-8f8504e3] {
  flex-grow: 1;
}
li.collection-list-item .error[data-v-8f8504e3] {
  flex-basis: 100%;
  width: 100%;
}
li.collection-list-item .resource-list-details[data-v-8f8504e3] {
  flex-basis: 100%;
  width: 100%;
}
li.collection-list-item .resource-list-details li[data-v-8f8504e3] {
  display: flex;
  margin-inline-start: var(--default-clickable-area);
  border-radius: 3px;
  cursor: pointer;
}
li.collection-list-item .resource-list-details li[data-v-8f8504e3]:hover {
  background-color: var(--color-background-dark);
}
li.collection-list-item .resource-list-details li a[data-v-8f8504e3] {
  flex-grow: 1;
  padding: 3px;
  max-width: calc(100% - 30px);
  display: flex;
}
li.collection-list-item .resource-list-details span[data-v-8f8504e3] {
  display: inline-block;
  vertical-align: top;
  margin-inline-end: 10px;
}
li.collection-list-item .resource-list-details span.resource-name[data-v-8f8504e3] {
  text-overflow: ellipsis;
  overflow: hidden;
  position: relative;
  vertical-align: top;
  white-space: nowrap;
  flex-grow: 1;
  padding: 4px;
}
li.collection-list-item .resource-list-details img[data-v-8f8504e3] {
  width: 24px;
  height: 24px;
}
li.collection-list-item .resource-list-details .icon-close[data-v-8f8504e3] {
  opacity: 0.7;
}
li.collection-list-item .resource-list-details .icon-close[data-v-8f8504e3]:hover, li.collection-list-item .resource-list-details .icon-close[data-v-8f8504e3]:focus {
  opacity: 1;
}
.should-shake[data-v-8f8504e3] {
  animation: shake-8f8504e3 0.6s 1 linear;
}
@keyframes shake-8f8504e3 {
0% {
    transform: translate(15px);
}
20% {
    transform: translate(-15px);
}
40% {
    transform: translate(7px);
}
60% {
    transform: translate(-7px);
}
80% {
    transform: translate(3px);
}
100% {
    transform: translate(0px);
}
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-a28f0c9a] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.collection-list[data-v-a28f0c9a] * {
  box-sizing: border-box;
}
.collection-list > li[data-v-a28f0c9a] {
  display: flex;
  align-items: center;
  gap: 12px;
}
.collection-list > li > .avatar[data-v-a28f0c9a] {
  margin-top: 0;
}
#collection-select-container[data-v-a28f0c9a] {
  display: flex;
  flex-direction: column;
}
.v-select span.avatar[data-v-a28f0c9a] {
  display: block;
  padding: 16px;
  opacity: 0.7;
  background-repeat: no-repeat;
  background-position: center;
}
.v-select span.avatar[data-v-a28f0c9a]:hover {
  opacity: 1;
}
p.hint[data-v-a28f0c9a] {
  z-index: 1;
  margin-top: -16px;
  padding: 8px 8px;
  color: var(--color-text-maxcontrast);
  line-height: normal;
}
div.avatar[data-v-a28f0c9a] {
  width: 32px;
  height: 32px;
  margin: 0;
  padding: 8px;
  background-color: var(--color-background-dark);
  margin-top: 30px;
}

/** TODO provide white icon in core */
.icon-projects[data-v-a28f0c9a] {
  display: block;
  padding: 8px;
  background-repeat: no-repeat;
  background-position: center;
}
.option__wrapper[data-v-a28f0c9a] {
  display: flex;
}
.option__wrapper .avatar[data-v-a28f0c9a] {
  display: block;
  width: 32px;
  height: 32px;
  background-color: var(--color-background-darker) !important;
}
.option__wrapper .option__title[data-v-a28f0c9a] {
  padding: 4px;
}
.fade-enter-active[data-v-a28f0c9a], .fade-leave-active[data-v-a28f0c9a] {
  transition: opacity 0.5s;
}
.fade-enter[data-v-a28f0c9a], .fade-leave-to[data-v-a28f0c9a] {
  opacity: 0;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-3ec4b698] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.color-picker[data-v-3ec4b698] {
  display: flex;
  overflow: hidden;
  align-content: flex-end;
  flex-direction: column;
  justify-content: space-between;
  width: 176px;
  padding: 8px;
  border-radius: 3px;
}
.color-picker--advanced-fields[data-v-3ec4b698] {
  width: 264px;
}
.color-picker__simple[data-v-3ec4b698] {
  display: grid;
  grid-template-columns: repeat(auto-fit, var(--default-clickable-area));
  grid-auto-rows: var(--default-clickable-area);
}
.color-picker__simple-color-circle[data-v-3ec4b698] {
  display: flex;
  align-items: center;
  justify-content: center;
  width: calc(var(--default-clickable-area) - 10px);
  height: calc(var(--default-clickable-area) - 10px);
  min-height: calc(var(--default-clickable-area) - 10px);
  margin: auto;
  padding: 0;
  color: white;
  border: 1px solid rgba(0, 0, 0, 0.25);
  border-radius: 50%;
  font-size: 16px;
}
.color-picker__simple-color-circle[data-v-3ec4b698]:focus-within {
  outline: 2px solid var(--color-main-text);
}
.color-picker__simple-color-circle[data-v-3ec4b698]:hover {
  opacity: 0.6;
}
.color-picker__simple-color-circle--active[data-v-3ec4b698] {
  width: calc(var(--default-clickable-area) - 6px);
  height: calc(var(--default-clickable-area) - 6px);
  min-height: calc(var(--default-clickable-area) - 6px);
  transition: all 100ms ease-in-out;
  opacity: 1 !important;
}
.color-picker__advanced[data-v-3ec4b698] {
  box-shadow: none !important;
}
.color-picker__navigation[data-v-3ec4b698] {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  margin-top: 10px;
}
[data-v-3ec4b698]  .vc-chrome {
  width: unset;
  background-color: var(--color-main-background);
}
[data-v-3ec4b698]  .vc-chrome-color-wrap {
  width: 30px;
  height: 30px;
}
[data-v-3ec4b698]  .vc-chrome-active-color {
  border-radius: 17px;
}
[data-v-3ec4b698]  .vc-chrome-body {
  padding: 14px 0 0 0;
  background-color: var(--color-main-background);
}
[data-v-3ec4b698]  .vc-chrome-body .vc-input__input {
  --input-border-radius: var(--border-radius-element);
  --input-border-width-offset: calc(var(--border-width-input-focused, 2px) - var(--border-width-input, 2px));
  width: 100%;
  height: var(--default-clickable-area);
  margin: 0;
  padding-inline: calc(var(--border-radius-element) + var(--input-border-width-offset));
  padding-block: var(--input-border-width-offset);
  border: var(--border-width-input, 2px) solid var(--color-border-maxcontrast);
  border-radius: var(--input-border-radius);
  font-size: var(--default-font-size);
  color: var(--color-main-text);
  box-shadow: none;
}
[data-v-3ec4b698]  .vc-chrome-body .vc-input__input:active:not([disabled]),[data-v-3ec4b698]  .vc-chrome-body .vc-input__input:hover:not([disabled]),[data-v-3ec4b698]  .vc-chrome-body .vc-input__input:focus:not([disabled]) {
  --input-border-width-offset: 0px;
  border-color: var(--color-main-text);
  border-width: var(--border-width-input-focused, 2px);
  box-shadow: 0 0 0 2px var(--color-main-background) !important;
}
[data-v-3ec4b698]  .vc-chrome-body .vc-input__input:active:not([disabled]) + .vc-input__label,[data-v-3ec4b698]  .vc-chrome-body .vc-input__input:hover:not([disabled]) + .vc-input__label,[data-v-3ec4b698]  .vc-chrome-body .vc-input__input:focus:not([disabled]) + .vc-input__label {
  color: var(--color-main-text);
}
[data-v-3ec4b698]  .vc-chrome-body .vc-input__label {
  position: absolute;
  inset-inline: var(--border-width-input-focused, 2px);
  inset-block-start: calc(-1.5 * var(--font-size-small, 13px) / 2);
  max-width: fit-content;
  margin-inline: calc(var(--border-radius-element) - var(--default-grid-baseline));
  margin-block: 0;
  padding-inline: var(--default-grid-baseline);
  font-family: var(--font-face);
  font-size: var(--font-size-small, 13px);
  line-height: 1.5;
  font-weight: 500;
  color: var(--color-text-maxcontrast);
  background-color: var(--color-main-background);
  pointer-events: none;
}
[data-v-3ec4b698]  .vc-chrome-toggle-btn {
  display: flex;
  justify-content: center;
  align-items: center;
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  margin-inline-start: 6px;
  filter: var(--background-invert-if-dark);
}
[data-v-3ec4b698]  .vc-chrome-toggle-icon {
  width: 24px;
  height: 24px;
  margin: 0;
}
[data-v-3ec4b698]  .vc-chrome-toggle-icon-highlight {
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  inset: 0;
}
[data-v-3ec4b698]  .vc-chrome-saturation-wrap {
  border-radius: 3px;
}
[data-v-3ec4b698]  .vc-chrome-saturation-circle {
  width: 20px;
  height: 20px;
}
.slide-enter-from[data-v-3ec4b698] {
  transform: translateX(-50%);
  opacity: 0;
}
.slide-enter-to[data-v-3ec4b698] {
  transform: translateX(0);
  opacity: 1;
}
.slide-leave-from[data-v-3ec4b698] {
  transform: translateX(0);
  opacity: 1;
}
.slide-leave-to[data-v-3ec4b698] {
  transform: translateX(-50%);
  opacity: 0;
}
.slide-enter-active[data-v-3ec4b698], .slide-leave-active[data-v-3ec4b698] {
  transition: all 50ms ease-in-out;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
#skip-actions.vue-skip-actions:focus-within {
  top: 0 !important;
  inset-inline-start: 0 !important;
  width: 100vw;
  height: 100vh;
  padding: var(--body-container-margin) !important;
  backdrop-filter: brightness(50%);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-225e6d1b] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.vue-skip-actions__container[data-v-225e6d1b] {
  background-color: var(--color-main-background);
  border-radius: var(--border-radius-element);
  padding: 22px;
}
.vue-skip-actions__headline[data-v-225e6d1b] {
  font-weight: bold;
  font-size: 20px;
  line-height: 30px;
  margin-bottom: 12px;
}
.vue-skip-actions__buttons[data-v-225e6d1b] {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
}
.vue-skip-actions__buttons[data-v-225e6d1b] > * {
  flex: 1 0 fit-content;
}
.vue-skip-actions__image[data-v-225e6d1b] {
  margin-top: 12px;
}
.vue-skip-actions__image[data-v-225e6d1b]:dir(rtl) {
  transform: rotateY(180deg);
}
.content[data-v-225e6d1b] {
  display: flex;
  width: calc(100% - var(--body-container-margin) * 2);
  border-radius: var(--body-container-radius);
  height: var(--body-height);
  overflow: hidden;
  padding: 0;
}
.content[data-v-225e6d1b]:not(.with-sidebar--full) {
  position: fixed;
}
.content[data-v-225e6d1b], .content[data-v-225e6d1b] * {
  box-sizing: border-box;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-27474da0] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0] {
  --dp-common-transition: all var(--animation-quick) ease-in;
  --dp-menu-padding: 6px 8px;
  --dp-animation-duration: var(--animation-quick);
  --dp-menu-appear-transition-timing: cubic-bezier(.4, 0, 1, 1);
  --dp-transition-timing: ease-out;
  --dp-action-row-transtion: all 0.2s ease-in;
  --dp-font-family: var(--font-face);
  --dp-border-radius: var(--border-radius-element);
  --dp-cell-border-radius: var(--border-radius-small);
  --dp-transition-length: 22px;
  --dp-transition-timing-general: var(--animation-quick);
  --dp-button-height: var(--default-clickable-area);
  --dp-month-year-row-height: var(--default-clickable-area);
  --dp-month-year-row-button-size: var(--clickable-area-small);
  --dp-button-icon-height: 20px;
  --dp-calendar-wrap-padding: 0 5px;
  --dp-cell-size: var(--default-clickable-area);
  --dp-cell-padding: 5px;
  --dp-common-padding: 10px;
  --dp-input-icon-padding: var(--default-clickable-area);
  --dp-input-padding: 6px 12px;
  --dp-menu-min-width: 260px;
  --dp-action-buttons-padding: 1px 6px;
  --dp-row-margin: 5px 0;
  --dp-calendar-header-cell-padding: 0.5rem;
  --dp-multi-calendars-spacing: 10px;
  --dp-overlay-col-padding: 3px;
  --dp-time-inc-dec-button-size: var(--default-clickable-area);
  --dp-font-size: 1rem;
  --dp-preview-font-size: var(--font-size-small);
  --dp-time-font-size: 2rem;
  --dp-action-button-height: var(--clickable-area-small);
  --dp-action-row-padding: 8px;
  --dp-direction: ltr;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  {
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_wrap {
  position: relative;
  width: 100%;
  box-sizing: unset;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_wrap:focus {
  border-color: var(--dp-border-color-hover);
  outline: none;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_valid {
  box-shadow: 0 0 var(--dp-border-radius) var(--dp-success-color);
  border-color: var(--dp-success-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_valid:hover {
  border-color: var(--dp-success-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_invalid {
  box-shadow: 0 0 var(--dp-border-radius) var(--dp-danger-color);
  border-color: var(--dp-danger-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_invalid:hover {
  border-color: var(--dp-danger-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input {
  background-color: var(--dp-background-color);
  border-radius: var(--dp-border-radius);
  font-family: var(--dp-font-family);
  border: 1px solid var(--dp-border-color);
  outline: none;
  transition: border-color 0.2s cubic-bezier(0.645, 0.045, 0.355, 1);
  width: 100%;
  font-size: var(--dp-font-size);
  line-height: calc(var(--dp-font-size) * 1.5);
  padding: var(--dp-input-padding);
  color: var(--dp-text-color);
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input::placeholder {
  opacity: 0.7;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input:hover:not(.dp__input_focus) {
  border-color: var(--dp-border-color-hover);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_reg {
  caret-color: rgba(0, 0, 0, 0);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_focus {
  border-color: var(--dp-border-color-focus);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__disabled {
  background: var(--dp-disabled-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__disabled::placeholder {
  color: var(--dp-disabled-color-text);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_icons {
  display: inline-block;
  width: var(--dp-font-size);
  height: var(--dp-font-size);
  stroke-width: 0;
  font-size: var(--dp-font-size);
  line-height: calc(var(--dp-font-size) * 1.5);
  padding: 6px 12px;
  color: var(--dp-icon-color);
  box-sizing: content-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_icon {
  cursor: pointer;
  position: absolute;
  top: 50%;
  inset-inline-start: 0;
  transform: translateY(-50%);
  color: var(--dp-icon-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--clear-btn {
  position: absolute;
  top: 50%;
  inset-inline-end: 0;
  transform: translateY(-50%);
  cursor: pointer;
  color: var(--dp-icon-color);
  background: rgba(0, 0, 0, 0);
  border: none;
  display: inline-flex;
  align-items: center;
  padding: 0;
  margin: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__input_icon_pad {
  padding-inline-start: var(--dp-input-icon-padding);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu {
  background: var(--dp-background-color);
  border-radius: var(--dp-border-radius);
  min-width: var(--dp-menu-min-width);
  font-family: var(--dp-font-family);
  font-size: var(--dp-font-size);
  user-select: none;
  border: 1px solid var(--dp-menu-border-color);
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu::after {
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu::before {
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu:focus {
  border: 1px solid var(--dp-menu-border-color);
  outline: none;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--menu-wrapper {
  position: absolute;
  z-index: 99999;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu_inner {
  padding: var(--dp-menu-padding);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--menu--inner-stretched {
  padding: 6px 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu_index {
  z-index: 99999;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-loading, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu_readonly, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu_disabled {
  position: absolute;
  inset: 0;
  z-index: 999999;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu_disabled {
  background: hsla(0, 0%, 100%, 0.5);
  cursor: not-allowed;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu_readonly {
  background: rgba(0, 0, 0, 0);
  cursor: default;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-loading {
  background: hsla(0, 0%, 100%, 0.5);
  cursor: default;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--menu-load-container {
  display: flex;
  height: 100%;
  width: 100%;
  justify-content: center;
  align-items: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--menu-loader {
  width: 48px;
  height: 48px;
  border: var(--dp-loader);
  border-bottom-color: rgba(0, 0, 0, 0);
  border-radius: 50%;
  display: inline-block;
  box-sizing: border-box;
  animation: dp-load-rotation-27474da0 1s linear infinite;
  position: absolute;
}
@keyframes dp-load-rotation-27474da0 {
0% {
    transform: rotate(0deg);
}
100% {
    transform: rotate(360deg);
}
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__arrow_top {
  left: var(--dp-arrow-left);
  top: 0;
  height: 12px;
  width: 12px;
  background-color: var(--dp-background-color);
  position: absolute;
  border-inline-end: 1px solid var(--dp-menu-border-color);
  border-top: 1px solid var(--dp-menu-border-color);
  transform: translate(-50%, -50%) rotate(-45deg);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__arrow_bottom {
  left: var(--dp-arrow-left);
  bottom: 0;
  height: 12px;
  width: 12px;
  background-color: var(--dp-background-color);
  position: absolute;
  border-inline-end: 1px solid var(--dp-menu-border-color);
  border-bottom: 1px solid var(--dp-menu-border-color);
  transform: translate(-50%, 50%) rotate(45deg);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_extra {
  text-align: center;
  padding: 2px 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-dates {
  padding: 5px;
  border-inline-end: 1px solid var(--dp-border-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-dates[data-dp-mobile] {
  display: flex;
  align-self: center;
  border: none;
  overflow-x: auto;
  max-width: calc(var(--dp-menu-width) - var(--dp-action-row-padding) * 2);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-dates-collapsed {
  display: flex;
  align-self: center;
  border: none;
  overflow-x: auto;
  max-width: calc(var(--dp-menu-width) - var(--dp-action-row-padding) * 2);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__sidebar_left {
  padding: 5px;
  border-inline-end: 1px solid var(--dp-border-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__sidebar_right {
  padding: 5px;
  margin-inline-end: 1px solid var(--dp-border-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-range {
  display: block;
  width: 100%;
  padding: 5px;
  text-align: left;
  white-space: nowrap;
  color: var(--dp-text-color);
  border-radius: var(--dp-border-radius);
  transition: var(--dp-common-transition);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-range:hover {
  background-color: var(--dp-hover-color);
  color: var(--dp-hover-text-color);
  cursor: pointer;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-range[data-dp-mobile] {
  border: 1px solid var(--dp-border-color);
  margin: 0 3px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-range[data-dp-mobile]:first-child {
  margin-left: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-range[data-dp-mobile]:last-child {
  margin-right: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-range-collapsed {
  border: 1px solid var(--dp-border-color);
  margin: 0 3px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-range-collapsed:first-child {
  margin-left: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--preset-range-collapsed:last-child {
  margin-right: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu_content_wrapper {
  display: flex;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__menu_content_wrapper[data-dp-mobile] {
  flex-direction: column-reverse;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--menu-content-wrapper-collapsed {
  flex-direction: column-reverse;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__calendar_header {
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  color: var(--dp-text-color);
  white-space: nowrap;
  font-weight: bold;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__calendar_header_item {
  text-align: center;
  flex-grow: 1;
  height: var(--dp-cell-size);
  padding: var(--dp-cell-padding);
  width: var(--dp-cell-size);
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__calendar_row {
  display: flex;
  justify-content: center;
  align-items: center;
  margin: var(--dp-row-margin);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__calendar_item {
  text-align: center;
  flex-grow: 1;
  box-sizing: border-box;
  color: var(--dp-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__calendar {
  position: relative;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__calendar_header_cell {
  border-bottom: thin solid var(--dp-border-color);
  padding: var(--dp-calendar-header-cell-padding);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_inner {
  display: flex;
  align-items: center;
  text-align: center;
  justify-content: center;
  border-radius: var(--dp-cell-border-radius);
  height: var(--dp-cell-size);
  padding: var(--dp-cell-padding);
  width: var(--dp-cell-size);
  border: 1px solid rgba(0, 0, 0, 0);
  box-sizing: border-box;
  position: relative;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_inner:hover {
  transition: all 0.2s;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_auto_range_start, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__date_hover_start:hover, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__range_start {
  border-end-end-radius: 0;
  border-start-end-radius: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_auto_range_end, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__date_hover_end:hover, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__range_end {
  border-end-start-radius: 0;
  border-start-start-radius: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__range_end, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__range_start, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__active_date {
  background: var(--dp-primary-color);
  color: var(--dp-primary-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__date_hover_end:hover, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__date_hover_start:hover, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__date_hover:hover {
  background: var(--dp-hover-color);
  color: var(--dp-hover-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_offset {
  color: var(--dp-secondary-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_disabled {
  color: var(--dp-secondary-color);
  cursor: not-allowed;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__range_between {
  background: var(--dp-range-between-dates-background-color);
  color: var(--dp-range-between-dates-text-color);
  border-radius: 0;
  border: 1px solid var(--dp-range-between-border-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__range_between_week {
  background: var(--dp-primary-color);
  color: var(--dp-primary-text-color);
  border-radius: 0;
  border-top: 1px solid var(--dp-primary-color);
  border-bottom: 1px solid var(--dp-primary-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__today {
  border: 1px solid var(--dp-primary-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__week_num {
  color: var(--dp-secondary-color);
  text-align: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_auto_range {
  border-radius: 0;
  border-top: 1px dashed var(--dp-primary-color);
  border-bottom: 1px dashed var(--dp-primary-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_auto_range_start {
  border-start-start-radius: var(--dp-cell-border-radius);
  border-end-start-radius: var(--dp-cell-border-radius);
  border-inline-start: 1px dashed var(--dp-primary-color);
  border-top: 1px dashed var(--dp-primary-color);
  border-bottom: 1px dashed var(--dp-primary-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_auto_range_end {
  border-start-end-radius: var(--dp-cell-border-radius);
  border-end-end-radius: var(--dp-cell-border-radius);
  border-top: 1px dashed var(--dp-primary-color);
  border-bottom: 1px dashed var(--dp-primary-color);
  border-inline-end: 1px dashed var(--dp-primary-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__calendar_header_separator {
  width: 100%;
  height: 1px;
  background: var(--dp-border-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__calendar_next {
  margin-inline-start: var(--dp-multi-calendars-spacing);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__marker_line, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__marker_dot {
  height: 5px;
  background-color: var(--dp-marker-color);
  position: absolute;
  bottom: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__marker_dot {
  width: 5px;
  border-radius: 50%;
  left: 50%;
  transform: translateX(-50%);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__marker_line {
  width: 100%;
  left: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__marker_tooltip {
  position: absolute;
  border-radius: var(--dp-border-radius);
  background-color: var(--dp-tooltip-color);
  padding: 5px;
  border: 1px solid var(--dp-border-color);
  z-index: 99999;
  box-sizing: border-box;
  cursor: default;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__tooltip_content {
  white-space: nowrap;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__tooltip_text {
  display: flex;
  align-items: center;
  flex-flow: row nowrap;
  color: var(--dp-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__tooltip_mark {
  height: 5px;
  width: 5px;
  border-radius: 50%;
  background-color: var(--dp-text-color);
  color: var(--dp-text-color);
  margin-inline-end: 5px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__arrow_bottom_tp {
  bottom: 0;
  height: 8px;
  width: 8px;
  background-color: var(--dp-tooltip-color);
  position: absolute;
  border-inline-end: 1px solid var(--dp-border-color);
  border-bottom: 1px solid var(--dp-border-color);
  transform: translate(-50%, 50%) rotate(45deg);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__instance_calendar {
  position: relative;
  width: 100%;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__flex_display[data-dp-mobile] {
  flex-direction: column;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--flex-display-collapsed {
  flex-direction: column;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_highlight {
  background-color: var(--dp-highlight-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__month_year_row {
  display: flex;
  align-items: center;
  height: var(--dp-month-year-row-height);
  color: var(--dp-text-color);
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inner_nav {
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  height: var(--dp-month-year-row-button-size);
  width: var(--dp-month-year-row-button-size);
  color: var(--dp-icon-color);
  text-align: center;
  border-radius: 50%;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inner_nav svg {
  height: var(--dp-button-icon-height);
  width: var(--dp-button-icon-height);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inner_nav:hover {
  background: var(--dp-hover-color);
  color: var(--dp-hover-icon-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  [dir=rtl] .dp__inner_nav {
  transform: rotate(180deg);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inner_nav_disabled:hover, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inner_nav_disabled {
  background: var(--dp-disabled-color);
  color: var(--dp-disabled-color-text);
  cursor: not-allowed;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--year-select, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__month_year_select {
  text-align: center;
  cursor: pointer;
  height: var(--dp-month-year-row-height);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: var(--dp-border-radius);
  box-sizing: border-box;
  color: var(--dp-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--year-select:hover, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__month_year_select:hover {
  background: var(--dp-hover-color);
  color: var(--dp-hover-text-color);
  transition: var(--dp-common-transition);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__month_year_select {
  width: 50%;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--year-select {
  width: 100%;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__month_year_wrap {
  display: flex;
  flex-direction: row;
  width: 100%;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__year_disable_select {
  justify-content: space-around;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--header-wrap {
  display: flex;
  width: 100%;
  flex-direction: column;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay {
  width: 100%;
  background: var(--dp-background-color);
  transition: opacity 1s ease-out;
  z-index: 99999;
  font-family: var(--dp-font-family);
  color: var(--dp-text-color);
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--overlay-absolute {
  position: absolute;
  height: 100%;
  top: 0;
  left: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--overlay-relative {
  position: relative;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_container::-webkit-scrollbar-track {
  box-shadow: var(--dp-scroll-bar-background);
  background-color: var(--dp-scroll-bar-background);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_container::-webkit-scrollbar {
  width: 5px;
  background-color: var(--dp-scroll-bar-background);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_container::-webkit-scrollbar-thumb {
  background-color: var(--dp-scroll-bar-color);
  border-radius: 10px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay:focus {
  border: none;
  outline: none;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__container_flex {
  display: flex;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__container_block {
  display: block;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_container {
  flex-direction: column;
  overflow-y: auto;
  height: var(--dp-overlay-height);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_picker_overlay_container {
  height: 100%;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_row {
  padding: 0;
  box-sizing: border-box;
  display: flex;
  margin-inline: auto;
  flex-wrap: wrap;
  max-width: 100%;
  width: 100%;
  align-items: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__flex_row {
  flex: 1;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_col {
  box-sizing: border-box;
  width: 33%;
  padding: var(--dp-overlay-col-padding);
  white-space: nowrap;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_cell_pad {
  padding: var(--dp-common-padding) 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_cell_active {
  cursor: pointer;
  border-radius: var(--dp-border-radius);
  text-align: center;
  background: var(--dp-primary-color);
  color: var(--dp-primary-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_cell {
  cursor: pointer;
  border-radius: var(--dp-border-radius);
  text-align: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_cell:hover {
  background: var(--dp-hover-color);
  color: var(--dp-hover-text-color);
  transition: var(--dp-common-transition);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__cell_in_between {
  background: var(--dp-hover-color);
  color: var(--dp-hover-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__over_action_scroll {
  right: 5px;
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_cell_disabled {
  cursor: not-allowed;
  background: var(--dp-disabled-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_cell_disabled:hover {
  background: var(--dp-disabled-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_cell_active_disabled {
  cursor: not-allowed;
  background: var(--dp-primary-disabled-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__overlay_cell_active_disabled:hover {
  background: var(--dp-primary-disabled-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__btn, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp--qr-btn, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp--time-overlay-btn, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp--time-invalid {
  border: none;
  font: inherit;
  transition: var(--dp-common-transition);
  line-height: normal;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--year-mode-picker {
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: space-between;
  height: var(--dp-cell-size);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--tp-wrap {
  max-width: var(--dp-menu-min-width);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--tp-wrap[data-dp-mobile] {
  max-width: 100%;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_input {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
  font-family: var(--dp-font-family);
  color: var(--dp-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col_reg_block {
  padding: 0 20px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col_reg_inline {
  padding: 0 10px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col_reg_with_button {
  padding: 0 15px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col_reg_with_button[data-compact~=true] {
  padding: 0 5px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col_sec {
  padding: 0 10px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col_sec_with_button {
  padding: 0 5px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col_sec_with_button[data-collapsed~=true] {
  padding: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col {
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_col_block {
  font-size: var(--dp-time-font-size);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_display_block {
  padding: 0 3px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_display_inline {
  padding: 5px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_picker_inline_container {
  display: flex;
  width: 100%;
  justify-content: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inc_dec_button {
  padding: 5px;
  margin: 0;
  height: var(--dp-time-inc-dec-button-size);
  width: var(--dp-time-inc-dec-button-size);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  border-radius: 50%;
  color: var(--dp-icon-color);
  box-sizing: border-box;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inc_dec_button svg {
  height: var(--dp-time-inc-dec-button-size);
  width: var(--dp-time-inc-dec-button-size);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inc_dec_button:hover {
  background: var(--dp-hover-color);
  color: var(--dp-primary-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_display {
  cursor: pointer;
  color: var(--dp-text-color);
  border-radius: var(--dp-border-radius);
  display: flex;
  align-items: center;
  justify-content: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__time_display:hover:enabled {
  background: var(--dp-hover-color);
  color: var(--dp-hover-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inc_dec_button_inline {
  width: 100%;
  padding: 0;
  height: 8px;
  cursor: pointer;
  display: flex;
  align-items: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inc_dec_button_disabled, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp__inc_dec_button_disabled:hover {
  background: var(--dp-disabled-color);
  color: var(--dp-disabled-color-text);
  cursor: not-allowed;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__pm_am_button {
  background: var(--dp-primary-color);
  color: var(--dp-primary-text-color);
  border: none;
  padding: var(--dp-common-padding);
  border-radius: var(--dp-border-radius);
  cursor: pointer;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__pm_am_button[data-compact~=true] {
  padding: 7px;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__tp_inline_btn_bar {
  width: 100%;
  height: 4px;
  background-color: var(--dp-secondary-color);
  transition: var(--dp-common-transition);
  border-collapse: collapse;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__tp_inline_btn_top:hover .dp__tp_btn_in_r {
  background-color: var(--dp-primary-color);
  transform: rotate(12deg) scale(1.15) translateY(-2px);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__tp_inline_btn_top:hover .dp__tp_btn_in_l {
  background-color: var(--dp-primary-color);
  transform: rotate(-12deg) scale(1.15) translateY(-2px);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__tp_inline_btn_bottom:hover .dp__tp_btn_in_r {
  background-color: var(--dp-primary-color);
  transform: rotate(-12deg) scale(1.15) translateY(-2px);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__tp_inline_btn_bottom:hover .dp__tp_btn_in_l {
  background-color: var(--dp-primary-color);
  transform: rotate(12deg) scale(1.15) translateY(-2px);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--time-overlay-btn {
  background: none;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--time-invalid {
  background-color: var(--dp-disabled-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_row {
  display: flex;
  align-items: center;
  width: 100%;
  padding: var(--dp-action-row-padding);
  box-sizing: border-box;
  color: var(--dp-text-color);
  flex-flow: row nowrap;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_row svg {
  height: var(--dp-button-icon-height);
  width: auto;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__selection_preview {
  display: block;
  color: var(--dp-text-color);
  font-size: var(--dp-preview-font-size);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_buttons {
  display: flex;
  flex: 0;
  white-space: nowrap;
  align-items: center;
  justify-content: flex-end;
  margin-inline-start: auto;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_button {
  display: inline-flex;
  align-items: center;
  background: rgba(0, 0, 0, 0);
  border: 1px solid rgba(0, 0, 0, 0);
  padding: var(--dp-action-buttons-padding);
  line-height: var(--dp-action-button-height);
  margin-inline-start: 3px;
  height: var(--dp-action-button-height);
  cursor: pointer;
  border-radius: var(--dp-border-radius);
  font-size: var(--dp-preview-font-size);
  font-family: var(--dp-font-family);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_cancel {
  color: var(--dp-text-color);
  border: 1px solid var(--dp-border-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_cancel:hover {
  border-color: var(--dp-primary-color);
  transition: var(--dp-action-row-transtion);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_buttons .dp__action_select {
  background: var(--dp-primary-color);
  color: var(--dp-primary-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_buttons .dp__action_select:hover {
  background: var(--dp-primary-color);
  transition: var(--dp-action-row-transtion);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__action_buttons .dp__action_select:disabled {
  background: var(--dp-primary-disabled-color);
  cursor: not-allowed;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp-quarter-picker-wrap {
  display: flex;
  flex-direction: column;
  height: 100%;
  min-width: var(--dp-menu-min-width);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--qr-btn-disabled {
  cursor: not-allowed;
  background: var(--dp-disabled-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--qr-btn-disabled:hover {
  background: var(--dp-disabled-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--qr-btn {
  width: 100%;
  padding: var(--dp-common-padding);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--qr-btn:not(.dp--highlighted, .dp--qr-btn-active, .dp--qr-btn-disabled, .dp--qr-btn-between) {
  background: none;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--qr-btn:hover:not(.dp--qr-btn-active, .dp--qr-btn-disabled) {
  background: var(--dp-hover-color);
  color: var(--dp-hover-text-color);
  transition: var(--dp-common-transition);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--quarter-items {
  display: flex;
  flex-direction: column;
  flex: 1;
  width: 100%;
  height: 100%;
  justify-content: space-evenly;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--qr-btn-active {
  background: var(--dp-primary-color);
  color: var(--dp-primary-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--qr-btn-between {
  background: var(--dp-hover-color);
  color: var(--dp-hover-text-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  :root {
  --dp-common-transition: all 0.1s ease-in;
  --dp-menu-padding: 6px 8px;
  --dp-animation-duration: 0.1s;
  --dp-menu-appear-transition-timing: cubic-bezier(.4, 0, 1, 1);
  --dp-transition-timing: ease-out;
  --dp-action-row-transtion: all 0.2s ease-in;
  --dp-font-family: -apple-system, blinkmacsystemfont, "Segoe UI", roboto, oxygen, ubuntu, cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  --dp-border-radius: 4px;
  --dp-cell-border-radius: 4px;
  --dp-transition-length: 22px;
  --dp-transition-timing-general: 0.1s;
  --dp-button-height: 35px;
  --dp-month-year-row-height: 35px;
  --dp-month-year-row-button-size: 25px;
  --dp-button-icon-height: 20px;
  --dp-calendar-wrap-padding: 0 5px;
  --dp-cell-size: 35px;
  --dp-cell-padding: 5px;
  --dp-common-padding: 10px;
  --dp-input-icon-padding: 35px;
  --dp-input-padding: 6px 30px 6px 12px;
  --dp-menu-min-width: 260px;
  --dp-action-buttons-padding: 1px 6px;
  --dp-row-margin: 5px 0;
  --dp-calendar-header-cell-padding: 0.5rem;
  --dp-multi-calendars-spacing: 10px;
  --dp-overlay-col-padding: 3px;
  --dp-time-inc-dec-button-size: 32px;
  --dp-font-size: 1rem;
  --dp-preview-font-size: 0.8rem;
  --dp-time-font-size: 2rem;
  --dp-action-button-height: 22px;
  --dp-action-row-padding: 8px;
  --dp-direction: ltr;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__theme_dark {
  --dp-background-color: #212121;
  --dp-text-color: #fff;
  --dp-hover-color: #484848;
  --dp-hover-text-color: #fff;
  --dp-hover-icon-color: #959595;
  --dp-primary-color: #005cb2;
  --dp-primary-disabled-color: #61a8ea;
  --dp-primary-text-color: #fff;
  --dp-secondary-color: #a9a9a9;
  --dp-border-color: #2d2d2d;
  --dp-menu-border-color: #2d2d2d;
  --dp-border-color-hover: #aaaeb7;
  --dp-border-color-focus: #aaaeb7;
  --dp-disabled-color: #737373;
  --dp-disabled-color-text: #d0d0d0;
  --dp-scroll-bar-background: #212121;
  --dp-scroll-bar-color: #484848;
  --dp-success-color: #00701a;
  --dp-success-color-disabled: #428f59;
  --dp-icon-color: #959595;
  --dp-danger-color: #e53935;
  --dp-marker-color: #e53935;
  --dp-tooltip-color: #3e3e3e;
  --dp-highlight-color: rgb(0 92 178 / 20%);
  --dp-range-between-dates-background-color: var(--dp-hover-color, #484848);
  --dp-range-between-dates-text-color: var(--dp-hover-text-color, #fff);
  --dp-range-between-border-color: var(--dp-hover-color, #fff);
  --dp-loader: 5px solid #005cb2;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__theme_light {
  --dp-background-color: #fff;
  --dp-text-color: #212121;
  --dp-hover-color: #f3f3f3;
  --dp-hover-text-color: #212121;
  --dp-hover-icon-color: #959595;
  --dp-primary-color: #1976d2;
  --dp-primary-disabled-color: #6bacea;
  --dp-primary-text-color: #fff;
  --dp-secondary-color: #c0c4cc;
  --dp-border-color: #ddd;
  --dp-menu-border-color: #ddd;
  --dp-border-color-hover: #aaaeb7;
  --dp-border-color-focus: #aaaeb7;
  --dp-disabled-color: #f6f6f6;
  --dp-scroll-bar-background: #f3f3f3;
  --dp-scroll-bar-color: #959595;
  --dp-success-color: #76d275;
  --dp-success-color-disabled: #a3d9b1;
  --dp-icon-color: #959595;
  --dp-danger-color: #ff6f60;
  --dp-marker-color: #ff6f60;
  --dp-tooltip-color: #fafafa;
  --dp-disabled-color-text: #8e8e8e;
  --dp-highlight-color: rgb(25 118 210 / 10%);
  --dp-range-between-dates-background-color: var(--dp-hover-color, #f3f3f3);
  --dp-range-between-dates-text-color: var(--dp-hover-text-color, #212121);
  --dp-range-between-border-color: var(--dp-hover-color, #f3f3f3);
  --dp-loader: 5px solid #1976d2;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__flex {
  display: flex;
  align-items: center;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__btn {
  background: none;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__main {
  font-family: var(--dp-font-family);
  user-select: none;
  box-sizing: border-box;
  position: relative;
  width: 100%;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__main * {
  direction: var(--dp-direction, ltr);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__pointer {
  cursor: pointer;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__icon {
  stroke: currentcolor;
  fill: currentcolor;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__button {
  width: 100%;
  text-align: center;
  color: var(--dp-icon-color);
  cursor: pointer;
  display: flex;
  align-items: center;
  place-content: center center;
  padding: var(--dp-common-padding);
  box-sizing: border-box;
  height: var(--dp-button-height);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__button.dp__overlay_action {
  position: absolute;
  bottom: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__button:hover {
  background: var(--dp-hover-color);
  color: var(--dp-hover-icon-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__button svg {
  height: var(--dp-button-icon-height);
  width: auto;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__button_bottom {
  border-bottom-left-radius: var(--dp-border-radius);
  border-bottom-right-radius: var(--dp-border-radius);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__flex_display {
  display: flex;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__flex_display_with_input {
  flex-direction: column;
  align-items: flex-start;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp__relative {
  position: relative;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .calendar-next-enter-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .calendar-next-leave-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .calendar-prev-enter-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .calendar-prev-leave-active {
  transition: all var(--dp-transition-timing-general) ease-out;
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .calendar-next-enter-from {
  opacity: 0;
  transform: translateX(var(--dp-transition-length));
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .calendar-next-leave-to {
  opacity: 0;
  transform: translateX(calc(var(--dp-transition-length) * -1));
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .calendar-prev-enter-from {
  opacity: 0;
  transform: translateX(calc(var(--dp-transition-length) * -1));
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .calendar-prev-leave-to {
  opacity: 0;
  transform: translateX(var(--dp-transition-length));
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-appear-bottom-enter-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-appear-bottom-leave-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-appear-top-enter-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-appear-top-leave-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-slide-up-enter-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-slide-up-leave-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-slide-down-enter-active, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-slide-down-leave-active {
  transition: all var(--dp-animation-duration) var(--dp-transition-timing);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-appear-top-enter-from, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-appear-top-leave-to, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-slide-down-leave-to, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-slide-up-enter-from {
  opacity: 0;
  transform: translateY(var(--dp-transition-length));
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-appear-bottom-enter-from, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-menu-appear-bottom-leave-to, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-slide-down-enter-from, .vue-date-time-picker__wrapper[data-v-27474da0]  .dp-slide-up-leave-to {
  opacity: 0;
  transform: translateY(calc(var(--dp-transition-length) * -1));
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--arrow-btn-nav {
  transition: var(--dp-common-transition);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--highlighted {
  background-color: var(--dp-highlight-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0]  .dp--hidden-el {
  visibility: hidden;
}
.vue-date-time-picker__wrapper .vue-date-time-picker--clearable[data-v-27474da0] .dp__input {
  padding-inline-end: var(--default-clickable-area);
}
.vue-date-time-picker__wrapper .vue-date-time-picker__timezone[data-v-27474da0] {
  min-width: unset;
  width: 100%;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .icon-vue {
  opacity: 1 !important;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp--tp-wrap,
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__action_extra {
  padding: var(--dp-menu-padding);
  padding-top: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__overlay.dp--overlay-absolute {
  padding: var(--dp-menu-padding);
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__overlay.dp--overlay-absolute .dp__btn.dp__button.dp__button_bottom {
  inset-block-end: 6px;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__btn.dp__button.dp__button_bottom,
.vue-date-time-picker__wrapper[data-v-27474da0] .dp--tp-wrap .dp__button {
  width: 100%;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__btn.dp__button.dp__overlay_action {
  width: calc(100% - 16px);
}
.vue-date-time-picker__wrapper[data-v-27474da0] input {
  padding-inline-start: var(--dp-input-icon-padding) !important;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__btn {
  margin: 0;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__inner_nav {
  height: fit-content;
  width: fit-content;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__btn.dp__button.dp__button_bottom {
  color: var(--color-primary-element-light);
  background-color: var(--color-primary-element-light);
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp--header-wrap .dp__btn:not(.dp__button_bottom),
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__time_col .dp__btn {
  background-color: var(--color-main-background);
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp--header-wrap .dp__btn:not(.dp__button_bottom):hover,
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__time_col .dp__btn:hover {
  background: var(--dp-hover-color);
  color: var(--dp-hover-icon-color);
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__month_year_select {
  flex: 1;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp--time-overlay-btn {
  font-size: calc(2 * var(--default-font-size)) !important;
}
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__time_input .dp__time_col_reg_block {
  padding: 0 calc(4 * var(--default-grid-baseline));
}
.vue-date-time-picker__wrapper .vue-date-time-picker.dp__theme_dark[data-v-27474da0],
.vue-date-time-picker__wrapper .vue-date-time-picker.dp__theme_light[data-v-27474da0],
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__theme_dark,
.vue-date-time-picker__wrapper[data-v-27474da0] .dp__theme_light {
  --dp-background-color: var(--color-main-background);
  --dp-text-color: var(--color-main-text);
  --dp-hover-color: var(--color-primary-element-light-hover);
  --dp-hover-text-color: var(--color-primary-element-light-text);
  --dp-hover-icon-color: var(--color-primary-element-light-text);
  --dp-primary-color: var(--color-primary-element);
  --dp-primary-disabled-color: var(--color-primary-element-hover);
  --dp-primary-text-color: var(--color-primary-element-text);
  --dp-secondary-color: var(--color-text-maxcontrast);
  --dp-border-color: var(--color-border);
  --dp-menu-border-color: var(--color-border-dark);
  --dp-border-color-hover: var(--color-border-maxcontrast);
  --dp-border-color-focus: var(--color-border-maxcontrast);
  --dp-disabled-color: var(--color-background-dark);
  --dp-disabled-color-text: var(--color-text-maxcontrast);
  --dp-scroll-bar-background: var(--color-scrollbar);
  --dp-scroll-bar-color: var(--color-scrollbar);
  --dp-success-color: var(--color-success);
  --dp-success-color-disabled: var(--color-success-hover);
  --dp-icon-color: var(--color-main-text);
  --dp-danger-color: var(--color-error);
  --dp-marker-color: var(--color-text-error, var(--color-error));
  --dp-tooltip-color: var(--color-main-text);
  --dp-highlight-color: var(--color-main-text);
}.emoji-mart,
.emoji-mart * {
  box-sizing: border-box;
  line-height: 1.15;
}
.emoji-mart {
  font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
  font-size: 16px;
  /* display: inline-block; */
  display: flex;
  flex-direction: column;
  height: 420px;
  color: #222427;
  border: 1px solid #d9d9d9;
  border-radius: 5px;
  background: #fff;
}
.emoji-mart-emoji {
  padding: 6px;
  position: relative;
  display: inline-block;
  font-size: 0;
  border: none;
  background: none;
  box-shadow: none;
}
.emoji-mart-emoji span {
  display: inline-block;
}
.emoji-mart-preview-emoji .emoji-mart-emoji span {
  width: 38px;
  height: 38px;
  font-size: 32px;
}
.emoji-type-native {
  font-family: 'Segoe UI Emoji', 'Segoe UI Symbol', 'Segoe UI',
    'Apple Color Emoji', 'Twemoji Mozilla', 'Noto Color Emoji', 'EmojiOne Color',
    'Android Emoji';
  word-break: keep-all;
}
.emoji-type-image {
  /* Emoji sheet has 56 columns, see also utils/emoji-data.js, SHEET_COLUMNS variable */
  /* Here we use (56+1) * 100% to avoid visible edges of nearby icons when scaling for different
   * screen sizes */
  background-size: 6100%;
}
.emoji-type-image.emoji-set-apple {
  background-image: url('https://unpkg.com/emoji-datasource-apple@15.0.1/img/apple/sheets-256/64.png');
}
.emoji-type-image.emoji-set-facebook {
  background-image: url('https://unpkg.com/emoji-datasource-facebook@15.0.1/img/facebook/sheets-256/64.png');
}
.emoji-type-image.emoji-set-google {
  background-image: url('https://unpkg.com/emoji-datasource-google@15.0.1/img/google/sheets-256/64.png');
}
.emoji-type-image.emoji-set-twitter {
  background-image: url('https://unpkg.com/emoji-datasource-twitter@15.0.1/img/twitter/sheets-256/64.png');
}
.emoji-mart-bar {
  border: 0 solid #d9d9d9;
}
.emoji-mart-bar:first-child {
  border-bottom-width: 1px;
  border-top-left-radius: 5px;
  border-top-right-radius: 5px;
}
.emoji-mart-bar:last-child {
  border-top-width: 1px;
  border-bottom-left-radius: 5px;
  border-bottom-right-radius: 5px;
}
.emoji-mart-scroll {
  position: relative;
  overflow-y: scroll;
  flex: 1;
  padding: 0 6px 6px 6px;
  z-index: 0; /* Fix for rendering sticky positioned category labels on Chrome */
  will-change: transform; /* avoids "repaints on scroll" in mobile Chrome */
  -webkit-overflow-scrolling: touch;
}
.emoji-mart-anchors {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  padding: 0 6px;
  color: #858585;
  line-height: 0;
}
.emoji-mart-anchor {
  position: relative;
  display: block;
  flex: 1 1 auto;
  text-align: center;
  padding: 12px 4px;
  overflow: hidden;
  transition: color 0.1s ease-out;
  border: none;
  background: none;
  box-shadow: none;
}
.emoji-mart-anchor:hover,
.emoji-mart-anchor-selected {
  color: #464646;
}
.emoji-mart-anchor-selected .emoji-mart-anchor-bar {
  bottom: 0;
}
.emoji-mart-anchor-bar {
  position: absolute;
  bottom: -3px;
  left: 0;
  width: 100%;
  height: 3px;
  background-color: #464646;
}
.emoji-mart-anchors i {
  display: inline-block;
  width: 100%;
  max-width: 22px;
}
.emoji-mart-anchors svg {
  fill: currentColor;
  max-height: 18px;
}
.emoji-mart .scroller {
  height: 250px;
  position: relative;
  flex: 1;
  padding: 0 6px 6px 6px;
  z-index: 0; /* Fix for rendering sticky positioned category labels on Chrome */
  will-change: transform; /* avoids "repaints on scroll" in mobile Chrome */
  -webkit-overflow-scrolling: touch;
}
.emoji-mart-search {
  margin-top: 6px;
  padding: 0 6px;
}
.emoji-mart-search input {
  font-size: 16px;
  display: block;
  width: 100%;
  padding: 0.2em 0.6em;
  border-radius: 25px;
  border: 1px solid #d9d9d9;
  outline: 0;
}
.emoji-mart-search-results {
  height: 250px;
  overflow-y: scroll;
}
.emoji-mart-category {
  position: relative;
}
.emoji-mart-category .emoji-mart-emoji span {
  z-index: 1;
  position: relative;
  text-align: center;
  cursor: default;
}
.emoji-mart-category .emoji-mart-emoji:hover:before,
.emoji-mart-emoji-selected:before {
  z-index: 0;
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #f4f4f4;
  border-radius: 100%;
  opacity: 0;
}
.emoji-mart-category .emoji-mart-emoji:hover:before,
.emoji-mart-emoji-selected:before {
  opacity: 1;
}
.emoji-mart-category-label {
  position: sticky;
  top: 0;
}
.emoji-mart-static .emoji-mart-category-label {
  z-index: 2;
  position: relative;
  /* position: sticky; */
  /* position: -webkit-sticky; */
}
.emoji-mart-category-label h3 {
  display: block;
  font-size: 16px;
  width: 100%;
  font-weight: 500;
  padding: 5px 6px;
  background-color: #fff;
  background-color: rgba(255, 255, 255, 0.95);
}
.emoji-mart-emoji {
  position: relative;
  display: inline-block;
  font-size: 0;
}
.emoji-mart-no-results {
  font-size: 14px;
  text-align: center;
  padding-top: 70px;
  color: #858585;
}
.emoji-mart-no-results .emoji-mart-category-label {
  display: none;
}
.emoji-mart-no-results .emoji-mart-no-results-label {
  margin-top: 0.2em;
}
.emoji-mart-no-results .emoji-mart-emoji:hover:before {
  content: none;
}
.emoji-mart-preview {
  position: relative;
  height: 70px;
}
.emoji-mart-preview-emoji,
.emoji-mart-preview-data,
.emoji-mart-preview-skins {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
.emoji-mart-preview-emoji {
  left: 12px;
}
.emoji-mart-preview-data {
  left: 68px;
  right: 12px;
  word-break: break-all;
}
.emoji-mart-preview-skins {
  right: 30px;
  text-align: right;
}
.emoji-mart-preview-name {
  font-size: 14px;
}
.emoji-mart-preview-shortname {
  font-size: 12px;
  color: #888;
}
.emoji-mart-preview-shortname + .emoji-mart-preview-shortname,
.emoji-mart-preview-shortname + .emoji-mart-preview-emoticon,
.emoji-mart-preview-emoticon + .emoji-mart-preview-emoticon {
  margin-left: 0.5em;
}
.emoji-mart-preview-emoticon {
  font-size: 11px;
  color: #bbb;
}
.emoji-mart-title span {
  display: inline-block;
  vertical-align: middle;
}
.emoji-mart-title .emoji-mart-emoji {
  padding: 0;
}
.emoji-mart-title-label {
  color: #999a9c;
  font-size: 21px;
  font-weight: 300;
}
.emoji-mart-skin-swatches {
  font-size: 0;
  padding: 2px 0;
  border: 1px solid #d9d9d9;
  border-radius: 12px;
  background-color: #fff;
}
.emoji-mart-skin-swatches-opened .emoji-mart-skin-swatch {
  width: 16px;
  padding: 0 2px;
}
.emoji-mart-skin-swatches-opened .emoji-mart-skin-swatch-selected:after {
  opacity: 0.75;
}
.emoji-mart-skin-swatch {
  display: inline-block;
  width: 0;
  vertical-align: middle;
  transition-property: width, padding;
  transition-duration: 0.125s;
  transition-timing-function: ease-out;
}
.emoji-mart-skin-swatch:nth-child(1) {
  transition-delay: 0s;
}
.emoji-mart-skin-swatch:nth-child(2) {
  transition-delay: 0.03s;
}
.emoji-mart-skin-swatch:nth-child(3) {
  transition-delay: 0.06s;
}
.emoji-mart-skin-swatch:nth-child(4) {
  transition-delay: 0.09s;
}
.emoji-mart-skin-swatch:nth-child(5) {
  transition-delay: 0.12s;
}
.emoji-mart-skin-swatch:nth-child(6) {
  transition-delay: 0.15s;
}
.emoji-mart-skin-swatch-selected {
  position: relative;
  width: 16px;
  padding: 0 2px;
}
.emoji-mart-skin-swatch-selected:after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 4px;
  height: 4px;
  margin: -2px 0 0 -2px;
  background-color: #fff;
  border-radius: 100%;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s ease-out;
}
.emoji-mart-skin {
  display: inline-block;
  width: 100%;
  padding-top: 100%;
  max-width: 12px;
  border-radius: 100%;
}
.emoji-mart-skin-tone-1 {
  background-color: #ffc93a;
}
.emoji-mart-skin-tone-2 {
  background-color: #fadcbc;
}
.emoji-mart-skin-tone-3 {
  background-color: #e0bb95;
}
.emoji-mart-skin-tone-4 {
  background-color: #bf8f68;
}
.emoji-mart-skin-tone-5 {
  background-color: #9b643d;
}
.emoji-mart-skin-tone-6 {
  background-color: #594539;
}

/* vue-virtual-scroller/dist/vue-virtual-scroller.css */
.emoji-mart .vue-recycle-scroller {
  position: relative;
}
.emoji-mart .vue-recycle-scroller.direction-vertical:not(.page-mode) {
  overflow-y: auto;
}
.emoji-mart .vue-recycle-scroller.direction-horizontal:not(.page-mode) {
  overflow-x: auto;
}
.emoji-mart .vue-recycle-scroller.direction-horizontal {
  display: flex;
}
.emoji-mart .vue-recycle-scroller__slot {
  flex: auto 0 0;
}
.emoji-mart .vue-recycle-scroller__item-wrapper {
  flex: 1;
  box-sizing: border-box;
  overflow: hidden;
  position: relative;
}
.emoji-mart .vue-recycle-scroller.ready .vue-recycle-scroller__item-view {
  position: absolute;
  top: 0;
  left: 0;
  will-change: transform;
}
.emoji-mart
  .vue-recycle-scroller.direction-vertical
  .vue-recycle-scroller__item-wrapper {
  width: 100%;
}
.emoji-mart
  .vue-recycle-scroller.direction-horizontal
  .vue-recycle-scroller__item-wrapper {
  height: 100%;
}
.emoji-mart
  .vue-recycle-scroller.ready.direction-vertical
  .vue-recycle-scroller__item-view {
  width: 100%;
}
.emoji-mart
  .vue-recycle-scroller.ready.direction-horizontal
  .vue-recycle-scroller__item-view {
  height: 100%;
}
.emoji-mart .resize-observer[data-v-b329ee4c] {
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  width: 100%;
  height: 100%;
  border: none;
  background-color: transparent;
  pointer-events: none;
  display: block;
  overflow: hidden;
  opacity: 0;
}
.emoji-mart .resize-observer[data-v-b329ee4c] object {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  overflow: hidden;
  pointer-events: none;
  z-index: -1;
}
.emoji-mart-search .hidden {
  display: none;
  visibility: hidden;
}

/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */

/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */

/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.nc-emoji-picker.emoji-mart {
  background-color: var(--color-main-background) !important;
  border: 0;
  color: var(--color-main-text) !important;
  display: flex !important;
  /* Label element in the section grid */
  /* An actual heading inside the element */
}
.nc-emoji-picker.emoji-mart button {
  border: none;
  background: transparent;
  font-size: inherit;
}
.nc-emoji-picker.emoji-mart .emoji-mart-bar,
.nc-emoji-picker.emoji-mart .emoji-mart-anchors,
.nc-emoji-picker.emoji-mart .emoji-mart-search,
.nc-emoji-picker.emoji-mart .emoji-mart-search input,
.nc-emoji-picker.emoji-mart .emoji-mart-category,
.nc-emoji-picker.emoji-mart .emoji-mart-category-label,
.nc-emoji-picker.emoji-mart .emoji-mart-category-label span,
.nc-emoji-picker.emoji-mart .emoji-mart-skin-swatches {
  background-color: transparent !important;
  border-color: var(--color-border) !important;
  color: inherit !important;
}
.nc-emoji-picker.emoji-mart .emoji-mart-anchors {
  padding-block: 0;
  padding-inline: calc(2 * var(--default-grid-baseline));
}
.nc-emoji-picker.emoji-mart .emoji-mart-anchor {
  border-radius: 0;
  margin: 0 !important;
  padding: 0 !important;
  height: var(--clickable-area-small);
  min-width: var(--clickable-area-small);
}
.nc-emoji-picker.emoji-mart .emoji-mart-anchor:hover {
  background-color: var(--color-background-hover);
}
.nc-emoji-picker.emoji-mart .emoji-mart-anchor:focus-visible {
  outline: 2px solid var(--color-primary-element) !important;
  outline-offset: -2px;
}
.nc-emoji-picker.emoji-mart .emoji-mart-anchor div {
  display: grid;
  place-content: center;
}
.nc-emoji-picker.emoji-mart .emoji-mart-scroll {
  padding-inline: calc(2 * var(--default-grid-baseline));
  padding-block: 0 calc(2 * var(--default-grid-baseline));
}
.nc-emoji-picker.emoji-mart .emoji-mart-category {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  justify-items: stretch;
}
.nc-emoji-picker.emoji-mart .emoji-mart-category.emoji-mart-no-results {
  grid-template-columns: 1fr;
  font-size: inherit;
  color: var(--color-text-maxcontrast) !important;
}
.nc-emoji-picker.emoji-mart div.emoji-mart-category-label {
  grid-column: span 8;
  justify-self: stretch;
}
.nc-emoji-picker.emoji-mart h3.emoji-mart-category-label {
  display: flex;
  align-items: center;
  height: var(--default-clickable-area);
  margin: 0;
  padding-inline: calc(2 * var(--default-grid-baseline));
  padding-block: 0;
  user-select: none;
}
.nc-emoji-picker.emoji-mart .emoji-mart-emoji {
  aspect-ratio: 1/1;
  text-align: center;
  margin: 0 !important;
  padding: 0 !important;
}
.nc-emoji-picker.emoji-mart .emoji-mart-emoji:hover, .nc-emoji-picker.emoji-mart .emoji-mart-emoji:focus-visible, .nc-emoji-picker.emoji-mart .emoji-mart-emoji.emoji-mart-emoji-selected {
  background-color: var(--color-background-hover) !important;
  border: none;
  border-radius: var(--border-radius-element);
  box-shadow: none !important;
  outline: 2px solid var(--color-primary-element) !important;
  outline-offset: -2px;
}
.nc-emoji-picker.emoji-mart .emoji-mart-emoji::before {
  display: none;
}
.nc-emoji-picker.emoji-mart .emoji-mart-emoji span {
  cursor: pointer;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-12f86ed6] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.search__wrapper[data-v-12f86ed6] {
  display: flex;
  flex-direction: row;
  gap: var(--default-grid-baseline);
  align-items: end;
  padding-block: var(--default-grid-baseline);
  padding-inline: calc(2 * var(--default-grid-baseline));
}
.row-selected button[data-v-12f86ed6], .row-selected span[data-v-12f86ed6] {
  vertical-align: middle;
}
.emoji-delete[data-v-12f86ed6] {
  vertical-align: top;
  margin-inline-start: -21px;
  margin-top: -3px;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-26ad2498] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
#guest-content-vue[data-v-26ad2498] {
  color: var(--color-main-text);
  background-color: var(--color-main-background);
  min-width: 0;
  border-radius: var(--border-radius-element);
  box-shadow: 0 0 10px var(--color-box-shadow);
  height: fit-content;
  padding: 15px;
  margin: 20px auto;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
#content.nc-guest-content {
  overflow: auto;
  margin-bottom: 0;
  height: calc(var(--body-height) + var(--body-container-margin));
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-dbefb31d] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/*!
 * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
.header-menu[data-v-dbefb31d] {
  position: relative;
  width: var(--header-height);
  height: var(--header-height);
}
.header-menu .header-menu__trigger[data-v-dbefb31d] {
  --button-size: var(--header-height) !important;
  height: var(--header-height);
  opacity: 0.85;
  filter: none !important;
  color: var(--color-background-plain-text, var(--color-primary-text)) !important;
}
.header-menu .header-menu__trigger[data-v-dbefb31d]:focus-visible {
  outline: none !important;
  box-shadow: none !important;
}
.header-menu .header-menu__trigger[data-v-dbefb31d] .button-vue__icon svg,
.header-menu .header-menu__trigger[data-v-dbefb31d] .button-vue__icon:not(:has(svg)) {
  mask: var(--header-menu-icon-mask, none);
}
.header-menu--opened .header-menu__trigger[data-v-dbefb31d], .header-menu__trigger[data-v-dbefb31d]:hover, .header-menu__trigger[data-v-dbefb31d]:focus, .header-menu__trigger[data-v-dbefb31d]:active {
  opacity: 1;
}
@media only screen and (max-width: 512px) {
.header-menu[data-v-dbefb31d] {
    width: var(--default-clickable-area);
}
.header-menu .header-menu__trigger[data-v-dbefb31d] {
    --button-size: var(--default-clickable-area) !important;
}
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-c1b2b551] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}

/*!
 * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
.header-menu[data-v-c1b2b551] {
  position: relative;
  width: var(--header-height);
  height: var(--header-height);
}
.header-menu .header-menu__trigger[data-v-c1b2b551] {
  --button-size: var(--header-height) !important;
  height: var(--header-height);
  opacity: 0.85;
  filter: none !important;
  color: var(--color-background-plain-text, var(--color-primary-text)) !important;
}
.header-menu .header-menu__trigger[data-v-c1b2b551]:focus-visible {
  outline: none !important;
  box-shadow: none !important;
}
.header-menu .header-menu__trigger[data-v-c1b2b551] .button-vue__icon svg,
.header-menu .header-menu__trigger[data-v-c1b2b551] .button-vue__icon:not(:has(svg)) {
  mask: var(--header-menu-icon-mask, none);
}
.header-menu--opened .header-menu__trigger[data-v-c1b2b551], .header-menu__trigger[data-v-c1b2b551]:hover, .header-menu__trigger[data-v-c1b2b551]:focus, .header-menu__trigger[data-v-c1b2b551]:active {
  opacity: 1;
}
@media only screen and (max-width: 512px) {
.header-menu[data-v-c1b2b551] {
    width: var(--default-clickable-area);
}
.header-menu .header-menu__trigger[data-v-c1b2b551] {
    --button-size: var(--default-clickable-area) !important;
}
}
.header-menu__wrapper[data-v-c1b2b551] {
  position: fixed;
  z-index: 2000;
  top: var(--header-height);
  inset-inline-end: 0;
  box-sizing: border-box;
  margin: 0 8px;
  border-radius: var(--border-radius-element);
  background-color: var(--color-main-background);
  filter: drop-shadow(0 1px 5px var(--color-box-shadow));
}
.header-menu__caret[data-v-c1b2b551] {
  position: absolute;
  z-index: 2001;
  bottom: 0;
  inset-inline-start: calc(50% - 10px);
  width: 0;
  height: 0;
  content: " ";
  pointer-events: none;
  border: 10px solid transparent;
  border-bottom-color: var(--color-main-background);
}
.header-menu__content[data-v-c1b2b551] {
  overflow: auto;
  width: 350px;
  max-width: calc(100vw - 16px);
  min-height: calc(var(--default-clickable-area) * 1.5);
  max-height: calc(100vh - var(--header-height) * 2);
}
.header-menu__content[data-v-c1b2b551] .empty-content {
  margin: 12vh 10px;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-4c860755] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.list-item__wrapper[data-v-4c860755] {
  display: flex;
  position: relative;
  width: 100%;
  padding: 2px 4px;
}
.list-item__wrapper[data-v-4c860755]:first-of-type {
  padding-block-start: 4px;
}
.list-item__wrapper[data-v-4c860755]:last-of-type {
  padding-block-end: 4px;
}
.list-item__wrapper--active .list-item[data-v-4c860755], .list-item__wrapper.active .list-item[data-v-4c860755] {
  background-color: var(--color-primary-element);
  color: var(--color-primary-element-text) !important;
}
.list-item__wrapper--active .list-item[data-v-4c860755]:hover, .list-item__wrapper--active .list-item[data-v-4c860755]:focus-within, .list-item__wrapper--active .list-item[data-v-4c860755]:has(:focus-visible), .list-item__wrapper--active .list-item[data-v-4c860755]:has(:active), .list-item__wrapper.active .list-item[data-v-4c860755]:hover, .list-item__wrapper.active .list-item[data-v-4c860755]:focus-within, .list-item__wrapper.active .list-item[data-v-4c860755]:has(:focus-visible), .list-item__wrapper.active .list-item[data-v-4c860755]:has(:active) {
  background-color: var(--color-primary-element-hover);
}
.list-item__wrapper--active .list-item-content__name[data-v-4c860755],
.list-item__wrapper--active .list-item-content__subname[data-v-4c860755],
.list-item__wrapper--active .list-item-content__details[data-v-4c860755],
.list-item__wrapper--active .list-item-details__details[data-v-4c860755], .list-item__wrapper.active .list-item-content__name[data-v-4c860755],
.list-item__wrapper.active .list-item-content__subname[data-v-4c860755],
.list-item__wrapper.active .list-item-content__details[data-v-4c860755],
.list-item__wrapper.active .list-item-details__details[data-v-4c860755] {
  color: var(--color-primary-element-text) !important;
}
.list-item__wrapper .list-item-content__name[data-v-4c860755],
.list-item__wrapper .list-item-content__subname[data-v-4c860755],
.list-item__wrapper .list-item-content__details[data-v-4c860755],
.list-item__wrapper .list-item-details__details[data-v-4c860755] {
  white-space: nowrap;
  margin-block: 0;
  margin-inline: 0 auto;
  overflow: hidden;
  text-overflow: ellipsis;
}
.list-item-content__name[data-v-4c860755] {
  min-width: 100px;
  flex: 1 1 10%;
  font-weight: 500;
}
.list-item-content__subname[data-v-4c860755] {
  flex: 1 0;
  min-width: 0;
  color: var(--color-text-maxcontrast);
}
.list-item-content__subname--bold[data-v-4c860755] {
  font-weight: 500;
}
.list-item[data-v-4c860755] {
  --list-item-padding: var(--default-grid-baseline);
  --list-item-height: 2lh;
  --list-item-border-radius: var(--border-radius-element, 32px);
  box-sizing: border-box;
  display: flex;
  position: relative;
  flex: 0 0 auto;
  justify-content: flex-start;
  padding: var(--list-item-padding);
  width: 100%;
  border-radius: var(--border-radius-element, 32px);
  cursor: pointer;
  transition: background-color var(--animation-quick) ease-in-out;
  list-style: none;
}
.list-item[data-v-4c860755]:hover, .list-item[data-v-4c860755]:focus-within, .list-item[data-v-4c860755]:has(:active), .list-item[data-v-4c860755]:has(:focus-visible) {
  background-color: var(--color-background-hover);
}
.list-item[data-v-4c860755]:has(.list-item__anchor:focus-visible) {
  outline: 2px solid var(--color-main-text);
  box-shadow: 0 0 0 4px var(--color-main-background);
}
.list-item--compact[data-v-4c860755] {
  --list-item-padding: calc(0.5 * var(--default-grid-baseline)) var(--default-grid-baseline);
}
.list-item--compact[data-v-4c860755]:not(:has(.list-item-content__subname)) {
  --list-item-height: var(--default-clickable-area);
}
.list-item--one-line[data-v-4c860755] {
  --list-item-height: var(--default-clickable-area);
  --list-item-border-radius: var(--border-radius-element, calc(var(--default-clickable-area) / 2));
  --list-item-padding: var(--default-grid-baseline);
}
.list-item--one-line .list-item-content__main[data-v-4c860755] {
  display: flex;
  justify-content: start;
  gap: 12px;
  min-width: 0;
}
.list-item--one-line .list-item-content__details[data-v-4c860755] {
  flex-direction: row;
  align-items: center;
  justify-content: end;
}
.list-item--one-line .list-item-content__name[data-v-4c860755] {
  align-self: center;
  max-width: 300px;
}
.list-item__anchor[data-v-4c860755] {
  color: inherit;
  display: flex;
  flex: 1 0 auto;
  align-items: center;
  height: var(--list-item-height);
  min-width: 0;
}
.list-item__anchor[data-v-4c860755]:focus-visible {
  outline: none;
}
.list-item-content[data-v-4c860755] {
  display: flex;
  flex: 1 0;
  justify-content: space-between;
  padding-inline-start: calc(2 * var(--default-grid-baseline));
  min-width: 0;
}
.list-item-content__main[data-v-4c860755] {
  flex: 1 0;
  width: 0;
  margin: auto 0;
}
.list-item-content__main--oneline[data-v-4c860755] {
  display: flex;
}
.list-item-content__details[data-v-4c860755] {
  display: flex;
  flex-direction: column;
  justify-content: end;
  align-items: end;
}
.list-item-content__actions[data-v-4c860755], .list-item-content__extra-actions[data-v-4c860755] {
  flex: 0 0 auto;
  align-self: center;
  justify-content: center;
  margin-inline-start: var(--default-grid-baseline);
}
.list-item-content__extra-actions[data-v-4c860755] {
  display: flex;
  align-items: center;
  gap: var(--default-grid-baseline);
}
.list-item-details__details[data-v-4c860755] {
  color: var(--color-text-maxcontrast);
  margin: 0 9px !important;
  font-weight: normal;
}
.list-item-details__extra[data-v-4c860755] {
  margin: 2px 4px 0 4px;
  display: flex;
  align-items: center;
}
.list-item-details__indicator[data-v-4c860755] {
  margin: 0 5px;
}
.list-item__extra[data-v-4c860755] {
  margin-top: var(--default-grid-baseline);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-f5135913] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.option[data-v-f5135913] {
  display: flex;
  align-items: center;
  width: 100%;
  height: var(--height);
  cursor: inherit;
}
.option__avatar[data-v-f5135913] {
  margin-inline-end: var(--margin);
}
.option__details[data-v-f5135913] {
  display: flex;
  flex: 1 1;
  flex-direction: column;
  justify-content: center;
  min-width: 0;
}
.option__lineone[data-v-f5135913] {
  color: var(--color-main-text);
}
.option__linetwo[data-v-f5135913] {
  color: var(--color-text-maxcontrast);
}
.option__lineone[data-v-f5135913], .option__linetwo[data-v-f5135913] {
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  line-height: 1.2;
}
.option__lineone strong[data-v-f5135913], .option__linetwo strong[data-v-f5135913] {
  font-weight: bold;
}
.option--compact .option__lineone[data-v-f5135913] {
  font-size: 14px;
}
.option--compact .option__linetwo[data-v-f5135913] {
  font-size: 11px;
  line-height: 1.5;
  margin-top: -4px;
}
.option__icon[data-v-f5135913] {
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  color: var(--color-text-maxcontrast);
}
.option__icon.icon[data-v-f5135913] {
  flex: 0 0 var(--default-clickable-area);
  opacity: 0.7;
  background-position: center;
  background-size: 16px;
}
.option__details[data-v-f5135913], .option__lineone[data-v-f5135913], .option__linetwo[data-v-f5135913], .option__icon[data-v-f5135913] {
  cursor: inherit;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-057b3c72] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.progress-bar[data-v-057b3c72] {
  display: block;
  height: var(--progress-bar-height);
  --progress-bar-color: var(--cd1c225c);
  --progress-bar-height: var(--fb577880);
}
.progress-bar--linear[data-v-057b3c72] {
  width: 100%;
  overflow: hidden;
  border: 0;
  padding: 0;
  background: var(--color-background-dark);
  border-radius: calc(var(--progress-bar-height) / 2);
}
.progress-bar--linear[data-v-057b3c72]::-webkit-progress-bar {
  height: var(--progress-bar-height);
  background-color: transparent;
}
.progress-bar--linear[data-v-057b3c72]::-webkit-progress-value {
  background: var(--progress-bar-color, var(--gradient-primary-background));
  border-radius: calc(var(--progress-bar-height) / 2);
}
.progress-bar--linear[data-v-057b3c72]::-moz-progress-bar {
  background: var(--progress-bar-color, var(--gradient-primary-background));
  border-radius: calc(var(--progress-bar-height) / 2);
}
.progress-bar--circular[data-v-057b3c72] {
  width: var(--progress-bar-height);
  color: var(--progress-bar-color);
}
.progress-bar--error[data-v-057b3c72] {
  color: var(--color-text-error, var(--color-error)) !important;
}
.progress-bar--error[data-v-057b3c72]::-moz-progress-bar {
  background: var(--color-text-error, var(--color-error)) !important;
}
.progress-bar--error[data-v-057b3c72]::-webkit-progress-value {
  background: var(--color-text-error, var(--color-error)) !important;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-19be28f6] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.team-resources__header[data-v-19be28f6] {
  font-weight: bold;
  margin-bottom: 6px;
}
.related-team[data-v-19be28f6] {
  border-radius: var(--border-radius-container);
  border: 2px solid var(--color-border-dark);
  margin-bottom: 6px;
}
.related-team__open[data-v-19be28f6] {
  border-color: var(--color-primary-element);
}
.related-team__header[data-v-19be28f6] {
  padding: 6px;
  padding-inline-end: 24px;
  display: flex;
  gap: 12px;
}
.related-team__name[data-v-19be28f6] {
  display: flex;
  flex-grow: 1;
  align-items: center;
  gap: 12px;
  padding: 6px 12px;
  font-weight: bold;
  margin: 0;
}
.related-team .related-team-provider[data-v-19be28f6] {
  padding: 6px 12px;
}
.related-team .related-team-provider__name[data-v-19be28f6] {
  font-weight: bold;
  margin-bottom: 3px;
}
.related-team .related-team-provider__link[data-v-19be28f6] {
  display: flex;
  gap: 12px;
  padding: 6px 12px;
  font-weight: bold;
}
.related-team .related-team-resource__link[data-v-19be28f6] {
  display: flex;
  gap: 12px;
  height: var(--default-clickable-area);
  align-items: center;
  border-radius: var(--border-radius-element);
}
.related-team .related-team-resource__link[data-v-19be28f6]:hover {
  background-color: var(--color-background-hover);
}
.related-team .related-team-resource__link[data-v-19be28f6]:focus {
  background-color: var(--color-background-hover);
  outline: 2px solid var(--color-primary-element);
}
.related-team .related-team-resource .resource__icon[data-v-19be28f6] {
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}
.related-team .related-team-resource .resource__icon > img[data-v-19be28f6] {
  border-radius: var(--border-radius-pill);
  overflow: hidden;
  width: 32px;
  height: 32px;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-bcd84980] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.resource[data-v-bcd84980] {
  display: flex;
  align-items: center;
  height: var(--default-clickable-area);
}
.resource__button[data-v-bcd84980] {
  width: 100% !important;
  justify-content: flex-start !important;
  padding: 0 !important;
}
.resource__button[data-v-bcd84980] .button-vue__wrapper {
  justify-content: flex-start !important;
}
.resource__button[data-v-bcd84980] .button-vue__wrapper .button-vue__text {
  font-weight: normal !important;
  margin-inline-start: 2px !important;
}
.resource__icon[data-v-bcd84980] {
  width: 32px;
  height: 32px;
  background-color: var(--color-text-maxcontrast);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}
.resource__icon img[data-v-bcd84980] {
  width: 16px;
  height: 16px;
  filter: var(--background-invert-if-dark);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-2a2d0b30] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.related-resources__header h5[data-v-2a2d0b30] {
  font-weight: bold;
  margin-bottom: 6px;
}
.related-resources__header p[data-v-2a2d0b30] {
  color: var(--color-text-maxcontrast);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-b62241e4] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.autocomplete-result[data-v-b62241e4] {
  display: flex;
  align-items: center;
  gap: var(--default-grid-baseline);
  line-height: 1.2;
  --auto-complete-result-avatar-size: var(--default-clickable-area);
}
.autocomplete-result__icon[data-v-b62241e4] {
  position: relative;
  flex: 0 0 var(--default-clickable-area);
  width: var(--default-clickable-area);
  min-width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  border-radius: var(--default-clickable-area);
  background-color: var(--color-background-darker);
  background-repeat: no-repeat;
  background-position: center;
  background-size: contain;
}
.autocomplete-result__icon--with-avatar[data-v-b62241e4] {
  color: inherit;
  background-size: cover;
}
.autocomplete-result__status[data-v-b62241e4] {
  --auto-complete-result-status-icon-size: clamp(14px, var(--auto-complete-result-avatar-size) * 0.4, 18px);
  --auto-complete-result-status-icon-position: calc(var(--auto-complete-result-avatar-size) / 2 * (1 - 1 / sqrt(2)) - var(--auto-complete-result-status-icon-size) / 2);
  box-sizing: border-box;
  position: absolute;
  inset-inline-end: var(--auto-complete-result-status-icon-position);
  bottom: var(--auto-complete-result-status-icon-position);
  height: var(--auto-complete-result-status-icon-size);
  width: var(--auto-complete-result-status-icon-size);
  border: 2px solid var(--color-main-background);
  border-radius: 50%;
  background-color: var(--color-main-background);
  font-size: calc(var(--auto-complete-result-status-icon-size) / 1.2);
  line-height: 1.2;
  background-repeat: no-repeat;
  background-size: var(--auto-complete-result-status-icon-size);
  background-position: center;
}
.autocomplete-result__status--icon[data-v-b62241e4] {
  border: none;
  background-color: transparent;
}
.autocomplete-result__content[data-v-b62241e4] {
  display: flex;
  flex: 1 1 100%;
  flex-direction: column;
  justify-content: center;
  min-width: 0;
}
.autocomplete-result__title[data-v-b62241e4], .autocomplete-result__subline[data-v-b62241e4] {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.autocomplete-result__subline[data-v-b62241e4] {
  color: var(--color-text-maxcontrast);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-8d63a41d] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.rich-contenteditable[data-v-8d63a41d] {
  --contenteditable-block-offset: calc(2 * var(--default-grid-baseline));
  --contenteditable-inline-start-offset: calc(2 * var(--default-grid-baseline));
  --contenteditable-inline-end-offset: calc(2 * var(--default-grid-baseline));
  position: relative;
  width: auto;
}
.rich-contenteditable__label[data-v-8d63a41d] {
  position: absolute;
  margin-inline: 14px;
  max-width: fit-content;
  inset-block-start: 11px;
  inset-inline: 0;
  color: var(--color-text-maxcontrast);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  pointer-events: none;
  transition: height var(--animation-quick), inset-block-start var(--animation-quick), font-size var(--animation-quick), color var(--animation-quick), background-color var(--animation-quick) var(--animation-slow);
}
.rich-contenteditable__input:focus + .rich-contenteditable__label[data-v-8d63a41d], .rich-contenteditable__input:not(.rich-contenteditable__input--empty) + .rich-contenteditable__label[data-v-8d63a41d] {
  inset-block-start: -10px;
  line-height: 1.5;
  font-size: 13px;
  font-weight: 500;
  border-radius: var(--default-grid-baseline) var(--default-grid-baseline) 0 0;
  background-color: var(--color-main-background);
  padding-inline: 5px;
  margin-inline: 9px;
  transition: height var(--animation-quick), inset-block-start var(--animation-quick), font-size var(--animation-quick), color var(--animation-quick);
}
.rich-contenteditable__input[data-v-8d63a41d] {
  overflow-y: auto;
  width: auto;
  margin: 0;
  padding-block: var(--contenteditable-block-offset);
  padding-inline: var(--contenteditable-inline-start-offset) var(--contenteditable-inline-end-offset);
  cursor: text;
  white-space: pre-wrap;
  overflow-wrap: break-word;
  color: var(--color-main-text);
  border: 2px solid var(--color-border-maxcontrast);
  border-radius: var(--border-radius-element);
  outline: none;
  background-color: var(--color-main-background);
  font-family: var(--font-face);
  font-size: inherit;
  tab-size: 4;
  min-height: var(--default-clickable-area);
  max-height: calc(var(--default-clickable-area) * 5.5);
}
.rich-contenteditable__input--has-label[data-v-8d63a41d] {
  margin-top: 10px;
}
.rich-contenteditable__input--empty[data-v-8d63a41d]:focus:before, .rich-contenteditable__input--empty[data-v-8d63a41d]:not(.rich-contenteditable__input--has-label):before {
  content: attr(aria-placeholder);
  color: var(--color-text-maxcontrast);
  position: absolute;
  width: calc(100% - var(--contenteditable-inline-start-offset) - var(--contenteditable-inline-end-offset));
  height: calc(100% - 2 * var(--contenteditable-block-offset));
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}
.rich-contenteditable__input[contenteditable=false][data-v-8d63a41d]:not(.rich-contenteditable__input--disabled) {
  cursor: default;
  background-color: transparent;
  color: var(--color-main-text);
  border-color: transparent;
  opacity: 1;
  border-radius: 0;
}
.rich-contenteditable__input--multiline[data-v-8d63a41d] {
  min-height: calc(var(--default-clickable-area) * 3);
  max-height: none;
}
.rich-contenteditable__input--disabled[data-v-8d63a41d] {
  opacity: 0.5;
  color: var(--color-text-maxcontrast);
  border: 2px solid var(--color-background-darker);
  border-radius: var(--border-radius-small);
  background-color: var(--color-background-dark);
}
.rich-contenteditable__input--overflow[data-v-8d63a41d], .rich-contenteditable__input--overflow[data-v-8d63a41d]:hover {
  border-color: var(--color-border-error, var(--color-error)) !important;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
._material-design-icon_1xkrb_12 {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
._tribute-container_1xkrb_20 {
  z-index: 9000;
  overflow: auto;
  position: absolute;
  /* stylelint-disable-next-line csstools/use-logical */ /* upstream logic */
  left: -100vw;
  margin: var(--default-grid-baseline) 0;
  padding: var(--default-grid-baseline);
  color: var(--color-text-maxcontrast);
  border-radius: var(--border-radius-element);
  background: var(--color-main-background);
  box-shadow: 0 1px 5px var(--color-box-shadow);
}
._tribute-container_1xkrb_20, ._tribute-container_1xkrb_20 * {
  box-sizing: border-box;
}
._tribute-container_1xkrb_20 ul {
  display: flex;
  flex-direction: column;
  gap: var(--default-grid-baseline);
}
._tribute-container_1xkrb_20 ._tribute-container__item_1xkrb_41 {
  color: var(--color-text-maxcontrast);
  border-radius: var(--border-radius-small);
  padding: var(--default-grid-baseline);
  cursor: pointer;
  min-height: var(--clickable-area-small, auto);
}
._tribute-container_1xkrb_20 ._tribute-container__item_1xkrb_41.highlight {
  color: var(--color-main-text);
  background: var(--color-background-hover);
}
._tribute-container_1xkrb_20 ._tribute-container__item_1xkrb_41.highlight, ._tribute-container_1xkrb_20 ._tribute-container__item_1xkrb_41.highlight * {
  cursor: pointer;
}
._tribute-container_1xkrb_20._tribute-container--focus-visible_1xkrb_55 .highlight._tribute-container__item_1xkrb_41 {
  outline: 2px solid var(--color-main-text) !important;
}
._tribute-container-autocomplete_1xkrb_59 {
  min-width: 250px;
  max-width: 300px;
  max-height: calc((var(--default-clickable-area) + 3 * var(--default-grid-baseline)) * 4.5 - 1.5 * var(--default-grid-baseline));
}
._tribute-container-emoji_1xkrb_65,
._tribute-container-link_1xkrb_66 {
  min-width: 200px;
  max-width: 200px;
  max-height: calc((24px + 3 * var(--default-grid-baseline)) * 5.5 - 1.5 * var(--default-grid-baseline));
}
._tribute-container-emoji_1xkrb_65 ._tribute-item_1xkrb_71,
._tribute-container-link_1xkrb_66 ._tribute-item_1xkrb_71 {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
._tribute-container-link_1xkrb_66 {
  min-width: 200px;
  max-width: 300px;
}
._tribute-container-link_1xkrb_66 ._tribute-item_1xkrb_71 {
  display: flex;
  align-items: center;
}
._tribute-container-link_1xkrb_66 ._tribute-item__title_1xkrb_86 {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
._tribute-container-link_1xkrb_66 ._tribute-item__icon_1xkrb_91 {
  margin: auto 0;
  width: 20px;
  height: 20px;
  object-fit: contain;
  padding-inline-end: var(--default-grid-baseline);
  filter: var(--background-invert-if-dark);
}
.nc-select-users[data-v-085bfabd] .vs__selected {
	padding-inline: 0 5px !important;
}
/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-72a58313] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.input-wrapper[data-v-72a58313] {
  display: flex;
  align-items: center;
  flex-wrap: wrap;
  width: 100%;
  max-width: 400px;
}
.input-wrapper .action-input__label[data-v-72a58313] {
  margin-inline-end: 12px;
}
.input-wrapper[data-v-72a58313]:disabled {
  cursor: default;
}
.input-wrapper .hint[data-v-72a58313] {
  color: var(--color-text-maxcontrast);
  margin-inline-start: 8px;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-dbbb3fd7] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.settings-section[data-v-dbbb3fd7] {
  display: block;
  padding: 0 0 calc(var(--default-grid-baseline) * 5) 0;
  margin: calc(var(--default-grid-baseline) * 7);
  width: min(900px, 100% - var(--default-grid-baseline) * 7 * 2);
}
.settings-section[data-v-dbbb3fd7]:not(:last-child) {
  border-bottom: 1px solid var(--color-border);
}
.settings-section__name[data-v-dbbb3fd7] {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  max-width: 900px;
  margin-top: 0;
}
.settings-section__info[data-v-dbbb3fd7] {
  display: flex;
  align-items: center;
  justify-content: center;
  width: var(--default-clickable-area);
  height: var(--default-clickable-area);
  margin: calc((var(--default-clickable-area) - 16px) / 2 * -1);
  margin-inline-start: 0;
  color: var(--color-text-maxcontrast);
}
.settings-section__info[data-v-dbbb3fd7]:hover, .settings-section__info[data-v-dbbb3fd7]:focus, .settings-section__info[data-v-dbbb3fd7]:active {
  color: var(--color-main-text);
}
.settings-section__desc[data-v-dbbb3fd7] {
  margin-top: -0.2em;
  margin-bottom: 1em;
  color: var(--color-text-maxcontrast);
  max-width: 900px;
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-1a32ff89] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.select-group-error[data-v-1a32ff89] {
  color: var(--color-text-error, var(--color-error));
  font-size: 13px;
  padding-inline-start: var(--border-radius-element);
}/**
 * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * SPDX-FileCopyrightText: 2021 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/*
* Ensure proper alignment of the vue material icons
*/
.material-design-icon[data-v-58be798d] {
  display: flex;
  align-self: center;
  justify-self: center;
  align-items: center;
  justify-content: center;
}
.textarea[data-v-58be798d] {
  position: relative;
  width: 100%;
  border-radius: var(--border-radius-element);
  margin-block-start: 6px;
  resize: vertical;
}
.textarea__main-wrapper[data-v-58be798d] {
  position: relative;
}
.textarea--disabled[data-v-58be798d] {
  opacity: 0.7;
  filter: saturate(0.7);
}
.textarea__input[data-v-58be798d] {
  margin: 0;
  padding-inline: 10px 6px;
  width: 100%;
  height: calc(var(--default-clickable-area) * 2);
  font-size: var(--default-font-size);
  text-overflow: ellipsis;
  background-color: var(--color-main-background);
  color: var(--color-main-text);
  border: var(--border-width-input, 2px) solid var(--color-border-maxcontrast);
  border-radius: var(--border-radius-element);
  cursor: pointer;
}
.textarea__input[data-v-58be798d]:active:not([disabled]), .textarea__input[data-v-58be798d]:hover:not([disabled]), .textarea__input[data-v-58be798d]:focus:not([disabled]) {
  border-width: var(--border-width-input-focused, 2px);
  border-color: var(--color-main-text);
  box-shadow: 0 0 0 2px var(--color-main-background) !important;
}
.textarea__input[data-v-58be798d]:not(:focus, .textarea__input--label-outside)::placeholder {
  opacity: 0;
}
.textarea__input[data-v-58be798d]:focus {
  cursor: text;
}
.textarea__input[data-v-58be798d]:disabled {
  cursor: default;
}
.textarea__input[data-v-58be798d]:focus-visible {
  box-shadow: unset !important;
}
.textarea__input--success[data-v-58be798d] {
  border-color: var(--color-border-success, var(--color-success)) !important;
}
.textarea__input--success[data-v-58be798d]:focus-visible {
  box-shadow: rgb(248, 250, 252) 0px 0px 0px 2px, var(--color-primary-element) 0px 0px 0px 4px, rgba(0, 0, 0, 0.05) 0px 1px 2px 0px;
}
.textarea__input--error[data-v-58be798d] {
  border-color: var(--color-border-error, var(--color-error)) !important;
}
.textarea__input--error[data-v-58be798d]:focus-visible {
  box-shadow: rgb(248, 250, 252) 0px 0px 0px 2px, var(--color-primary-element) 0px 0px 0px 4px, rgba(0, 0, 0, 0.05) 0px 1px 2px 0px;
}
.textarea__label[data-v-58be798d] {
  position: absolute;
  margin-inline: 12px 0;
  max-width: fit-content;
  inset-block-start: 11px;
  inset-inline: 0;
  color: var(--color-text-maxcontrast);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  pointer-events: none;
  transition: height var(--animation-quick), inset-block-start var(--animation-quick), font-size var(--animation-quick), color var(--animation-quick), background-color var(--animation-quick) var(--animation-slow);
}
.textarea__input:focus + .textarea__label[data-v-58be798d], .textarea__input:not(:placeholder-shown) + .textarea__label[data-v-58be798d] {
  inset-block-start: -10px;
  line-height: 1.5;
  font-size: 13px;
  font-weight: 500;
  color: var(--color-main-text);
  background-color: var(--color-main-background);
  padding-inline: 4px;
  margin-inline-start: 8px;
  transition: height var(--animation-quick), inset-block-start var(--animation-quick), font-size var(--animation-quick), color var(--animation-quick);
}
.textarea__helper-text-message[data-v-58be798d] {
  padding-block: 4px;
  display: flex;
  align-items: center;
}
.textarea__helper-text-message__icon[data-v-58be798d] {
  margin-inline-end: 8px;
}
.textarea__helper-text-message--error[data-v-58be798d] {
  color: var(--color-error-text);
}
.textarea__helper-text-message--success[data-v-58be798d] {
  color: var(--color-success-text);
}.input-div[data-v-920e1d5d] {
  --input-height: 44px;
  position: relative;
  margin-bottom: var(--default-grid-baseline);
  display: block !important;
}
.input-div label[data-v-920e1d5d] {
  display: block;
  margin-bottom: 2px;
}
.input-div input[data-v-920e1d5d] {
  margin: 0;
}
.input-div input.has-submit[data-v-920e1d5d], .input-div input.error[data-v-920e1d5d], .input-div input.success[data-v-920e1d5d], .input-div input.checking[data-v-920e1d5d] {
  padding-inline-end: var(--input-height);
}
.input-div input.has-modifier[data-v-920e1d5d] {
  padding: 0 var(--input-height);
}
.input-div input.error[data-v-920e1d5d] {
  border-color: var(--color-error);
}
.input-div input.success[data-v-920e1d5d] {
  border-color: var(--color-success);
}
.input-div .input-wrapper[data-v-920e1d5d] {
  position: relative;
  display: flex;
}
.input-div .input-wrapper > input[data-v-920e1d5d] {
  flex: 1;
}
.input-div .helper[data-v-920e1d5d] {
  min-height: 1.5rem;
  font-size: 0.8em;
  opacity: 0.8;
}
.input-div .helper.error[data-v-920e1d5d] {
  opacity: 1;
  color: var(--color-error);
}
.input-div.numeric .input-wrapper input[data-v-920e1d5d] {
  text-align: center;
  max-width: 4rem;
  padding: 0;
}
.input-div .signaling-icon[data-v-920e1d5d] {
  position: absolute;
  inset-inline-end: 0;
  width: var(--input-height);
  height: var(--input-height);
}
.input-div .modifier[data-v-920e1d5d] {
  position: absolute;
  height: 100%;
  width: var(--input-height);
  border-color: var(--color-border-dark);
  cursor: pointer;
}
.input-div .modifier[data-v-920e1d5d]:hover {
  background-color: var(--color-background-hover);
}
.input-div .modifier.add[data-v-920e1d5d] {
  inset-inline-end: 0;
  border-inline-start: solid 2px var(--color-border-maxcontrast);
  border-radius: 0 var(--border-radius) var(--border-radius) 0;
}
.input-div .modifier.subtract[data-v-920e1d5d] {
  border-inline-end: solid 2px var(--color-border-maxcontrast);
  border-radius: var(--border-radius) 0 0 var(--border-radius);
}.loading-overlay {
  position: absolute;
  inset-inline-start: 0;
  top: 0;
  width: 100vw;
  height: 100vh;
  background: var(--color-main-background);
  opacity: 0.9;
  z-index: 9999;
}
.loading-overlay .loading-overlay__inner {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
}
.loading-overlay .loading-overlay__name {
  margin-bottom: 10px;
  text-align: center;
  font-weight: bold;
  font-size: 20px;
  line-height: 30px;
}
.loading-overlay .loading-overlay__description {
  color: var(--color-text-maxcontrast);
  text-align: center;
  text-wrap-style: balance;
}
.loading-overlay .loading-overlay__spinner {
  inset-inline-start: 50%;
}.canvas {
  margin: auto;
  padding: 32px;
}
.qr-url {
  font-size: 0.6em;
  margin-top: 16px;
}
@media print {
.noprint {
    display: none;
}
}
.collapsible {
  position: relative;
  margin-bottom: 1.5rem;
}
.collapsible .collapsible_container {
  position: relative;
  overflow: auto;
  width: 100%;
  transition: height 0.3s ease;
  padding-right: 8px;
}
.collapsible .collapsible_container.no-transition {
  transition: none !important;
}
.collapsible .collapsible_wrapper {
  position: relative;
  overflow: hidden;
}
.collapsible .collapsible_wrapper::before, .collapsible .collapsible_wrapper::after {
  content: "";
  position: absolute;
  left: 0;
  right: 8px;
  height: 2.5rem;
  pointer-events: none;
  z-index: 1;
}
.collapsible .collapsible_wrapper::before {
  top: 0;
  background: linear-gradient(to bottom, var(--color-main-background), rgba(0, 0, 0, 0));
  opacity: 0;
  transition: opacity 0.2s;
}
.collapsible .collapsible_wrapper::after {
  bottom: 0;
  background: linear-gradient(to top, var(--color-main-background), rgba(0, 0, 0, 0));
  opacity: 0;
  transition: opacity 0.2s;
}
.collapsible .collapsible_wrapper.has-top-shadow::before {
  opacity: 1;
}
.collapsible .collapsible_wrapper.has-bottom-shadow::after {
  opacity: 1;
}
.resize-handle {
  position: absolute;
  left: 0;
  right: 0;
  height: 12px;
  cursor: ns-resize;
  background: transparent;
  z-index: 1;
}
.resize-handle::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 0;
  right: 0;
  height: 1px;
  background: var(--color-border);
  transform: translateY(-0.5px);
}
.resize-handle::after {
  content: "• • •";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 0.15rem 0.5rem;
  font-size: 1rem;
  line-height: 1;
  color: var(--color-main-text);
  background: var(--color-border, rgba(0, 0, 0, 0.05));
  border-radius: 0.5rem;
  pointer-events: none;
  user-select: none;
}
.resize-handle:hover::after {
  color: var(--color-loading-dark);
  background: var(--color-background-darker, rgba(0, 0, 0, 0.1));
}`));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
const appName = "agora";
const appVersion = "1.0.0-rc5";
import { bb as getCanonicalLocale, a as _export_sfc, d as defineComponent, m as mergeModels, u as useModel, bC as useSlots, $ as useTemplateRef, aI as useElementSize, b as computed, a2 as createElementId, P as ref, f as createBlock, l as createCommentVNode, o as openBlock, g as withCtx, k as createBaseVNode, t as toDisplayString, n as unref, h as resolveDynamicComponent, i as mergeProps, aa as toHandlers, G as normalizeClass, c as createElementBlock, r as renderSlot, M as Fragment, O as renderList, bj as NcModal, a3 as register, bD as inject, w as warn$1, bE as useIsMobile, e as watch, v as onMounted, bx as subscribe, b4 as emit, bF as createFocusTrap, bG as getTrapStack, b6 as onUnmounted, by as unsubscribe, j as createVNode, bf as withKeys, a4 as t, L as NcIconSvgWrapper, bH as mdiMenuOpen, bI as mdiMenu, U as NcButton, bJ as t13, at as IconClose, V as resolveComponent, Q as withDirectives, T as vModelText, ae as withModifiers, bK as t47, bL as t21, bM as t20, ab as NcLoadingIcon, b7 as NcActionButton, b8 as NcActions, C as createTextVNode, x as normalizeProps, y as guardReactiveProps, _ as _export_sfc$1, s as translate, bc as NC_ACTIONS_IS_SEMANTIC_MENU, X as getDefaultExportFromCjs, bN as e, aQ as cancelableClient, aR as v, aw as logger, a5 as createSlots, bO as mdiEyeOff, bP as mdiEye, bQ as t45, bd as ActionGlobalMixin, bR as defineAsyncComponent, p as normalizeStyle, bh as onBeforeUnmount, bS as provide, br as getCurrentInstance, ar as h, aK as nextTick, bT as distExports, S as vShow, bU as useSwipe, bV as isRtl, a6 as mdiArrowRight, bW as useFocusWithin, bX as t44, bY as escapeHTML, bZ as t14, b_ as isSlotPopulated, b$ as vOnClickOutside, ad as resolveDirective, bi as Teleport, af as Transition, c0 as useIsSmallMobile, a8 as mdiClose, c1 as t6, c2 as t27, c3 as defaultPalette, a0 as mdiCheck, c4 as mdiArrowLeft, c5 as mdiDotsHorizontal, q as NcPopover, c6 as onBeforeMount, c7 as reactive, c8 as toRef, c9 as isRef, ca as render$6, cb as toValue, Z as useAttrs, cc as getCurrentScope, cd as onScopeDispose, ce as onBeforeUpdate, cf as mdiChevronUp, cg as mdiChevronDown, ch as mdiChevronRight, ci as mdiChevronLeft, cj as mdiClock, ck as mdiCalendarBlank, aD as t40, cl as t35, cm as t15, cn as t5, co as Color, cp as t39, cq as t36, cr as t8, cs as t32, ct as t0, cu as t46, cv as vModelDynamic } from "./NcEmptyContent-q-geAf0w-DpSvTJqc.chunk.mjs";
import { _ as _sfc_main$v, w as NcEmptyContent, L as Logger } from "./NcDashboardWidget-Wkx_9xKh-Bw6f1oJM.chunk.mjs";
import { C as ChevronDown, b as NcInputField, e as _sfc_main$w, f as __vitePreload, l as loadState, N as NcCheckboxRadioSwitch, a as NcSelect } from "./NcRichText-G8kzsdwx-IKlnWRaR.chunk.mjs";
/*!
 * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
function getFirstDay() {
  if (typeof globalThis.firstDay !== "undefined") {
    return globalThis.firstDay;
  }
  const intl = new Intl.Locale(getCanonicalLocale());
  const weekInfo = intl.getWeekInfo?.() ?? intl.weekInfo;
  if (weekInfo) {
    return weekInfo.firstDay % 7;
  }
  return 1;
}
function getDayNames() {
  if (typeof globalThis.dayNames !== "undefined") {
    return globalThis.dayNames;
  }
  const locale = getCanonicalLocale();
  return [
    (/* @__PURE__ */ new Date("1970-01-04T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "long" }),
    (/* @__PURE__ */ new Date("1970-01-05T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "long" }),
    (/* @__PURE__ */ new Date("1970-01-06T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "long" }),
    (/* @__PURE__ */ new Date("1970-01-07T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "long" }),
    (/* @__PURE__ */ new Date("1970-01-08T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "long" }),
    (/* @__PURE__ */ new Date("1970-01-09T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "long" }),
    (/* @__PURE__ */ new Date("1970-01-10T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "long" })
  ];
}
function getDayNamesMin() {
  if (typeof globalThis.dayNamesMin !== "undefined") {
    return globalThis.dayNamesMin;
  }
  const locale = getCanonicalLocale();
  return [
    (/* @__PURE__ */ new Date("1970-01-04T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "narrow" }),
    (/* @__PURE__ */ new Date("1970-01-05T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "narrow" }),
    (/* @__PURE__ */ new Date("1970-01-06T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "narrow" }),
    (/* @__PURE__ */ new Date("1970-01-07T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "narrow" }),
    (/* @__PURE__ */ new Date("1970-01-08T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "narrow" }),
    (/* @__PURE__ */ new Date("1970-01-09T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "narrow" }),
    (/* @__PURE__ */ new Date("1970-01-10T00:00:00.000Z")).toLocaleDateString(locale, { weekday: "narrow" })
  ];
}
const _hoisted_1$x = ["id", "textContent"];
const _hoisted_2$v = ["aria-label", "aria-labelledby"];
const _hoisted_3$p = { class: "dialog__text" };
const _hoisted_4$k = { class: "dialog__actions" };
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  __name: "NcDialog",
  props: /* @__PURE__ */ mergeModels({
    name: {},
    message: { default: "" },
    additionalTrapElements: { default: () => [] },
    container: { default: "body" },
    size: { default: "small" },
    buttons: { default: () => [] },
    isForm: { type: Boolean },
    noClose: { type: Boolean },
    closeOnClickOutside: { type: Boolean },
    outTransition: { type: Boolean },
    navigationAriaLabel: { default: "" },
    navigationAriaLabelledby: { default: "" },
    contentClasses: { default: "" },
    dialogClasses: { default: "" },
    navigationClasses: { default: "" }
  }, {
    "open": { type: Boolean, ...{ default: true } },
    "openModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["closing", "reset", "submit"], ["update:open"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const open = useModel(__props, "open");
    const emit2 = __emit;
    const slots = useSlots();
    const wrapper = useTemplateRef("wrapper-key");
    const { width: dialogWidth } = useElementSize(wrapper, { width: 900, height: 0 });
    const isNavigationCollapsed = computed(() => dialogWidth.value < 876);
    const hasNavigation = computed(() => slots?.navigation !== void 0);
    const navigationId = createElementId();
    const navigationAriaLabelAttr = computed(() => props.navigationAriaLabel || void 0);
    const navigationAriaLabelledbyAttr = computed(() => {
      if (props.navigationAriaLabel) {
        return void 0;
      }
      return props.navigationAriaLabelledby || navigationId;
    });
    const dialogElement = useTemplateRef("dialog-key");
    const dialogTagName = computed(() => props.isForm && !hasNavigation.value ? "form" : "div");
    const dialogListeners = computed(
      () => dialogTagName.value === "form" ? {
        /**
         * @param event - Form submit event
         */
        submit(event) {
          event.preventDefault();
          emit2("submit", event);
        },
        /**
         * @param event - Form submit event
         */
        reset(event) {
          event.preventDefault();
          emit2("reset", event);
        }
      } : {}
    );
    const showModal = ref(true);
    function handleButtonClose(button, result) {
      if (button.type === "submit" && dialogTagName.value === "form" && "reportValidity" in dialogElement.value && !dialogElement.value.reportValidity()) {
        return;
      }
      handleClosing(result);
      window.setTimeout(() => handleClosed(), 300);
    }
    function handleClosing(result) {
      showModal.value = false;
      emit2("closing", result);
    }
    const handleClosed = () => {
      showModal.value = true;
      open.value = false;
    };
    const modalProps = computed(() => ({
      noClose: props.noClose,
      container: props.container === void 0 ? "body" : props.container,
      // we do not pass the name as we already have the name as the headline
      // name: props.name,
      // But we need to set the correct label id so the dialog is labelled
      labelId: navigationId,
      size: props.size,
      show: open.value && showModal.value,
      outTransition: props.outTransition,
      closeOnClickOutside: props.closeOnClickOutside,
      additionalTrapElements: props.additionalTrapElements
    }));
    return (_ctx, _cache) => {
      return open.value ? (openBlock(), createBlock(unref(NcModal), mergeProps({
        key: 0,
        class: "dialog__modal",
        "enable-slideshow": false,
        "disable-swipe": ""
      }, modalProps.value, {
        onClose: handleClosed,
        "onUpdate:show": _cache[0] || (_cache[0] = ($event) => handleClosing())
      }), {
        default: withCtx(() => [
          createBaseVNode("h2", {
            id: unref(navigationId),
            class: "dialog__name",
            textContent: toDisplayString(_ctx.name)
          }, null, 8, _hoisted_1$x),
          (openBlock(), createBlock(resolveDynamicComponent(dialogTagName.value), mergeProps({
            ref: "dialog-key",
            class: ["dialog", _ctx.dialogClasses]
          }, toHandlers(dialogListeners.value)), {
            default: withCtx(() => [
              createBaseVNode("div", {
                ref: "wrapper-key",
                class: normalizeClass(["dialog__wrapper", { "dialog__wrapper--collapsed": isNavigationCollapsed.value }])
              }, [
                hasNavigation.value ? (openBlock(), createElementBlock("nav", {
                  key: 0,
                  class: normalizeClass(["dialog__navigation", _ctx.navigationClasses]),
                  "aria-label": navigationAriaLabelAttr.value,
                  "aria-labelledby": navigationAriaLabelledbyAttr.value
                }, [
                  renderSlot(_ctx.$slots, "navigation", { isCollapsed: isNavigationCollapsed.value }, void 0, true)
                ], 10, _hoisted_2$v)) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: normalizeClass(["dialog__content", _ctx.contentClasses])
                }, [
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    createBaseVNode("p", _hoisted_3$p, toDisplayString(_ctx.message), 1)
                  ], true)
                ], 2)
              ], 2),
              createBaseVNode("div", _hoisted_4$k, [
                renderSlot(_ctx.$slots, "actions", {}, () => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.buttons, (button, idx) => {
                    return openBlock(), createBlock(unref(_sfc_main$v), mergeProps({ key: idx }, { ref_for: true }, button, {
                      onClick: (_, result) => handleButtonClose(button, result)
                    }), null, 16, ["onClick"]);
                  }), 128))
                ], true)
              ])
            ]),
            _: 3
          }, 16, ["class"]))
        ]),
        _: 3
      }, 16)) : createCommentVNode("", true);
    };
  }
});
const NcDialog = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["__scopeId", "data-v-5392f82b"]]);
const _sfc_main$t = {
  name: "NcAppNavigationList"
};
const _hoisted_1$w = { class: "app-navigation-list" };
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", _hoisted_1$w, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ]);
}
const NcAppNavigationList = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$m], ["__scopeId", "data-v-57437e4a"]]);
register();
const _hoisted_1$1$3 = { class: "app-navigation-toggle-wrapper" };
const _sfc_main$1$4 = /* @__PURE__ */ defineComponent({
  __name: "NcAppNavigationToggle",
  props: {
    "open": { type: Boolean, ...{ required: true } },
    "openModifiers": {}
  },
  emits: ["update:open"],
  setup(__props) {
    const open = useModel(__props, "open");
    const title = computed(() => open.value ? t("Close navigation") : t("Open navigation"));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1$3, [
        createVNode(unref(NcButton), {
          class: "app-navigation-toggle",
          "aria-controls": "app-navigation-vue",
          "aria-expanded": open.value ? "true" : "false",
          "aria-label": title.value,
          title: title.value,
          variant: "tertiary",
          onClick: _cache[0] || (_cache[0] = ($event) => open.value = !open.value)
        }, {
          icon: withCtx(() => [
            createVNode(NcIconSvgWrapper, {
              path: open.value ? unref(mdiMenuOpen) : unref(mdiMenu)
            }, null, 8, ["path"])
          ]),
          _: 1
        }, 8, ["aria-expanded", "aria-label", "title"])
      ]);
    };
  }
});
const NcAppNavigationToggle = /* @__PURE__ */ _export_sfc(_sfc_main$1$4, [["__scopeId", "data-v-e17a2190"]]);
const _hoisted_1$v = ["aria-hidden", "aria-label", "aria-labelledby", "inert"];
const _hoisted_2$u = { class: "app-navigation__search" };
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "NcAppNavigation",
  props: {
    ariaLabel: {},
    ariaLabelledby: {}
  },
  setup(__props) {
    let focusTrap;
    const setHasAppNavigation = inject("NcContent:setHasAppNavigation", () => warn$1("NcAppNavigation is not mounted inside NcContent, this is probably an error."), false);
    const appNavigationContainer = useTemplateRef("app-navigation-container-key");
    const isMobile = useIsMobile();
    const open = ref(!isMobile.value);
    watch(isMobile, () => {
      open.value = !isMobile.value;
    });
    watch(open, () => {
      toggleFocusTrap();
    });
    onMounted(() => {
      setHasAppNavigation(true);
      subscribe("toggle-navigation", toggleNavigationByEventBus);
      emit("navigation-toggled", {
        open: open.value
      });
      focusTrap = createFocusTrap(appNavigationContainer.value, {
        allowOutsideClick: true,
        fallbackFocus: appNavigationContainer.value,
        trapStack: getTrapStack(),
        escapeDeactivates: false
      });
      toggleFocusTrap();
    });
    onUnmounted(() => {
      setHasAppNavigation(false);
      unsubscribe("toggle-navigation", toggleNavigationByEventBus);
      focusTrap.deactivate();
    });
    function toggleNavigation(state) {
      if (open.value === state) {
        emit("navigation-toggled", {
          open: open.value
        });
        return;
      }
      open.value = state === void 0 ? !open.value : state;
      const bodyStyles = getComputedStyle(document.body);
      const animationLength = parseInt(bodyStyles.getPropertyValue("--animation-quick")) || 100;
      setTimeout(() => {
        emit("navigation-toggled", {
          open: open.value
        });
      }, 1.5 * animationLength);
    }
    function toggleNavigationByEventBus({ open: open2 }) {
      return toggleNavigation(open2);
    }
    function toggleFocusTrap() {
      if (isMobile.value && open.value) {
        focusTrap.activate();
      } else {
        focusTrap.deactivate();
      }
    }
    function handleEsc() {
      if (isMobile.value) {
        toggleNavigation(false);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref: "app-navigation-container-key",
        class: normalizeClass(["app-navigation", { "app-navigation--closed": !open.value }])
      }, [
        createBaseVNode("nav", {
          id: "app-navigation-vue",
          "aria-hidden": open.value ? "false" : "true",
          "aria-label": _ctx.ariaLabel || void 0,
          "aria-labelledby": _ctx.ariaLabelledby || void 0,
          class: "app-navigation__content",
          inert: !open.value || void 0,
          onKeydown: withKeys(handleEsc, ["esc"])
        }, [
          createBaseVNode("div", _hoisted_2$u, [
            renderSlot(_ctx.$slots, "search", {}, void 0, true)
          ]),
          createBaseVNode("div", {
            class: normalizeClass(["app-navigation__body", { "app-navigation__body--no-list": !_ctx.$slots.list }])
          }, [
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ], 2),
          _ctx.$slots.list ? (openBlock(), createBlock(unref(NcAppNavigationList), {
            key: 0,
            class: "app-navigation__list"
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "list", {}, void 0, true)
            ]),
            _: 3
          })) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "footer", {}, void 0, true)
        ], 40, _hoisted_1$v),
        createVNode(NcAppNavigationToggle, {
          open: open.value,
          "onUpdate:open": toggleNavigation
        }, null, 8, ["open"])
      ], 2);
    };
  }
});
const NcAppNavigation = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["__scopeId", "data-v-0d73a3a1"]]);
const _sfc_main$r = {
  name: "ChevronUpIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$u = ["aria-hidden", "aria-label"];
const _hoisted_2$t = ["fill", "width", "height"];
const _hoisted_3$o = { d: "M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z" };
const _hoisted_4$j = { key: 0 };
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon chevron-up-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$o, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$j, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$t))
  ], 16, _hoisted_1$u);
}
const ChevronUp = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$l]]);
const _sfc_main$q = {
  name: "ArrowRightIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$t = ["aria-hidden", "aria-label"];
const _hoisted_2$s = ["fill", "width", "height"];
const _hoisted_3$n = { d: "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z" };
const _hoisted_4$i = { key: 0 };
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon arrow-right-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$n, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$i, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$s))
  ], 16, _hoisted_1$t);
}
const IconArrowRight = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$k]]);
register(t13);
const _sfc_main$p = {
  name: "NcInputConfirmCancel",
  components: {
    IconArrowRight,
    IconClose,
    NcButton
  },
  props: {
    /**
     * If this element is used on a primary element set to true for primary styling.
     */
    primary: {
      default: false,
      type: Boolean
    },
    placeholder: {
      default: "",
      type: String
    },
    modelValue: {
      default: "",
      type: String
    }
  },
  emits: [
    "cancel",
    "confirm",
    "update:modelValue"
  ],
  data() {
    return {
      labelConfirm: t("Confirm changes"),
      labelCancel: t("Cancel changes")
    };
  },
  computed: {
    valueModel: {
      get() {
        return this.modelValue;
      },
      set(newValue) {
        this.$emit("update:modelValue", newValue);
      }
    }
  },
  methods: {
    confirm() {
      this.$emit("confirm");
    },
    cancel() {
      this.$emit("cancel");
    },
    focusInput() {
      this.$refs.input.focus();
    }
  }
};
const _hoisted_1$s = { class: "app-navigation-input-confirm" };
const _hoisted_2$r = ["placeholder"];
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconArrowRight = resolveComponent("IconArrowRight");
  const _component_NcButton = resolveComponent("NcButton");
  const _component_IconClose = resolveComponent("IconClose");
  return openBlock(), createElementBlock("div", _hoisted_1$s, [
    createBaseVNode("form", {
      onSubmit: _cache[1] || (_cache[1] = withModifiers((...args) => $options.confirm && $options.confirm(...args), ["prevent"])),
      onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.cancel && $options.cancel(...args), ["exact", "stop", "prevent"]), ["esc"])),
      onClick: _cache[3] || (_cache[3] = withModifiers(() => {
      }, ["stop", "prevent"]))
    }, [
      withDirectives(createBaseVNode("input", {
        ref: "input",
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.valueModel = $event),
        type: "text",
        class: "app-navigation-input-confirm__input",
        placeholder: $props.placeholder
      }, null, 8, _hoisted_2$r), [
        [vModelText, $options.valueModel]
      ]),
      createVNode(_component_NcButton, {
        "aria-label": $data.labelConfirm,
        type: "submit",
        variant: "primary",
        onClick: withModifiers($options.confirm, ["stop", "prevent"])
      }, {
        icon: withCtx(() => [
          createVNode(_component_IconArrowRight, { size: 20 })
        ]),
        _: 1
      }, 8, ["aria-label", "onClick"]),
      createVNode(_component_NcButton, {
        "aria-label": $data.labelCancel,
        type: "reset",
        variant: $props.primary ? "primary" : "tertiary",
        onClick: withModifiers($options.cancel, ["stop", "prevent"])
      }, {
        icon: withCtx(() => [
          createVNode(_component_IconClose, { size: 20 })
        ]),
        _: 1
      }, 8, ["aria-label", "variant", "onClick"])
    ], 32)
  ]);
}
const NcInputConfirmCancel = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$j], ["__scopeId", "data-v-71f6ed5a"]]);
const _sfc_main$o = defineComponent({
  name: "NcVNodes",
  props: {
    /**
     * The vnodes to render
     */
    vnodes: {
      type: [Array, Object],
      default: null
    }
  },
  /**
   * The render function to display the component
   */
  render() {
    return this.vnodes || this.$slots?.default?.({});
  }
});
register(t21, t47);
const _sfc_main$3$2 = {
  name: "PencilIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$2$2 = ["aria-hidden", "aria-label"];
const _hoisted_2$2$2 = ["fill", "width", "height"];
const _hoisted_3$2$2 = { d: "M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z" };
const _hoisted_4$2$2 = { key: 0 };
function _sfc_render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon pencil-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$2$2, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$2$2, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$2$2))
  ], 16, _hoisted_1$2$2);
}
const Pencil = /* @__PURE__ */ _export_sfc(_sfc_main$3$2, [["render", _sfc_render$3$1]]);
const _sfc_main$2$2 = {
  name: "UndoIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$1$2 = ["aria-hidden", "aria-label"];
const _hoisted_2$1$2 = ["fill", "width", "height"];
const _hoisted_3$1$2 = { d: "M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z" };
const _hoisted_4$1$2 = { key: 0 };
function _sfc_render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon undo-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$1$2, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$1$2, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$1$2))
  ], 16, _hoisted_1$1$2);
}
const Undo = /* @__PURE__ */ _export_sfc(_sfc_main$2$2, [["render", _sfc_render$2$1]]);
register(t20);
const _sfc_main$1$3 = {
  name: "NcAppNavigationIconCollapsible",
  components: {
    NcButton,
    ChevronDown,
    ChevronUp
  },
  props: {
    open: {
      type: Boolean,
      default: true
    }
  },
  emits: ["click"],
  computed: {
    labelButton() {
      return this.open ? t("Collapse menu") : t("Open menu");
    }
  },
  methods: {
    onClick(e2) {
      this.$emit("click", e2);
    }
  }
};
function _sfc_render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChevronUp = resolveComponent("ChevronUp");
  const _component_ChevronDown = resolveComponent("ChevronDown");
  const _component_NcButton = resolveComponent("NcButton");
  return openBlock(), createBlock(_component_NcButton, {
    class: normalizeClass(["icon-collapse", { "icon-collapse--open": $props.open }]),
    "aria-label": $options.labelButton,
    variant: "tertiary",
    onClick: $options.onClick
  }, {
    icon: withCtx(() => [
      $props.open ? (openBlock(), createBlock(_component_ChevronUp, {
        key: 0,
        size: 20
      })) : (openBlock(), createBlock(_component_ChevronDown, {
        key: 1,
        size: 20
      }))
    ]),
    _: 1
  }, 8, ["class", "aria-label", "onClick"]);
}
const NcAppNavigationIconCollapsible = /* @__PURE__ */ _export_sfc(_sfc_main$1$3, [["render", _sfc_render$1$2], ["__scopeId", "data-v-a21d21e6"]]);
const _sfc_main$n = {
  name: "NcAppNavigationItem",
  components: {
    NcActions,
    NcActionButton,
    NcAppNavigationIconCollapsible,
    NcInputConfirmCancel,
    NcLoadingIcon,
    NcVNodes: _sfc_main$o,
    Pencil,
    Undo
  },
  props: {
    /**
     * If you are not using vue-router you can use the property to set this item as the active navigation entry.
     * When using vue-router and the `to` property this is set automatically.
     */
    active: {
      type: Boolean,
      default: false
    },
    /**
     * The main text content of the entry.
     */
    name: {
      type: String,
      required: true
    },
    /**
     * The title attribute of the element.
     */
    title: {
      type: String,
      default: null
    },
    /**
     * id attribute of the list item element
     */
    id: {
      type: String,
      default: () => createElementId(),
      validator: (id) => id.trim() !== ""
    },
    /**
     * Refers to the icon on the left, this prop accepts a class
     * like 'icon-category-enabled'.
     */
    icon: {
      type: String,
      default: ""
    },
    /**
     * Displays a loading animated icon on the left of the element
     * instead of the icon.
     */
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * Passing in a route will make the root element of this
     * component a `<router-link />` that points to that route.
     * By leaving this blank, the root element will be a `<li>`.
     */
    to: {
      type: [String, Object],
      default: null
    },
    /**
     * A direct link. This will be used as the `href` attribute.
     * This will ignore any `to` prop being defined.
     */
    href: {
      type: String,
      default: null
    },
    /**
     * Gives the possibility to collapse the children elements into the
     * parent element (true) or expands the children elements (false).
     */
    allowCollapse: {
      type: Boolean,
      default: false
    },
    /**
     * Makes the name of the item editable by providing an `ActionButton`
     * component that toggles a form
     */
    editable: {
      type: Boolean,
      default: false
    },
    /**
     * Only for 'editable' items, sets label for the edit action button.
     */
    editLabel: {
      type: String,
      default: ""
    },
    /**
     * Only for items in 'editable' mode, sets the placeholder text for the editing form.
     */
    editPlaceholder: {
      type: String,
      default: ""
    },
    /**
     * Pins the item to the bottom left area, above the settings. Do not
     * place 'non-pinned' `AppnavigationItem` components below `pinned`
     * ones.
     */
    pinned: {
      type: Boolean,
      default: false
    },
    /**
     * Puts the item in the 'undo' state.
     */
    undo: {
      type: Boolean,
      default: false
    },
    /**
     * The navigation collapsible state (synced)
     */
    open: {
      type: Boolean,
      default: false
    },
    /**
     * The actions menu open state (synced)
     */
    menuOpen: {
      type: Boolean,
      default: false
    },
    /**
     * Force the actions to display in a three dot menu
     */
    forceMenu: {
      type: Boolean,
      default: false
    },
    /**
     * The action's menu default icon
     */
    menuIcon: {
      type: String,
      default: void 0
    },
    /**
     * The action's menu direction
     */
    menuPlacement: {
      type: String,
      default: "bottom"
    },
    /**
     * Entry aria details
     */
    ariaDescription: {
      type: String,
      default: null
    },
    /**
     * To be used only when the elements in the actions menu are very important
     */
    forceDisplayActions: {
      type: Boolean,
      default: false
    },
    /**
     * Number of action items outside the menu
     */
    inlineActions: {
      type: Number,
      default: 0
    }
  },
  emits: [
    "update:menuOpen",
    "update:open",
    "update:name",
    "click",
    "undo"
  ],
  setup() {
    return {
      isMobile: useIsMobile()
    };
  },
  data() {
    return {
      actionsBoundariesElement: void 0,
      editingValue: "",
      opened: this.open,
      // Collapsible state
      editingActive: false,
      /**
       * Tracks the open state of the actions menu
       */
      menuOpenLocalValue: false,
      focused: false
    };
  },
  computed: {
    isRouterLink() {
      return this.to && !this.href;
    },
    // Checks if the component is already a children of another
    // instance of AppNavigationItem
    canHaveChildren() {
      if (this.$parent.$options._componentTag === "AppNavigationItem") {
        return false;
      } else {
        return true;
      }
    },
    editButtonAriaLabel() {
      return this.editLabel ? this.editLabel : t("Edit item");
    },
    undoButtonAriaLabel() {
      return t("Undo changes");
    }
  },
  watch: {
    open(newVal) {
      this.opened = newVal;
    }
  },
  mounted() {
    this.actionsBoundariesElement = document.querySelector("#content-vue") || void 0;
  },
  methods: {
    // sync opened menu state with prop
    onMenuToggle(state) {
      this.$emit("update:menuOpen", state);
      this.menuOpenLocalValue = state;
    },
    // toggle the collapsible state
    toggleCollapse() {
      this.opened = !this.opened;
      this.$emit("update:open", this.opened);
    },
    /**
     * Handle link click
     *
     * @param {PointerEvent} event - Native click event
     * @param {Function} [navigate] - VueRouter link's navigate if any
     * @param {string} [routerLinkHref] - VueRouter link's href
     */
    onClick(event, navigate, routerLinkHref) {
      this.$emit("click", event);
      if (event.metaKey || event.altKey || event.ctrlKey || event.shiftKey) {
        return;
      }
      if (routerLinkHref) {
        navigate?.(event);
        event.preventDefault();
      }
    },
    // Edition methods
    handleEdit() {
      this.editingValue = this.name;
      this.editingActive = true;
      this.onMenuToggle(false);
      this.$nextTick(() => {
        this.$refs.editingInput.focusInput();
      });
    },
    cancelEditing() {
      this.editingActive = false;
    },
    handleEditingDone() {
      this.$emit("update:name", this.editingValue);
      this.editingValue = "";
      this.editingActive = false;
    },
    // Undo methods
    handleUndo() {
      this.$emit("undo");
    },
    /**
     * Show actions upon focus
     */
    handleFocus() {
      this.focused = true;
    },
    handleBlur() {
      this.focused = false;
    },
    /**
     * This method checks if the root element of the component is focused and
     * if that's the case it focuses the actions button if available
     *
     * @param {Event} e the keydown event
     */
    handleTab(e2) {
      if (!this.$refs.actions) {
        return;
      }
      if (this.focused) {
        e2.preventDefault();
        this.$refs.actions.$refs.triggerButton.$el.focus();
        this.focused = false;
      } else {
        this.$refs.actions.$refs.triggerButton.$el.blur();
      }
    },
    /**
     * Is this an external link
     *
     * @param {string} href The link to check
     * @return {boolean} Whether it is external or not
     */
    isExternal(href) {
      return href && href.match(/[a-z]+:\/\//i);
    }
  }
};
const _hoisted_1$r = ["id"];
const _hoisted_2$q = ["aria-current", "aria-description", "aria-expanded", "href", "target", "title", "onClick"];
const _hoisted_3$m = {
  key: 0,
  class: "editingContainer"
};
const _hoisted_4$h = {
  key: 1,
  class: "app-navigation-entry__deleted"
};
const _hoisted_5$4 = { class: "app-navigation-entry__deleted-description" };
const _hoisted_6$3 = {
  key: 0,
  class: "app-navigation-entry__counter-wrapper"
};
const _hoisted_7$3 = {
  key: 0,
  class: "app-navigation-entry__children"
};
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcLoadingIcon = resolveComponent("NcLoadingIcon");
  const _component_NcInputConfirmCancel = resolveComponent("NcInputConfirmCancel");
  const _component_Pencil = resolveComponent("Pencil");
  const _component_NcActionButton = resolveComponent("NcActionButton");
  const _component_Undo = resolveComponent("Undo");
  const _component_NcActions = resolveComponent("NcActions");
  const _component_NcAppNavigationIconCollapsible = resolveComponent("NcAppNavigationIconCollapsible");
  return openBlock(), createElementBlock("li", {
    id: $props.id,
    class: normalizeClass([{
      "app-navigation-entry--opened": $data.opened,
      "app-navigation-entry--pinned": $props.pinned,
      "app-navigation-entry--collapsible": $props.allowCollapse && !!_ctx.$slots.default
    }, "app-navigation-entry-wrapper"])
  }, [
    (openBlock(), createBlock(resolveDynamicComponent($options.isRouterLink ? "router-link" : "NcVNodes"), normalizeProps(guardReactiveProps({ ...$options.isRouterLink && { custom: true, to: $props.to } })), {
      default: withCtx(({ href: routerLinkHref, navigate, isActive }) => [
        createBaseVNode("div", {
          class: normalizeClass([{
            "app-navigation-entry--editing": $data.editingActive,
            "app-navigation-entry--deleted": $props.undo,
            "active": isActive && $props.to || $props.active
          }, "app-navigation-entry"])
        }, [
          !$props.undo ? (openBlock(), createElementBlock("a", {
            key: 0,
            class: "app-navigation-entry-link",
            "aria-current": $props.active || isActive && $props.to ? "page" : void 0,
            "aria-description": $props.ariaDescription,
            "aria-expanded": !!_ctx.$slots.default ? $data.opened.toString() : void 0,
            href: $props.href || routerLinkHref || "#",
            target: $options.isExternal($props.href) ? "_blank" : void 0,
            title: $props.title || $props.name,
            onBlur: _cache[1] || (_cache[1] = (...args) => $options.handleBlur && $options.handleBlur(...args)),
            onClick: ($event) => $options.onClick($event, navigate, routerLinkHref),
            onFocus: _cache[2] || (_cache[2] = (...args) => $options.handleFocus && $options.handleFocus(...args)),
            onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.handleTab && $options.handleTab(...args), ["exact"]), ["tab"]))
          }, [
            createBaseVNode("div", {
              class: normalizeClass([{ [$props.icon]: $props.icon }, "app-navigation-entry-icon"])
            }, [
              $props.loading ? (openBlock(), createBlock(_component_NcLoadingIcon, { key: 0 })) : renderSlot(_ctx.$slots, "icon", {
                key: 1,
                active: $props.active || $props.to && isActive
              }, void 0, true)
            ], 2),
            createBaseVNode("span", {
              class: normalizeClass(["app-navigation-entry__name", { "hidden-visually": $data.editingActive }])
            }, toDisplayString($props.name), 3),
            $data.editingActive ? (openBlock(), createElementBlock("div", _hoisted_3$m, [
              createVNode(_component_NcInputConfirmCancel, {
                ref: "editingInput",
                modelValue: $data.editingValue,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.editingValue = $event),
                placeholder: $props.editPlaceholder !== "" ? $props.editPlaceholder : $props.name,
                primary: isActive && $props.to || $props.active,
                onCancel: $options.cancelEditing,
                onConfirm: $options.handleEditingDone
              }, null, 8, ["modelValue", "placeholder", "primary", "onCancel", "onConfirm"])
            ])) : createCommentVNode("", true)
          ], 40, _hoisted_2$q)) : createCommentVNode("", true),
          $props.undo ? (openBlock(), createElementBlock("div", _hoisted_4$h, [
            createBaseVNode("div", _hoisted_5$4, toDisplayString($props.name), 1)
          ])) : createCommentVNode("", true),
          (!!_ctx.$slots.actions || !!_ctx.$slots.counter || $props.editable || $props.undo) && !$data.editingActive ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass(["app-navigation-entry__utils", { "app-navigation-entry__utils--display-actions": $props.forceDisplayActions || $data.menuOpenLocalValue || $props.menuOpen }])
          }, [
            !!_ctx.$slots.counter ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
              renderSlot(_ctx.$slots, "counter", {}, void 0, true)
            ])) : createCommentVNode("", true),
            !!_ctx.$slots.actions || $props.editable && !$data.editingActive || $props.undo ? (openBlock(), createBlock(_component_NcActions, {
              key: 1,
              ref: "actions",
              inline: $props.inlineActions,
              class: "app-navigation-entry__actions",
              container: "#app-navigation-vue",
              "boundaries-element": $data.actionsBoundariesElement,
              placement: $props.menuPlacement,
              open: $props.menuOpen,
              "force-menu": $props.forceMenu,
              "default-icon": $props.menuIcon,
              variant: isActive && $props.to || $props.active ? "primary" : null,
              "onUpdate:open": $options.onMenuToggle
            }, {
              icon: withCtx(() => [
                renderSlot(_ctx.$slots, "menu-icon", {}, void 0, true)
              ]),
              default: withCtx(() => [
                $props.editable && !$data.editingActive ? (openBlock(), createBlock(_component_NcActionButton, {
                  key: 0,
                  "aria-label": $options.editButtonAriaLabel,
                  onClick: $options.handleEdit
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_Pencil, { size: 20 })
                  ]),
                  default: withCtx(() => [
                    createTextVNode(" " + toDisplayString($props.editLabel), 1)
                  ]),
                  _: 1
                }, 8, ["aria-label", "onClick"])) : createCommentVNode("", true),
                $props.undo ? (openBlock(), createBlock(_component_NcActionButton, {
                  key: 1,
                  "aria-label": $options.undoButtonAriaLabel,
                  onClick: $options.handleUndo
                }, {
                  icon: withCtx(() => [
                    createVNode(_component_Undo, { size: 20 })
                  ]),
                  _: 1
                }, 8, ["aria-label", "onClick"])) : createCommentVNode("", true),
                renderSlot(_ctx.$slots, "actions", {}, void 0, true)
              ]),
              _: 2
            }, 1032, ["inline", "boundaries-element", "placement", "open", "force-menu", "default-icon", "variant", "onUpdate:open"])) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true),
          $props.allowCollapse && !!_ctx.$slots.default ? (openBlock(), createBlock(_component_NcAppNavigationIconCollapsible, {
            key: 3,
            open: $data.opened,
            onClick: withModifiers($options.toggleCollapse, ["prevent", "stop"])
          }, null, 8, ["open", "onClick"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "extra", {}, void 0, true)
        ], 2)
      ]),
      _: 3
    }, 16)),
    $options.canHaveChildren && !!_ctx.$slots.default ? (openBlock(), createElementBlock("ul", _hoisted_7$3, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ])) : createCommentVNode("", true)
  ], 10, _hoisted_1$r);
}
const NcAppNavigationItem = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$i], ["__scopeId", "data-v-7c1c910e"]]);
const _sfc_main$m = {
  name: "CheckIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$q = ["aria-hidden", "aria-label"];
const _hoisted_2$p = ["fill", "width", "height"];
const _hoisted_3$l = { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" };
const _hoisted_4$g = { key: 0 };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon check-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$l, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$g,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$p))
  ], 16, _hoisted_1$q);
}
const CheckIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["render", _sfc_render$h], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Check.vue"]]);
register();
const _hoisted_1$p = ["for"];
const _hoisted_2$o = ["id", "type", "value", "min", "max"];
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  ...{ inheritAttrs: false },
  __name: "NcDateTimePickerNative",
  props: /* @__PURE__ */ mergeModels({
    class: { default: void 0 },
    id: { default: () => createElementId() },
    inputClass: { default: "" },
    type: { default: "date" },
    label: { default: () => t("Please choose a date") },
    min: { default: null },
    max: { default: null },
    hideLabel: { type: Boolean }
  }, {
    "modelValue": { default: null },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const props = __props;
    const modelValue = useModel(__props, "modelValue");
    const formattedValue = computed(() => modelValue.value ? formatValue(modelValue.value) : "");
    const formattedMax = computed(() => props.max ? formatValue(props.max) : void 0);
    const formattedMin = computed(() => props.min ? formatValue(props.min) : void 0);
    function getReadableDate(value) {
      const yyyy = value.getFullYear().toString().padStart(4, "0");
      const MM = (value.getMonth() + 1).toString().padStart(2, "0");
      const dd = value.getDate().toString().padStart(2, "0");
      const hh = value.getHours().toString().padStart(2, "0");
      const mm = value.getMinutes().toString().padStart(2, "0");
      return { yyyy, MM, dd, hh, mm };
    }
    function formatValue(value) {
      const { yyyy, MM, dd, hh, mm } = getReadableDate(value);
      if (props.type === "datetime-local") {
        return `${yyyy}-${MM}-${dd}T${hh}:${mm}`;
      } else if (props.type === "date") {
        return `${yyyy}-${MM}-${dd}`;
      } else if (props.type === "month") {
        return `${yyyy}-${MM}`;
      } else if (props.type === "time") {
        return `${hh}:${mm}`;
      } else if (props.type === "week") {
        const startDate = new Date(Number.parseInt(yyyy), 0, 1);
        const daysSinceBeginningOfYear = Math.floor((value.getTime() - startDate.getTime()) / (24 * 60 * 60 * 1e3));
        const weekNumber = Math.ceil(daysSinceBeginningOfYear / 7);
        return `${yyyy}-W${weekNumber}`;
      }
      return "";
    }
    function onInput(event) {
      const input = event.target;
      if (!input || isNaN(input.valueAsNumber)) {
        modelValue.value = null;
      } else if (props.type === "time") {
        const time = input.value;
        const { yyyy, MM, dd } = getReadableDate(modelValue.value || /* @__PURE__ */ new Date());
        modelValue.value = /* @__PURE__ */ new Date(`${yyyy}-${MM}-${dd}T${time}`);
      } else if (props.type === "month") {
        const MM = (new Date(input.value).getMonth() + 1).toString().padStart(2, "0");
        const { yyyy, dd, hh, mm } = getReadableDate(modelValue.value || /* @__PURE__ */ new Date());
        modelValue.value = /* @__PURE__ */ new Date(`${yyyy}-${MM}-${dd}T${hh}:${mm}`);
      } else {
        const timezoneOffsetSeconds = new Date(input.valueAsNumber).getTimezoneOffset() * 1e3 * 60;
        const inputDateWithTimezone = input.valueAsNumber + timezoneOffsetSeconds;
        modelValue.value = new Date(inputDateWithTimezone);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["native-datetime-picker", _ctx.$props.class])
      }, [
        createBaseVNode("label", {
          class: normalizeClass(["native-datetime-picker__label", { "hidden-visually": _ctx.hideLabel }]),
          for: _ctx.id
        }, toDisplayString(_ctx.label), 11, _hoisted_1$p),
        createBaseVNode("input", mergeProps({
          id: _ctx.id,
          class: ["native-datetime-picker__input", _ctx.inputClass],
          type: _ctx.type,
          value: formattedValue.value,
          min: formattedMin.value,
          max: formattedMax.value
        }, _ctx.$attrs, { onInput }), null, 16, _hoisted_2$o)
      ], 2);
    };
  }
});
const NcDateTimePickerNative = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-f356c0a6"]]);
const _sfc_main$k = {
  name: "ChevronLeftIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$o = ["aria-hidden", "aria-label"];
const _hoisted_2$n = ["fill", "width", "height"];
const _hoisted_3$k = { d: "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z" };
const _hoisted_4$f = { key: 0 };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon chevron-left-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$k, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$f,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$n))
  ], 16, _hoisted_1$o);
}
const ChevronLeftIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["render", _sfc_render$g], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/ChevronLeft.vue"]]);
const _sfc_main$j = {
  name: "ChevronRightIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$n = ["aria-hidden", "aria-label"];
const _hoisted_2$m = ["fill", "width", "height"];
const _hoisted_3$j = { d: "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z" };
const _hoisted_4$e = { key: 0 };
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon chevron-right-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$j, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$e,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$m))
  ], 16, _hoisted_1$n);
}
const ChevronRightIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["render", _sfc_render$f], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/ChevronRight.vue"]]);
const _sfc_main$i = {
  name: "PlusIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$m = ["aria-hidden", "aria-label"];
const _hoisted_2$l = ["fill", "width", "height"];
const _hoisted_3$i = { d: "M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" };
const _hoisted_4$d = { key: 0 };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon plus-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$i, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$d,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$l))
  ], 16, _hoisted_1$m);
}
const PlusIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["render", _sfc_render$e], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Plus.vue"]]);
const _sfc_main$h = {
  name: "MinusIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$l = ["aria-hidden", "aria-label"];
const _hoisted_2$k = ["fill", "width", "height"];
const _hoisted_3$h = { d: "M19,13H5V11H19V13Z" };
const _hoisted_4$c = { key: 0 };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon minus-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$h, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$c,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$k))
  ], 16, _hoisted_1$l);
}
const MinusIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["render", _sfc_render$d], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/Minus.vue"]]);
const _sfc_main$g = {
  name: "ArrowRightIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$k = ["aria-hidden", "aria-label"];
const _hoisted_2$j = ["fill", "width", "height"];
const _hoisted_3$g = { d: "M4,11V13H16L10.5,18.5L11.92,19.92L19.84,12L11.92,4.08L10.5,5.5L16,11H4Z" };
const _hoisted_4$b = { key: 0 };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon arrow-right-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$g, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$b,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$j))
  ], 16, _hoisted_1$k);
}
const ArrowRightIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["render", _sfc_render$c], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/ArrowRight.vue"]]);
const _sfc_main$f = {
  name: "AlertCircleOutlineIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$j = ["aria-hidden", "aria-label"];
const _hoisted_2$i = ["fill", "width", "height"];
const _hoisted_3$f = { d: "M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z" };
const _hoisted_4$a = { key: 0 };
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon alert-circle-outline-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$f, [
        $props.title ? (openBlock(), createElementBlock(
          "title",
          _hoisted_4$a,
          toDisplayString($props.title),
          1
          /* TEXT */
        )) : createCommentVNode("v-if", true)
      ])
    ], 8, _hoisted_2$i))
  ], 16, _hoisted_1$j);
}
const AlertIcon = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["render", _sfc_render$b], ["__file", "/var/www/nextcloud/apps/agora/node_modules/vue-material-design-icons/AlertCircleOutline.vue"]]);
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "Spinner",
  props: {
    title: { type: String, required: false, default: () => translate("agora", "Loading …") },
    fillColor: { type: String, required: false, default: "currentColor" },
    size: { type: Number, required: false, default: 24 }
  },
  setup(__props, { expose: __expose }) {
    __expose();
    const __returned__ = {};
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1$i = ["aria-hidden", "aria-label"];
const _hoisted_2$h = ["width", "height"];
const _hoisted_3$e = ["stroke"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    "aria-hidden": !$props.title,
    "aria-label": $props.title,
    class: "material-design-icon spinner",
    role: "img"
  }, [
    (openBlock(), createElementBlock("svg", {
      viewBox: "0 0 100 100",
      width: $props.size,
      height: $props.size
    }, [
      createBaseVNode("circle", {
        cx: "50",
        cy: "50",
        r: "45",
        stroke: $props.fillColor
      }, null, 8, _hoisted_3$e)
    ], 8, _hoisted_2$h))
  ], 8, _hoisted_1$i);
}
const Spinner = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["render", _sfc_render$a], ["__scopeId", "data-v-af5e33aa"], ["__file", "/var/www/nextcloud/apps/agora/src/components/AppIcons/modules/Spinner.vue"]]);
register();
const _sfc_main$d = defineComponent({
  name: "NcActionButtonGroup",
  inject: {
    isInSemanticMenu: {
      from: NC_ACTIONS_IS_SEMANTIC_MENU,
      default: false
    }
  },
  props: {
    /**
     * Optional text shown below the button group
     */
    name: {
      required: false,
      default: void 0,
      type: String
    }
  },
  setup() {
    return {
      labelId: createElementId()
    };
  },
  methods: {
    t
  }
});
const _hoisted_1$h = ["role"];
const _hoisted_2$g = ["id"];
const _hoisted_3$d = ["aria-labelledby"];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: "nc-button-group-base",
    role: _ctx.isInSemanticMenu && "presentation"
  }, [
    _ctx.name ? (openBlock(), createElementBlock("div", {
      key: 0,
      id: _ctx.labelId
    }, toDisplayString(_ctx.name), 9, _hoisted_2$g)) : createCommentVNode("", true),
    createBaseVNode("ul", {
      class: "nc-button-group-content",
      role: "group",
      "aria-labelledby": _ctx.name ? _ctx.labelId : void 0
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 8, _hoisted_3$d)
  ], 8, _hoisted_1$h);
}
const NcActionButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$9]]);
var debounce$1 = { exports: {} };
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce) return debounce$1.exports;
  hasRequiredDebounce = 1;
  function debounce2(function_, wait = 100, options = {}) {
    if (typeof function_ !== "function") {
      throw new TypeError(`Expected the first parameter to be a function, got \`${typeof function_}\`.`);
    }
    if (wait < 0) {
      throw new RangeError("`wait` must not be negative.");
    }
    const { immediate } = typeof options === "boolean" ? { immediate: options } : options;
    let storedContext;
    let storedArguments;
    let timeoutId;
    let timestamp;
    let result;
    function run2() {
      const callContext = storedContext;
      const callArguments = storedArguments;
      storedContext = void 0;
      storedArguments = void 0;
      result = function_.apply(callContext, callArguments);
      return result;
    }
    function later() {
      const last = Date.now() - timestamp;
      if (last < wait && last >= 0) {
        timeoutId = setTimeout(later, wait - last);
      } else {
        timeoutId = void 0;
        if (!immediate) {
          result = run2();
        }
      }
    }
    const debounced = function(...arguments_) {
      if (storedContext && this !== storedContext && Object.getPrototypeOf(this) === Object.getPrototypeOf(storedContext)) {
        throw new Error("Debounced method called with different contexts of the same prototype.");
      }
      storedContext = this;
      storedArguments = arguments_;
      timestamp = Date.now();
      const callNow = immediate && !timeoutId;
      if (!timeoutId) {
        timeoutId = setTimeout(later, wait);
      }
      if (callNow) {
        result = run2();
      }
      return result;
    };
    Object.defineProperty(debounced, "isPending", {
      get() {
        return timeoutId !== void 0;
      }
    });
    debounced.clear = () => {
      if (!timeoutId) {
        return;
      }
      clearTimeout(timeoutId);
      timeoutId = void 0;
    };
    debounced.flush = () => {
      if (!timeoutId) {
        return;
      }
      debounced.trigger();
    };
    debounced.trigger = () => {
      result = run2();
      debounced.clear();
    };
    return debounced;
  }
  debounce$1.exports.debounce = debounce2;
  debounce$1.exports = debounce2;
  return debounce$1.exports;
}
var debounceExports = /* @__PURE__ */ requireDebounce();
const debounce = /* @__PURE__ */ getDefaultExportFromCjs(debounceExports);
register();
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "NcPasswordField",
  props: /* @__PURE__ */ mergeModels({
    class: {},
    inputClass: { default: "" },
    id: {},
    label: {},
    labelOutside: { type: Boolean },
    placeholder: {},
    showTrailingButton: { type: Boolean, default: true },
    success: { type: Boolean },
    error: { type: Boolean },
    helperText: {},
    disabled: { type: Boolean },
    pill: { type: Boolean },
    checkPasswordStrength: { type: Boolean },
    minlength: { default: void 0 },
    asText: { type: Boolean }
  }, {
    "modelValue": { default: "" },
    "modelModifiers": {},
    "visible": { type: Boolean, ...{ default: false } },
    "visibleModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["valid", "invalid"], ["update:modelValue", "update:visible"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const modelValue = useModel(__props, "modelValue");
    watch(modelValue, debounce(checkPassword, 500));
    const visible = useModel(__props, "visible");
    const emit2 = __emit;
    __expose({
      focus,
      select
    });
    const { password_policy: passwordPolicy } = e();
    const inputField = useTemplateRef("input-field-key");
    const internalHelpMessage = ref("");
    const isValid2 = ref();
    const propsToForward = computed(() => {
      const all = { ...props };
      delete all.checkPasswordStrength;
      delete all.minlength;
      delete all.asText;
      delete all.error;
      delete all.helperText;
      delete all.inputClass;
      delete all.success;
      return all;
    });
    async function checkPassword() {
      if (!props.checkPasswordStrength) {
        return;
      }
      try {
        const { data } = await cancelableClient.post(v("apps/password_policy/api/v1/validate"), { password: modelValue.value });
        isValid2.value = data.ocs.data.passed;
        if (data.ocs.data.passed) {
          internalHelpMessage.value = t("Password is secure");
          emit2("valid");
          return;
        }
        internalHelpMessage.value = data.ocs.data.reason;
        emit2("invalid");
      } catch (error) {
        logger.error("Password policy returned an error", { error });
      }
    }
    function toggleVisibility() {
      visible.value = !visible.value;
    }
    function focus(options) {
      inputField.value.focus(options);
    }
    function select() {
      inputField.value.select();
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(NcInputField, mergeProps(propsToForward.value, {
        ref: "input-field-key",
        modelValue: modelValue.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => modelValue.value = $event),
        error: _ctx.error || isValid2.value === false,
        "helper-text": _ctx.helperText || internalHelpMessage.value,
        "input-class": [_ctx.inputClass, { "password-field__input--secure-text": !visible.value && _ctx.asText }],
        minlength: _ctx.minlength ?? unref(passwordPolicy)?.minLength ?? 0,
        success: _ctx.success || isValid2.value === true,
        "trailing-button-label": visible.value ? unref(t)("Hide password") : unref(t)("Show password"),
        type: visible.value || _ctx.asText ? "text" : "password",
        onTrailingButtonClick: toggleVisibility
      }), createSlots({
        "trailing-button-icon": withCtx(() => [
          createVNode(NcIconSvgWrapper, {
            path: visible.value ? unref(mdiEyeOff) : unref(mdiEye)
          }, null, 8, ["path"])
        ]),
        _: 2
      }, [
        !!_ctx.$slots.icon ? {
          name: "icon",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "icon", {}, void 0, true)
          ]),
          key: "0"
        } : void 0
      ]), 1040, ["modelValue", "error", "helper-text", "input-class", "minlength", "success", "trailing-button-label", "type"]);
    };
  }
});
const NcPasswordField = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-929be55a"]]);
register(t45);
const _sfc_main$b = {
  name: "NcActionInput",
  components: {
    NcDateTimePickerNative,
    NcPasswordField,
    NcTextField: _sfc_main$w,
    // Lazy load components with more than 50kB bundle size impact
    NcColorPicker: defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => index$1), true ? void 0 : void 0, import.meta.url)),
    NcDateTimePicker: defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => index), true ? void 0 : void 0, import.meta.url)),
    NcSelect: defineAsyncComponent(() => __vitePreload(() => Promise.resolve().then(() => index$2), true ? void 0 : void 0, import.meta.url))
  },
  mixins: [ActionGlobalMixin],
  inheritAttrs: false,
  props: {
    /**
     * id attribute of the checkbox element
     */
    id: {
      type: String,
      default: () => "action-" + createElementId(),
      validator: (id) => id.trim() !== ""
    },
    /**
     * id attribute of the text input element
     */
    inputId: {
      type: String,
      default: () => "action-input-" + createElementId(),
      validator: (id) => id.trim() !== ""
    },
    /**
     * Icon to show with the action, can be either a CSS class or an URL
     */
    icon: {
      type: String,
      default: ""
    },
    /**
     * type attribute of the input field
     */
    type: {
      type: String,
      default: "text",
      validator(type) {
        return [
          "date",
          "datetime-local",
          "month",
          "multiselect",
          "number",
          "password",
          "search",
          "tel",
          "text",
          "time",
          "url",
          "week",
          "color",
          "email"
        ].indexOf(type) > -1;
      }
    },
    /**
     * id attribute for the native date time picker
     */
    idNativeDateTimePicker: {
      type: String,
      default: "date-time-picker_id"
    },
    /**
     * Flag to use a native date time picker
     */
    isNativePicker: {
      type: Boolean,
      default: false
    },
    /**
     * The visible input label for accessibility purposes.
     */
    label: {
      type: String,
      default: null
    },
    /**
     * If you want to show the label just above the
     * input field, pass in `true` to this prop.
     */
    labelOutside: {
      type: Boolean,
      default: true
    },
    /**
     * value attribute of the input field
     */
    modelValue: {
      type: [String, Date, Number, Array],
      default: ""
    },
    /**
     * disabled state of the input field
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * aria-label attribute of the input field
     */
    ariaLabel: {
      type: String,
      default: ""
    },
    /**
     * Attribute forwarded to the underlying NcPasswordField and NcTextField
     */
    showTrailingButton: {
      type: Boolean,
      default: true
    },
    /**
     * Trailing button label forwarded to the underlying NcTextField
     */
    trailingButtonLabel: {
      type: String,
      default: t("Submit")
    },
    /**
     * CSS class to apply to the root element.
     */
    class: {
      type: [String, Array, Object],
      default: ""
    }
  },
  emits: [
    "submit",
    "update:modelValue"
  ],
  computed: {
    isIconUrl() {
      try {
        return new URL(this.icon);
      } catch (error) {
        return false;
      }
    },
    isMultiselectType() {
      return this.type === "multiselect";
    },
    nativeDatePickerType() {
      switch (this.type) {
        case "date":
        case "month":
        case "time":
        case "week":
        case "datetime-local":
          return this.type;
      }
      return false;
    },
    datePickerType() {
      if (!this.isNativePicker) {
        switch (this.type) {
          case "date":
          case "month":
          case "time":
            return this.type;
          case "datetime-local":
            return "datetime";
        }
      }
      return false;
    },
    /**
     * determines if the action is focusable
     *
     * @return {boolean} is the action focusable ?
     */
    isFocusable() {
      return !this.disabled;
    }
  },
  methods: {
    // closing datepicker popup on mouseleave = unfocus
    onLeave() {
      if (this.$refs.datetimepicker && this.$refs.datetimepicker.$refs.datepicker) {
        this.$refs.datetimepicker.$refs.datepicker.closePopup();
      }
    },
    onSubmit(event) {
      event.preventDefault();
      event.stopPropagation();
      if (!this.disabled) {
        this.$emit("submit", event);
      } else {
        return false;
      }
    },
    onUpdateModelValue(event) {
      this.$emit("update:modelValue", event);
    }
  }
};
const _hoisted_1$g = { class: "action-input__icon-wrapper" };
const _hoisted_2$f = ["disabled"];
const _hoisted_3$c = { class: "action-input__container" };
const _hoisted_4$9 = ["for"];
const _hoisted_5$3 = { class: "action-input__input-container" };
const _hoisted_6$2 = {
  key: 4,
  class: "action-input__container"
};
const _hoisted_7$2 = ["for"];
const _hoisted_8$2 = { class: "action-input__input-container" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcDateTimePicker = resolveComponent("NcDateTimePicker");
  const _component_NcDateTimePickerNative = resolveComponent("NcDateTimePickerNative");
  const _component_NcSelect = resolveComponent("NcSelect");
  const _component_NcPasswordField = resolveComponent("NcPasswordField");
  const _component_NcColorPicker = resolveComponent("NcColorPicker");
  const _component_NcTextField = resolveComponent("NcTextField");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(["action", [{ "action--disabled": $props.disabled }, _ctx.$props.class]])
  }, [
    createBaseVNode("span", {
      class: normalizeClass([{
        "action-input-picker--disabled": $props.disabled,
        "action-input--visible-label": $props.labelOutside && $props.label
      }, "action-input"]),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => $options.onLeave && $options.onLeave(...args))
    }, [
      createBaseVNode("span", _hoisted_1$g, [
        renderSlot(_ctx.$slots, "icon", {}, () => [
          createBaseVNode("span", {
            class: normalizeClass([[$options.isIconUrl ? "action-input__icon--url" : $props.icon], "action-input__icon"]),
            style: normalizeStyle({ backgroundImage: $options.isIconUrl ? `url(${$props.icon})` : null }),
            "aria-hidden": "true"
          }, null, 6)
        ], true)
      ]),
      createBaseVNode("form", {
        ref: "form",
        class: "action-input__form",
        disabled: $props.disabled,
        onSubmit: _cache[2] || (_cache[2] = withModifiers((...args) => $options.onSubmit && $options.onSubmit(...args), ["prevent"]))
      }, [
        createBaseVNode("div", _hoisted_3$c, [
          $props.label && $props.labelOutside ? (openBlock(), createElementBlock("label", {
            key: 0,
            class: normalizeClass(["action-input__text-label", { "action-input__text-label--hidden": !$props.labelOutside }]),
            for: $props.inputId
          }, toDisplayString($props.label), 11, _hoisted_4$9)) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_5$3, [
            $options.datePickerType ? (openBlock(), createBlock(_component_NcDateTimePicker, mergeProps({
              key: 0,
              ref: "datetimepicker",
              "model-value": $props.modelValue,
              style: { "z-index": "99999999999" },
              placeholder: _ctx.text,
              disabled: $props.disabled,
              type: $options.datePickerType,
              "input-class": ["mx-input", { focusable: $options.isFocusable }],
              class: "action-input__datetimepicker"
            }, _ctx.$attrs, { "onUpdate:modelValue": $options.onUpdateModelValue }), null, 16, ["model-value", "placeholder", "disabled", "type", "input-class", "onUpdate:modelValue"])) : $props.isNativePicker ? (openBlock(), createBlock(_component_NcDateTimePickerNative, mergeProps({
              key: 1,
              id: $props.idNativeDateTimePicker,
              "model-value": $props.modelValue,
              type: $options.nativeDatePickerType,
              "input-class": { focusable: $options.isFocusable },
              class: "action-input__datetimepicker"
            }, _ctx.$attrs, { "onUpdate:modelValue": $options.onUpdateModelValue }), null, 16, ["id", "model-value", "type", "input-class", "onUpdate:modelValue"])) : $options.isMultiselectType ? (openBlock(), createBlock(_component_NcSelect, mergeProps({
              key: 2,
              "model-value": $props.modelValue,
              placeholder: _ctx.text,
              disabled: $props.disabled,
              "append-to-body": false,
              "input-class": { focusable: $options.isFocusable },
              class: "action-input__multi"
            }, _ctx.$attrs, { "onUpdate:modelValue": $options.onUpdateModelValue }), null, 16, ["model-value", "placeholder", "disabled", "input-class", "onUpdate:modelValue"])) : $props.type === "password" ? (openBlock(), createBlock(_component_NcPasswordField, mergeProps({
              key: 3,
              id: $props.inputId,
              "model-value": $props.modelValue,
              label: $props.label,
              "label-outside": !$props.label || $props.labelOutside,
              placeholder: _ctx.text,
              disabled: $props.disabled,
              "input-class": { focusable: $options.isFocusable },
              "show-trailing-button": $props.showTrailingButton && !$props.disabled
            }, _ctx.$attrs, { "onUpdate:modelValue": $options.onUpdateModelValue }), null, 16, ["id", "model-value", "label", "label-outside", "placeholder", "disabled", "input-class", "show-trailing-button", "onUpdate:modelValue"])) : $props.type === "color" ? (openBlock(), createElementBlock("div", _hoisted_6$2, [
              $props.label && $props.type === "color" ? (openBlock(), createElementBlock("label", {
                key: 0,
                class: normalizeClass(["action-input__text-label", { "action-input__text-label--hidden": !$props.labelOutside }]),
                for: $props.inputId
              }, toDisplayString($props.label), 11, _hoisted_7$2)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_8$2, [
                createVNode(_component_NcColorPicker, mergeProps({
                  id: "inputId",
                  "model-value": $props.modelValue,
                  class: "colorpicker__trigger"
                }, _ctx.$attrs, {
                  "onUpdate:modelValue": $options.onUpdateModelValue,
                  onSubmit: _cache[0] || (_cache[0] = ($event) => _ctx.$refs.form.requestSubmit())
                }), {
                  default: withCtx(() => [
                    createBaseVNode("button", {
                      style: normalizeStyle({ "background-color": $props.modelValue }),
                      class: normalizeClass(["colorpicker__preview", { focusable: $options.isFocusable }])
                    }, null, 6)
                  ]),
                  _: 1
                }, 16, ["model-value", "onUpdate:modelValue"])
              ])
            ])) : (openBlock(), createBlock(_component_NcTextField, mergeProps({
              key: 5,
              id: $props.inputId,
              "model-value": $props.modelValue,
              label: $props.label,
              "label-outside": !$props.label || $props.labelOutside,
              placeholder: _ctx.text,
              disabled: $props.disabled,
              "input-class": { focusable: $options.isFocusable },
              type: $props.type,
              "trailing-button-icon": "arrowRight",
              "trailing-button-label": $props.trailingButtonLabel,
              "show-trailing-button": $props.showTrailingButton && !$props.disabled
            }, _ctx.$attrs, {
              onTrailingButtonClick: _cache[1] || (_cache[1] = ($event) => _ctx.$refs.form.requestSubmit()),
              "onUpdate:modelValue": $options.onUpdateModelValue
            }), null, 16, ["id", "model-value", "label", "label-outside", "placeholder", "disabled", "input-class", "type", "trailing-button-label", "show-trailing-button", "onUpdate:modelValue"]))
          ])
        ])
      ], 40, _hoisted_2$f)
    ], 34)
  ], 2);
}
const NcActionInput = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$8], ["__scopeId", "data-v-7607f0e9"]]);
const Pe = {
  __name: "splitpanes",
  props: {
    horizontal: { type: Boolean, default: false },
    pushOtherPanes: { type: Boolean, default: true },
    maximizePanes: { type: Boolean, default: true },
    // Maximize pane on splitter double click/tap.
    rtl: { type: Boolean, default: false },
    // Right to left direction.
    firstSplitter: { type: Boolean, default: false }
  },
  emits: [
    "ready",
    "resize",
    "resized",
    "pane-click",
    "pane-maximize",
    "pane-add",
    "pane-remove",
    "splitter-click",
    "splitter-dblclick"
  ],
  setup(D, { emit: h$1 }) {
    const y = h$1, u = D, E = useSlots(), l = ref([]), M = computed(() => l.value.reduce((e2, n) => (e2[~~n.id] = n) && e2, {})), m = computed(() => l.value.length), x = ref(null), S = ref(false), c = ref({
      mouseDown: false,
      dragging: false,
      activeSplitter: null,
      cursorOffset: 0
      // Cursor offset within the splitter.
    }), f = ref({
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }), _ = computed(() => ({
      [`splitpanes splitpanes--${u.horizontal ? "horizontal" : "vertical"}`]: true,
      "splitpanes--dragging": c.value.dragging
    })), R = () => {
      document.addEventListener("mousemove", r, { passive: false }), document.addEventListener("mouseup", P), "ontouchstart" in window && (document.addEventListener("touchmove", r, { passive: false }), document.addEventListener("touchend", P));
    }, O = () => {
      document.removeEventListener("mousemove", r, { passive: false }), document.removeEventListener("mouseup", P), "ontouchstart" in window && (document.removeEventListener("touchmove", r, { passive: false }), document.removeEventListener("touchend", P));
    }, b = (e2, n) => {
      const t2 = e2.target.closest(".splitpanes__splitter");
      if (t2) {
        const { left: i, top: a } = t2.getBoundingClientRect(), { clientX: s, clientY: o } = "ontouchstart" in window && e2.touches ? e2.touches[0] : e2;
        c.value.cursorOffset = u.horizontal ? o - a : s - i;
      }
      R(), c.value.mouseDown = true, c.value.activeSplitter = n;
    }, r = (e2) => {
      c.value.mouseDown && (e2.preventDefault(), c.value.dragging = true, requestAnimationFrame(() => {
        K2(I(e2)), d("resize", { event: e2 }, true);
      }));
    }, P = (e2) => {
      c.value.dragging && (window.getSelection().removeAllRanges(), d("resized", { event: e2 }, true)), c.value.mouseDown = false, c.value.activeSplitter = null, setTimeout(() => {
        c.value.dragging = false, O();
      }, 100);
    }, A = (e2, n) => {
      "ontouchstart" in window && (e2.preventDefault(), f.value.splitter === n ? (clearTimeout(f.value.timeoutId), f.value.timeoutId = null, U(e2, n), f.value.splitter = null) : (f.value.splitter = n, f.value.timeoutId = setTimeout(() => f.value.splitter = null, 500))), c.value.dragging || d("splitter-click", { event: e2, index: n }, true);
    }, U = (e2, n) => {
      if (d("splitter-dblclick", { event: e2, index: n }, true), u.maximizePanes) {
        let t2 = 0;
        l.value = l.value.map((i, a) => (i.size = a === n ? i.max : i.min, a !== n && (t2 += i.min), i)), l.value[n].size -= t2, d("pane-maximize", { event: e2, index: n, pane: l.value[n] }), d("resized", { event: e2, index: n }, true);
      }
    }, W = (e2, n) => {
      d("pane-click", {
        event: e2,
        index: M.value[n].index,
        pane: M.value[n]
      });
    }, I = (e2) => {
      const n = x.value.getBoundingClientRect(), { clientX: t2, clientY: i } = "ontouchstart" in window && e2.touches ? e2.touches[0] : e2;
      return {
        x: t2 - (u.horizontal ? 0 : c.value.cursorOffset) - n.left,
        y: i - (u.horizontal ? c.value.cursorOffset : 0) - n.top
      };
    }, J = (e2) => {
      e2 = e2[u.horizontal ? "y" : "x"];
      const n = x.value[u.horizontal ? "clientHeight" : "clientWidth"];
      return u.rtl && !u.horizontal && (e2 = n - e2), e2 * 100 / n;
    }, K2 = (e2) => {
      const n = c.value.activeSplitter;
      let t2 = {
        prevPanesSize: $(n),
        nextPanesSize: N(n),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const i = 0 + (u.pushOtherPanes ? 0 : t2.prevPanesSize), a = 100 - (u.pushOtherPanes ? 0 : t2.nextPanesSize), s = Math.max(Math.min(J(e2), a), i);
      let o = [n, n + 1], v2 = l.value[o[0]] || null, p = l.value[o[1]] || null;
      const H = v2.max < 100 && s >= v2.max + t2.prevPanesSize, ue = p.max < 100 && s <= 100 - (p.max + N(n + 1));
      if (H || ue) {
        H ? (v2.size = v2.max, p.size = Math.max(100 - v2.max - t2.prevPanesSize - t2.nextPanesSize, 0)) : (v2.size = Math.max(100 - p.max - t2.prevPanesSize - N(n + 1), 0), p.size = p.max);
        return;
      }
      if (u.pushOtherPanes) {
        const j = Q(t2, s);
        if (!j) return;
        ({ sums: t2, panesToResize: o } = j), v2 = l.value[o[0]] || null, p = l.value[o[1]] || null;
      }
      v2 !== null && (v2.size = Math.min(Math.max(s - t2.prevPanesSize - t2.prevReachedMinPanes, v2.min), v2.max)), p !== null && (p.size = Math.min(Math.max(100 - s - t2.nextPanesSize - t2.nextReachedMinPanes, p.min), p.max));
    }, Q = (e2, n) => {
      const t2 = c.value.activeSplitter, i = [t2, t2 + 1];
      return n < e2.prevPanesSize + l.value[i[0]].min && (i[0] = V(t2).index, e2.prevReachedMinPanes = 0, i[0] < t2 && l.value.forEach((a, s) => {
        s > i[0] && s <= t2 && (a.size = a.min, e2.prevReachedMinPanes += a.min);
      }), e2.prevPanesSize = $(i[0]), i[0] === void 0) ? (e2.prevReachedMinPanes = 0, l.value[0].size = l.value[0].min, l.value.forEach((a, s) => {
        s > 0 && s <= t2 && (a.size = a.min, e2.prevReachedMinPanes += a.min);
      }), l.value[i[1]].size = 100 - e2.prevReachedMinPanes - l.value[0].min - e2.prevPanesSize - e2.nextPanesSize, null) : n > 100 - e2.nextPanesSize - l.value[i[1]].min && (i[1] = Z(t2).index, e2.nextReachedMinPanes = 0, i[1] > t2 + 1 && l.value.forEach((a, s) => {
        s > t2 && s < i[1] && (a.size = a.min, e2.nextReachedMinPanes += a.min);
      }), e2.nextPanesSize = N(i[1] - 1), i[1] === void 0) ? (e2.nextReachedMinPanes = 0, l.value.forEach((a, s) => {
        s < m.value - 1 && s >= t2 + 1 && (a.size = a.min, e2.nextReachedMinPanes += a.min);
      }), l.value[i[0]].size = 100 - e2.prevPanesSize - N(i[0] - 1), null) : { sums: e2, panesToResize: i };
    }, $ = (e2) => l.value.reduce((n, t2, i) => n + (i < e2 ? t2.size : 0), 0), N = (e2) => l.value.reduce((n, t2, i) => n + (i > e2 + 1 ? t2.size : 0), 0), V = (e2) => [...l.value].reverse().find((t2) => t2.index < e2 && t2.size > t2.min) || {}, Z = (e2) => l.value.find((t2) => t2.index > e2 + 1 && t2.size > t2.min) || {}, ee = () => {
      var n;
      const e2 = Array.from(((n = x.value) == null ? void 0 : n.children) || []);
      for (const t2 of e2) {
        const i = t2.classList.contains("splitpanes__pane"), a = t2.classList.contains("splitpanes__splitter");
        !i && !a && (t2.remove(), console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed."));
      }
    }, F = (e2, n, t2 = false) => {
      const i = e2 - 1, a = document.createElement("div");
      a.classList.add("splitpanes__splitter"), t2 || (a.onmousedown = (s) => b(s, i), typeof window < "u" && "ontouchstart" in window && (a.ontouchstart = (s) => b(s, i)), a.onclick = (s) => A(s, i + 1)), a.ondblclick = (s) => U(s, i + 1), n.parentNode.insertBefore(a, n);
    }, ne = (e2) => {
      e2.onmousedown = void 0, e2.onclick = void 0, e2.ondblclick = void 0, e2.remove();
    }, C = () => {
      var t2;
      const e2 = Array.from(((t2 = x.value) == null ? void 0 : t2.children) || []);
      for (const i of e2)
        i.className.includes("splitpanes__splitter") && ne(i);
      let n = 0;
      for (const i of e2)
        i.className.includes("splitpanes__pane") && (!n && u.firstSplitter ? F(n, i, true) : n && F(n, i), n++);
    }, ie = ({ uid: e2, ...n }) => {
      const t2 = M.value[e2];
      for (const [i, a] of Object.entries(n)) t2[i] = a;
    }, te = (e2) => {
      var t2;
      let n = -1;
      Array.from(((t2 = x.value) == null ? void 0 : t2.children) || []).some((i) => (i.className.includes("splitpanes__pane") && n++, i.isSameNode(e2.el))), l.value.splice(n, 0, { ...e2, index: n }), l.value.forEach((i, a) => i.index = a), S.value && nextTick(() => {
        C(), L({ addedPane: l.value[n] }), d("pane-add", { pane: l.value[n] });
      });
    }, ae = (e2) => {
      const n = l.value.findIndex((i) => i.id === e2);
      l.value[n].el = null;
      const t2 = l.value.splice(n, 1)[0];
      l.value.forEach((i, a) => i.index = a), nextTick(() => {
        C(), d("pane-remove", { pane: t2 }), L({ removedPane: { ...t2 } });
      });
    }, L = (e2 = {}) => {
      !e2.addedPane && !e2.removedPane ? le() : l.value.some((n) => n.givenSize !== null || n.min || n.max < 100) ? oe(e2) : se(), S.value && d("resized");
    }, se = () => {
      const e2 = 100 / m.value;
      let n = 0;
      const t2 = [], i = [];
      for (const a of l.value)
        a.size = Math.max(Math.min(e2, a.max), a.min), n -= a.size, a.size >= a.max && t2.push(a.id), a.size <= a.min && i.push(a.id);
      n > 0.1 && q(n, t2, i);
    }, le = () => {
      let e2 = 100;
      const n = [], t2 = [];
      let i = 0;
      for (const s of l.value)
        e2 -= s.size, s.givenSize !== null && i++, s.size >= s.max && n.push(s.id), s.size <= s.min && t2.push(s.id);
      let a = 100;
      if (e2 > 0.1) {
        for (const s of l.value)
          s.givenSize === null && (s.size = Math.max(Math.min(e2 / (m.value - i), s.max), s.min)), a -= s.size;
        a > 0.1 && q(a, n, t2);
      }
    }, oe = ({ addedPane: e2, removedPane: n } = {}) => {
      let t2 = 100 / m.value, i = 0;
      const a = [], s = [];
      ((e2 == null ? void 0 : e2.givenSize) ?? null) !== null && (t2 = (100 - e2.givenSize) / (m.value - 1));
      for (const o of l.value)
        i -= o.size, o.size >= o.max && a.push(o.id), o.size <= o.min && s.push(o.id);
      if (!(Math.abs(i) < 0.1)) {
        for (const o of l.value)
          (e2 == null ? void 0 : e2.givenSize) !== null && (e2 == null ? void 0 : e2.id) === o.id || (o.size = Math.max(Math.min(t2, o.max), o.min)), i -= o.size, o.size >= o.max && a.push(o.id), o.size <= o.min && s.push(o.id);
        i > 0.1 && q(i, a, s);
      }
    }, q = (e2, n, t2) => {
      let i;
      e2 > 0 ? i = e2 / (m.value - n.length) : i = e2 / (m.value - t2.length), l.value.forEach((a, s) => {
        if (e2 > 0 && !n.includes(a.id)) {
          const o = Math.max(Math.min(a.size + i, a.max), a.min), v2 = o - a.size;
          e2 -= v2, a.size = o;
        } else if (!t2.includes(a.id)) {
          const o = Math.max(Math.min(a.size + i, a.max), a.min), v2 = o - a.size;
          e2 -= v2, a.size = o;
        }
      }), Math.abs(e2) > 0.1 && nextTick(() => {
        S.value && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }, d = (e2, n = void 0, t2 = false) => {
      const i = (n == null ? void 0 : n.index) ?? c.value.activeSplitter ?? null;
      y(e2, {
        ...n,
        ...i !== null && { index: i },
        ...t2 && i !== null && {
          prevPane: l.value[i - (u.firstSplitter ? 1 : 0)],
          nextPane: l.value[i + (u.firstSplitter ? 0 : 1)]
        },
        panes: l.value.map((a) => ({ min: a.min, max: a.max, size: a.size }))
      });
    };
    watch(() => u.firstSplitter, () => C()), onMounted(() => {
      ee(), C(), L(), d("ready"), S.value = true;
    }), onBeforeUnmount(() => S.value = false);
    const re = () => {
      var e2;
      return h(
        "div",
        { ref: x, class: _.value },
        (e2 = E.default) == null ? void 0 : e2.call(E)
      );
    };
    return provide("panes", l), provide("indexedPanes", M), provide("horizontal", computed(() => u.horizontal)), provide("requestUpdate", ie), provide("onPaneAdd", te), provide("onPaneRemove", ae), provide("onPaneClick", W), (e2, n) => (openBlock(), createBlock(resolveDynamicComponent(re)));
  }
}, ge = {
  __name: "pane",
  props: {
    size: { type: [Number, String] },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  setup(D) {
    var b;
    const h2 = D, y = inject("requestUpdate"), u = inject("onPaneAdd"), E = inject("horizontal"), l = inject("onPaneRemove"), M = inject("onPaneClick"), m = (b = getCurrentInstance()) == null ? void 0 : b.uid, x = inject("indexedPanes"), S = computed(() => x.value[m]), c = ref(null), f = computed(() => {
      const r = isNaN(h2.size) || h2.size === void 0 ? 0 : parseFloat(h2.size);
      return Math.max(Math.min(r, R.value), _.value);
    }), _ = computed(() => {
      const r = parseFloat(h2.minSize);
      return isNaN(r) ? 0 : r;
    }), R = computed(() => {
      const r = parseFloat(h2.maxSize);
      return isNaN(r) ? 100 : r;
    }), O = computed(() => {
      var r;
      return `${E.value ? "height" : "width"}: ${(r = S.value) == null ? void 0 : r.size}%`;
    });
    return watch(() => f.value, (r) => y({ uid: m, size: r })), watch(() => _.value, (r) => y({ uid: m, min: r })), watch(() => R.value, (r) => y({ uid: m, max: r })), onMounted(() => {
      u({
        id: m,
        el: c.value,
        min: _.value,
        max: R.value,
        // The given size (useful to know the user intention).
        givenSize: h2.size === void 0 ? null : f.value,
        size: f.value
        // The computed current size at any time.
      });
    }), onBeforeUnmount(() => l(m)), (r, P) => (openBlock(), createElementBlock("div", {
      ref_key: "paneEl",
      ref: c,
      class: "splitpanes__pane",
      onClick: P[0] || (P[0] = (A) => unref(M)(A, r._.uid)),
      style: normalizeStyle(O.value)
    }, [
      renderSlot(r.$slots, "default")
    ], 4));
  }
};
register();
const _sfc_main$1$2 = /* @__PURE__ */ defineComponent({
  __name: "NcAppContentDetailsToggle",
  setup(__props) {
    const isMobile = useIsMobile();
    watch(isMobile, toggleAppNavigationButton, { immediate: true });
    onBeforeUnmount(() => {
      if (isMobile.value) {
        toggleAppNavigationButton(false);
      }
    });
    function toggleAppNavigationButton(hide = true) {
      const appNavigationToggle = document.querySelector(".app-navigation .app-navigation-toggle");
      if (appNavigationToggle) {
        appNavigationToggle.style.display = hide ? "none" : "";
        if (hide === true) {
          emit("toggle-navigation", { open: false });
        }
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(NcButton), {
        "aria-label": unref(t)("Go back to the list"),
        class: normalizeClass(["app-details-toggle", { "app-details-toggle--mobile": unref(isMobile) }]),
        title: unref(t)("Go back to the list"),
        variant: "tertiary"
      }, {
        icon: withCtx(() => [
          createVNode(unref(NcIconSvgWrapper), {
            directional: "",
            path: unref(mdiArrowRight)
          }, null, 8, ["path"])
        ]),
        _: 1
      }, 8, ["aria-label", "class", "title"]);
    };
  }
});
const NcAppContentDetailsToggle = /* @__PURE__ */ _export_sfc(_sfc_main$1$2, [["__scopeId", "data-v-a5fd2a54"]]);
let realAppName = "missing-app-name";
try {
  realAppName = appName;
} catch {
  logger.error("The `@nextcloud/vue` library was used without setting / replacing the `appName`.");
}
const APP_NAME = realAppName;
const browserStorage = distExports.getBuilder("nextcloud").persist().build();
const instanceName = e().theming?.name ?? "Nextcloud";
const activeApp = loadState("core", "active-app", APP_NAME);
const localizedAppName = loadState("core", "apps", []).find(({ id }) => id === activeApp)?.name ?? APP_NAME;
const _sfc_main$a = {
  name: "NcAppContent",
  components: {
    NcAppContentDetailsToggle,
    Pane: ge,
    Splitpanes: Pe
  },
  props: {
    /**
     * Allows to disable the control by swipe of the app navigation open state.
     */
    disableSwipe: {
      type: Boolean,
      default: false
    },
    /**
     * Allows you to set the default width of the resizable list in % on vertical-split
     * or respectively the default height on horizontal-split.
     *
     * Must be between `listMinWidth` and `listMaxWidth`.
     */
    listSize: {
      type: Number,
      default: 20
    },
    /**
     * Allows you to set the minimum width of the list column in % on vertical-split
     * or respectively the minimum height on horizontal-split.
     */
    listMinWidth: {
      type: Number,
      default: 15
    },
    /**
     * Allows you to set the maximum width of the list column in % on vertical-split
     * or respectively the maximum height on horizontal-split.
     */
    listMaxWidth: {
      type: Number,
      default: 40
    },
    /**
     * Specify the config key for the pane config sizes
     * Default is the global var appName if you use the webpack-vue-config
     */
    paneConfigKey: {
      type: String,
      default: ""
    },
    /**
     * When in mobile view, only the list or the details are shown.
     *
     * If you provide a list, you need to provide a variable
     * that will be set to true by the user when an element of
     * the list gets selected. The details will then show a back
     * arrow to return to the list that will update this prop to false.
     */
    showDetails: {
      type: Boolean,
      default: true
    },
    /**
     * Content layout used when there is a list together with content:
     * - `vertical-split` - a 2-column layout with list and default content separated vertically
     * - `no-split` - a single column layout; List is shown when `showDetails` is `false`, otherwise the default slot content is shown with a back button to return to the list.
     * - 'horizontal-split' - a 2-column layout with list and default content separated horizontally
     * On mobile screen `no-split` layout is forced.
     */
    layout: {
      type: String,
      default: "vertical-split",
      validator(value) {
        return ["no-split", "vertical-split", "horizontal-split"].includes(value);
      }
    },
    /**
     * Specify the `<h1>` page heading
     */
    pageHeading: {
      type: String,
      default: null
    },
    /**
     * Allow setting the page's `<title>`
     *
     * If a page heading is set it defaults to `{pageHeading} - {appName} - {instanceName}` e.g. `Favorites - Files - MyPersonalCloud`.
     * When the page heading and the app name is the same only one is used, e.g. `Files - Files - MyPersonalCloud` is shown as `Files - MyPersonalCloud`.
     * When setting the prop then the following format will be used: `{pageTitle} - {instanceName}`
     */
    pageTitle: {
      type: String,
      default: null
    }
  },
  emits: [
    "update:showDetails",
    "resizeList"
  ],
  setup() {
    return {
      isMobile: useIsMobile(),
      isRtl
    };
  },
  data() {
    return {
      contentHeight: 0,
      hasList: false,
      hasContent: false,
      swiping: {},
      listPaneSize: this.restorePaneConfig()
    };
  },
  computed: {
    paneConfigID() {
      if (this.paneConfigKey !== "") {
        return `pane-list-size-${this.paneConfigKey}`;
      }
      try {
        return `pane-list-size-${APP_NAME}`;
      } catch (e2) {
        logger.info("[NcAppContent]: falling back to global nextcloud pane config");
        return "pane-list-size-nextcloud";
      }
    },
    detailsPaneSize() {
      if (this.listPaneSize) {
        return 100 - this.listPaneSize;
      }
      return this.paneDefaults.details.size;
    },
    paneDefaults() {
      return {
        list: {
          size: this.listSize,
          min: this.listMinWidth,
          max: this.listMaxWidth
        },
        // set the inverse values of the details column
        // based on the provided (or default) values of the list column
        details: {
          size: 100 - this.listSize,
          min: 100 - this.listMaxWidth,
          max: 100 - this.listMinWidth
        }
      };
    },
    realPageTitle() {
      const entries = /* @__PURE__ */ new Set();
      if (this.pageTitle) {
        for (const part of this.pageTitle.split(" - ")) {
          entries.add(part);
        }
      } else if (this.pageHeading) {
        for (const part of this.pageHeading.split(" - ")) {
          entries.add(part);
        }
        if (entries.size > 0) {
          entries.add(localizedAppName);
        }
      } else {
        return null;
      }
      entries.add(instanceName);
      return [...entries.values()].join(" - ");
    }
  },
  watch: {
    realPageTitle: {
      immediate: true,
      handler() {
        if (this.realPageTitle !== null) {
          document.title = this.realPageTitle;
        }
      }
    }
  },
  updated() {
    this.checkSlots();
  },
  mounted() {
    if (!this.disableSwipe) {
      this.swiping = useSwipe(this.$el, {
        onSwipeEnd: this.handleSwipe
      });
    }
    this.checkSlots();
    this.restorePaneConfig();
  },
  methods: {
    /**
     * handle the swipe event
     *
     * @param {TouchEvent} e The touch event
     * @param {import('@vueuse/core').SwipeDirection} direction The swipe direction of the event
     */
    handleSwipe(e2, direction) {
      const minSwipeX = 70;
      const touchZone = 300;
      if (Math.abs(this.swiping.lengthX) > minSwipeX) {
        if (this.swiping.coordsStart.x < touchZone / 2 && direction === "right") {
          emit("toggle-navigation", {
            open: true
          });
        } else if (this.swiping.coordsStart.x < touchZone * 1.5 && direction === "left") {
          emit("toggle-navigation", {
            open: false
          });
        }
      }
    },
    handlePaneResize(event) {
      const listPaneSize = parseInt(event.panes[0].size, 10);
      browserStorage.setItem(this.paneConfigID, JSON.stringify(listPaneSize));
      this.listPaneSize = listPaneSize;
      this.$emit("resizeList", { size: listPaneSize });
      console.debug("AppContent pane config", listPaneSize);
    },
    // $slots is not reactive, we need to update this manually
    checkSlots() {
      this.hasList = !!this.$slots.list;
      this.hasContent = !!this.$slots.default;
    },
    // browserStorage is not reactive, we need to update this manually
    restorePaneConfig() {
      const listPaneSize = parseInt(browserStorage.getItem(this.paneConfigID), 10);
      if (!isNaN(listPaneSize) && listPaneSize !== this.listPaneSize) {
        console.debug("AppContent pane config", listPaneSize);
        this.listPaneSize = listPaneSize;
        return listPaneSize;
      }
    },
    /**
     * The user clicked the back arrow from the details view
     */
    hideDetails() {
      this.$emit("update:showDetails", false);
    }
  }
};
const _hoisted_1$f = {
  key: 0,
  class: "hidden-visually"
};
const _hoisted_2$e = {
  key: 1,
  class: "app-content-wrapper"
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcAppContentDetailsToggle = resolveComponent("NcAppContentDetailsToggle");
  const _component_Pane = resolveComponent("Pane");
  const _component_Splitpanes = resolveComponent("Splitpanes");
  return openBlock(), createElementBlock("main", {
    id: "app-content-vue",
    class: normalizeClass(["app-content no-snapper", { "app-content--has-list": $data.hasList }])
  }, [
    $props.pageHeading ? (openBlock(), createElementBlock("h1", _hoisted_1$f, toDisplayString($props.pageHeading), 1)) : createCommentVNode("", true),
    $data.hasList ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      $setup.isMobile || $props.layout === "no-split" ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["app-content-wrapper app-content-wrapper--no-split", {
          "app-content-wrapper--show-details": $props.showDetails,
          "app-content-wrapper--show-list": !$props.showDetails,
          "app-content-wrapper--mobile": $setup.isMobile
        }])
      }, [
        $props.showDetails ? (openBlock(), createBlock(_component_NcAppContentDetailsToggle, {
          key: 0,
          onClick: withModifiers($options.hideDetails, ["stop", "prevent"])
        }, null, 8, ["onClick"])) : createCommentVNode("", true),
        withDirectives(createBaseVNode("div", null, [
          renderSlot(_ctx.$slots, "list", {}, void 0, true)
        ], 512), [
          [vShow, !$props.showDetails]
        ]),
        $props.showDetails ? renderSlot(_ctx.$slots, "default", { key: 1 }, void 0, true) : createCommentVNode("", true)
      ], 2)) : $props.layout === "vertical-split" || $props.layout === "horizontal-split" ? (openBlock(), createElementBlock("div", _hoisted_2$e, [
        createVNode(_component_Splitpanes, {
          horizontal: $props.layout === "horizontal-split",
          class: normalizeClass(["default-theme", {
            "splitpanes--horizontal": $props.layout === "horizontal-split",
            "splitpanes--vertical": $props.layout === "vertical-split"
          }]),
          rtl: $setup.isRtl,
          onResized: $options.handlePaneResize
        }, {
          default: withCtx(() => [
            createVNode(_component_Pane, {
              class: "splitpanes__pane-list",
              size: $data.listPaneSize || $options.paneDefaults.list.size,
              "min-size": $options.paneDefaults.list.min,
              "max-size": $options.paneDefaults.list.max
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "list", {}, void 0, true)
              ]),
              _: 3
            }, 8, ["size", "min-size", "max-size"]),
            createVNode(_component_Pane, {
              class: "splitpanes__pane-details",
              size: $options.detailsPaneSize,
              "min-size": $options.paneDefaults.details.min,
              "max-size": $options.paneDefaults.details.max
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default", {}, void 0, true)
              ]),
              _: 3
            }, 8, ["size", "min-size", "max-size"])
          ]),
          _: 3
        }, 8, ["horizontal", "class", "rtl", "onResized"])
      ])) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    !$data.hasList ? renderSlot(_ctx.$slots, "default", { key: 2 }, void 0, true) : createCommentVNode("", true)
  ], 2);
}
const NcAppContent = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$7], ["__scopeId", "data-v-8d2eca70"]]);
({
  props: {
    /**
     * Any [NcActions](#/Components/NcActions?id=ncactions-1) prop
     */
    // Not an actual prop but needed to show in vue-styleguidist docs
    // eslint-disable-next-line
    ...NcActions.props
  }
});
register();
/* @__PURE__ */ defineComponent({
  __name: "NcAppNavigationSearch",
  props: /* @__PURE__ */ mergeModels({
    /**
     * Text used to label the search input
     */
    label: {
      type: String,
      default: t("Search…")
    },
    /**
     * Placeholder of the search input
     * By default the value of `label` is used.
     */
    placeholder: {
      type: String,
      default: null
    }
  }, {
    "modelValue": { default: "" },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const model = useModel(__props, "modelValue");
    const slots = useSlots();
    const inputElement = ref();
    const { focused: inputHasFocus } = useFocusWithin(inputElement);
    const transitionTimeout = Number.parseInt(window.getComputedStyle(window.document.body).getPropertyValue("--animation-quick")) || 100;
    const actionsContainer = useTemplateRef("actions-container-key");
    const hasActions = () => !!slots.actions?.({});
    const showActions = ref(true);
    const timeoutId = ref();
    const hideActions = ref(false);
    watch(inputHasFocus, () => {
      showActions.value = !inputHasFocus.value;
      window.clearTimeout(timeoutId.value);
      if (showActions.value) {
        hideActions.value = false;
      } else {
        window.setTimeout(() => {
          hideActions.value = !showActions.value;
        }, transitionTimeout);
      }
    });
    function onCloseSearch() {
      model.value = "";
      if (hasActions()) {
        showActions.value = true;
        nextTick(() => actionsContainer.value?.querySelector("button")?.focus());
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["app-navigation-search", {
          "app-navigation-search--has-actions": hasActions()
        }])
      }, [
        createVNode(NcInputField, {
          ref_key: "inputElement",
          ref: inputElement,
          modelValue: model.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => model.value = $event),
          "aria-label": __props.label,
          class: "app-navigation-search__input",
          "label-outside": "",
          placeholder: __props.placeholder ?? __props.label,
          "show-trailing-button": "",
          "trailing-button-label": unref(t)("Clear search"),
          type: "search",
          onTrailingButtonClick: onCloseSearch
        }, {
          "trailing-button-icon": withCtx(() => [
            createVNode(IconClose, { size: 20 })
          ]),
          _: 1
        }, 8, ["modelValue", "aria-label", "placeholder", "trailing-button-label"]),
        hasActions() ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "actions-container-key",
          class: normalizeClass(["app-navigation-search__actions", {
            "app-navigation-search__actions--hidden": !showActions.value,
            "hidden-visually": hideActions.value
          }])
        }, [
          renderSlot(_ctx.$slots, "actions", {}, void 0, true)
        ], 2)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
register();
register(t44);
const _sfc_main$9 = {
  name: "NcAppSettingsDialog",
  components: {
    NcDialog,
    NcVNodes: _sfc_main$o
  },
  provide() {
    return {
      registerSection: this.registerSection,
      unregisterSection: this.unregisterSection
    };
  },
  props: {
    /**
     * Determines the open / closed state of the modal
     */
    open: {
      type: Boolean,
      required: true
    },
    /**
     * Shows the navigation on desktop if true
     */
    showNavigation: {
      type: Boolean,
      default: false
    },
    /**
     * Selector for the popover container
     */
    container: {
      type: String,
      default: "body"
    },
    /**
     * Name of the settings
     */
    name: {
      type: String,
      default: ""
    },
    /**
     * Additional elements to add to the focus trap
     */
    additionalTrapElements: {
      type: Array,
      default: () => []
    }
  },
  emits: ["update:open"],
  setup() {
    return {
      isMobile: useIsMobile()
    };
  },
  data() {
    return {
      selectedSection: "",
      linkClicked: false,
      addedScrollListener: false,
      scroller: null,
      /**
       * Currently registered settings sections
       * @type {{ id: string, name: string, icon?: import('vue').VNode[] }[]}
       */
      sections: []
    };
  },
  computed: {
    dialogProperties() {
      return {
        additionalTrapElements: this.additionalTrapElements,
        closeOnClickOutside: true,
        class: "app-settings",
        container: this.container,
        contentClasses: "app-settings__content",
        size: "large",
        name: this.name,
        navigationClasses: "app-settings__navigation"
      };
    },
    /**
     * Check if one or more navigation entries provide icons
     */
    hasNavigationIcons() {
      return this.sections.some(({ icon }) => !!icon);
    },
    hasNavigation() {
      if (this.isMobile || !this.showNavigation) {
        return false;
      } else {
        return true;
      }
    },
    settingsNavigationAriaLabel() {
      return t("Settings navigation");
    }
  },
  updated() {
    if (!this.$refs.settingsScroller) {
      return;
    }
    this.scroller = this.$refs.settingsScroller;
    if (!this.addedScrollListener) {
      this.scroller.addEventListener("scroll", this.handleScroll);
      this.addedScrollListener = true;
    }
  },
  methods: {
    /**
     * Called when a new section is registered
     * @param {string} id The section ID
     * @param {string} name The section name
     * @param {import('vue').VNode[]|undefined} icon Optional icon component
     */
    registerSection(id, name, icon) {
      if (this.sections.some(({ id: otherId }) => id === otherId)) {
        throw new Error(`Duplicate section id found: ${id}. Settings navigation sections must have unique section ids.`);
      }
      if (this.sections.some(({ name: otherName }) => name === otherName)) {
        warn$1(`Duplicate section name found: ${name}. Settings navigation sections must have unique section names.`);
      }
      const newSections = [...this.sections, { id, name, icon }];
      this.sections = newSections.sort(({ id: idA }, { id: idB }) => {
        const indexOf = (id2) => this.$slots.default?.().indexOf((vnode) => vnode?.props?.id === id2) ?? -1;
        return indexOf(idA) - indexOf(idB);
      });
      if (this.sections.length === 1) {
        this.selectedSection = id;
      }
    },
    /**
     * Called when a section is unregistered to remove it from dialog
     * @param {string} id The section ID
     */
    unregisterSection(id) {
      this.sections = this.sections.filter(({ id: otherId }) => id !== otherId);
      if (this.selectedSection === id) {
        this.selectedSection = this.sections[0]?.id ?? "";
      }
    },
    /**
     * Scrolls the content to the selected settings section.absolute
     *
     * @param {string} item the ID of the section
     */
    handleSettingsNavigationClick(item) {
      this.linkClicked = true;
      document.getElementById("settings-section_" + item).scrollIntoView({
        behavior: "smooth",
        inline: "nearest"
      });
      this.selectedSection = item;
      setTimeout(() => {
        this.linkClicked = false;
      }, 1e3);
    },
    handleCloseModal(isOpen) {
      if (isOpen) {
        return;
      }
      this.$emit("update:open", false);
      this.scroller.removeEventListener("scroll", this.handleScroll);
      this.addedScrollListener = false;
      this.scroller.scrollTop = 0;
    },
    handleScroll() {
      if (!this.linkClicked) {
        this.unfocusNavigationItem();
      }
    },
    /**
     * Remove selected section once the user starts scrolling
     *
     * @type {import('debounce').DebouncedFunction<() => void>}
     */
    unfocusNavigationItem: debounce(function() {
      this.selectedSection = "";
      if (document.activeElement.className.includes("navigation-list__link")) {
        document.activeElement.blur();
      }
    }, 300)
  }
};
const _hoisted_1$e = {
  key: 0,
  class: "navigation-list"
};
const _hoisted_2$d = ["aria-current", "href", "onClick", "onKeydown"];
const _hoisted_3$b = {
  key: 0,
  class: "navigation-list__link-icon"
};
const _hoisted_4$8 = { class: "navigation-list__link-text" };
const _hoisted_5$2 = { ref: "settingsScroller" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcVNodes = resolveComponent("NcVNodes");
  const _component_NcDialog = resolveComponent("NcDialog");
  return $props.open ? (openBlock(), createBlock(_component_NcDialog, mergeProps({
    key: 0,
    "navigation-aria-label": $options.settingsNavigationAriaLabel
  }, $options.dialogProperties, { "onUpdate:open": $options.handleCloseModal }), createSlots({
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_5$2, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 512)
    ]),
    _: 2
  }, [
    $options.hasNavigation ? {
      name: "navigation",
      fn: withCtx(({ isCollapsed }) => [
        !isCollapsed ? (openBlock(), createElementBlock("ul", _hoisted_1$e, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.sections, (section) => {
            return openBlock(), createElementBlock("li", {
              key: section.id
            }, [
              createBaseVNode("a", {
                "aria-current": `${section.id === $data.selectedSection}`,
                class: normalizeClass({
                  "navigation-list__link": true,
                  "navigation-list__link--active": section.id === $data.selectedSection,
                  "navigation-list__link--icon": $options.hasNavigationIcons
                }),
                href: `#settings-section_${section.id}`,
                tabindex: "0",
                onClick: withModifiers(($event) => $options.handleSettingsNavigationClick(section.id), ["prevent"]),
                onKeydown: withKeys(($event) => $options.handleSettingsNavigationClick(section.id), ["enter"])
              }, [
                $options.hasNavigationIcons ? (openBlock(), createElementBlock("div", _hoisted_3$b, [
                  section.icon ? (openBlock(), createBlock(_component_NcVNodes, {
                    key: 0,
                    vnodes: section.icon
                  }, null, 8, ["vnodes"])) : createCommentVNode("", true)
                ])) : createCommentVNode("", true),
                createBaseVNode("span", _hoisted_4$8, toDisplayString(section.name), 1)
              ], 42, _hoisted_2$d)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]),
      key: "0"
    } : void 0
  ]), 1040, ["navigation-aria-label", "onUpdate:open"])) : createCommentVNode("", true);
}
const NcAppSettingsDialog = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$6], ["__scopeId", "data-v-92616d32"]]);
const encodedTlds = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
const encodedUtlds = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2";
const numeric = "numeric";
const ascii = "ascii";
const alpha = "alpha";
const asciinumeric = "asciinumeric";
const alphanumeric = "alphanumeric";
const domain = "domain";
const emoji = "emoji";
const scheme = "scheme";
const slashscheme = "slashscheme";
const whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t2, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t2) < 0) {
      group.push(t2);
    }
  }
}
function flagsForToken(t2, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t2) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token = null) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex2 = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex2.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly = false) {
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t2 = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      Object.assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t2) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = Object.assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t2, allFlags, groups);
        } else if (flags) {
          addToGroups(t2, flags, groups);
        }
      }
      nextState.t = t2;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
const ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
const tr$1 = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
const ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
const tt$1 = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
const WORD = "WORD";
const UWORD = "UWORD";
const ASCIINUMERICAL = "ASCIINUMERICAL";
const ALPHANUMERICAL = "ALPHANUMERICAL";
const LOCALHOST = "LOCALHOST";
const TLD = "TLD";
const UTLD = "UTLD";
const SCHEME = "SCHEME";
const SLASH_SCHEME = "SLASH_SCHEME";
const NUM = "NUM";
const WS = "WS";
const NL = "NL";
const OPENBRACE = "OPENBRACE";
const CLOSEBRACE = "CLOSEBRACE";
const OPENBRACKET = "OPENBRACKET";
const CLOSEBRACKET = "CLOSEBRACKET";
const OPENPAREN = "OPENPAREN";
const CLOSEPAREN = "CLOSEPAREN";
const OPENANGLEBRACKET = "OPENANGLEBRACKET";
const CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
const FULLWIDTHLEFTPAREN = "FULLWIDTHLEFTPAREN";
const FULLWIDTHRIGHTPAREN = "FULLWIDTHRIGHTPAREN";
const LEFTCORNERBRACKET = "LEFTCORNERBRACKET";
const RIGHTCORNERBRACKET = "RIGHTCORNERBRACKET";
const LEFTWHITECORNERBRACKET = "LEFTWHITECORNERBRACKET";
const RIGHTWHITECORNERBRACKET = "RIGHTWHITECORNERBRACKET";
const FULLWIDTHLESSTHAN = "FULLWIDTHLESSTHAN";
const FULLWIDTHGREATERTHAN = "FULLWIDTHGREATERTHAN";
const AMPERSAND = "AMPERSAND";
const APOSTROPHE = "APOSTROPHE";
const ASTERISK = "ASTERISK";
const AT = "AT";
const BACKSLASH = "BACKSLASH";
const BACKTICK = "BACKTICK";
const CARET = "CARET";
const COLON = "COLON";
const COMMA = "COMMA";
const DOLLAR = "DOLLAR";
const DOT = "DOT";
const EQUALS = "EQUALS";
const EXCLAMATION = "EXCLAMATION";
const HYPHEN = "HYPHEN";
const PERCENT = "PERCENT";
const PIPE = "PIPE";
const PLUS = "PLUS";
const POUND = "POUND";
const QUERY = "QUERY";
const QUOTE = "QUOTE";
const FULLWIDTHMIDDLEDOT = "FULLWIDTHMIDDLEDOT";
const SEMI = "SEMI";
const SLASH = "SLASH";
const TILDE = "TILDE";
const UNDERSCORE = "UNDERSCORE";
const EMOJI$1 = "EMOJI";
const SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL,
  AMPERSAND,
  APOSTROPHE,
  ASCIINUMERICAL,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  CLOSEANGLEBRACKET,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEPAREN,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EMOJI: EMOJI$1,
  EQUALS,
  EXCLAMATION,
  FULLWIDTHGREATERTHAN,
  FULLWIDTHLEFTPAREN,
  FULLWIDTHLESSTHAN,
  FULLWIDTHMIDDLEDOT,
  FULLWIDTHRIGHTPAREN,
  HYPHEN,
  LEFTCORNERBRACKET,
  LEFTWHITECORNERBRACKET,
  LOCALHOST,
  NL,
  NUM,
  OPENANGLEBRACKET,
  OPENBRACE,
  OPENBRACKET,
  OPENPAREN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  RIGHTCORNERBRACKET,
  RIGHTWHITECORNERBRACKET,
  SCHEME,
  SEMI,
  SLASH,
  SLASH_SCHEME,
  SYM,
  TILDE,
  TLD,
  UNDERSCORE,
  UTLD,
  UWORD,
  WORD,
  WS
});
const ASCII_LETTER = /[a-z]/;
const LETTER = new RegExp("\\p{L}", "u");
const EMOJI = new RegExp("\\p{Emoji}", "u");
const DIGIT = /\d/;
const SPACE = /\s/;
const CR = "\r";
const LF = "\n";
const EMOJI_VARIATION = "️";
const EMOJI_JOINER = "‍";
const OBJECT_REPLACEMENT = "￼";
let tlds = null, utlds = null;
function init$2(customSchemes = []) {
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt$1(Start, "'", APOSTROPHE);
  tt$1(Start, "{", OPENBRACE);
  tt$1(Start, "}", CLOSEBRACE);
  tt$1(Start, "[", OPENBRACKET);
  tt$1(Start, "]", CLOSEBRACKET);
  tt$1(Start, "(", OPENPAREN);
  tt$1(Start, ")", CLOSEPAREN);
  tt$1(Start, "<", OPENANGLEBRACKET);
  tt$1(Start, ">", CLOSEANGLEBRACKET);
  tt$1(Start, "（", FULLWIDTHLEFTPAREN);
  tt$1(Start, "）", FULLWIDTHRIGHTPAREN);
  tt$1(Start, "「", LEFTCORNERBRACKET);
  tt$1(Start, "」", RIGHTCORNERBRACKET);
  tt$1(Start, "『", LEFTWHITECORNERBRACKET);
  tt$1(Start, "』", RIGHTWHITECORNERBRACKET);
  tt$1(Start, "＜", FULLWIDTHLESSTHAN);
  tt$1(Start, "＞", FULLWIDTHGREATERTHAN);
  tt$1(Start, "&", AMPERSAND);
  tt$1(Start, "*", ASTERISK);
  tt$1(Start, "@", AT);
  tt$1(Start, "`", BACKTICK);
  tt$1(Start, "^", CARET);
  tt$1(Start, ":", COLON);
  tt$1(Start, ",", COMMA);
  tt$1(Start, "$", DOLLAR);
  tt$1(Start, ".", DOT);
  tt$1(Start, "=", EQUALS);
  tt$1(Start, "!", EXCLAMATION);
  tt$1(Start, "-", HYPHEN);
  tt$1(Start, "%", PERCENT);
  tt$1(Start, "|", PIPE);
  tt$1(Start, "+", PLUS);
  tt$1(Start, "#", POUND);
  tt$1(Start, "?", QUERY);
  tt$1(Start, '"', QUOTE);
  tt$1(Start, "/", SLASH);
  tt$1(Start, ";", SEMI);
  tt$1(Start, "~", TILDE);
  tt$1(Start, "_", UNDERSCORE);
  tt$1(Start, "\\", BACKSLASH);
  tt$1(Start, "・", FULLWIDTHMIDDLEDOT);
  const Num = tr$1(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr$1(Num, DIGIT, Num);
  const Asciinumeric = tr$1(Num, ASCII_LETTER, ASCIINUMERICAL, {
    [asciinumeric]: true
  });
  const Alphanumeric = tr$1(Num, LETTER, ALPHANUMERICAL, {
    [alphanumeric]: true
  });
  const Word = tr$1(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr$1(Word, DIGIT, Asciinumeric);
  tr$1(Word, ASCII_LETTER, Word);
  tr$1(Asciinumeric, DIGIT, Asciinumeric);
  tr$1(Asciinumeric, ASCII_LETTER, Asciinumeric);
  const UWord = tr$1(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr$1(UWord, ASCII_LETTER);
  tr$1(UWord, DIGIT, Alphanumeric);
  tr$1(UWord, LETTER, UWord);
  tr$1(Alphanumeric, DIGIT, Alphanumeric);
  tr$1(Alphanumeric, ASCII_LETTER);
  tr$1(Alphanumeric, LETTER, Alphanumeric);
  const Nl2 = tt$1(Start, LF, NL, {
    [whitespace]: true
  });
  const Cr2 = tt$1(Start, CR, WS, {
    [whitespace]: true
  });
  const Ws = tr$1(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt$1(Start, OBJECT_REPLACEMENT, Ws);
  tt$1(Cr2, LF, Nl2);
  tt$1(Cr2, OBJECT_REPLACEMENT, Ws);
  tr$1(Cr2, SPACE, Ws);
  tt$1(Ws, CR);
  tt$1(Ws, LF);
  tr$1(Ws, SPACE, Ws);
  tt$1(Ws, OBJECT_REPLACEMENT, Ws);
  const Emoji = tr$1(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tt$1(Emoji, "#");
  tr$1(Emoji, EMOJI, Emoji);
  tt$1(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt$1(Emoji, EMOJI_JOINER);
  tt$1(EmojiJoiner, "#");
  tr$1(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word], [DIGIT, Asciinumeric]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord], [DIGIT, Alphanumeric]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: Object.assign({
      groups
    }, tk)
  };
}
function run$1(start, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index2 = 0;
  while (index2 < len) {
    let first = str.charCodeAt(index2);
    let second;
    let char = first < 55296 || first > 56319 || index2 + 1 === len || (second = str.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str[index2] : str.slice(index2, index2 + 2);
    result.push(char);
    index2 += char.length;
  }
  return result;
}
function fastts(state, input, t2, defaultt, jr2) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr2.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t2);
  next.jr = jr2.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]);
      i++;
    }
  }
  return words;
}
const defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender2 = null) {
  let o = Object.assign({}, defaults);
  if (opts) {
    o = Object.assign(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender2) {
    this.defaultRender = defaultRender2;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir2) {
    return ir2;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir2 = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir2, token.t, token);
  }
};
function noop(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "…" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol = defaults.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs = options.getObj("attributes", href, token);
    const eventListeners = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      Object.assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
const Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
const Text = createTokenClass("text");
const Nl$1 = createTokenClass("nl");
const Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2 = defaults.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
const makeState = (arg) => new State(arg);
function init$1({
  groups
}) {
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, PERCENT, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt$1(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt$1(Domain, AT);
  tt$1(Localpart, AT, LocalpartAt);
  tt$1(Scheme, AT, LocalpartAt);
  tt$1(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt$1(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt$1(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt$1(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt$1(EmailDomain, HYPHEN);
  tt$1(EmailDomainHyphen, HYPHEN, EmailDomainHyphen);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt$1(Email$1, DOT, EmailDomainDot);
  tt$1(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt$1(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt$1(Domain, HYPHEN);
  const DomainDot = tt$1(Domain, DOT);
  tt$1(DomainHyphen, HYPHEN, DomainHyphen);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt$1(DomainDotTld, DOT, DomainDot);
  tt$1(DomainDotTld, HYPHEN, DomainHyphen);
  tt$1(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt$1(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt$1(DomainDotTld, SLASH, Url$1);
  tt$1(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt$1(Scheme, COLON);
  const SlashSchemeColon = tt$1(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt$1(SlashSchemeColon, SLASH);
  const UriPrefix = tt$1(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt$1(Scheme, DOT, DomainDot);
  tt$1(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt$1(SlashScheme, DOT, DomainDot);
  tt$1(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt$1(SchemeColon, SLASH, Url$1);
  tt$1(SchemeColon, QUERY, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt$1(UriPrefix, SLASH, Url$1);
  const bracketPairs = [
    [OPENBRACE, CLOSEBRACE],
    // {}
    [OPENBRACKET, CLOSEBRACKET],
    // []
    [OPENPAREN, CLOSEPAREN],
    // ()
    [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
    // <>
    [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
    // （）
    [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
    // 「」
    [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
    // 『』
    [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN]
    // ＜＞
  ];
  for (let i = 0; i < bracketPairs.length; i++) {
    const [OPEN, CLOSE] = bracketPairs[i];
    const UrlOpen = tt$1(Url$1, OPEN);
    tt$1(UrlNonaccept, OPEN, UrlOpen);
    tt$1(UrlOpen, CLOSE, Url$1);
    const UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    const UrlOpenSyms = makeState();
    ta(UrlOpen, qsNonAccepting);
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);
    tt$1(UrlOpenQ, CLOSE, Url$1);
    tt$1(UrlOpenSyms, CLOSE, Url$1);
  }
  tt$1(Start, LOCALHOST, DomainDotTld);
  tt$1(Start, NL, Nl$1);
  return {
    start: Start,
    tokens: tk
  };
}
function run(start, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
const warn = typeof console !== "undefined" && console && console.warn || (() => {
});
const warnAdvice = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.";
const INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
  return INIT;
}
function registerCustomProtocol(scheme2, optionalSlashSlash = false) {
  if (INIT.initialized) {
    warn(`linkifyjs: already initialized - will not register custom scheme "${scheme2}" ${warnAdvice}`);
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme2)) {
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  }
  INIT.customSchemes.push([scheme2, optionalSlashSlash]);
}
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
  return INIT;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
tokenize.scan = run$1;
function find(str, type = null, opts = null) {
  if (type && typeof type === "object") {
    if (opts) {
      throw Error(`linkifyjs: Invalid link type ${type}; must be a string`);
    }
    opts = type;
    type = null;
  }
  const options = new Options(opts);
  const tokens = tokenize(str);
  const filtered = [];
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}
function linkifyString(str) {
  const options = new Options({
    defaultProtocol: "https",
    target: "_blank",
    className: "external linkified",
    attributes: {
      rel: "nofollow noopener noreferrer"
    }
  }, defaultRender);
  const tokens = tokenize(str);
  const result = [];
  for (const token of tokens) {
    if (token.t === "nl" && options.get("nl2br")) {
      result.push("<br>\n");
    } else if (!token.isLink || !options.check(token)) {
      result.push(escapeHTML(token.toString()));
    } else {
      result.push(options.render(token));
    }
  }
  return result.join("");
}
function escapeAttr(href) {
  return href.replace(/"/g, "&quot;");
}
function attributesToString(attributes) {
  const result = [];
  for (const attr in attributes) {
    const val = attributes[attr] + "";
    result.push(`${attr}="${escapeAttr(val)}"`);
  }
  return result.join(" ");
}
function defaultRender({ tagName, attributes, content }) {
  return `<${tagName} ${attributesToString(attributes)}>${escapeHTML(content)}</${tagName}>`;
}
const directive$1 = function(el, { value }) {
  if (value?.linkify === true) {
    el.innerHTML = linkifyString(value.text);
  }
};
const _hoisted_1$d = ["title"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "NcAppSidebarHeader",
  props: {
    name: {},
    title: {},
    linkify: { type: Boolean }
  },
  setup(__props) {
    const headerRef = inject("NcAppSidebar:header:ref");
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock("h2", {
        ref_key: "headerRef",
        ref: headerRef,
        tabindex: "-1",
        title: _ctx.title
      }, [
        createTextVNode(toDisplayString(_ctx.name), 1)
      ], 8, _hoisted_1$d)), [
        [unref(directive$1), { text: _ctx.name, linkify: _ctx.linkify }]
      ]);
    };
  }
});
const directive = {
  mounted(el) {
    el.focus();
  }
};
register(t14);
const _sfc_main$4$1 = {
  name: "DockRightIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$4$1 = ["aria-hidden", "aria-label"];
const _hoisted_2$4$1 = ["fill", "width", "height"];
const _hoisted_3$3$1 = { d: "M20 4H4A2 2 0 0 0 2 6V18A2 2 0 0 0 4 20H20A2 2 0 0 0 22 18V6A2 2 0 0 0 20 4M15 18H4V6H15Z" };
const _hoisted_4$3$1 = { key: 0 };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon dock-right-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$3$1, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$3$1, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$4$1))
  ], 16, _hoisted_1$4$1);
}
const IconDockRight = /* @__PURE__ */ _export_sfc(_sfc_main$4$1, [["render", _sfc_render$4]]);
const _sfc_main$3$1 = {
  name: "StarIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$3$1 = ["aria-hidden", "aria-label"];
const _hoisted_2$3$1 = ["fill", "width", "height"];
const _hoisted_3$2$1 = { d: "M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" };
const _hoisted_4$2$1 = { key: 0 };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon star-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$2$1, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$2$1, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$3$1))
  ], 16, _hoisted_1$3$1);
}
const IconStar = /* @__PURE__ */ _export_sfc(_sfc_main$3$1, [["render", _sfc_render$3]]);
const _sfc_main$2$1 = {
  name: "StarOutlineIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$2$1 = ["aria-hidden", "aria-label"];
const _hoisted_2$2$1 = ["fill", "width", "height"];
const _hoisted_3$1$1 = { d: "M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z" };
const _hoisted_4$1$1 = { key: 0 };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon star-outline-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$1$1, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$1$1, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$2$1))
  ], 16, _hoisted_1$2$1);
}
const IconStarOutline = /* @__PURE__ */ _export_sfc(_sfc_main$2$1, [["render", _sfc_render$2]]);
const _sfc_main$1$1 = {
  name: "NcAppSidebarTabs",
  components: {
    NcCheckboxRadioSwitch,
    NcVNodes: _sfc_main$o
  },
  provide() {
    return {
      registerTab: this.registerTab,
      unregisterTab: this.unregisterTab,
      // Getter as an alternative to Vue 2.7 computed(() => this.activeTab)
      getActiveTab: () => this.activeTab,
      // Used to check whether the tab header is shown so the tabs can reference the tab header for `aria-labelledby` or not
      isTablistShown: () => this.hasMultipleTabs
    };
  },
  props: {
    /**
     * Id of the tab to activate
     */
    active: {
      type: String,
      default: ""
    },
    /**
     * Force the tab navigation to display even if there is only one tab
     */
    forceTabs: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:active"],
  data() {
    return {
      /**
       * Tab descriptions from the passed NcSidebarTab components' props to build the tab navbar from.
       */
      tabs: [],
      /**
       * Local active (open) tab's ID. It allows to use component without v-model:active
       */
      activeTab: ""
    };
  },
  computed: {
    /**
     * Has multiple tabs. If only one tab - its content is shown without navigation
     *
     * @return {boolean}
     */
    hasMultipleTabs() {
      return this.tabs.length > 1;
    },
    showForSingleTab() {
      return this.forceTabs && this.tabs.length === 1;
    },
    currentTabIndex() {
      return this.tabs.findIndex((tab) => tab.id === this.activeTab);
    }
  },
  watch: {
    active(active) {
      if (active !== this.activeTab) {
        this.updateActive();
      }
    }
  },
  methods: {
    /**
     * Set the current active tab
     *
     * @param {string} id the id of the tab
     */
    setActive(id) {
      this.activeTab = id;
      this.$emit("update:active", this.activeTab);
    },
    /**
     * Focus the previous tab
     * and emit to the parent component
     */
    focusPreviousTab() {
      if (this.currentTabIndex > 0) {
        this.setActive(this.tabs[this.currentTabIndex - 1].id);
      }
      this.focusActiveTab();
    },
    /**
     * Focus the next tab
     * and emit to the parent component
     */
    focusNextTab() {
      if (this.currentTabIndex < this.tabs.length - 1) {
        this.setActive(this.tabs[this.currentTabIndex + 1].id);
      }
      this.focusActiveTab();
    },
    /**
     * Focus the first tab
     * and emit to the parent component
     */
    focusFirstTab() {
      this.setActive(this.tabs[0].id);
      this.focusActiveTab();
    },
    /**
     * Focus the last tab
     * and emit to the parent component
     */
    focusLastTab() {
      this.setActive(this.tabs[this.tabs.length - 1].id);
      this.focusActiveTab();
    },
    /**
     * Focus the current active tab
     */
    focusActiveTab() {
      this.$el.querySelector(`#tab-button-${this.activeTab}`).focus();
    },
    /**
     * Focus the content on tab
     * see aria accessibility guidelines
     */
    focusActiveTabContent() {
      this.$el.querySelector("#tab-" + this.activeTab).focus();
    },
    /**
     * Update the current active tab
     */
    updateActive() {
      this.activeTab = this.active && this.tabs.some((tab) => tab.id === this.active) ? this.active : this.tabs.length > 0 ? this.tabs[0].id : "";
    },
    /**
     * Register child tab in the tabs
     *
     * @param {object} tab child tab passed to slot
     */
    registerTab(tab) {
      this.tabs.push(tab);
      this.tabs.sort((a, b) => {
        if (a.order === b.order) {
          return OC.Util.naturalSortCompare(a.name, b.name);
        }
        return a.order - b.order;
      });
      this.updateActive();
    },
    /**
     * Unregister child tab from the tabs
     *
     * @param {string} id tab's id
     */
    unregisterTab(id) {
      const tabIndex = this.tabs.findIndex((tab) => tab.id === id);
      if (tabIndex !== -1) {
        this.tabs.splice(tabIndex, 1);
      }
      if (this.activeTab === id) {
        this.updateActive();
      }
    }
  }
};
const _hoisted_1$1$1 = { class: "app-sidebar-tabs" };
const _hoisted_2$1$1 = { class: "app-sidebar-tabs__tab-caption" };
function _sfc_render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NcVNodes = resolveComponent("NcVNodes");
  const _component_NcCheckboxRadioSwitch = resolveComponent("NcCheckboxRadioSwitch");
  return openBlock(), createElementBlock("div", _hoisted_1$1$1, [
    $options.hasMultipleTabs || $options.showForSingleTab ? (openBlock(), createElementBlock("div", {
      key: 0,
      role: "tablist",
      class: "app-sidebar-tabs__nav",
      onKeydown: [
        _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => $options.focusPreviousTab && $options.focusPreviousTab(...args), ["exact", "prevent", "stop"]), ["left"])),
        _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.focusNextTab && $options.focusNextTab(...args), ["exact", "prevent", "stop"]), ["right"])),
        _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.focusActiveTabContent && $options.focusActiveTabContent(...args), ["exact", "prevent", "stop"]), ["tab"])),
        _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.focusFirstTab && $options.focusFirstTab(...args), ["exact", "prevent", "stop"]), ["home"])),
        _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.focusLastTab && $options.focusLastTab(...args), ["exact", "prevent", "stop"]), ["end"])),
        _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => $options.focusFirstTab && $options.focusFirstTab(...args), ["exact", "prevent", "stop"]), ["page-up"])),
        _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => $options.focusLastTab && $options.focusLastTab(...args), ["exact", "prevent", "stop"]), ["page-down"]))
      ]
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.tabs, (tab) => {
        return openBlock(), createBlock(_component_NcCheckboxRadioSwitch, {
          key: tab.id,
          "aria-controls": `tab-${tab.id}`,
          "aria-selected": String($data.activeTab === tab.id),
          "button-variant": true,
          "model-value": $data.activeTab === tab.id,
          "wrapper-id": `tab-button-${tab.id}`,
          tabindex: $data.activeTab === tab.id ? 0 : -1,
          "button-variant-grouped": "horizontal",
          class: normalizeClass(["app-sidebar-tabs__tab", { active: tab.id === $data.activeTab }]),
          role: "tab",
          type: "button",
          "onUpdate:modelValue": ($event) => $options.setActive(tab.id)
        }, {
          icon: withCtx(() => [
            createVNode(_component_NcVNodes, {
              vnodes: tab.renderIcon()
            }, {
              default: withCtx(() => [
                createBaseVNode("span", {
                  class: normalizeClass(["app-sidebar-tabs__tab-icon", tab.icon])
                }, null, 2)
              ]),
              _: 2
            }, 1032, ["vnodes"])
          ]),
          default: withCtx(() => [
            createBaseVNode("span", _hoisted_2$1$1, toDisplayString(tab.name), 1)
          ]),
          _: 2
        }, 1032, ["aria-controls", "aria-selected", "model-value", "wrapper-id", "tabindex", "class", "onUpdate:modelValue"]);
      }), 128))
    ], 32)) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: normalizeClass([{ "app-sidebar-tabs__content--multiple": $options.hasMultipleTabs }, "app-sidebar-tabs__content"])
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ], 2)
  ]);
}
const NcAppSidebarTabs = /* @__PURE__ */ _export_sfc(_sfc_main$1$1, [["render", _sfc_render$1$1], ["__scopeId", "data-v-9a713930"]]);
const _sfc_main$7 = {
  name: "NcAppSidebar",
  components: {
    NcActions,
    NcAppSidebarHeader: _sfc_main$8,
    NcAppSidebarTabs,
    NcButton,
    NcLoadingIcon,
    NcEmptyContent,
    IconArrowRight,
    IconClose,
    IconDockRight,
    IconStar,
    IconStarOutline
  },
  directives: {
    Focus: directive,
    /** @type {import('vue').ObjectDirective} */
    ClickOutside: vOnClickOutside
  },
  inject: {
    ncContentSelector: {
      from: "NcContent:selector",
      default: void 0
    }
  },
  props: {
    active: {
      type: String,
      default: ""
    },
    name: {
      type: String,
      default: "",
      required: true
    },
    /**
     * Allow to edit the sidebar name.
     */
    nameEditable: {
      type: Boolean,
      default: false
    },
    namePlaceholder: {
      type: String,
      default: ""
    },
    subname: {
      type: String,
      default: ""
    },
    /**
     * Title to display for the subname.
     */
    subtitle: {
      type: String,
      default: ""
    },
    /**
     * Url to the top header background image
     * Applied with css
     */
    background: {
      type: String,
      default: ""
    },
    /**
     * Enable the favourite icon if not null
     * See fired events
     */
    starred: {
      type: Boolean,
      default: null
    },
    /**
     * Show loading spinner instead of the star icon
     */
    starLoading: {
      type: Boolean,
      default: false
    },
    /**
     * Show loading spinner instead of tabs
     */
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * Display the sidebar in compact mode
     */
    compact: {
      type: Boolean,
      default: false
    },
    /**
     * Only display close button and default slot content.
     * Don't display other header content and primary and secondary actions.
     * Useful when showing the EmptyContent component as content.
     */
    empty: {
      type: Boolean,
      default: false
    },
    /**
     * Force the actions to display in a three dot menu
     */
    forceMenu: {
      type: Boolean,
      default: false
    },
    /**
     * Force the tab navigation to display even if there is only one tab
     */
    forceTabs: {
      type: Boolean,
      default: false
    },
    /**
     * Linkify the name
     */
    linkifyName: {
      type: Boolean,
      default: false
    },
    /**
     * Title to display for the name.
     * Can be set to the same text in case it's too long.
     */
    title: {
      type: String,
      default: ""
    },
    /**
     * Allow to conditionally show the sidebar
     * You can also use `v-if` on the sidebar, but using the open prop allow to keep
     * the sidebar inside the DOM for performance if it is opened and closed multiple times.
     *
     * When using the `open` property to close the sidebar a built-in toggle button will be shown to reopen it,
     * similar to the app navigation. You can remove this button with the `no-toggle` prop.
     */
    open: {
      type: Boolean,
      default: true
    },
    /**
     * Custom classes to assign to the sidebar toggle button.
     * If needed this can be used to assign styles to the button using `:deep()` selector.
     */
    toggleClasses: {
      type: [String, Array, Object],
      default: ""
    },
    /**
     * Custom attrs to assign to the sidebar toggle button.
     */
    toggleAttrs: {
      type: Object,
      default: void 0
    },
    /**
     * Do not add the built-in toggle button with `open` prop.
     */
    noToggle: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "close",
    "closed",
    "opened",
    // 'figureClick', not emitted on purpose to make "hasFigureClickListener" work
    "update:active",
    "update:name",
    "update:nameEditable",
    "update:open",
    "update:starred",
    "submitName",
    "dismissEditing"
  ],
  setup() {
    const headerRef = ref(null);
    provide("NcAppSidebar:header:ref", headerRef);
    return {
      uid: createElementId(),
      isMobile: useIsSmallMobile(),
      headerRef
    };
  },
  data() {
    return {
      changeNameTranslated: t("Change name"),
      closeTranslated: t("Close sidebar"),
      favoriteTranslated: t("Favorite"),
      isStarred: this.starred,
      focusTrap: null,
      elementToReturnFocus: null
    };
  },
  computed: {
    canStar() {
      return this.isStarred !== null;
    },
    hasFigureClickListener() {
      return !!this.$attrs.onFigureClick;
    }
  },
  watch: {
    starred() {
      this.isStarred = this.starred;
    },
    isMobile() {
      this.toggleFocusTrap();
    },
    open() {
      this.checkToggleButtonContainerAvailability();
    }
  },
  created() {
    this.preserveElementToReturnFocus();
    this.checkToggleButtonContainerAvailability();
  },
  beforeUnmount() {
    this.$emit("closed");
    this.focusTrap?.deactivate();
  },
  methods: {
    isSlotPopulated,
    t,
    preserveElementToReturnFocus() {
      if (document.activeElement && document.activeElement !== document.body) {
        this.elementToReturnFocus = document.activeElement;
        if (this.elementToReturnFocus.getAttribute("role") === "menuitem") {
          const menu = this.elementToReturnFocus.closest('[role="menu"]');
          if (menu) {
            const menuTrigger = document.querySelector(`[aria-controls="${menu.id}"]`);
            this.elementToReturnFocus = menuTrigger;
          }
        }
      }
    },
    initFocusTrap() {
      if (this.focusTrap) {
        return;
      }
      this.focusTrap = createFocusTrap([
        // The sidebar itself
        this.$refs.sidebar,
        // Nextcloud Server header navigarion
        document.querySelector("#header")
      ], {
        allowOutsideClick: true,
        fallbackFocus: this.$refs.closeButton.$el,
        trapStack: getTrapStack(),
        escapeDeactivates: false
      });
    },
    /**
     * Activate focus trap if it is currently needed, otherwise deactivate
     */
    toggleFocusTrap() {
      if (this.open && this.isMobile) {
        this.initFocusTrap();
        this.focusTrap.activate();
      } else {
        this.focusTrap?.deactivate();
      }
    },
    /**
     * Close the sidebar on pressing the escape key on mobile
     *
     * @param {KeyboardEvent} event key down event
     */
    onKeydownEsc(event) {
      if (this.isMobile) {
        event.stopPropagation();
        this.closeSidebar();
      }
    },
    onAfterEnter(element) {
      if (this.elementToReturnFocus) {
        this.focus();
      }
      this.toggleFocusTrap();
      this.$emit("opened", element);
    },
    onAfterLeave(element) {
      this.$emit("closed", element);
      this.toggleFocusTrap();
      this.elementToReturnFocus?.focus({ focusVisible: true });
      this.elementToReturnFocus = null;
    },
    /**
     * Used to tell parent component the user asked to close the sidebar
     *
     * @param {Event} e close icon click event
     */
    closeSidebar(e2) {
      this.$emit("close", e2);
      this.$emit("update:open", false);
    },
    /**
     * Emit figure click event to parent component
     *
     * @param {Event} e click event
     */
    onFigureClick(e2) {
      this.$emit("figureClick", e2);
    },
    /**
     * Toggle the favourite state
     * and emit to the parent component
     */
    toggleStarred() {
      this.isStarred = !this.isStarred;
      this.$emit("update:starred", this.isStarred);
    },
    async editName() {
      this.$emit("update:nameEditable", true);
      if (this.nameEditable) {
        await this.$nextTick();
        this.$refs.nameInput.focus();
      }
    },
    /**
     * Focus the sidebar
     * @public
     */
    focus() {
      if (!this.open && !this.noToggle) {
        this.$refs.toggle.$el.focus();
        return;
      }
      try {
        this.headerRef.focus();
      } catch {
        warn$1("NcAppSidebar should have focusable header for accessibility reasons. Use NcAppSidebarHeader component.");
      }
    },
    /**
     * Focus the active tab
     * @public
     */
    focusActiveTabContent() {
      this.preserveElementToReturnFocus();
      this.$refs.tabs.focusActiveTabContent();
    },
    /**
     * Check if the toggle button container is available
     */
    checkToggleButtonContainerAvailability() {
      if (this.open === false && !this.noToggle && !this.ncContentSelector) {
        console.warn(
          "[NcAppSidebar] It looks like you want to use NcAppSidebar with the built-in toggle button. This feature is only available when NcAppSidebar is used in NcContent."
        );
      }
    },
    /**
     * Emit name change event to parent component
     *
     * @param {Event} event input event
     */
    onNameInput(event) {
      this.$emit("update:name", event.target.value);
    },
    /**
     * Emit when the name form edit confirm button is pressed in order
     * to change the name.
     *
     * @param {Event} event submit event
     */
    onSubmitName(event) {
      this.$emit("update:nameEditable", false);
      this.$emit("submitName", event);
    },
    onDismissEditing() {
      this.$emit("update:nameEditable", false);
      this.$emit("dismissEditing");
    },
    onUpdateActive(activeTab) {
      this.$emit("update:active", activeTab);
    }
  }
};
const _hoisted_1$c = ["aria-labelledby"];
const _hoisted_2$c = { class: "app-sidebar-header__info" };
const _hoisted_3$a = {
  key: 0,
  class: "app-sidebar-header__tertiary-actions"
};
const _hoisted_4$7 = { class: "app-sidebar-header__name-container" };
const _hoisted_5$1 = { class: "app-sidebar-header__mainname-container" };
const _hoisted_6$1 = ["placeholder", "value"];
const _hoisted_7$1 = ["title"];
const _hoisted_8$1 = {
  key: 2,
  class: "app-sidebar-header__description"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconDockRight = resolveComponent("IconDockRight");
  const _component_NcButton = resolveComponent("NcButton");
  const _component_NcLoadingIcon = resolveComponent("NcLoadingIcon");
  const _component_IconStar = resolveComponent("IconStar");
  const _component_IconStarOutline = resolveComponent("IconStarOutline");
  const _component_NcAppSidebarHeader = resolveComponent("NcAppSidebarHeader");
  const _component_IconArrowRight = resolveComponent("IconArrowRight");
  const _component_NcActions = resolveComponent("NcActions");
  const _component_IconClose = resolveComponent("IconClose");
  const _component_NcAppSidebarTabs = resolveComponent("NcAppSidebarTabs");
  const _component_NcEmptyContent = resolveComponent("NcEmptyContent");
  const _directive_focus = resolveDirective("focus");
  const _directive_click_outside = resolveDirective("click-outside");
  return openBlock(), createBlock(Transition, {
    appear: "",
    name: "slide-right",
    onAfterEnter: $options.onAfterEnter,
    onAfterLeave: $options.onAfterLeave
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("aside", {
        id: "app-sidebar-vue",
        ref: "sidebar",
        class: "app-sidebar",
        "aria-labelledby": `app-sidebar-vue-${$setup.uid}__header`,
        onKeydown: _cache[6] || (_cache[6] = withKeys((...args) => $options.onKeydownEsc && $options.onKeydownEsc(...args), ["esc"]))
      }, [
        $options.ncContentSelector && !$props.open && !$props.noToggle ? (openBlock(), createBlock(Teleport, {
          key: 0,
          to: $options.ncContentSelector
        }, [
          createVNode(_component_NcButton, mergeProps({
            ref: "toggle",
            "aria-label": $options.t("Open sidebar"),
            class: ["app-sidebar__toggle", $props.toggleClasses],
            variant: "tertiary"
          }, $props.toggleAttrs, {
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:open", true))
          }), {
            icon: withCtx(() => [
              renderSlot(_ctx.$slots, "toggle-icon", {}, () => [
                createVNode(_component_IconDockRight, { size: 20 })
              ], true)
            ]),
            _: 3
          }, 16, ["aria-label", "class"])
        ], 8, ["to"])) : createCommentVNode("", true),
        createBaseVNode("header", {
          class: normalizeClass([{
            "app-sidebar-header--with-figure": $options.isSlotPopulated(_ctx.$slots.header?.()) || $props.background,
            "app-sidebar-header--compact": $props.compact
          }, "app-sidebar-header"])
        }, [
          !$props.empty ? renderSlot(_ctx.$slots, "info", { key: 0 }, () => [
            createBaseVNode("div", _hoisted_2$c, [
              $options.isSlotPopulated(_ctx.$slots.header?.()) || $props.background ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass([{
                  "app-sidebar-header__figure--with-action": $options.hasFigureClickListener
                }, "app-sidebar-header__figure"]),
                style: normalizeStyle({
                  backgroundImage: `url(${$props.background})`
                }),
                tabindex: "0",
                onClick: _cache[1] || (_cache[1] = (...args) => $options.onFigureClick && $options.onFigureClick(...args)),
                onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => $options.onFigureClick && $options.onFigureClick(...args), ["enter"]))
              }, [
                renderSlot(_ctx.$slots, "header", { class: "app-sidebar-header__background" }, void 0, true)
              ], 38)) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: normalizeClass([{
                  "app-sidebar-header__desc--with-tertiary-action": $options.canStar || $options.isSlotPopulated(_ctx.$slots["tertiary-actions"]?.()),
                  "app-sidebar-header__desc--editable": $props.nameEditable && !$props.subname,
                  "app-sidebar-header__desc--with-subname--editable": $props.nameEditable && $props.subname,
                  "app-sidebar-header__desc--without-actions": !$options.isSlotPopulated(_ctx.$slots["secondary-actions"]?.())
                }, "app-sidebar-header__desc"])
              }, [
                $options.canStar || $options.isSlotPopulated(_ctx.$slots["tertiary-actions"]?.()) ? (openBlock(), createElementBlock("div", _hoisted_3$a, [
                  renderSlot(_ctx.$slots, "tertiary-actions", {}, () => [
                    $options.canStar ? (openBlock(), createBlock(_component_NcButton, {
                      key: 0,
                      "aria-label": $data.favoriteTranslated,
                      pressed: $data.isStarred,
                      class: "app-sidebar-header__star",
                      variant: "secondary",
                      onClick: withModifiers($options.toggleStarred, ["prevent"])
                    }, {
                      icon: withCtx(() => [
                        $props.starLoading ? (openBlock(), createBlock(_component_NcLoadingIcon, { key: 0 })) : $data.isStarred ? (openBlock(), createBlock(_component_IconStar, {
                          key: 1,
                          size: 20
                        })) : (openBlock(), createBlock(_component_IconStarOutline, {
                          key: 2,
                          size: 20
                        }))
                      ]),
                      _: 1
                    }, 8, ["aria-label", "pressed", "onClick"])) : createCommentVNode("", true)
                  ], true)
                ])) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_4$7, [
                  createBaseVNode("div", _hoisted_5$1, [
                    withDirectives(createVNode(_component_NcAppSidebarHeader, {
                      class: "app-sidebar-header__mainname",
                      name: $props.name,
                      linkify: $props.linkifyName,
                      title: $props.title,
                      tabindex: $props.nameEditable ? 0 : -1,
                      onClick: withModifiers($options.editName, ["self"])
                    }, null, 8, ["name", "linkify", "title", "tabindex", "onClick"]), [
                      [vShow, !$props.nameEditable]
                    ]),
                    $props.nameEditable ? withDirectives((openBlock(), createElementBlock("form", {
                      key: 0,
                      class: "app-sidebar-header__mainname-form",
                      onSubmit: _cache[5] || (_cache[5] = withModifiers((...args) => $options.onSubmitName && $options.onSubmitName(...args), ["prevent"]))
                    }, [
                      withDirectives(createBaseVNode("input", {
                        ref: "nameInput",
                        class: "app-sidebar-header__mainname-input",
                        type: "text",
                        placeholder: $props.namePlaceholder,
                        value: $props.name,
                        onKeydown: _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.onDismissEditing && $options.onDismissEditing(...args), ["stop"]), ["esc"])),
                        onInput: _cache[4] || (_cache[4] = (...args) => $options.onNameInput && $options.onNameInput(...args))
                      }, null, 40, _hoisted_6$1), [
                        [_directive_focus]
                      ]),
                      createVNode(_component_NcButton, {
                        "aria-label": $data.changeNameTranslated,
                        type: "submit",
                        variant: "tertiary-no-background"
                      }, {
                        icon: withCtx(() => [
                          createVNode(_component_IconArrowRight, { size: 20 })
                        ]),
                        _: 1
                      }, 8, ["aria-label"])
                    ], 32)), [
                      [_directive_click_outside, () => $options.onSubmitName()]
                    ]) : createCommentVNode("", true),
                    $options.isSlotPopulated(_ctx.$slots["secondary-actions"]?.()) ? (openBlock(), createBlock(_component_NcActions, {
                      key: 1,
                      class: "app-sidebar-header__menu",
                      "force-menu": $props.forceMenu
                    }, {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "secondary-actions", {}, void 0, true)
                      ]),
                      _: 3
                    }, 8, ["force-menu"])) : createCommentVNode("", true)
                  ]),
                  $props.subname.trim() !== "" || _ctx.$slots["subname"] ? (openBlock(), createElementBlock("p", {
                    key: 0,
                    title: $props.subtitle || void 0,
                    class: "app-sidebar-header__subname"
                  }, [
                    renderSlot(_ctx.$slots, "subname", {}, () => [
                      createTextVNode(toDisplayString($props.subname), 1)
                    ], true)
                  ], 8, _hoisted_7$1)) : createCommentVNode("", true)
                ])
              ], 2)
            ])
          ], true) : (openBlock(), createBlock(_component_NcAppSidebarHeader, {
            key: 1,
            class: "app-sidebar-header__mainname--hidden",
            name: $props.name,
            tabindex: "-1"
          }, null, 8, ["name"])),
          createVNode(_component_NcButton, {
            ref: "closeButton",
            "aria-label": $data.closeTranslated,
            title: $data.closeTranslated,
            class: "app-sidebar__close",
            variant: "tertiary",
            onClick: withModifiers($options.closeSidebar, ["prevent"])
          }, {
            icon: withCtx(() => [
              createVNode(_component_IconClose, { size: 20 })
            ]),
            _: 1
          }, 8, ["aria-label", "title", "onClick"]),
          $options.isSlotPopulated(_ctx.$slots.description?.()) && !$props.empty ? (openBlock(), createElementBlock("div", _hoisted_8$1, [
            renderSlot(_ctx.$slots, "description", {}, void 0, true)
          ])) : createCommentVNode("", true)
        ], 2),
        withDirectives(createVNode(_component_NcAppSidebarTabs, {
          ref: "tabs",
          active: $props.active,
          "force-tabs": $props.forceTabs,
          "onUpdate:active": $options.onUpdateActive
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ]),
          _: 3
        }, 8, ["active", "force-tabs", "onUpdate:active"]), [
          [vShow, !$props.loading]
        ]),
        $props.loading ? (openBlock(), createBlock(_component_NcEmptyContent, { key: 1 }, {
          icon: withCtx(() => [
            createVNode(_component_NcLoadingIcon, { size: 64 })
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ], 40, _hoisted_1$c), [
        [vShow, $props.open]
      ])
    ]),
    _: 3
  }, 8, ["onAfterEnter", "onAfterLeave"]);
}
const NcAppSidebar = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$5], ["__scopeId", "data-v-75d9d903"]]);
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module) {
    var has = Object.prototype.hasOwnProperty, prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names2 = [], events, name;
      if (this._eventsCount === 0) return names2;
      for (name in events = this._events) {
        if (has.call(events, name)) names2.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events));
      }
      return names2;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit2(event, a1, a2, a3, a4, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn2 || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix2;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module.exports = EventEmitter2;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
class TimeoutError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "TimeoutError";
  }
}
class AbortError extends Error {
  constructor(message2) {
    super();
    this.name = "AbortError";
    this.message = message2;
  }
}
const getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
const getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise, options) {
  const {
    milliseconds,
    fallback,
    message: message2,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  let abortHandler;
  const wrappedPromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      abortHandler = () => {
        reject(getAbortedReason(signal));
      };
      signal.addEventListener("abort", abortHandler, { once: true });
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      promise.then(resolve, reject);
      return;
    }
    const timeoutError = new TimeoutError();
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      if (message2 === false) {
        resolve();
      } else if (message2 instanceof Error) {
        reject(message2);
      } else {
        timeoutError.message = message2 ?? `Promise timed out after ${milliseconds} milliseconds`;
        reject(timeoutError);
      }
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise);
      } catch (error) {
        reject(error);
      }
    })();
  });
  const cancelablePromise = wrappedPromise.finally(() => {
    cancelablePromise.clear();
    if (abortHandler && options.signal) {
      options.signal.removeEventListener("abort", abortHandler);
    }
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
function lowerBound(array, value, comparator) {
  let first = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it2 = first + step;
    if (comparator(array[it2], value) <= 0) {
      first = ++it2;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first;
}
class PriorityQueue {
  #queue = [];
  enqueue(run2, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      id: options.id,
      run: run2
    };
    if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {
      this.#queue.push(element);
      return;
    }
    const index2 = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);
    this.#queue.splice(index2, 0, element);
  }
  setPriority(id, priority) {
    const index2 = this.#queue.findIndex((element) => element.id === id);
    if (index2 === -1) {
      throw new ReferenceError(`No promise function with the id "${id}" exists in the queue.`);
    }
    const [item] = this.#queue.splice(index2, 1);
    this.enqueue(item.run, { priority, id });
  }
  dequeue() {
    const item = this.#queue.shift();
    return item?.run;
  }
  filter(options) {
    return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return this.#queue.length;
  }
}
class PQueue extends EventEmitter {
  #carryoverConcurrencyCount;
  #isIntervalIgnored;
  #intervalCount = 0;
  #intervalCap;
  #interval;
  #intervalEnd = 0;
  #intervalId;
  #timeoutId;
  #queue;
  #queueClass;
  #pending = 0;
  // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194
  #concurrency;
  #isPaused;
  #throwOnTimeout;
  // Use to assign a unique identifier to a promise function, if not explicitly specified
  #idAssigner = 1n;
  /**
      Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.
  
      Applies to each future operation.
      */
  timeout;
  // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`
  constructor(options) {
    super();
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${options.intervalCap?.toString() ?? ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${options.interval?.toString() ?? ""}\` (${typeof options.interval})`);
    }
    this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;
    this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;
    this.#intervalCap = options.intervalCap;
    this.#interval = options.interval;
    this.#queue = new options.queueClass();
    this.#queueClass = options.queueClass;
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    this.#throwOnTimeout = options.throwOnTimeout === true;
    this.#isPaused = options.autoStart === false;
  }
  get #doesIntervalAllowAnother() {
    return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;
  }
  get #doesConcurrentAllowAnother() {
    return this.#pending < this.#concurrency;
  }
  #next() {
    this.#pending--;
    this.#tryToStartAnother();
    this.emit("next");
  }
  #onResumeInterval() {
    this.#onInterval();
    this.#initializeIntervalIfNeeded();
    this.#timeoutId = void 0;
  }
  get #isIntervalPaused() {
    const now = Date.now();
    if (this.#intervalId === void 0) {
      const delay = this.#intervalEnd - now;
      if (delay < 0) {
        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
      } else {
        if (this.#timeoutId === void 0) {
          this.#timeoutId = setTimeout(() => {
            this.#onResumeInterval();
          }, delay);
        }
        return true;
      }
    }
    return false;
  }
  #tryToStartAnother() {
    if (this.#queue.size === 0) {
      if (this.#intervalId) {
        clearInterval(this.#intervalId);
      }
      this.#intervalId = void 0;
      this.emit("empty");
      if (this.#pending === 0) {
        this.emit("idle");
      }
      return false;
    }
    if (!this.#isPaused) {
      const canInitializeInterval = !this.#isIntervalPaused;
      if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {
        const job = this.#queue.dequeue();
        if (!job) {
          return false;
        }
        this.emit("active");
        job();
        if (canInitializeInterval) {
          this.#initializeIntervalIfNeeded();
        }
        return true;
      }
    }
    return false;
  }
  #initializeIntervalIfNeeded() {
    if (this.#isIntervalIgnored || this.#intervalId !== void 0) {
      return;
    }
    this.#intervalId = setInterval(() => {
      this.#onInterval();
    }, this.#interval);
    this.#intervalEnd = Date.now() + this.#interval;
  }
  #onInterval() {
    if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {
      clearInterval(this.#intervalId);
      this.#intervalId = void 0;
    }
    this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;
    this.#processQueue();
  }
  /**
  Executes all queued functions until it reaches the limit.
  */
  #processQueue() {
    while (this.#tryToStartAnother()) {
    }
  }
  get concurrency() {
    return this.#concurrency;
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    this.#concurrency = newConcurrency;
    this.#processQueue();
  }
  async #throwOnAbort(signal) {
    return new Promise((_resolve, reject) => {
      signal.addEventListener("abort", () => {
        reject(signal.reason);
      }, { once: true });
    });
  }
  /**
      Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.
  
      For example, this can be used to prioritize a promise function to run earlier.
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 0, id: '🦀'});
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦄', {priority: 1});
  
      queue.setPriority('🦀', 2);
      ```
  
      In this case, the promise function with `id: '🦀'` runs second.
  
      You can also deprioritize a promise function to delay its execution:
  
      ```js
      import PQueue from 'p-queue';
  
      const queue = new PQueue({concurrency: 1});
  
      queue.add(async () => '🦄', {priority: 1});
      queue.add(async () => '🦀', {priority: 1, id: '🦀'});
      queue.add(async () => '🦄');
      queue.add(async () => '🦄', {priority: 0});
  
      queue.setPriority('🦀', -1);
      ```
      Here, the promise function with `id: '🦀'` executes last.
      */
  setPriority(id, priority) {
    this.#queue.setPriority(id, priority);
  }
  async add(function_, options = {}) {
    options.id ??= (this.#idAssigner++).toString();
    options = {
      timeout: this.timeout,
      throwOnTimeout: this.#throwOnTimeout,
      ...options
    };
    return new Promise((resolve, reject) => {
      this.#queue.enqueue(async () => {
        this.#pending++;
        this.#intervalCount++;
        try {
          options.signal?.throwIfAborted();
          let operation = function_({ signal: options.signal });
          if (options.timeout) {
            operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });
          }
          if (options.signal) {
            operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);
          }
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          if (error instanceof TimeoutError && !options.throwOnTimeout) {
            resolve();
            return;
          }
          reject(error);
          this.emit("error", error);
        } finally {
          this.#next();
        }
      }, options);
      this.emit("add");
      this.#tryToStartAnother();
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  /**
  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)
  */
  start() {
    if (!this.#isPaused) {
      return this;
    }
    this.#isPaused = false;
    this.#processQueue();
    return this;
  }
  /**
  Put queue execution on hold.
  */
  pause() {
    this.#isPaused = true;
  }
  /**
  Clear the queue.
  */
  clear() {
    this.#queue = new this.#queueClass();
  }
  /**
      Can be called multiple times. Useful if you for example add additional items at a later time.
  
      @returns A promise that settles when the queue becomes empty.
      */
  async onEmpty() {
    if (this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("empty");
  }
  /**
      @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.
  
      If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.
  
      Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.
      */
  async onSizeLessThan(limit) {
    if (this.#queue.size < limit) {
      return;
    }
    await this.#onEvent("next", () => this.#queue.size < limit);
  }
  /**
      The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.
  
      @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.
      */
  async onIdle() {
    if (this.#pending === 0 && this.#queue.size === 0) {
      return;
    }
    await this.#onEvent("idle");
  }
  async #onEvent(event, filter) {
    return new Promise((resolve) => {
      const listener = () => {
        if (filter && !filter()) {
          return;
        }
        this.off(event, listener);
        resolve();
      };
      this.on(event, listener);
    });
  }
  /**
  Size of the queue, the number of queued items waiting to run.
  */
  get size() {
    return this.#queue.size;
  }
  /**
      Size of the queue, filtered by the given options.
  
      For example, this can be used to find the number of items remaining in the queue with a specific priority level.
      */
  sizeBy(options) {
    return this.#queue.filter(options).length;
  }
  /**
  Number of running items (no longer in the queue).
  */
  get pending() {
    return this.#pending;
  }
  /**
  Whether the queue is currently paused.
  */
  get isPaused() {
    return this.#isPaused;
  }
}
new PQueue({ concurrency: 5 });
register();
const _hoisted_1$b = {
  key: 0,
  class: "nc-chip__icon"
};
const _hoisted_2$b = { class: "nc-chip__text" };
/* @__PURE__ */ defineComponent({
  __name: "NcChip",
  props: {
    ariaLabelClose: { default: t("Close") },
    actionsContainer: { default: "body" },
    text: { default: "" },
    iconPath: { default: void 0 },
    iconSvg: { default: void 0 },
    noClose: { type: Boolean },
    variant: { default: "secondary" }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const slots = useSlots();
    const canClose = computed(() => !props.noClose);
    const hasActions = () => !!slots.actions;
    const hasIcon = () => Boolean(props.iconPath || props.iconSvg || !!slots.icon);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["nc-chip", {
          [`nc-chip--${_ctx.variant}`]: true,
          "nc-chip--no-actions": _ctx.noClose && !hasActions(),
          "nc-chip--no-icon": !hasIcon()
        }])
      }, [
        hasIcon() ? (openBlock(), createElementBlock("span", _hoisted_1$b, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            _ctx.iconPath || _ctx.iconSvg ? (openBlock(), createBlock(NcIconSvgWrapper, {
              key: 0,
              inline: "",
              path: _ctx.iconPath,
              svg: _ctx.iconPath ? void 0 : _ctx.iconSvg,
              size: 18
            }, null, 8, ["path", "svg"])) : createCommentVNode("", true)
          ], true)
        ])) : createCommentVNode("", true),
        createBaseVNode("span", _hoisted_2$b, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.text), 1)
          ], true)
        ]),
        canClose.value || hasActions() ? (openBlock(), createBlock(NcActions, {
          key: 1,
          class: "nc-chip__actions",
          container: _ctx.actionsContainer,
          "force-menu": !canClose.value,
          variant: "tertiary-no-background"
        }, {
          default: withCtx(() => [
            canClose.value ? (openBlock(), createBlock(NcActionButton, {
              key: 0,
              "close-after-click": "",
              onClick: _cache[0] || (_cache[0] = ($event) => emit2("close"))
            }, {
              icon: withCtx(() => [
                createVNode(NcIconSvgWrapper, {
                  path: unref(mdiClose),
                  size: 20
                }, null, 8, ["path"])
              ]),
              default: withCtx(() => [
                createTextVNode(" " + toDisplayString(_ctx.ariaLabelClose), 1)
              ]),
              _: 1
            })) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "actions", {}, void 0, true)
          ]),
          _: 3
        }, 8, ["container", "force-menu"])) : createCommentVNode("", true)
      ], 2);
    };
  }
});
register(t6);
register(t27);
const prefix = "";
function styleInject(css, ref2) {
  if (ref2 === void 0) ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}
const install = function(app, options) {
  const { componentPrefix = prefix } = options || {};
  app.component(`${componentPrefix}${this.name}`, this);
};
const _checkboardCache = {};
var script$5 = {
  name: "Checkboard",
  props: {
    size: {
      type: [Number, String],
      default: 8
    },
    white: {
      type: String,
      default: "#fff"
    },
    grey: {
      type: String,
      default: "#e6e6e6"
    }
  },
  computed: {
    bgStyle() {
      return {
        "background-image": `url(${getCheckboard(this.white, this.grey, this.size)})`
      };
    }
  }
};
function renderCheckboard(c1, c2, size) {
  if (typeof document === "undefined")
    return null;
  const canvas2 = document.createElement("canvas");
  canvas2.width = canvas2.height = size * 2;
  const ctx = canvas2.getContext("2d");
  if (!ctx)
    return null;
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas2.width, canvas2.height);
  ctx.fillStyle = c2;
  ctx.fillRect(0, 0, size, size);
  ctx.translate(size, size);
  ctx.fillRect(0, 0, size, size);
  return canvas2.toDataURL();
}
function getCheckboard(c1, c2, size) {
  const key = `${c1},${c2},${size}`;
  if (_checkboardCache[key])
    return _checkboardCache[key];
  const checkboard = renderCheckboard(c1, c2, size);
  _checkboardCache[key] = checkboard;
  return checkboard;
}
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: "vc-checkerboard",
      style: normalizeStyle($options.bgStyle)
    },
    null,
    4
    /* STYLE */
  );
}
var css_248z$5 = ".vc-checkerboard{background-size:contain;bottom:0;left:0;position:absolute;right:0;top:0}";
styleInject(css_248z$5);
script$5.render = render$5;
script$5.__file = "src/components/checkboard/checkboard.vue";
script$5.install = install;
var script$4 = {
  name: "Alpha",
  components: {
    Checkboard: script$5
  },
  props: {
    value: Object,
    onChange: Function
  },
  computed: {
    colors() {
      return this.value;
    },
    gradientColor() {
      const { rgba } = this.colors;
      const rgbStr = [rgba.r, rgba.g, rgba.b].join(",");
      return `linear-gradient(to right, rgba(${rgbStr}, 0) 0%, rgba(${rgbStr}, 1) 100%)`;
    }
  },
  methods: {
    handleChange(e2, skip) {
      !skip && e2.preventDefault();
      const { container } = this.$refs;
      if (!container) {
        return;
      }
      const containerWidth = container.clientWidth;
      const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
      const pageX = e2.pageX || (e2.touches ? e2.touches[0].pageX : 0);
      const left = pageX - xOffset;
      let a;
      if (left < 0)
        a = 0;
      else if (left > containerWidth)
        a = 1;
      else
        a = Math.round(left * 100 / containerWidth) / 100;
      if (this.colors.a !== a) {
        this.$emit("change", {
          h: this.colors.hsl.h,
          s: this.colors.hsl.s,
          l: this.colors.hsl.l,
          a,
          source: "rgba"
        });
      }
    },
    handleMouseDown(e2) {
      this.handleChange(e2, true);
      window.addEventListener("mousemove", this.handleChange);
      window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp() {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }
};
const _hoisted_1$a = { class: "vc-alpha" };
const _hoisted_2$a = { class: "vc-alpha-checkboard-wrap" };
const _hoisted_3$9 = /* @__PURE__ */ createBaseVNode(
  "div",
  { class: "vc-alpha-picker" },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$6 = [
  _hoisted_3$9
];
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkboard = resolveComponent("Checkboard");
  return openBlock(), createElementBlock("div", _hoisted_1$a, [
    createBaseVNode("div", _hoisted_2$a, [
      createVNode(_component_Checkboard)
    ]),
    createBaseVNode(
      "div",
      {
        class: "vc-alpha-gradient",
        style: normalizeStyle({ background: $options.gradientColor })
      },
      null,
      4
      /* STYLE */
    ),
    createBaseVNode(
      "div",
      {
        ref: "container",
        class: "vc-alpha-container",
        onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
        onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
        onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
      },
      [
        createBaseVNode(
          "div",
          {
            class: "vc-alpha-pointer",
            style: normalizeStyle({ left: `${$options.colors.a * 100}%` })
          },
          _hoisted_4$6,
          4
          /* STYLE */
        )
      ],
      544
      /* HYDRATE_EVENTS, NEED_PATCH */
    )
  ]);
}
var css_248z$4 = ".vc-alpha,.vc-alpha-checkboard-wrap{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-checkboard-wrap{overflow:hidden}.vc-alpha-gradient{bottom:0;left:0;position:absolute;right:0;top:0}.vc-alpha-container{cursor:pointer;height:100%;margin:0 3px;position:relative;z-index:2}.vc-alpha-pointer{position:absolute;z-index:2}.vc-alpha-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
styleInject(css_248z$4);
script$4.render = render$4;
script$4.__file = "src/components/alpha/alpha.vue";
script$4.install = install;
function bound01(n, max) {
  if (isOnePointZero(n)) {
    n = "100%";
  }
  var isPercent = isPercentage(n);
  n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
  if (isPercent) {
    n = parseInt(String(n * max), 10) / 100;
  }
  if (Math.abs(n - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
  } else {
    n = n % max / parseFloat(String(max));
  }
  return n;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }
  return n;
}
function pad2$1(c) {
  return c.length === 1 ? "0" + c : String(c);
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h2 = 0;
  var s = 0;
  var l = (max + min) / 2;
  if (max === min) {
    s = 0;
    h2 = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, l };
}
function hue2rgb(p, q, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p + (q - p) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q;
  }
  if (t2 < 2 / 3) {
    return p + (q - p) * (2 / 3 - t2) * 6;
  }
  return p;
}
function hslToRgb(h2, s, l) {
  var r;
  var g;
  var b;
  h2 = bound01(h2, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  if (s === 0) {
    g = l;
    b = l;
    r = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h2 + 1 / 3);
    g = hue2rgb(p, q, h2);
    b = hue2rgb(p, q, h2 - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h2 = 0;
  var v2 = max;
  var d = max - min;
  var s = max === 0 ? 0 : d / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, v: v2 };
}
function hsvToRgb(h2, s, v2) {
  h2 = bound01(h2, 360) * 6;
  s = bound01(s, 100);
  v2 = bound01(v2, 100);
  var i = Math.floor(h2);
  var f = h2 - i;
  var p = v2 * (1 - s);
  var q = v2 * (1 - f * s);
  var t2 = v2 * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v2, q, p, p, t2, v2][mod];
  var g = [t2, v2, v2, q, p, p][mod];
  var b = [p, p, t2, v2, v2, q][mod];
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [
    pad2$1(Math.round(r).toString(16)),
    pad2$1(Math.round(g).toString(16)),
    pad2$1(Math.round(b).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [
    pad2$1(Math.round(r).toString(16)),
    pad2$1(Math.round(g).toString(16)),
    pad2$1(Math.round(b).toString(16)),
    pad2$1(convertDecimalToHex(a))
  ];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s = null;
  var v2 = null;
  var l = null;
  var ok = false;
  var format2 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v2 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v2);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match2 = matchers.rgb.exec(color);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3] };
  }
  match2 = matchers.rgba.exec(color);
  if (match2) {
    return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
  }
  match2 = matchers.hsl.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3] };
  }
  match2 = matchers.hsla.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
  }
  match2 = matchers.hsv.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3] };
  }
  match2 = matchers.hsva.exec(color);
  if (match2) {
    return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
  }
  match2 = matchers.hex8.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      a: convertHexToDecimal(match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex6.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1]),
      g: parseIntFromHex(match2[2]),
      b: parseIntFromHex(match2[3]),
      format: named ? "name" : "hex"
    };
  }
  match2 = matchers.hex4.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      a: convertHexToDecimal(match2[4] + match2[4]),
      format: named ? "name" : "hex8"
    };
  }
  match2 = matchers.hex3.exec(color);
  if (match2) {
    return {
      r: parseIntFromHex(match2[1] + match2[1]),
      g: parseIntFromHex(match2[2] + match2[2]),
      b: parseIntFromHex(match2[3] + match2[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = (
  /** @class */
  (function() {
    function TinyColor2(color, opts) {
      if (color === void 0) {
        color = "";
      }
      if (opts === void 0) {
        opts = {};
      }
      var _a2;
      if (color instanceof TinyColor2) {
        return color;
      }
      if (typeof color === "number") {
        color = numberInputToObject(color);
      }
      this.originalInput = color;
      var rgb = inputToRGB(color);
      this.originalInput = color;
      this.r = rgb.r;
      this.g = rgb.g;
      this.b = rgb.b;
      this.a = rgb.a;
      this.roundA = Math.round(100 * this.a) / 100;
      this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
      this.gradientType = opts.gradientType;
      if (this.r < 1) {
        this.r = Math.round(this.r);
      }
      if (this.g < 1) {
        this.g = Math.round(this.g);
      }
      if (this.b < 1) {
        this.b = Math.round(this.b);
      }
      this.isValid = rgb.ok;
    }
    TinyColor2.prototype.isDark = function() {
      return this.getBrightness() < 128;
    };
    TinyColor2.prototype.isLight = function() {
      return !this.isDark();
    };
    TinyColor2.prototype.getBrightness = function() {
      var rgb = this.toRgb();
      return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
    };
    TinyColor2.prototype.getLuminance = function() {
      var rgb = this.toRgb();
      var R;
      var G;
      var B;
      var RsRGB = rgb.r / 255;
      var GsRGB = rgb.g / 255;
      var BsRGB = rgb.b / 255;
      if (RsRGB <= 0.03928) {
        R = RsRGB / 12.92;
      } else {
        R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
      }
      if (GsRGB <= 0.03928) {
        G = GsRGB / 12.92;
      } else {
        G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
      }
      if (BsRGB <= 0.03928) {
        B = BsRGB / 12.92;
      } else {
        B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
      }
      return 0.2126 * R + 0.7152 * G + 0.0722 * B;
    };
    TinyColor2.prototype.getAlpha = function() {
      return this.a;
    };
    TinyColor2.prototype.setAlpha = function(alpha2) {
      this.a = boundAlpha(alpha2);
      this.roundA = Math.round(100 * this.a) / 100;
      return this;
    };
    TinyColor2.prototype.isMonochrome = function() {
      var s = this.toHsl().s;
      return s === 0;
    };
    TinyColor2.prototype.toHsv = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
    };
    TinyColor2.prototype.toHsvString = function() {
      var hsv = rgbToHsv(this.r, this.g, this.b);
      var h2 = Math.round(hsv.h * 360);
      var s = Math.round(hsv.s * 100);
      var v2 = Math.round(hsv.v * 100);
      return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHsl = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
    };
    TinyColor2.prototype.toHslString = function() {
      var hsl = rgbToHsl(this.r, this.g, this.b);
      var h2 = Math.round(hsl.h * 360);
      var s = Math.round(hsl.s * 100);
      var l = Math.round(hsl.l * 100);
      return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toHex = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return rgbToHex(this.r, this.g, this.b, allow3Char);
    };
    TinyColor2.prototype.toHexString = function(allow3Char) {
      if (allow3Char === void 0) {
        allow3Char = false;
      }
      return "#" + this.toHex(allow3Char);
    };
    TinyColor2.prototype.toHex8 = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
    };
    TinyColor2.prototype.toHex8String = function(allow4Char) {
      if (allow4Char === void 0) {
        allow4Char = false;
      }
      return "#" + this.toHex8(allow4Char);
    };
    TinyColor2.prototype.toHexShortString = function(allowShortChar) {
      if (allowShortChar === void 0) {
        allowShortChar = false;
      }
      return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
    };
    TinyColor2.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toRgbString = function() {
      var r = Math.round(this.r);
      var g = Math.round(this.g);
      var b = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toPercentageRgb = function() {
      var fmt = function(x) {
        return "".concat(Math.round(bound01(x, 255) * 100), "%");
      };
      return {
        r: fmt(this.r),
        g: fmt(this.g),
        b: fmt(this.b),
        a: this.a
      };
    };
    TinyColor2.prototype.toPercentageRgbString = function() {
      var rnd = function(x) {
        return Math.round(bound01(x, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
    };
    TinyColor2.prototype.toName = function() {
      if (this.a === 0) {
        return "transparent";
      }
      if (this.a < 1) {
        return false;
      }
      var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
      for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
        var _b = _a2[_i], key = _b[0], value = _b[1];
        if (hex === value) {
          return key;
        }
      }
      return false;
    };
    TinyColor2.prototype.toString = function(format2) {
      var formatSet = Boolean(format2);
      format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
      var formattedString = false;
      var hasAlpha = this.a < 1 && this.a >= 0;
      var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
      if (needsAlphaFormat) {
        if (format2 === "name" && this.a === 0) {
          return this.toName();
        }
        return this.toRgbString();
      }
      if (format2 === "rgb") {
        formattedString = this.toRgbString();
      }
      if (format2 === "prgb") {
        formattedString = this.toPercentageRgbString();
      }
      if (format2 === "hex" || format2 === "hex6") {
        formattedString = this.toHexString();
      }
      if (format2 === "hex3") {
        formattedString = this.toHexString(true);
      }
      if (format2 === "hex4") {
        formattedString = this.toHex8String(true);
      }
      if (format2 === "hex8") {
        formattedString = this.toHex8String();
      }
      if (format2 === "name") {
        formattedString = this.toName();
      }
      if (format2 === "hsl") {
        formattedString = this.toHslString();
      }
      if (format2 === "hsv") {
        formattedString = this.toHsvString();
      }
      return formattedString || this.toHexString();
    };
    TinyColor2.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    };
    TinyColor2.prototype.clone = function() {
      return new TinyColor2(this.toString());
    };
    TinyColor2.prototype.lighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.brighten = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var rgb = this.toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return new TinyColor2(rgb);
    };
    TinyColor2.prototype.darken = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.tint = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("white", amount);
    };
    TinyColor2.prototype.shade = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      return this.mix("black", amount);
    };
    TinyColor2.prototype.desaturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.saturate = function(amount) {
      if (amount === void 0) {
        amount = 10;
      }
      var hsl = this.toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.greyscale = function() {
      return this.desaturate(100);
    };
    TinyColor2.prototype.spin = function(amount) {
      var hsl = this.toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.mix = function(color, amount) {
      if (amount === void 0) {
        amount = 50;
      }
      var rgb1 = this.toRgb();
      var rgb2 = new TinyColor2(color).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return new TinyColor2(rgba);
    };
    TinyColor2.prototype.analogous = function(results, slices) {
      if (results === void 0) {
        results = 6;
      }
      if (slices === void 0) {
        slices = 30;
      }
      var hsl = this.toHsl();
      var part = 360 / slices;
      var ret = [this];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(new TinyColor2(hsl));
      }
      return ret;
    };
    TinyColor2.prototype.complement = function() {
      var hsl = this.toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return new TinyColor2(hsl);
    };
    TinyColor2.prototype.monochromatic = function(results) {
      if (results === void 0) {
        results = 6;
      }
      var hsv = this.toHsv();
      var h2 = hsv.h;
      var s = hsv.s;
      var v2 = hsv.v;
      var res = [];
      var modification = 1 / results;
      while (results--) {
        res.push(new TinyColor2({ h: h2, s, v: v2 }));
        v2 = (v2 + modification) % 1;
      }
      return res;
    };
    TinyColor2.prototype.splitcomplement = function() {
      var hsl = this.toHsl();
      var h2 = hsl.h;
      return [
        this,
        new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
        new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    };
    TinyColor2.prototype.onBackground = function(background) {
      var fg = this.toRgb();
      var bg = new TinyColor2(background).toRgb();
      var alpha2 = fg.a + bg.a * (1 - fg.a);
      return new TinyColor2({
        r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha2,
        g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha2,
        b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha2,
        a: alpha2
      });
    };
    TinyColor2.prototype.triad = function() {
      return this.polyad(3);
    };
    TinyColor2.prototype.tetrad = function() {
      return this.polyad(4);
    };
    TinyColor2.prototype.polyad = function(n) {
      var hsl = this.toHsl();
      var h2 = hsl.h;
      var result = [this];
      var increment = 360 / n;
      for (var i = 1; i < n; i++) {
        result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
      }
      return result;
    };
    TinyColor2.prototype.equals = function(color) {
      return this.toRgbString() === new TinyColor2(color).toRgbString();
    };
    return TinyColor2;
  })()
);
function tinycolor(...args) {
  return new TinyColor(...args);
}
function _colorChange(data, oldHue) {
  const alpha2 = data && data.a;
  let color;
  if (data && data.hsl)
    color = tinycolor(data.hsl);
  else if (data && data.hex && data.hex.length > 0)
    color = tinycolor(data.hex);
  else if (data && data.hsv)
    color = tinycolor(data.hsv);
  else if (data && data.rgba)
    color = tinycolor(data.rgba);
  else if (data && data.rgb)
    color = tinycolor(data.rgb);
  else
    color = tinycolor(data);
  if (color && (color._a === void 0 || color._a === null))
    color.setAlpha(alpha2 || color.getAlpha());
  const hsl = color.toHsl();
  const hsv = color.toHsv();
  if (hsl.s === 0)
    hsv.h = hsl.h = data.h || data.hsl && data.hsl.h || oldHue || 0;
  if (hsv.v < 0.0164) {
    hsv.h = data.h || data.hsv && data.hsv.h || 0;
    hsv.s = data.s || data.hsv && data.hsv.s || 0;
  }
  if (hsl.l < 0.01) {
    hsl.h = data.h || data.hsl && data.hsl.h || 0;
    hsl.s = data.s || data.hsl && data.hsl.s || 0;
  }
  return {
    hsl,
    hex: color.toHexString().toUpperCase(),
    hex8: color.toHex8String().toUpperCase(),
    rgba: color.toRgb(),
    hsv,
    oldHue: data.h || oldHue || hsl.h,
    source: data.source,
    a: color.getAlpha()
  };
}
var colorMixin = {
  model: {
    prop: "modelValue",
    event: "update:modelValue"
  },
  props: ["modelValue"],
  data() {
    return {
      val: _colorChange(this.modelValue)
    };
  },
  computed: {
    colors: {
      get() {
        return this.val;
      },
      set(newVal) {
        this.val = newVal;
        this.$emit("update:modelValue", newVal);
      }
    }
  },
  watch: {
    modelValue(newVal) {
      this.val = _colorChange(newVal);
    }
  },
  methods: {
    colorChange(data, oldHue) {
      this.oldHue = this.colors.hsl.h;
      this.colors = _colorChange(data, oldHue || this.oldHue);
    },
    isValidHex(hex) {
      return tinycolor(hex).isValid;
    },
    simpleCheckForValidColor(data) {
      const keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
      let checked = 0;
      let passed = 0;
      for (let i = 0; i < keysToCheck.length; i++) {
        const letter = keysToCheck[i];
        if (data[letter]) {
          checked++;
          if (!isNaN(data[letter]))
            passed++;
        }
      }
      if (checked === passed)
        return data;
    },
    paletteUpperCase(palette) {
      return palette.map((c) => c.toUpperCase());
    },
    isTransparent(color) {
      return tinycolor(color).getAlpha() === 0;
    }
  }
};
var script$3 = {
  name: "EditableInput",
  props: {
    label: String,
    labelText: String,
    desc: String,
    value: [String, Number],
    max: Number,
    min: Number,
    arrowOffset: {
      type: Number,
      default: 1
    }
  },
  computed: {
    val: {
      get() {
        return this.value;
      },
      set(v2) {
        if (!(this.max === void 0) && +v2 > this.max)
          this.$refs.input.value = this.max;
        else
          return v2;
      }
    },
    labelId() {
      return `input__label__${this.label}__${Math.random().toString().slice(2, 5)}`;
    },
    labelSpanText() {
      return this.labelText || this.label;
    }
  },
  methods: {
    update(e2) {
      this.handleChange(e2.target.value);
    },
    handleChange(newVal) {
      const data = {};
      data[this.label] = newVal;
      if (data.hex === void 0 && data["#"] === void 0)
        this.$emit("change", data);
      else if (newVal.length > 5)
        this.$emit("change", data);
    },
    // **** unused
    // handleBlur (e) {
    //   console.log(e)
    // },
    handleKeyDown(e2) {
      let { val } = this;
      const number = Number(val);
      if (number) {
        const amount = this.arrowOffset || 1;
        if (e2.keyCode === 38) {
          val = number + amount;
          this.handleChange(val);
          e2.preventDefault();
        }
        if (e2.keyCode === 40) {
          val = number - amount;
          this.handleChange(val);
          e2.preventDefault();
        }
      }
    }
    // **** unused
    // handleDrag (e) {
    //   console.log(e)
    // },
    // handleMouseDown (e) {
    //   console.log(e)
    // }
  }
};
const _hoisted_1$9 = { class: "vc-editable-input" };
const _hoisted_2$9 = ["aria-labelledby"];
const _hoisted_3$8 = ["id", "for"];
const _hoisted_4$5 = { class: "vc-input__desc" };
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    withDirectives(createBaseVNode("input", {
      ref: "input",
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $options.val = $event),
      "aria-labelledby": $options.labelId,
      class: "vc-input__input",
      onKeydown: _cache[1] || (_cache[1] = (...args) => $options.handleKeyDown && $options.handleKeyDown(...args)),
      onInput: _cache[2] || (_cache[2] = (...args) => $options.update && $options.update(...args))
    }, null, 40, _hoisted_2$9), [
      [vModelText, $options.val]
    ]),
    createBaseVNode("span", {
      id: $options.labelId,
      for: $props.label,
      class: "vc-input__label"
    }, toDisplayString($options.labelSpanText), 9, _hoisted_3$8),
    createBaseVNode(
      "span",
      _hoisted_4$5,
      toDisplayString($props.desc),
      1
      /* TEXT */
    )
  ]);
}
var css_248z$3 = ".vc-editable-input{position:relative}.vc-input__input{border:0;outline:none;padding:0}.vc-input__label{text-transform:capitalize}";
styleInject(css_248z$3);
script$3.render = render$3;
script$3.__file = "src/components/editable-input/editable-input.vue";
script$3.install = install;
function clamp(value, min, max) {
  return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
}
var script$2 = {
  name: "Saturation",
  props: {
    value: Object
  },
  computed: {
    colors() {
      return this.value;
    },
    bgColor() {
      return `hsl(${this.colors.hsv.h}, 100%, 50%)`;
    },
    pointerTop() {
      return `${-(this.colors.hsv.v * 100) + 1 + 100}%`;
    },
    pointerLeft() {
      return `${this.colors.hsv.s * 100}%`;
    }
  },
  methods: {
    handleChange(e2, skip) {
      !skip && e2.preventDefault();
      const { container } = this.$refs;
      if (!container) {
        return;
      }
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
      const yOffset = container.getBoundingClientRect().top + window.pageYOffset;
      const pageX = e2.pageX || (e2.touches ? e2.touches[0].pageX : 0);
      const pageY = e2.pageY || (e2.touches ? e2.touches[0].pageY : 0);
      const left = clamp(pageX - xOffset, 0, containerWidth);
      const top = clamp(pageY - yOffset, 0, containerHeight);
      const saturation = left / containerWidth;
      const bright = clamp(-(top / containerHeight) + 1, 0, 1);
      this.onChange({
        h: this.colors.hsv.h,
        s: saturation,
        v: bright,
        a: this.colors.hsv.a,
        source: "hsva"
      });
    },
    onChange(param) {
      this.$emit("change", param);
    },
    handleMouseDown(e2) {
      window.addEventListener("mousemove", this.handleChange);
      window.addEventListener("mouseup", this.handleChange);
      window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp(e2) {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }
};
const _hoisted_1$8 = /* @__PURE__ */ createBaseVNode(
  "div",
  { class: "vc-saturation--white" },
  null,
  -1
  /* HOISTED */
);
const _hoisted_2$8 = /* @__PURE__ */ createBaseVNode(
  "div",
  { class: "vc-saturation--black" },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$7 = /* @__PURE__ */ createBaseVNode(
  "div",
  { class: "vc-saturation-circle" },
  null,
  -1
  /* HOISTED */
);
const _hoisted_4$4 = [
  _hoisted_3$7
];
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      ref: "container",
      class: "vc-saturation",
      style: normalizeStyle({ background: $options.bgColor }),
      onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
      onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
      onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
    },
    [
      _hoisted_1$8,
      _hoisted_2$8,
      createBaseVNode(
        "div",
        {
          class: "vc-saturation-pointer",
          style: normalizeStyle({ top: $options.pointerTop, left: $options.pointerLeft })
        },
        _hoisted_4$4,
        4
        /* STYLE */
      )
    ],
    36
    /* STYLE, HYDRATE_EVENTS */
  );
}
var css_248z$2 = ".vc-saturation,.vc-saturation--black,.vc-saturation--white{bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0}.vc-saturation--white{background:linear-gradient(90deg,#fff,hsla(0,0%,100%,0))}.vc-saturation--black{background:linear-gradient(0deg,#000,transparent)}.vc-saturation-pointer{cursor:pointer;position:absolute}.vc-saturation-circle{border-radius:50%;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);cursor:head;height:4px;transform:translate(-2px,-2px);width:4px}";
styleInject(css_248z$2);
script$2.render = render$2;
script$2.__file = "src/components/saturation/saturation.vue";
script$2.install = install;
var script$1 = {
  name: "Hue",
  props: {
    value: Object,
    direction: {
      type: String,
      // [horizontal | vertical]
      default: "horizontal"
    }
  },
  data() {
    return {
      oldHue: 0,
      pullDirection: ""
    };
  },
  computed: {
    colors() {
      return this.value;
    },
    directionClass() {
      return {
        "vc-hue--horizontal": this.direction === "horizontal",
        "vc-hue--vertical": this.direction === "vertical"
      };
    },
    pointerTop() {
      if (this.direction === "vertical") {
        if (this.colors.hsl.h === 0 && this.pullDirection === "right")
          return 0;
        return `${-(this.colors.hsl.h * 100 / 360) + 100}%`;
      }
      return 0;
    },
    pointerLeft() {
      if (this.direction === "vertical")
        return 0;
      if (this.colors.hsl.h === 0 && this.pullDirection === "right")
        return "100%";
      return `${this.colors.hsl.h * 100 / 360}%`;
    }
  },
  watch: {
    value: {
      handler(value, oldVal) {
        const { h: h2 } = value.hsl;
        if (h2 !== 0 && h2 - this.oldHue > 0)
          this.pullDirection = "right";
        if (h2 !== 0 && h2 - this.oldHue < 0)
          this.pullDirection = "left";
        this.oldHue = h2;
      },
      deep: true,
      immediate: true
    }
  },
  methods: {
    handleChange(e2, skip) {
      !skip && e2.preventDefault();
      const { container } = this.$refs;
      if (!container) {
        return;
      }
      const containerWidth = container.clientWidth;
      const containerHeight = container.clientHeight;
      const xOffset = container.getBoundingClientRect().left + window.pageXOffset;
      const yOffset = container.getBoundingClientRect().top + window.pageYOffset;
      const pageX = e2.pageX || (e2.touches ? e2.touches[0].pageX : 0);
      const pageY = e2.pageY || (e2.touches ? e2.touches[0].pageY : 0);
      const left = pageX - xOffset;
      const top = pageY - yOffset;
      let h2;
      let percent;
      if (this.direction === "vertical") {
        if (top < 0) {
          h2 = 360;
        } else if (top > containerHeight) {
          h2 = 0;
        } else {
          percent = -(top * 100 / containerHeight) + 100;
          h2 = 360 * percent / 100;
        }
        if (this.colors.hsl.h !== h2) {
          this.$emit("change", {
            h: h2,
            s: this.colors.hsl.s,
            l: this.colors.hsl.l,
            a: this.colors.hsl.a,
            source: "hsl"
          });
        }
      } else {
        if (left < 0) {
          h2 = 0;
        } else if (left > containerWidth) {
          h2 = 360;
        } else {
          percent = left * 100 / containerWidth;
          h2 = 360 * percent / 100;
        }
        if (this.colors.hsl.h !== h2) {
          this.$emit("change", {
            h: h2,
            s: this.colors.hsl.s,
            l: this.colors.hsl.l,
            a: this.colors.hsl.a,
            source: "hsl"
          });
        }
      }
    },
    handleMouseDown(e2) {
      this.handleChange(e2, true);
      window.addEventListener("mousemove", this.handleChange);
      window.addEventListener("mouseup", this.handleChange);
      window.addEventListener("mouseup", this.handleMouseUp);
    },
    handleMouseUp(e2) {
      this.unbindEventListeners();
    },
    unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }
};
const _hoisted_1$7 = ["aria-valuenow"];
const _hoisted_2$7 = /* @__PURE__ */ createBaseVNode(
  "div",
  { class: "vc-hue-picker" },
  null,
  -1
  /* HOISTED */
);
const _hoisted_3$6 = [
  _hoisted_2$7
];
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["vc-hue", [$options.directionClass]])
    },
    [
      createBaseVNode("div", {
        ref: "container",
        class: "vc-hue-container",
        role: "slider",
        "aria-valuenow": $options.colors.hsl.h,
        "aria-valuemin": "0",
        "aria-valuemax": "360",
        onMousedown: _cache[0] || (_cache[0] = (...args) => $options.handleMouseDown && $options.handleMouseDown(...args)),
        onTouchmove: _cache[1] || (_cache[1] = (...args) => $options.handleChange && $options.handleChange(...args)),
        onTouchstart: _cache[2] || (_cache[2] = (...args) => $options.handleChange && $options.handleChange(...args))
      }, [
        createBaseVNode(
          "div",
          {
            class: "vc-hue-pointer",
            style: normalizeStyle({ top: $options.pointerTop, left: $options.pointerLeft }),
            role: "presentation"
          },
          _hoisted_3$6,
          4
          /* STYLE */
        )
      ], 40, _hoisted_1$7)
    ],
    2
    /* CLASS */
  );
}
var css_248z$1 = ".vc-hue{border-radius:2px;bottom:0;left:0;position:absolute;right:0;top:0}.vc-hue--horizontal{background:linear-gradient(90deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue--vertical{background:linear-gradient(0deg,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red)}.vc-hue-container{cursor:pointer;height:100%;margin:0 2px;position:relative}.vc-hue-pointer{position:absolute;z-index:2}.vc-hue-picker{background:#fff;border-radius:1px;box-shadow:0 0 2px rgba(0,0,0,.6);cursor:pointer;height:8px;margin-top:1px;transform:translateX(-2px);width:4px}";
styleInject(css_248z$1);
script$1.render = render$1;
script$1.__file = "src/components/hue/hue.vue";
script$1.install = install;
var script = {
  name: "Chrome",
  components: {
    Saturation: script$2,
    Hue: script$1,
    Alpha: script$4,
    EdIn: script$3,
    Checkboard: script$5
  },
  mixins: [colorMixin],
  props: {
    disableAlpha: {
      type: Boolean,
      default: false
    },
    disableFields: {
      type: Boolean,
      default: false
    },
    format: {
      type: String,
      default: "hex"
    }
  },
  data() {
    return {
      fieldsIndex: "hex",
      highlight: false
    };
  },
  computed: {
    hsl() {
      const { h: h2, s, l } = this.colors.hsl;
      return {
        h: h2.toFixed(),
        s: `${(s * 100).toFixed()}%`,
        l: `${(l * 100).toFixed()}%`
      };
    },
    activeColor() {
      const { rgba } = this.colors;
      return `rgba(${[rgba.r, rgba.g, rgba.b, rgba.a].join(",")})`;
    },
    hasAlpha() {
      return this.colors.a < 1;
    }
  },
  watch: {
    format: {
      handler(val) {
        this.fieldsIndex = val;
      },
      immediate: true
    }
  },
  methods: {
    childChange(data) {
      this.colorChange(data);
    },
    inputChange(data) {
      if (!data)
        return;
      if (data.hex) {
        this.isValidHex(data.hex) && this.colorChange({
          hex: data.hex,
          source: "hex"
        });
      } else if (data.r || data.g || data.b || data.a) {
        this.colorChange({
          r: data.r || this.colors.rgba.r,
          g: data.g || this.colors.rgba.g,
          b: data.b || this.colors.rgba.b,
          a: data.a || this.colors.rgba.a,
          source: "rgba"
        });
      } else if (data.h || data.s || data.l) {
        const s = data.s ? data.s.replace("%", "") / 100 : this.colors.hsl.s;
        const l = data.l ? data.l.replace("%", "") / 100 : this.colors.hsl.l;
        this.colorChange({
          h: data.h || this.colors.hsl.h,
          s,
          l,
          source: "hsl"
        });
      }
    },
    toggleViews() {
      switch (this.fieldsIndex) {
        case "hex":
          this.fieldsIndex = `rgb${this.disableAlpha ? "" : "a"}`;
          break;
        case "rgb":
        case "rgba":
          this.fieldsIndex = `hsl${this.disableAlpha ? "" : "a"}`;
          break;
        default:
          this.fieldsIndex = "hex";
          break;
      }
      this.$emit("update:format", this.fieldsIndex);
    },
    showHighlight() {
      this.highlight = true;
    },
    hideHighlight() {
      this.highlight = false;
    }
  }
};
const _hoisted_1$6 = { class: "vc-chrome-saturation-wrap" };
const _hoisted_2$6 = { class: "vc-chrome-body" };
const _hoisted_3$5 = { class: "vc-chrome-controls" };
const _hoisted_4$3 = { class: "vc-chrome-color-wrap" };
const _hoisted_5 = ["aria-label"];
const _hoisted_6 = { class: "vc-chrome-sliders" };
const _hoisted_7 = { class: "vc-chrome-hue-wrap" };
const _hoisted_8 = {
  key: 0,
  class: "vc-chrome-alpha-wrap"
};
const _hoisted_9 = {
  key: 0,
  class: "vc-chrome-fields-wrap"
};
const _hoisted_10 = { class: "vc-chrome-fields" };
const _hoisted_11 = { class: "vc-chrome-field" };
const _hoisted_12 = { class: "vc-chrome-fields" };
const _hoisted_13 = { class: "vc-chrome-field" };
const _hoisted_14 = { class: "vc-chrome-field" };
const _hoisted_15 = { class: "vc-chrome-field" };
const _hoisted_16 = {
  key: 0,
  class: "vc-chrome-field"
};
const _hoisted_17 = { class: "vc-chrome-fields" };
const _hoisted_18 = { class: "vc-chrome-field" };
const _hoisted_19 = { class: "vc-chrome-field" };
const _hoisted_20 = { class: "vc-chrome-field" };
const _hoisted_21 = {
  key: 0,
  class: "vc-chrome-field"
};
const _hoisted_22 = { class: "vc-chrome-toggle-icon" };
const _hoisted_23 = /* @__PURE__ */ createBaseVNode(
  "path",
  {
    fill: "#333",
    d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z"
  },
  null,
  -1
  /* HOISTED */
);
const _hoisted_24 = [
  _hoisted_23
];
const _hoisted_25 = { class: "vc-chrome-toggle-icon-highlight" };
function render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Saturation = resolveComponent("Saturation");
  const _component_Checkboard = resolveComponent("Checkboard");
  const _component_Hue = resolveComponent("Hue");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_EdIn = resolveComponent("EdIn");
  return openBlock(), createElementBlock(
    "div",
    {
      role: "application",
      "aria-label": "Chrome color picker",
      class: normalizeClass(["vc-chrome", [$props.disableAlpha ? "vc-chrome__disable-alpha" : ""]])
    },
    [
      createBaseVNode("div", _hoisted_1$6, [
        createVNode(_component_Saturation, {
          value: _ctx.colors,
          onChange: $options.childChange
        }, null, 8, ["value", "onChange"])
      ]),
      createBaseVNode("div", _hoisted_2$6, [
        createBaseVNode("div", _hoisted_3$5, [
          createBaseVNode("div", _hoisted_4$3, [
            createBaseVNode("div", {
              "aria-label": `current color is ${_ctx.colors.hex}`,
              class: "vc-chrome-active-color",
              style: normalizeStyle({ background: $options.activeColor })
            }, null, 12, _hoisted_5),
            !$props.disableAlpha ? (openBlock(), createBlock(_component_Checkboard, { key: 0 })) : createCommentVNode("v-if", true)
          ]),
          createBaseVNode("div", _hoisted_6, [
            createBaseVNode("div", _hoisted_7, [
              createVNode(_component_Hue, {
                value: _ctx.colors,
                onChange: $options.childChange
              }, null, 8, ["value", "onChange"])
            ]),
            !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_8, [
              createVNode(_component_Alpha, {
                value: _ctx.colors,
                onChange: $options.childChange
              }, null, 8, ["value", "onChange"])
            ])) : createCommentVNode("v-if", true)
          ])
        ]),
        !$props.disableFields ? (openBlock(), createElementBlock("div", _hoisted_9, [
          withDirectives(createBaseVNode(
            "div",
            _hoisted_10,
            [
              createCommentVNode(" hex "),
              createBaseVNode("div", _hoisted_11, [
                !$options.hasAlpha ? (openBlock(), createBlock(_component_EdIn, {
                  key: 0,
                  label: "hex",
                  value: _ctx.colors.hex,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])) : createCommentVNode("v-if", true),
                $options.hasAlpha ? (openBlock(), createBlock(_component_EdIn, {
                  key: 1,
                  label: "hex",
                  value: _ctx.colors.hex8,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])) : createCommentVNode("v-if", true)
              ])
            ],
            512
            /* NEED_PATCH */
          ), [
            [vShow, $data.fieldsIndex === "hex"]
          ]),
          withDirectives(createBaseVNode(
            "div",
            _hoisted_12,
            [
              createCommentVNode(" rgba "),
              createBaseVNode("div", _hoisted_13, [
                createVNode(_component_EdIn, {
                  label: "r",
                  value: _ctx.colors.rgba.r,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              createBaseVNode("div", _hoisted_14, [
                createVNode(_component_EdIn, {
                  label: "g",
                  value: _ctx.colors.rgba.g,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              createBaseVNode("div", _hoisted_15, [
                createVNode(_component_EdIn, {
                  label: "b",
                  value: _ctx.colors.rgba.b,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_16, [
                createVNode(_component_EdIn, {
                  label: "a",
                  value: _ctx.colors.a,
                  "arrow-offset": 0.01,
                  max: 1,
                  onChange: $options.inputChange
                }, null, 8, ["value", "arrow-offset", "onChange"])
              ])) : createCommentVNode("v-if", true)
            ],
            512
            /* NEED_PATCH */
          ), [
            [vShow, ["rgb", "rgba"].includes($data.fieldsIndex)]
          ]),
          withDirectives(createBaseVNode(
            "div",
            _hoisted_17,
            [
              createCommentVNode(" hsla "),
              createBaseVNode("div", _hoisted_18, [
                createVNode(_component_EdIn, {
                  label: "h",
                  value: $options.hsl.h,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              createBaseVNode("div", _hoisted_19, [
                createVNode(_component_EdIn, {
                  label: "s",
                  value: $options.hsl.s,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              createBaseVNode("div", _hoisted_20, [
                createVNode(_component_EdIn, {
                  label: "l",
                  value: $options.hsl.l,
                  onChange: $options.inputChange
                }, null, 8, ["value", "onChange"])
              ]),
              !$props.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_21, [
                createVNode(_component_EdIn, {
                  label: "a",
                  value: _ctx.colors.a,
                  "arrow-offset": 0.01,
                  max: 1,
                  onChange: $options.inputChange
                }, null, 8, ["value", "arrow-offset", "onChange"])
              ])) : createCommentVNode("v-if", true)
            ],
            512
            /* NEED_PATCH */
          ), [
            [vShow, ["hsl", "hsla"].includes($data.fieldsIndex)]
          ]),
          createCommentVNode(" btn "),
          createBaseVNode("div", {
            class: "vc-chrome-toggle-btn",
            role: "button",
            "aria-label": "Change another color definition",
            onClick: _cache[3] || (_cache[3] = (...args) => $options.toggleViews && $options.toggleViews(...args))
          }, [
            createBaseVNode("div", _hoisted_22, [
              (openBlock(), createElementBlock(
                "svg",
                {
                  style: { "width": "24px", "height": "24px" },
                  viewBox: "0 0 24 24",
                  onMouseover: _cache[0] || (_cache[0] = (...args) => $options.showHighlight && $options.showHighlight(...args)),
                  onMouseenter: _cache[1] || (_cache[1] = (...args) => $options.showHighlight && $options.showHighlight(...args)),
                  onMouseout: _cache[2] || (_cache[2] = (...args) => $options.hideHighlight && $options.hideHighlight(...args))
                },
                _hoisted_24,
                32
                /* HYDRATE_EVENTS */
              ))
            ]),
            withDirectives(createBaseVNode(
              "div",
              _hoisted_25,
              null,
              512
              /* NEED_PATCH */
            ), [
              [vShow, $data.highlight]
            ])
          ]),
          createCommentVNode(" btn ")
        ])) : createCommentVNode("v-if", true)
      ])
    ],
    2
    /* CLASS */
  );
}
var css_248z = ".vc-chrome{background:#fff;background-color:#fff;border-radius:2px;box-shadow:0 0 2px rgba(0,0,0,.3),0 4px 8px rgba(0,0,0,.3);box-sizing:initial;font-family:Menlo;width:225px}.vc-chrome-controls{display:flex}.vc-chrome-color-wrap{position:relative;width:36px}.vc-chrome-active-color{border-radius:15px;height:30px;overflow:hidden;position:relative;width:30px;z-index:1}.vc-chrome-color-wrap .vc-checkerboard{background-size:auto;border-radius:15px;height:30px;width:30px}.vc-chrome-sliders{flex:1}.vc-chrome-fields-wrap{display:flex;padding-top:16px}.vc-chrome-fields{display:flex;flex:1;margin-left:-6px}.vc-chrome-field{padding-left:6px;width:100%}.vc-chrome-toggle-btn{position:relative;text-align:right;width:32px}.vc-chrome-toggle-icon{cursor:pointer;margin-right:-4px;margin-top:12px;position:relative;z-index:2}.vc-chrome-toggle-icon-highlight{background:#eee;border-radius:4px;height:28px;left:12px;position:absolute;top:10px;width:24px}.vc-chrome-hue-wrap{margin-bottom:8px}.vc-chrome-alpha-wrap,.vc-chrome-hue-wrap{height:10px;position:relative}.vc-chrome-alpha-wrap .vc-alpha-gradient,.vc-chrome-hue-wrap .vc-hue{border-radius:2px}.vc-chrome-alpha-wrap .vc-alpha-picker,.vc-chrome-hue-wrap .vc-hue-picker{background-color:#f8f8f8;border-radius:6px;box-shadow:0 1px 4px 0 rgba(0,0,0,.37);height:12px;transform:translate(-6px,-2px);width:12px}.vc-chrome-body{background-color:#fff;padding:16px 16px 12px}.vc-chrome-saturation-wrap{border-radius:2px 2px 0 0;overflow:hidden;padding-bottom:55%;position:relative;width:100%}.vc-chrome-saturation-wrap .vc-saturation-circle{height:12px;width:12px}.vc-chrome-fields .vc-input__input{border:none;border-radius:2px;box-shadow:inset 0 0 0 1px #dadada;color:#333;font-size:11px;height:21px;text-align:center;width:100%}.vc-chrome-fields .vc-input__label{color:#969696;display:block;font-size:11px;line-height:11px;margin-top:12px;text-align:center;text-transform:uppercase}.vc-chrome__disable-alpha .vc-chrome-active-color{height:18px;width:18px}.vc-chrome__disable-alpha .vc-chrome-color-wrap{width:30px}.vc-chrome__disable-alpha .vc-chrome-hue-wrap{margin-bottom:4px;margin-top:4px}";
styleInject(css_248z);
script.render = render;
script.__file = "src/components/chrome/chrome.vue";
script.install = install;
register();
const _hoisted_1$5 = ["aria-label"];
const _hoisted_2$5 = {
  key: 0,
  class: "color-picker__simple"
};
const _hoisted_3$4 = ["aria-label", "name", "checked", "onClick"];
const _hoisted_4$2 = {
  key: 0,
  class: "color-picker__navigation"
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "NcColorPicker",
  props: /* @__PURE__ */ mergeModels({
    advancedFields: { type: Boolean },
    container: { default: "body" },
    palette: { default: () => [...defaultPalette] },
    paletteOnly: { type: Boolean }
  }, {
    "modelValue": { required: true },
    "modelModifiers": {},
    "open": { type: Boolean },
    "openModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["submit", "closed"], ["update:modelValue", "update:open"]),
  setup(__props, { emit: __emit }) {
    const HEX_REGEX = /^#([a-f0-9]{3}|[a-f0-9]{6})$/i;
    const props = __props;
    const currentColor = useModel(__props, "modelValue");
    const open = useModel(__props, "open");
    const emit2 = __emit;
    const id = createElementId();
    const advanced = ref(false);
    const normalizedPalette = computed(() => {
      let palette = props.palette;
      for (const color of palette) {
        if (typeof color === "string" && !color.match(HEX_REGEX) || typeof color === "object" && !color.color?.match(HEX_REGEX)) {
          logger.error("[NcColorPicker] Invalid palette passed", { color });
          palette = [...defaultPalette];
          break;
        }
      }
      return palette.map((item) => ({
        color: typeof item === "object" ? item.color : item,
        name: typeof item === "object" && item.name ? item.name : t("A color with a HEX value {hex}", { hex: item.color })
      }));
    });
    const contrastColor = computed(() => {
      const black = "#000000";
      const white = "#FFFFFF";
      return calculateLuma(currentColor.value) > 0.5 ? black : white;
    });
    function handleConfirm(hideCallback) {
      emit2("submit", currentColor.value);
      hideCallback();
      advanced.value = false;
    }
    function pickColor(color) {
      if (typeof color !== "string") {
        color = "hex" in color ? color.hex : color.color;
      }
      currentColor.value = color;
    }
    function calculateLuma(color) {
      const [red, green, blue] = hexToRGB(color);
      return (0.2126 * red + 0.7152 * green + 0.0722 * blue) / 255;
    }
    function hexToRGB(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!result) {
        return [0, 0, 0];
      }
      return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(NcPopover), {
        shown: open.value,
        "onUpdate:shown": _cache[3] || (_cache[3] = ($event) => open.value = $event),
        container: _ctx.container,
        "popup-role": "dialog",
        onApplyHide: _cache[4] || (_cache[4] = ($event) => emit2("closed"))
      }, {
        trigger: withCtx((slotProps) => [
          renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(slotProps)), void 0, true)
        ]),
        default: withCtx((slotProps) => [
          createBaseVNode("div", {
            role: "dialog",
            class: normalizeClass(["color-picker", { "color-picker--advanced-fields": advanced.value && _ctx.advancedFields }]),
            "aria-modal": "true",
            "aria-label": unref(t)("Color picker")
          }, [
            createVNode(Transition, {
              name: "slide",
              mode: "out-in"
            }, {
              default: withCtx(() => [
                !advanced.value ? (openBlock(), createElementBlock("div", _hoisted_2$5, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(normalizedPalette.value, ({ color, name }, index2) => {
                    return openBlock(), createElementBlock("label", {
                      key: index2,
                      class: normalizeClass(["color-picker__simple-color-circle", { "color-picker__simple-color-circle--active": color === currentColor.value }]),
                      style: normalizeStyle({
                        backgroundColor: color,
                        color: contrastColor.value
                      })
                    }, [
                      color === currentColor.value ? (openBlock(), createBlock(unref(NcIconSvgWrapper), {
                        key: 0,
                        path: unref(mdiCheck)
                      }, null, 8, ["path"])) : createCommentVNode("", true),
                      createBaseVNode("input", {
                        type: "radio",
                        class: "hidden-visually",
                        "aria-label": name,
                        name: `color-picker-${unref(id)}`,
                        checked: color === currentColor.value,
                        onClick: ($event) => pickColor(color)
                      }, null, 8, _hoisted_3$4)
                    ], 6);
                  }), 128))
                ])) : (openBlock(), createBlock(unref(script), {
                  key: 1,
                  modelValue: currentColor.value,
                  "onUpdate:modelValue": [
                    _cache[0] || (_cache[0] = ($event) => currentColor.value = $event),
                    pickColor
                  ],
                  class: "color-picker__advanced",
                  "disable-alpha": true,
                  "disable-fields": !_ctx.advancedFields
                }, null, 8, ["modelValue", "disable-fields"]))
              ]),
              _: 1
            }),
            !_ctx.paletteOnly ? (openBlock(), createElementBlock("div", _hoisted_4$2, [
              advanced.value ? (openBlock(), createBlock(unref(NcButton), {
                key: 0,
                "aria-label": unref(t)("Back"),
                variant: "tertiary",
                onClick: _cache[1] || (_cache[1] = ($event) => advanced.value = false)
              }, {
                icon: withCtx(() => [
                  createVNode(unref(NcIconSvgWrapper), {
                    directional: "",
                    path: unref(mdiArrowLeft)
                  }, null, 8, ["path"])
                ]),
                _: 1
              }, 8, ["aria-label"])) : (openBlock(), createBlock(unref(NcButton), {
                key: 1,
                "aria-label": unref(t)("More options"),
                variant: "tertiary",
                onClick: _cache[2] || (_cache[2] = ($event) => advanced.value = true)
              }, {
                icon: withCtx(() => [
                  createVNode(unref(NcIconSvgWrapper), { path: unref(mdiDotsHorizontal) }, null, 8, ["path"])
                ]),
                _: 1
              }, 8, ["aria-label"])),
              createVNode(unref(NcButton), {
                variant: "primary",
                onClick: ($event) => handleConfirm(slotProps.hide)
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(t)("Choose")), 1)
                ]),
                _: 2
              }, 1032, ["onClick"])
            ])) : createCommentVNode("", true)
          ], 10, _hoisted_1$5)
        ]),
        _: 3
      }, 8, ["shown", "container"]);
    };
  }
});
const NcColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-3ec4b698"]]);
register();
const contentSvg = '<!--\n  - SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n  - SPDX-License-Identifier: AGPL-3.0-or-later\n-->\n<svg width="395" height="314" viewBox="0 0 395 314" fill="none" xmlns="http://www.w3.org/2000/svg">\n<rect width="395" height="314" rx="11" fill="#439DCD"/>\n<rect x="13" y="51" width="366" height="248" rx="8" fill="white"/>\n<rect x="22" y="111" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="127" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="63" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="191" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="143" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="79" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="159" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="95" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="175" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<path d="M288 145C277.56 147.8 265.32 149 254 149C242.68 149 230.44 147.8 220 145L218 153C225.44 155 234 156.32 242 157V209H250V185H258V209H266V157C274 156.32 282.56 155 290 153L288 145ZM254 145C258.4 145 262 141.4 262 137C262 132.6 258.4 129 254 129C249.6 129 246 132.6 246 137C246 141.4 249.6 145 254 145Z" fill="#DEDEDE"/>\n<path d="M43.5358 13C38.6641 13 34.535 16.2415 33.2552 20.6333C32.143 18.3038 29.7327 16.6718 26.9564 16.6718C23.1385 16.6718 20 19.7521 20 23.4993C20 27.2465 23.1385 30.3282 26.9564 30.3282C29.7327 30.3282 32.1429 28.6952 33.2552 26.3653C34.535 30.7575 38.6641 34 43.5358 34C48.3715 34 52.4796 30.8064 53.7921 26.4637C54.9249 28.7407 57.3053 30.3282 60.0421 30.3282C63.8601 30.3282 67 27.2465 67 23.4993C67 19.7521 63.8601 16.6718 60.0421 16.6718C57.3053 16.6718 54.9249 18.2583 53.7921 20.5349C52.4796 16.1926 48.3715 13 43.5358 13ZM43.5358 17.0079C47.2134 17.0079 50.1512 19.8899 50.1512 23.4993C50.1512 27.1087 47.2134 29.9921 43.5358 29.9921C39.8583 29.9921 36.9218 27.1087 36.9218 23.4993C36.9218 19.8899 39.8583 17.0079 43.5358 17.0079ZM26.9564 20.6797C28.5677 20.6797 29.8307 21.9179 29.8307 23.4993C29.8307 25.0807 28.5677 26.3203 26.9564 26.3203C25.3452 26.3203 24.0836 25.0807 24.0836 23.4993C24.0836 21.9179 25.3452 20.6797 26.9564 20.6797ZM60.0421 20.6797C61.6534 20.6797 62.9164 21.9179 62.9164 23.4993C62.9164 25.0807 61.6534 26.3203 60.0421 26.3203C58.4309 26.3203 57.1693 25.0807 57.1693 23.4993C57.1693 21.9179 58.4309 20.6797 60.0421 20.6797Z" fill="white"/>\n<rect x="79" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="99" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="119" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="139" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="159" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="179" y="20" width="8" height="8" rx="4" fill="white"/>\n<path fill-rule="evenodd" clip-rule="evenodd" d="M12 0C5.37258 0 0 5.37259 0 12V302C0 308.627 5.37259 314 12 314H383C389.627 314 395 308.627 395 302V12C395 5.37258 389.627 0 383 0H12ZM140 44C132.268 44 126 50.268 126 58V292C126 299.732 132.268 306 140 306H372C379.732 306 386 299.732 386 292V58C386 50.268 379.732 44 372 44H140Z" fill="black" fill-opacity="0.35"/>\n</svg>\n';
const navigationSvg = '<!--\n  - SPDX-FileCopyrightText: 2023 Nextcloud GmbH and Nextcloud contributors\n  - SPDX-License-Identifier: AGPL-3.0-or-later\n-->\n<svg width="395" height="314" viewBox="0 0 395 314" fill="none" xmlns="http://www.w3.org/2000/svg">\n<rect width="395" height="314" rx="11" fill="#439DCD"/>\n<rect x="13" y="51" width="366" height="248" rx="8" fill="white"/>\n<rect x="22" y="111" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="127" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="63" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="191" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="143" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="79" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="159" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="95" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<rect x="22" y="175" width="92" height="12" rx="6" fill="#DEDEDE"/>\n<path d="M288 145C277.56 147.8 265.32 149 254 149C242.68 149 230.44 147.8 220 145L218 153C225.44 155 234 156.32 242 157V209H250V185H258V209H266V157C274 156.32 282.56 155 290 153L288 145ZM254 145C258.4 145 262 141.4 262 137C262 132.6 258.4 129 254 129C249.6 129 246 132.6 246 137C246 141.4 249.6 145 254 145Z" fill="#DEDEDE"/>\n<path d="M43.5358 13C38.6641 13 34.535 16.2415 33.2552 20.6333C32.143 18.3038 29.7327 16.6718 26.9564 16.6718C23.1385 16.6718 20 19.7521 20 23.4993C20 27.2465 23.1385 30.3282 26.9564 30.3282C29.7327 30.3282 32.1429 28.6952 33.2552 26.3653C34.535 30.7575 38.6641 34 43.5358 34C48.3715 34 52.4796 30.8064 53.7921 26.4637C54.9249 28.7407 57.3053 30.3282 60.0421 30.3282C63.8601 30.3282 67 27.2465 67 23.4993C67 19.7521 63.8601 16.6718 60.0421 16.6718C57.3053 16.6718 54.9249 18.2583 53.7921 20.5349C52.4796 16.1926 48.3715 13 43.5358 13ZM43.5358 17.0079C47.2134 17.0079 50.1512 19.8899 50.1512 23.4993C50.1512 27.1087 47.2134 29.9921 43.5358 29.9921C39.8583 29.9921 36.9218 27.1087 36.9218 23.4993C36.9218 19.8899 39.8583 17.0079 43.5358 17.0079ZM26.9564 20.6797C28.5677 20.6797 29.8307 21.9179 29.8307 23.4993C29.8307 25.0807 28.5677 26.3203 26.9564 26.3203C25.3452 26.3203 24.0836 25.0807 24.0836 23.4993C24.0836 21.9179 25.3452 20.6797 26.9564 20.6797ZM60.0421 20.6797C61.6534 20.6797 62.9164 21.9179 62.9164 23.4993C62.9164 25.0807 61.6534 26.3203 60.0421 26.3203C58.4309 26.3203 57.1693 25.0807 57.1693 23.4993C57.1693 21.9179 58.4309 20.6797 60.0421 20.6797Z" fill="white"/>\n<rect x="79" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="99" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="119" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="139" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="159" y="20" width="8" height="8" rx="4" fill="white"/>\n<rect x="179" y="20" width="8" height="8" rx="4" fill="white"/>\n<path fill-rule="evenodd" clip-rule="evenodd" d="M12 0C5.37258 0 0 5.37259 0 12V302C0 308.627 5.37259 314 12 314H383C389.627 314 395 308.627 395 302V12C395 5.37258 389.627 0 383 0H12ZM112 44C119.732 44 126 50.268 126 58V292C126 299.732 119.732 306 112 306H20C12.268 306 6 299.732 6 292V58C6 50.268 12.268 44 20 44H112Z" fill="black" fill-opacity="0.35"/>\n</svg>\n';
const _hoisted_1$4 = { class: "vue-skip-actions__container" };
const _hoisted_2$4 = { class: "vue-skip-actions__headline" };
const _hoisted_3$3 = { class: "vue-skip-actions__buttons" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "NcContent",
  props: {
    appName: {}
  },
  setup(__props) {
    const props = __props;
    provide("NcContent:setHasAppNavigation", setAppNavigation);
    provide("NcContent:selector", "#content-vue");
    provide("appName", computed(() => props.appName));
    const isMobile = useIsMobile();
    const hasAppNavigation = ref(false);
    const currentFocus = ref();
    const currentImage = computed(() => currentFocus.value === "navigation" ? navigationSvg : contentSvg);
    onBeforeMount(() => {
      const container = document.getElementById("skip-actions");
      if (container) {
        container.innerHTML = "";
        container.classList.add("vue-skip-actions");
      }
    });
    function openAppNavigation() {
      emit("toggle-navigation", { open: true });
      nextTick(() => {
        window.location.hash = "app-navigation-vue";
        document.getElementById("app-navigation-vue").focus();
      });
    }
    function setAppNavigation(value) {
      hasAppNavigation.value = value;
      if (!currentFocus.value) {
        currentFocus.value = "navigation";
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        id: "content-vue",
        class: normalizeClass(["content", `app-${_ctx.appName.toLowerCase()}`])
      }, [
        (openBlock(), createBlock(Teleport, { to: "#skip-actions" }, [
          createBaseVNode("div", _hoisted_1$4, [
            createBaseVNode("div", _hoisted_2$4, toDisplayString(unref(t)("Keyboard navigation help")), 1),
            createBaseVNode("div", _hoisted_3$3, [
              withDirectives(createVNode(NcButton, {
                href: "#app-navigation-vue",
                variant: "tertiary",
                onClick: withModifiers(openAppNavigation, ["prevent"]),
                onFocusin: _cache[0] || (_cache[0] = ($event) => currentFocus.value = "navigation"),
                onMouseover: _cache[1] || (_cache[1] = ($event) => currentFocus.value = "navigation")
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(t)("Skip to app navigation")), 1)
                ]),
                _: 1
              }, 512), [
                [vShow, hasAppNavigation.value]
              ]),
              createVNode(NcButton, {
                href: "#app-content-vue",
                variant: "tertiary",
                onFocusin: _cache[2] || (_cache[2] = ($event) => currentFocus.value = "content"),
                onMouseover: _cache[3] || (_cache[3] = ($event) => currentFocus.value = "content")
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(unref(t)("Skip to main content")), 1)
                ]),
                _: 1
              })
            ]),
            withDirectives(createVNode(NcIconSvgWrapper, {
              class: "vue-skip-actions__image",
              svg: currentImage.value,
              size: "auto"
            }, null, 8, ["svg"]), [
              [vShow, !unref(isMobile)]
            ])
          ])
        ])),
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    };
  }
});
const NcContent = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-225e6d1b"]]);
const millisecondsInWeek = 6048e5;
const millisecondsInDay = 864e5;
const millisecondsInMinute = 6e4;
const millisecondsInHour = 36e5;
const millisecondsInSecond = 1e3;
const constructFromSymbol = Symbol.for("constructDateFrom");
function constructFrom(date, value) {
  if (typeof date === "function") return date(value);
  if (date && typeof date === "object" && constructFromSymbol in date)
    return date[constructFromSymbol](value);
  if (date instanceof Date) return new date.constructor(value);
  return new Date(value);
}
function toDate(argument, context) {
  return constructFrom(context || argument, argument);
}
function addDays(date, amount, options) {
  const _date = toDate(date, options?.in);
  if (isNaN(amount)) return constructFrom(options?.in || date, NaN);
  if (!amount) return _date;
  _date.setDate(_date.getDate() + amount);
  return _date;
}
function addMonths(date, amount, options) {
  const _date = toDate(date, options?.in);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  const dayOfMonth = _date.getDate();
  const endOfDesiredMonth = constructFrom(date, _date.getTime());
  endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
  const daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    _date.setFullYear(
      endOfDesiredMonth.getFullYear(),
      endOfDesiredMonth.getMonth(),
      dayOfMonth
    );
    return _date;
  }
}
function add(date, duration, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0
  } = duration;
  const _date = toDate(date, options?.in);
  const dateWithMonths = months || years ? addMonths(_date, months + years * 12) : _date;
  const dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
  const minutesToAdd = minutes + hours * 60;
  const secondsToAdd = seconds + minutesToAdd * 60;
  const msToAdd = secondsToAdd * 1e3;
  return constructFrom(date, +dateWithDays + msToAdd);
}
function addMilliseconds(date, amount, options) {
  return constructFrom(date, +toDate(date) + amount);
}
function addHours(date, amount, options) {
  return addMilliseconds(date, amount * millisecondsInHour);
}
let defaultOptions = {};
function getDefaultOptions$1() {
  return defaultOptions;
}
function startOfWeek(date, options) {
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}
function getISOWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}
function normalizeDates(context, ...dates) {
  const normalize = constructFrom.bind(
    null,
    dates.find((date) => typeof date === "object")
  );
  return dates.map(normalize);
}
function startOfDay(date, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function differenceInCalendarDays(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const laterStartOfDay = startOfDay(laterDate_);
  const earlierStartOfDay = startOfDay(earlierDate_);
  const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
  const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
  return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
}
function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}
function addQuarters(date, amount, options) {
  return addMonths(date, amount * 3, options);
}
function addYears(date, amount, options) {
  return addMonths(date, amount * 12, options);
}
function compareAsc(dateLeft, dateRight) {
  const diff = +toDate(dateLeft) - +toDate(dateRight);
  if (diff < 0) return -1;
  else if (diff > 0) return 1;
  return diff;
}
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(date) {
  return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
}
function getQuarter(date, options) {
  const _date = toDate(date, options?.in);
  const quarter = Math.trunc(_date.getMonth() / 3) + 1;
  return quarter;
}
function differenceInCalendarYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() - earlierDate_.getFullYear();
}
function differenceInYears(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const sign = compareAsc(laterDate_, earlierDate_);
  const diff = Math.abs(differenceInCalendarYears(laterDate_, earlierDate_));
  laterDate_.setFullYear(1584);
  earlierDate_.setFullYear(1584);
  const partial = compareAsc(laterDate_, earlierDate_) === -sign;
  const result = sign * (diff - +partial);
  return result === 0 ? 0 : result;
}
function normalizeInterval(context, interval) {
  const [start, end] = normalizeDates(context, interval.start, interval.end);
  return { start, end };
}
function eachDayOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options?.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +start : +end;
  const date = reversed ? end : start;
  date.setHours(0, 0, 0, 0);
  let step = 1;
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start, date));
    date.setDate(date.getDate() + step);
    date.setHours(0, 0, 0, 0);
  }
  return reversed ? dates.reverse() : dates;
}
function startOfQuarter(date, options) {
  const _date = toDate(date, options?.in);
  const currentMonth = _date.getMonth();
  const month = currentMonth - currentMonth % 3;
  _date.setMonth(month, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function eachQuarterOfInterval(interval, options) {
  const { start, end } = normalizeInterval(options?.in, interval);
  let reversed = +start > +end;
  const endTime = reversed ? +startOfQuarter(start) : +startOfQuarter(end);
  let date = reversed ? startOfQuarter(end) : startOfQuarter(start);
  let step = 1;
  const dates = [];
  while (+date <= endTime) {
    dates.push(constructFrom(start, date));
    date = addQuarters(date, step);
  }
  return reversed ? dates.reverse() : dates;
}
function startOfMonth(date, options) {
  const _date = toDate(date, options?.in);
  _date.setDate(1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}
function endOfYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  _date.setFullYear(year + 1, 0, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function startOfYear(date, options) {
  const date_ = toDate(date, options?.in);
  date_.setFullYear(date_.getFullYear(), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}
function endOfWeek(date, options) {
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const _date = toDate(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  _date.setDate(_date.getDate() + diff);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
function endOfQuarter(date, options) {
  const _date = toDate(date, options?.in);
  const currentMonth = _date.getMonth();
  const month = currentMonth - currentMonth % 3 + 3;
  _date.setMonth(month, 0);
  _date.setHours(23, 59, 59, 999);
  return _date;
}
const formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
const formatDistance = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
const dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
const timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
const dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
const formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = options?.context ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = options?.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = options?.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index2 = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index2];
  };
}
const eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
const quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
const monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
const dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
const dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
const formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
const ordinalNumber = (dirtyNumber, _options) => {
  const number = Number(dirtyNumber);
  const rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
const localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // [TODO] -- I challenge you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // [TODO] -- I challenge you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
const parseOrdinalNumberPattern = /\d+/i;
const matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
const parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
const matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
const parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
const matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
const parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
const matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
const parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
const matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
const parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
const match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function getDayOfYear(date, options) {
  const _date = toDate(date, options?.in);
  const diff = differenceInCalendarDays(_date, startOfYear(_date));
  const dayOfYear = diff + 1;
  return dayOfYear;
}
function getISOWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function getWeekYear(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const defaultOptions2 = getDefaultOptions$1();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const firstWeekOfNextYear = constructFrom(options?.in || date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(options?.in || date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (+_date >= +startOfNextYear) {
    return year + 1;
  } else if (+_date >= +startOfThisYear) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(date, options) {
  const defaultOptions2 = getDefaultOptions$1();
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(options?.in || date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}
function getWeek(date, options) {
  const _date = toDate(date, options?.in);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}
function addLeadingZeros(number, targetLength) {
  const sign = number < 0 ? "-" : "";
  const output = Math.abs(number).toString().padStart(targetLength, "0");
  return sign + output;
}
const lightFormatters = {
  // Year
  y(date, token) {
    const signedYear = date.getFullYear();
    const year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M(date, token) {
    const month = date.getMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d(date, token) {
    return addLeadingZeros(date.getDate(), token.length);
  },
  // AM or PM
  a(date, token) {
    const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(date, token) {
    return addLeadingZeros(date.getHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H(date, token) {
    return addLeadingZeros(date.getHours(), token.length);
  },
  // Minute
  m(date, token) {
    return addLeadingZeros(date.getMinutes(), token.length);
  },
  // Second
  s(date, token) {
    return addLeadingZeros(date.getSeconds(), token.length);
  },
  // Fraction of second
  S(date, token) {
    const numberOfDigits = token.length;
    const milliseconds = date.getMilliseconds();
    const fractionalSeconds = Math.trunc(
      milliseconds * Math.pow(10, numberOfDigits - 3)
    );
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
const dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
const formatters = {
  // Era
  G: function(date, token, localize2) {
    const era = date.getFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, { width: "abbreviated" });
      // A, B
      case "GGGGG":
        return localize2.era(era, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, { width: "wide" });
    }
  },
  // Year
  y: function(date, token, localize2) {
    if (token === "yo") {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, { unit: "year" });
    }
    return lightFormatters.y(date, token);
  },
  // Local week-numbering year
  Y: function(date, token, localize2, options) {
    const signedWeekYear = getWeekYear(date, options);
    const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      const twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, { unit: "year" });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function(date, token) {
    const isoWeekYear = getISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(date, token) {
    const year = date.getFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(date, token, localize2) {
    const quarter = Math.ceil((date.getMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(date, token, localize2) {
    const month = date.getMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, { unit: "month" });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(date, token, localize2, options) {
    const week = getWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, { unit: "week" });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function(date, token, localize2) {
    const isoWeek = getISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, { unit: "week" });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getDate(), { unit: "date" });
    }
    return lightFormatters.d(date, token);
  },
  // Day of year
  D: function(date, token, localize2) {
    const dayOfYear = getDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(date, token, localize2, options) {
    const dayOfWeek = date.getDay();
    const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(date, token, localize2) {
    const dayOfWeek = date.getDay();
    const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(date, token, localize2) {
    const hours = date.getHours();
    const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(date, token, localize2) {
    const hours = date.getHours();
    let dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(date, token, localize2) {
    if (token === "ho") {
      let hours = date.getHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return lightFormatters.h(date, token);
  },
  // Hour [0-23]
  H: function(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
    }
    return lightFormatters.H(date, token);
  },
  // Hour [0-11]
  K: function(date, token, localize2) {
    const hours = date.getHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function(date, token, localize2) {
    let hours = date.getHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, { unit: "hour" });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
    }
    return lightFormatters.m(date, token);
  },
  // Second
  s: function(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
    }
    return lightFormatters.s(date, token);
  },
  // Fraction of second
  S: function(date, token) {
    return lightFormatters.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(date, token, _localize) {
    const timezoneOffset = date.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function(date, token, _localize) {
    const timestamp = Math.trunc(+date / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function(date, token, _localize) {
    return addLeadingZeros(+date, token.length);
  }
};
function formatTimezoneShort(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = Math.trunc(absOffset / 60);
  const minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, delimiter) {
  if (offset % 60 === 0) {
    const sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, delimiter);
}
function formatTimezone(offset, delimiter = "") {
  const sign = offset > 0 ? "-" : "+";
  const absOffset = Math.abs(offset);
  const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
  const minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
const dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
const timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
const dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
const longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const dayOfYearTokenRE = /^D+$/;
const weekYearTokenRE = /^Y+$/;
const throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp$1 = /^'([^]*?)'?$/;
const doubleQuoteRegExp$1 = /''/g;
const unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(date, formatStr, options) {
  const defaultOptions2 = getDefaultOptions$1();
  const locale = options?.locale ?? defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const originalDate = toDate(date, options?.in);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  let parts = formatStr.match(longFormattingTokensRegExp$1).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map((substring) => {
    if (substring === "''") {
      return { isToken: false, value: "'" };
    }
    const firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return { isToken: false, value: cleanEscapedString$1(substring) };
    }
    if (formatters[firstCharacter]) {
      return { isToken: true, value: substring };
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
      );
    }
    return { isToken: false, value: substring };
  });
  if (locale.localize.preprocessor) {
    parts = locale.localize.preprocessor(originalDate, parts);
  }
  const formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  return parts.map((part) => {
    if (!part.isToken) return part.value;
    const token = part.value;
    if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token) || !options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, String(date));
    }
    const formatter = formatters[token[0]];
    return formatter(originalDate, token, locale.localize, formatterOptions);
  }).join("");
}
function cleanEscapedString$1(input) {
  const matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function getDay(date, options) {
  return toDate(date, options?.in).getDay();
}
function getDaysInMonth(date, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const monthIndex = _date.getMonth();
  const lastDayOfMonth = constructFrom(_date, 0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function getDefaultOptions() {
  return Object.assign({}, getDefaultOptions$1());
}
function getHours(date, options) {
  return toDate(date, options?.in).getHours();
}
function getISODay(date, options) {
  const day = toDate(date, options?.in).getDay();
  return day === 0 ? 7 : day;
}
function getMinutes(date, options) {
  return toDate(date, options?.in).getMinutes();
}
function getMonth(date, options) {
  return toDate(date, options?.in).getMonth();
}
function getSeconds(date) {
  return toDate(date).getSeconds();
}
function getYear(date, options) {
  return toDate(date, options?.in).getFullYear();
}
function isAfter(date, dateToCompare) {
  return +toDate(date) > +toDate(dateToCompare);
}
function isBefore(date, dateToCompare) {
  return +toDate(date) < +toDate(dateToCompare);
}
function isEqual(leftDate, rightDate) {
  return +toDate(leftDate) === +toDate(rightDate);
}
function transpose(date, constructor) {
  const date_ = isConstructor(constructor) ? new constructor(0) : constructFrom(constructor, 0);
  date_.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
  date_.setHours(
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  );
  return date_;
}
function isConstructor(constructor) {
  return typeof constructor === "function" && constructor.prototype?.constructor === constructor;
}
const TIMEZONE_UNIT_PRIORITY = 10;
class Setter {
  subPriority = 0;
  validate(_utcDate, _options) {
    return true;
  }
}
class ValueSetter extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }
  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
}
class DateTimezoneSetter extends Setter {
  priority = TIMEZONE_UNIT_PRIORITY;
  subPriority = -1;
  constructor(context, reference) {
    super();
    this.context = context || ((date) => constructFrom(reference, date));
  }
  set(date, flags) {
    if (flags.timestampIsSet) return date;
    return constructFrom(date, transpose(date, this.context));
  }
}
class Parser {
  run(dateString, token, match2, options) {
    const result = this.parse(dateString, token, match2, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
}
class EraParser extends Parser {
  priority = 140;
  parse(dateString, token, match2) {
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      // A, B
      case "GGGGG":
        return match2.era(dateString, { width: "narrow" });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
    }
  }
  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["R", "u", "t", "T"];
}
const numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
const timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
class YearParser extends Parser {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value) {
    const currentYear = date.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}
class LocalWeekYearParser extends Parser {
  priority = 130;
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value, options) {
    const currentYear = getWeekYear(date, options);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate
      );
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return startOfWeek(date, options);
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T"
  ];
}
class ISOWeekYearParser extends Parser {
  priority = 130;
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    const firstWeekOfYear = constructFrom(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
  incompatibleTokens = [
    "G",
    "y",
    "Y",
    "u",
    "Q",
    "q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T"
  ];
}
class ExtendedYearParser extends Parser {
  priority = 130;
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"];
}
class QuarterParser extends Parser {
  priority = 120;
  parse(dateString, token, match2) {
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class StandAloneQuarterParser extends Parser {
  priority = 120;
  parse(dateString, token, match2) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class MonthParser extends Parser {
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "L",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
  priority = 110;
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      // 1, 2, ..., 12
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      // 01, 02, ..., 12
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      // Jan, Feb, ..., Dec
      case "MMM":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      // J, F, ..., D
      case "MMMMM":
        return match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}
class StandAloneMonthParser extends Parser {
  priority = 110;
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      // 01, 02, ..., 12
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      // J, F, ..., D
      case "LLLLL":
        return match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
function setWeek(date, week, options) {
  const date_ = toDate(date, options?.in);
  const diff = getWeek(date_, options) - week;
  date_.setDate(date_.getDate() - diff * 7);
  return toDate(date_, options?.in);
}
class LocalWeekParser extends Parser {
  priority = 100;
  parse(dateString, token, match2) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value, options) {
    return startOfWeek(setWeek(date, value, options), options);
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "i",
    "t",
    "T"
  ];
}
function setISOWeek(date, week, options) {
  const _date = toDate(date, options?.in);
  const diff = getISOWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}
class ISOWeekParser extends Parser {
  priority = 100;
  parse(dateString, token, match2) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value) {
    return startOfISOWeek(setISOWeek(date, value));
  }
  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "e",
    "c",
    "t",
    "T"
  ];
}
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class DateParser extends Parser {
  priority = 90;
  subPriority = 1;
  parse(dateString, token, match2) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear = isLeapYearIndex(year);
    const month = date.getMonth();
    if (isLeapYear) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
class DayOfYearParser extends Parser {
  priority = 90;
  subpriority = 1;
  parse(dateString, token, match2) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear = isLeapYearIndex(year);
    if (isLeapYear) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "E",
    "i",
    "e",
    "c",
    "t",
    "T"
  ];
}
function setDay(date, day, options) {
  const defaultOptions2 = getDefaultOptions$1();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  const date_ = toDate(date, options?.in);
  const currentDay = date_.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date_, diff, options);
}
class DayParser extends Parser {
  priority = 90;
  parse(dateString, token, match2) {
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // T
      case "EEEEE":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // Tuesday
      case "EEEE":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["D", "i", "e", "c", "t", "T"];
}
class LocalDayParser extends Parser {
  priority = 90;
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      // 3
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "eo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      // Tue
      case "eee":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // T
      case "eeeee":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      // Tuesday
      case "eeee":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "c",
    "t",
    "T"
  ];
}
class StandAloneLocalDayParser extends Parser {
  priority = 90;
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      // 3
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "co":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      // Tue
      case "ccc":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      // T
      case "ccccc":
        return match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      // Tuesday
      case "cccc":
      default:
        return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "e",
    "t",
    "T"
  ];
}
function setISODay(date, day, options) {
  const date_ = toDate(date, options?.in);
  const currentDay = getISODay(date_, options);
  const diff = day - currentDay;
  return addDays(date_, diff, options);
}
class ISODayParser extends Parser {
  priority = 90;
  parse(dateString, token, match2) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      // 2
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      // 2nd
      case "io":
        return match2.ordinalNumber(dateString, { unit: "day" });
      // Tue
      case "iii":
        return mapValue(
          match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // T
      case "iiiii":
        return mapValue(
          match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // Tu
      case "iiiiii":
        return mapValue(
          match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      // Tuesday
      case "iiii":
      default:
        return mapValue(
          match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date, _flags, value) {
    date = setISODay(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  incompatibleTokens = [
    "y",
    "Y",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "w",
    "d",
    "D",
    "E",
    "e",
    "c",
    "t",
    "T"
  ];
}
class AMPMParser extends Parser {
  priority = 80;
  parse(dateString, token, match2) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["b", "B", "H", "k", "t", "T"];
}
class AMPMMidnightParser extends Parser {
  priority = 80;
  parse(dateString, token, match2) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["a", "B", "H", "k", "t", "T"];
}
class DayPeriodParser extends Parser {
  priority = 80;
  parse(dateString, token, match2) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["a", "b", "t", "T"];
}
class Hour1to12Parser extends Parser {
  priority = 70;
  parse(dateString, token, match2) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
  incompatibleTokens = ["H", "K", "k", "t", "T"];
}
class Hour0to23Parser extends Parser {
  priority = 70;
  parse(dateString, token, match2) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["a", "b", "h", "K", "k", "t", "T"];
}
class Hour0To11Parser extends Parser {
  priority = 70;
  parse(dateString, token, match2) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
  incompatibleTokens = ["h", "H", "k", "t", "T"];
}
class Hour1To24Parser extends Parser {
  priority = 70;
  parse(dateString, token, match2) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }
  incompatibleTokens = ["a", "b", "h", "H", "K", "t", "T"];
}
class MinuteParser extends Parser {
  priority = 60;
  parse(dateString, token, match2) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match2.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }
  incompatibleTokens = ["t", "T"];
}
class SecondParser extends Parser {
  priority = 50;
  parse(dateString, token, match2) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match2.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }
  incompatibleTokens = ["t", "T"];
}
class FractionOfSecondParser extends Parser {
  priority = 30;
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }
  incompatibleTokens = ["t", "T"];
}
class ISOTimezoneWithZParser extends Parser {
  priority = 10;
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
  incompatibleTokens = ["t", "T", "x"];
}
class ISOTimezoneParser extends Parser {
  priority = 10;
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
  incompatibleTokens = ["t", "T", "X"];
}
class TimestampSecondsParser extends Parser {
  priority = 40;
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
  }
  incompatibleTokens = "*";
}
class TimestampMillisecondsParser extends Parser {
  priority = 20;
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }
  incompatibleTokens = "*";
}
const parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
const escapedStringRegExp = /^'([^]*?)'?$/;
const doubleQuoteRegExp = /''/g;
const notWhitespaceRegExp = /\S/;
const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse$1(dateStr, formatStr, referenceDate, options) {
  const invalidDate = () => constructFrom(options?.in || referenceDate, NaN);
  const defaultOptions2 = getDefaultOptions();
  const locale = options?.locale ?? defaultOptions2.locale ?? enUS;
  const firstWeekContainsDate = options?.firstWeekContainsDate ?? options?.locale?.options?.firstWeekContainsDate ?? defaultOptions2.firstWeekContainsDate ?? defaultOptions2.locale?.options?.firstWeekContainsDate ?? 1;
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions2.weekStartsOn ?? defaultOptions2.locale?.options?.weekStartsOn ?? 0;
  if (!formatStr)
    return dateStr ? invalidDate() : toDate(referenceDate, options?.in);
  const subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  const setters = [new DateTimezoneSetter(options?.in, referenceDate)];
  const tokens = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  const usedTokens = [];
  for (let token of tokens) {
    if (!options?.useAdditionalWeekYearTokens && isProtectedWeekYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    if (!options?.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    const firstCharacter = token[0];
    const parser = parsers[firstCharacter];
    if (parser) {
      const { incompatibleTokens } = parser;
      if (Array.isArray(incompatibleTokens)) {
        const incompatibleToken = usedTokens.find(
          (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
        );
        if (incompatibleToken) {
          throw new RangeError(
            `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`
          );
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError(
          `The format string mustn't contain \`${token}\` and any other token at the same time`
        );
      }
      usedTokens.push({ token: firstCharacter, fullToken: token });
      const parseResult = parser.run(
        dateStr,
        token,
        locale.match,
        subFnOptions
      );
      if (!parseResult) {
        return invalidDate();
      }
      setters.push(parseResult.setter);
      dateStr = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      }
      if (dateStr.indexOf(token) === 0) {
        dateStr = dateStr.slice(token.length);
      } else {
        return invalidDate();
      }
    }
  }
  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
    return invalidDate();
  }
  const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a, b) => b - a).filter((priority, index2, array) => array.indexOf(priority) === index2).map(
    (priority) => setters.filter((setter) => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)
  ).map((setterArray) => setterArray[0]);
  let date = toDate(referenceDate, options?.in);
  if (isNaN(+date)) return invalidDate();
  const flags = {};
  for (const setter of uniquePrioritySetters) {
    if (!setter.validate(date, subFnOptions)) {
      return invalidDate();
    }
    const result = setter.set(date, flags, subFnOptions);
    if (Array.isArray(result)) {
      date = result[0];
      Object.assign(flags, result[1]);
    } else {
      date = result;
    }
  }
  return date;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function isSameQuarter(laterDate, earlierDate, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return +startOfQuarter(dateLeft_) === +startOfQuarter(dateRight_);
}
function subDays(date, amount, options) {
  return addDays(date, -amount, options);
}
function setMonth(date, month, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const midMonth = constructFrom(date, 0);
  midMonth.setFullYear(year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(midMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}
function set(date, values, options) {
  let _date = toDate(date, options?.in);
  if (isNaN(+_date)) return constructFrom(date, NaN);
  if (values.year != null) _date.setFullYear(values.year);
  if (values.month != null) _date = setMonth(_date, values.month);
  if (values.date != null) _date.setDate(values.date);
  if (values.hours != null) _date.setHours(values.hours);
  if (values.minutes != null) _date.setMinutes(values.minutes);
  if (values.seconds != null) _date.setSeconds(values.seconds);
  if (values.milliseconds != null) _date.setMilliseconds(values.milliseconds);
  return _date;
}
function setHours(date, hours, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(hours);
  return _date;
}
function setMilliseconds(date, milliseconds, options) {
  const _date = toDate(date, options?.in);
  _date.setMilliseconds(milliseconds);
  return _date;
}
function setMinutes(date, minutes, options) {
  const date_ = toDate(date, options?.in);
  date_.setMinutes(minutes);
  return date_;
}
function setSeconds(date, seconds, options) {
  const _date = toDate(date, options?.in);
  _date.setSeconds(seconds);
  return _date;
}
function setYear(date, year, options) {
  const date_ = toDate(date, options?.in);
  if (isNaN(+date_)) return constructFrom(date, NaN);
  date_.setFullYear(year);
  return date_;
}
function subMonths(date, amount, options) {
  return addMonths(date, -amount, options);
}
function sub(date, duration, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0
  } = duration;
  const withoutMonths = subMonths(date, months + years * 12, options);
  const withoutDays = subDays(withoutMonths, days + weeks * 7, options);
  const minutesToSub = minutes + hours * 60;
  const secondsToSub = seconds + minutesToSub * 60;
  const msToSub = secondsToSub * 1e3;
  return constructFrom(date, +withoutDays - msToSub);
}
function subYears(date, amount, options) {
  return addYears(date, -amount, options);
}
function Gt() {
  const e2 = useAttrs();
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img",
      ...e2
    },
    [
      createBaseVNode("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      createBaseVNode("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
Gt.compatConfig = {
  MODE: 3
};
function Tn() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      createBaseVNode("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Tn.compatConfig = {
  MODE: 3
};
function Wa() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Wa.compatConfig = {
  MODE: 3
};
function Va() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
Va.compatConfig = {
  MODE: 3
};
function ja() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      createBaseVNode("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
ja.compatConfig = {
  MODE: 3
};
function Ka() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Ka.compatConfig = {
  MODE: 3
};
function Ga() {
  return openBlock(), createElementBlock(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon",
      role: "img"
    },
    [
      createBaseVNode("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Ga.compatConfig = {
  MODE: 3
};
const tt = (e2, t2) => t2 ? new Date(e2.toLocaleString("en-US", { timeZone: t2 })) : new Date(e2), Qa = (e2, t2, r) => {
  const a = La(e2, t2, r);
  return a || K();
}, kl = (e2, t2, r) => {
  const a = t2.dateInTz ? tt(new Date(e2), t2.dateInTz) : K(e2);
  return r ? je(a, true) : a;
}, La = (e2, t2, r) => {
  if (!e2) return null;
  const a = r ? je(K(e2), true) : K(e2);
  return t2 ? t2.exactMatch ? kl(e2, t2, r) : tt(a, t2.timezone) : a;
}, wl = (e2) => {
  const r = new Date(e2.getFullYear(), 0, 1).getTimezoneOffset();
  return e2.getTimezoneOffset() < r;
}, Dl = (e2, t2) => {
  if (!e2) return 0;
  const r = /* @__PURE__ */ new Date(), a = new Date(r.toLocaleString("en-US", { timeZone: "UTC" })), n = new Date(r.toLocaleString("en-US", { timeZone: e2 })), c = (wl(t2 ?? n) ? n : t2 ?? n).getTimezoneOffset() / 60;
  return (+a - +n) / (1e3 * 60 * 60) - c;
};
var ut = /* @__PURE__ */ ((e2) => (e2.month = "month", e2.year = "year", e2))(ut || {}), it = /* @__PURE__ */ ((e2) => (e2.top = "top", e2.bottom = "bottom", e2))(it || {}), _t = /* @__PURE__ */ ((e2) => (e2.header = "header", e2.calendar = "calendar", e2.timePicker = "timePicker", e2))(_t || {}), qe = /* @__PURE__ */ ((e2) => (e2.month = "month", e2.year = "year", e2.calendar = "calendar", e2.time = "time", e2.minutes = "minutes", e2.hours = "hours", e2.seconds = "seconds", e2))(qe || {});
const Ml = ["timestamp", "date", "iso"];
var Ze = /* @__PURE__ */ ((e2) => (e2.up = "up", e2.down = "down", e2.left = "left", e2.right = "right", e2))(Ze || {}), Oe = /* @__PURE__ */ ((e2) => (e2.arrowUp = "ArrowUp", e2.arrowDown = "ArrowDown", e2.arrowLeft = "ArrowLeft", e2.arrowRight = "ArrowRight", e2.enter = "Enter", e2.space = " ", e2.esc = "Escape", e2.tab = "Tab", e2.home = "Home", e2.end = "End", e2.pageUp = "PageUp", e2.pageDown = "PageDown", e2))(Oe || {}), zt = /* @__PURE__ */ ((e2) => (e2.MONTH_AND_YEAR = "MM-yyyy", e2.YEAR = "yyyy", e2.DATE = "dd-MM-yyyy", e2))(zt || {});
function sn(e2) {
  return (t2) => {
    const r = new Intl.DateTimeFormat(e2, {
      weekday: "short",
      timeZone: "UTC"
    }).format(/* @__PURE__ */ new Date(`2017-01-0${t2}T00:00:00+00:00`));
    return e2 === "ar" ? r.slice(2, 5) : r.slice(0, 2);
  };
}
function $l(e2) {
  return (t2) => format(tt(/* @__PURE__ */ new Date(`2017-01-0${t2}T00:00:00+00:00`), "UTC"), "EEEEEE", { locale: e2 });
}
const Al = (e2, t2, r) => {
  const a = [1, 2, 3, 4, 5, 6, 7];
  let n;
  if (e2 !== null)
    try {
      n = a.map($l(e2));
    } catch {
      n = a.map(sn(t2));
    }
  else
    n = a.map(sn(t2));
  const u = n.slice(0, r), c = n.slice(r + 1, n.length);
  return [n[r]].concat(...c).concat(...u);
}, qa = (e2, t2, r) => {
  const a = [];
  for (let n = +e2[0]; n <= +e2[1]; n++)
    a.push({ value: +n, text: Cn(n, t2) });
  return r ? a.reverse() : a;
}, Sn = (e2, t2, r) => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((u) => {
    const c = u < 10 ? `0${u}` : u;
    return /* @__PURE__ */ new Date(`2017-${c}-01T00:00:00+00:00`);
  });
  if (e2 !== null)
    try {
      const u = r === "long" ? "LLLL" : "LLL";
      return a.map((c, p) => {
        const d = format(tt(c, "UTC"), u, { locale: e2 });
        return {
          text: d.charAt(0).toUpperCase() + d.substring(1),
          value: p
        };
      });
    } catch {
    }
  const n = new Intl.DateTimeFormat(t2, { month: r, timeZone: "UTC" });
  return a.map((u, c) => {
    const p = n.format(u);
    return {
      text: p.charAt(0).toUpperCase() + p.substring(1),
      value: c
    };
  });
}, Tl = (e2) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e2], He = (e2) => {
  const t2 = unref(e2);
  return t2 != null && t2.$el ? t2 == null ? void 0 : t2.$el : t2;
}, Sl = (e2) => ({ type: "dot", ...e2 ?? {} }), Pn = (e2) => Array.isArray(e2) ? !!e2[0] && !!e2[1] : false, Xa = {
  prop: (e2) => `"${e2}" prop must be enabled!`,
  dateArr: (e2) => `You need to use array as "model-value" binding in order to support "${e2}"`
}, ze = (e2) => e2, un = (e2) => e2 === 0 ? e2 : !e2 || isNaN(+e2) ? null : +e2, dn = (e2) => e2 === null, Rn = (e2) => {
  if (e2)
    return [...e2.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, Pl = (e2) => {
  const t2 = [], r = (a) => a.filter((n) => n);
  for (let a = 0; a < e2.length; a += 3) {
    const n = [e2[a], e2[a + 1], e2[a + 2]];
    t2.push(r(n));
  }
  return t2;
}, xt = (e2, t2, r) => {
  const a = r != null, n = t2 != null;
  if (!a && !n) return false;
  const u = +r, c = +t2;
  return a && n ? +e2 > u || +e2 < c : a ? +e2 > u : n ? +e2 < c : false;
}, Wt = (e2, t2) => Pl(e2).map((r) => r.map((a) => {
  const { active: n, disabled: u, isBetween: c, highlighted: p } = t2(a);
  return {
    ...a,
    active: n,
    disabled: u,
    className: {
      dp__overlay_cell_active: n,
      dp__overlay_cell: !n,
      dp__overlay_cell_disabled: u,
      dp__overlay_cell_pad: true,
      dp__overlay_cell_active_disabled: u && n,
      dp__cell_in_between: c,
      "dp--highlighted": p
    }
  };
})), $t = (e2, t2, r = false) => {
  e2 && t2.allowStopPropagation && (r && e2.stopImmediatePropagation(), e2.stopPropagation());
}, Rl = () => [
  "a[href]",
  "area[href]",
  "input:not([disabled]):not([type='hidden'])",
  "select:not([disabled])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "[tabindex]:not([tabindex='-1'])",
  "[data-datepicker-instance]"
].join(", ");
function Cl(e2, t2) {
  let r = [...document.querySelectorAll(Rl())];
  r = r.filter((n) => !e2.contains(n) || n.hasAttribute("data-datepicker-instance"));
  const a = r.indexOf(e2);
  if (a >= 0 && (t2 ? a - 1 >= 0 : a + 1 <= r.length))
    return r[a + (t2 ? -1 : 1)];
}
const Fa = (e2, t2) => e2 == null ? void 0 : e2.querySelector(`[data-dp-element="${t2}"]`), Cn = (e2, t2) => new Intl.NumberFormat(t2, { useGrouping: false, style: "decimal" }).format(e2), Ja = (e2, t2) => format(e2, t2 ?? zt.DATE), Ta = (e2) => Array.isArray(e2), va = (e2, t2, r) => t2.get(Ja(e2, r)), Ol = (e2, t2) => e2 ? t2 ? t2 instanceof Map ? !!va(e2, t2) : t2(K(e2)) : false : true, xe = (e2, t2, r = false, a) => {
  if (e2.key === Oe.enter || e2.key === Oe.space)
    return r && e2.preventDefault(), t2();
  if (a) return a(e2);
}, Bl = () => "ontouchstart" in window || navigator.maxTouchPoints > 0, On = (e2, t2) => e2 ? zt.MONTH_AND_YEAR : t2 ? zt.YEAR : zt.DATE, Bn = (e2) => e2 < 10 ? `0${e2}` : e2, cn = (e2, t2, r, a, n, u) => {
  const c = parse$1(e2, t2.slice(0, e2.length), /* @__PURE__ */ new Date(), { locale: u });
  return isValid(c) && isDate(c) ? a || n ? c : set(c, {
    hours: +r.hours,
    minutes: +(r == null ? void 0 : r.minutes),
    seconds: +(r == null ? void 0 : r.seconds),
    milliseconds: 0
  }) : null;
}, _l = (e2, t2, r, a, n, u) => {
  const c = Array.isArray(r) ? r[0] : r;
  if (typeof t2 == "string")
    return cn(e2, t2, c, a, n, u);
  if (Array.isArray(t2)) {
    let p = null;
    for (const d of t2)
      if (p = cn(e2, d, c, a, n, u), p)
        break;
    return p;
  }
  return typeof t2 == "function" ? t2(e2) : null;
}, K = (e2) => e2 ? new Date(e2) : /* @__PURE__ */ new Date(), Yl = (e2, t2, r) => {
  if (t2) {
    const n = (e2.getMonth() + 1).toString().padStart(2, "0"), u = e2.getDate().toString().padStart(2, "0"), c = e2.getHours().toString().padStart(2, "0"), p = e2.getMinutes().toString().padStart(2, "0"), d = r ? e2.getSeconds().toString().padStart(2, "0") : "00";
    return `${e2.getFullYear()}-${n}-${u}T${c}:${p}:${d}.000Z`;
  }
  const a = Date.UTC(
    e2.getUTCFullYear(),
    e2.getUTCMonth(),
    e2.getUTCDate(),
    e2.getUTCHours(),
    e2.getUTCMinutes(),
    e2.getUTCSeconds()
  );
  return new Date(a).toISOString();
}, je = (e2, t2) => {
  const r = K(JSON.parse(JSON.stringify(e2))), a = set(r, { hours: 0, minutes: 0, seconds: 0, milliseconds: 0 });
  return t2 ? startOfMonth(a) : a;
}, At = (e2, t2, r, a) => {
  let n = e2 ? K(e2) : K();
  return (t2 || t2 === 0) && (n = setHours(n, +t2)), (r || r === 0) && (n = setMinutes(n, +r)), (a || a === 0) && (n = setSeconds(n, +a)), setMilliseconds(n, 0);
}, Ne = (e2, t2) => !e2 || !t2 ? false : isBefore(je(e2), je(t2)), Te = (e2, t2) => !e2 || !t2 ? false : isEqual(je(e2), je(t2)), Fe = (e2, t2) => !e2 || !t2 ? false : isAfter(je(e2), je(t2)), ea = (e2, t2, r) => e2 != null && e2[0] && (e2 != null && e2[1]) ? Fe(r, e2[0]) && Ne(r, e2[1]) : e2 != null && e2[0] && t2 ? Fe(r, e2[0]) && Ne(r, t2) || Ne(r, e2[0]) && Fe(r, t2) : false, dt = (e2) => {
  const t2 = set(new Date(e2), { date: 1 });
  return je(t2);
}, Sa = (e2, t2, r) => t2 && (r || r === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((a) => a === t2 ? [a, r] : [a, isNaN(+e2[a]) ? void 0 : +e2[a]])
) : {
  hours: isNaN(+e2.hours) ? void 0 : +e2.hours,
  minutes: isNaN(+e2.minutes) ? void 0 : +e2.minutes,
  seconds: isNaN(+e2.seconds) ? void 0 : +e2.seconds
}, Yt = (e2) => ({
  hours: getHours(e2),
  minutes: getMinutes(e2),
  seconds: getSeconds(e2)
}), _n = (e2, t2) => {
  if (t2) {
    const r = getYear(K(t2));
    if (r > e2) return 12;
    if (r === e2) return getMonth(K(t2));
  }
}, Yn = (e2, t2) => {
  if (t2) {
    const r = getYear(K(t2));
    return r < e2 ? -1 : r === e2 ? getMonth(K(t2)) : void 0;
  }
}, Vt = (e2) => {
  if (e2) return getYear(K(e2));
}, In = (e2, t2) => {
  const r = Fe(e2, t2) ? t2 : e2, a = Fe(t2, e2) ? t2 : e2;
  return eachDayOfInterval({ start: r, end: a });
}, Il = (e2) => {
  const t2 = addMonths(e2, 1);
  return { month: getMonth(t2), year: getYear(t2) };
}, gt = (e2, t2) => {
  const r = startOfWeek(e2, { weekStartsOn: +t2 }), a = endOfWeek(e2, { weekStartsOn: +t2 });
  return [r, a];
}, En = (e2, t2) => {
  const r = {
    hours: getHours(K()),
    minutes: getMinutes(K()),
    seconds: t2 ? getSeconds(K()) : 0
  };
  return Object.assign(r, e2);
}, Mt = (e2, t2, r) => [set(K(e2), { date: 1 }), set(K(), { month: t2, year: r, date: 1 })], ht = (e2, t2, r) => {
  let a = e2 ? K(e2) : K();
  return (t2 || t2 === 0) && (a = setMonth(a, t2)), r && (a = setYear(a, r)), a;
}, Nn = (e2, t2, r, a, n) => {
  if (!a || n && !t2 || !n && !r) return false;
  const u = n ? addMonths(e2, 1) : subMonths(e2, 1), c = [getMonth(u), getYear(u)];
  return n ? !Nl(...c, t2) : !El(...c, r);
}, El = (e2, t2, r) => Ne(...Mt(r, e2, t2)) || Te(...Mt(r, e2, t2)), Nl = (e2, t2, r) => Fe(...Mt(r, e2, t2)) || Te(...Mt(r, e2, t2)), Ln = (e2, t2, r, a, n, u, c) => {
  if (typeof t2 == "function" && !c) return t2(e2);
  const p = r ? { locale: r } : void 0;
  return Array.isArray(e2) ? `${format(e2[0], u, p)}${n && !e2[1] ? "" : a}${e2[1] ? format(e2[1], u, p) : ""}` : format(e2, u, p);
}, Nt = (e2) => {
  if (e2) return null;
  throw new Error(Xa.prop("partial-range"));
}, sa = (e2, t2) => {
  if (t2) return e2();
  throw new Error(Xa.prop("range"));
}, za = (e2) => Array.isArray(e2) ? isValid(e2[0]) && (e2[1] ? isValid(e2[1]) : true) : e2 ? isValid(e2) : false, Ll = (e2, t2) => set(t2 ?? K(), {
  hours: +e2.hours || 0,
  minutes: +e2.minutes || 0,
  seconds: +e2.seconds || 0
}), Pa = (e2, t2, r, a) => {
  if (!e2) return true;
  if (a) {
    const n = r === "max" ? isBefore(e2, t2) : isAfter(e2, t2), u = { seconds: 0, milliseconds: 0 };
    return n || isEqual(set(e2, u), set(t2, u));
  }
  return r === "max" ? e2.getTime() <= t2.getTime() : e2.getTime() >= t2.getTime();
}, Ra = (e2, t2, r) => e2 ? Ll(e2, t2) : K(r ?? t2), fn = (e2, t2, r, a, n) => {
  if (Array.isArray(a)) {
    const c = Ra(e2, a[0], t2), p = Ra(e2, a[1], t2);
    return Pa(a[0], c, r, !!t2) && Pa(a[1], p, r, !!t2) && n;
  }
  const u = Ra(e2, a, t2);
  return Pa(a, u, r, !!t2) && n;
}, Ca = (e2) => set(K(), Yt(e2)), Fl = (e2, t2, r) => {
  if (e2 instanceof Map) {
    const a = `${Bn(r + 1)}-${t2}`;
    return e2.size ? e2.has(a) : false;
  }
  return typeof e2 == "function" ? e2(je(set(K(), { month: r, year: t2 }), true)) : false;
}, zl = (e2, t2, r) => {
  if (e2 instanceof Map) {
    const a = `${Bn(r + 1)}-${t2}`;
    return e2.size ? e2.has(a) : true;
  }
  return true;
}, Fn = (e2, t2, r) => typeof e2 == "function" ? e2({ month: t2, year: r }) : !!e2.months.find((a) => a.month === t2 && a.year === r), Za = (e2, t2) => typeof e2 == "function" ? e2(t2) : e2.years.includes(t2), Ha = (e2) => `dp-${format(e2, "yyyy-MM-dd")}`, vn = (e2, t2) => {
  const r = subDays(je(t2), e2), a = addDays(je(t2), e2);
  return { before: r, after: a };
}, Qt = reactive({
  menuFocused: false,
  shiftKeyInMenu: false
}), zn = () => {
  const e2 = (a) => {
    Qt.menuFocused = a;
  }, t2 = (a) => {
    Qt.shiftKeyInMenu !== a && (Qt.shiftKeyInMenu = a);
  };
  return {
    control: computed(() => ({ shiftKeyInMenu: Qt.shiftKeyInMenu, menuFocused: Qt.menuFocused })),
    setMenuFocused: e2,
    setShiftKey: t2
  };
}, Ce = reactive({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), Oa = ref(null), ua = ref(false), Ba = ref(false), _a = ref(false), Ya = ref(false), Qe = ref(0), Le = ref(0), St = () => {
  const e2 = computed(() => ua.value ? [...Ce.selectionGrid, Ce.actionRow].filter((h2) => h2.length) : Ba.value ? [
    ...Ce.timePicker[0],
    ...Ce.timePicker[1],
    Ya.value ? [] : [Oa.value],
    Ce.actionRow
  ].filter((h2) => h2.length) : _a.value ? [...Ce.monthPicker, Ce.actionRow] : [Ce.monthYear, ...Ce.calendar, Ce.time, Ce.actionRow].filter((h2) => h2.length)), t2 = (h2) => {
    Qe.value = h2 ? Qe.value + 1 : Qe.value - 1;
    let R = null;
    e2.value[Le.value] && (R = e2.value[Le.value][Qe.value]), !R && e2.value[Le.value + (h2 ? 1 : -1)] ? (Le.value = Le.value + (h2 ? 1 : -1), Qe.value = h2 ? 0 : e2.value[Le.value].length - 1) : R || (Qe.value = h2 ? Qe.value - 1 : Qe.value + 1);
  }, r = (h2) => {
    if (Le.value === 0 && !h2 || Le.value === e2.value.length && h2) return;
    Le.value = h2 ? Le.value + 1 : Le.value - 1, e2.value[Le.value] ? e2.value[Le.value] && !e2.value[Le.value][Qe.value] && Qe.value !== 0 && (Qe.value = e2.value[Le.value].length - 1) : Le.value = h2 ? Le.value - 1 : Le.value + 1;
  }, a = (h2) => {
    let R = null;
    e2.value[Le.value] && (R = e2.value[Le.value][Qe.value]), R ? R.focus({ preventScroll: !ua.value }) : Qe.value = h2 ? Qe.value - 1 : Qe.value + 1;
  }, n = () => {
    t2(true), a(true);
  }, u = () => {
    t2(false), a(false);
  }, c = () => {
    r(false), a(true);
  }, p = () => {
    r(true), a(true);
  }, d = (h2, R) => {
    Ce[R] = h2;
  }, Y = (h2, R) => {
    Ce[R] = h2;
  }, f = () => {
    Qe.value = 0, Le.value = 0;
  };
  return {
    buildMatrix: d,
    buildMultiLevelMatrix: Y,
    setTimePickerBackRef: (h2) => {
      Oa.value = h2;
    },
    setSelectionGrid: (h2) => {
      ua.value = h2, f(), h2 || (Ce.selectionGrid = []);
    },
    setTimePicker: (h2, R = false) => {
      Ba.value = h2, Ya.value = R, f(), h2 || (Ce.timePicker[0] = [], Ce.timePicker[1] = []);
    },
    setTimePickerElements: (h2, R = 0) => {
      Ce.timePicker[R] = h2;
    },
    arrowRight: n,
    arrowLeft: u,
    arrowUp: c,
    arrowDown: p,
    clearArrowNav: () => {
      Ce.monthYear = [], Ce.calendar = [], Ce.time = [], Ce.actionRow = [], Ce.selectionGrid = [], Ce.timePicker[0] = [], Ce.timePicker[1] = [], ua.value = false, Ba.value = false, Ya.value = false, _a.value = false, f(), Oa.value = null;
    },
    setMonthPicker: (h2) => {
      _a.value = h2, f();
    },
    refSets: Ce
    // exposed for testing
  };
}, mn = (e2) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e2 ?? {}
}), Hl = (e2) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (t2) => `Increment ${t2}`,
  decrementValue: (t2) => `Decrement ${t2}`,
  openTpOverlay: (t2) => `Open ${t2} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: void 0,
  weekDay: void 0,
  clearInput: "Clear value",
  calendarIcon: "Calendar icon",
  timePicker: "Time picker",
  monthPicker: (t2) => `Month picker${t2 ? " overlay" : ""}`,
  yearPicker: (t2) => `Year picker${t2 ? " overlay" : ""}`,
  timeOverlay: (t2) => `${t2} overlay`,
  ...e2 ?? {}
}), pn = (e2) => e2 ? typeof e2 == "boolean" ? e2 ? 2 : 0 : +e2 >= 2 ? +e2 : 2 : 0, Ul = (e2) => {
  const t2 = typeof e2 == "object" && e2, r = {
    static: true,
    solo: false
  };
  if (!e2) return { ...r, count: pn(false) };
  const a = t2 ? e2 : {}, n = t2 ? a.count ?? true : e2, u = pn(n);
  return Object.assign(r, a, { count: u });
}, Wl = (e2, t2, r) => e2 || (typeof r == "string" ? r : t2), Vl = (e2) => typeof e2 == "boolean" ? e2 ? mn({}) : false : mn(e2), jl = (e2) => {
  const t2 = {
    enterSubmit: true,
    tabSubmit: true,
    openMenu: "open",
    selectOnFocus: false,
    rangeSeparator: " - ",
    escClose: true
  };
  return typeof e2 == "object" ? { ...t2, ...e2 ?? {}, enabled: true } : { ...t2, enabled: e2 };
}, Kl = (e2) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e2 ?? {}
}), Gl = (e2) => ({
  showSelect: true,
  showCancel: true,
  showNow: false,
  showPreview: true,
  ...e2 ?? {}
}), Ql = (e2) => {
  const t2 = { input: false };
  return typeof e2 == "object" ? { ...t2, ...e2 ?? {}, enabled: true } : {
    enabled: e2,
    ...t2
  };
}, ql = (e2) => ({ ...{
  allowStopPropagation: true,
  closeOnScroll: false,
  modeHeight: 255,
  allowPreventDefault: false,
  closeOnClearValue: true,
  closeOnAutoApply: true,
  noSwipe: false,
  keepActionRow: false,
  onClickOutside: void 0,
  tabOutClosesMenu: true,
  arrowLeft: void 0,
  keepViewOnOffsetClick: false,
  timeArrowHoldThreshold: 0,
  shadowDom: false,
  mobileBreakpoint: 600,
  setDateOnMenuClose: false
}, ...e2 ?? {} }), Xl = (e2) => {
  const t2 = {
    dates: Array.isArray(e2) ? e2.map((r) => K(r)) : [],
    years: [],
    months: [],
    quarters: [],
    weeks: [],
    weekdays: [],
    options: { highlightDisabled: false }
  };
  return typeof e2 == "function" ? e2 : { ...t2, ...e2 ?? {} };
}, Jl = (e2) => typeof e2 == "object" ? {
  type: (e2 == null ? void 0 : e2.type) ?? "local",
  hideOnOffsetDates: (e2 == null ? void 0 : e2.hideOnOffsetDates) ?? false
} : {
  type: e2,
  hideOnOffsetDates: false
}, Zl = (e2) => {
  const t2 = {
    noDisabledRange: false,
    showLastInRange: true,
    minMaxRawRange: false,
    partialRange: true,
    disableTimeRangeValidation: false,
    maxRange: void 0,
    minRange: void 0,
    autoRange: void 0,
    fixedStart: false,
    fixedEnd: false
  };
  return typeof e2 == "object" ? { enabled: true, ...t2, ...e2 } : {
    enabled: e2,
    ...t2
  };
}, xl = (e2) => e2 ? typeof e2 == "string" ? {
  timezone: e2,
  exactMatch: false,
  dateInTz: void 0,
  emitTimezone: void 0,
  convertModel: true
} : {
  timezone: e2.timezone,
  exactMatch: e2.exactMatch ?? false,
  dateInTz: e2.dateInTz ?? void 0,
  emitTimezone: e2.emitTimezone ?? void 0,
  convertModel: e2.convertModel ?? true
} : { timezone: void 0, exactMatch: false, emitTimezone: void 0 }, Ia = (e2, t2, r, a) => new Map(
  e2.map((n) => {
    const u = Qa(n, t2, a);
    return [Ja(u, r), u];
  })
), er = (e2, t2) => e2.length ? new Map(
  e2.map((r) => {
    const a = Qa(r.date, t2);
    return [Ja(a, zt.DATE), r];
  })
) : null, tr = (e2) => {
  var r;
  const t2 = On(e2.isMonthPicker, e2.isYearPicker);
  return {
    minDate: La(e2.minDate, e2.timezone, e2.isSpecific),
    maxDate: La(e2.maxDate, e2.timezone, e2.isSpecific),
    disabledDates: Ta(e2.disabledDates) ? Ia(e2.disabledDates, e2.timezone, t2, e2.isSpecific) : e2.disabledDates,
    allowedDates: Ta(e2.allowedDates) ? Ia(e2.allowedDates, e2.timezone, t2, e2.isSpecific) : null,
    highlight: typeof e2.highlight == "object" && Ta((r = e2.highlight) == null ? void 0 : r.dates) ? Ia(e2.highlight.dates, e2.timezone, t2) : e2.highlight,
    markers: er(e2.markers, e2.timezone)
  };
}, ar = (e2) => typeof e2 == "boolean" ? { enabled: e2, dragSelect: true, limit: null } : {
  enabled: !!e2,
  limit: e2.limit ? +e2.limit : null,
  dragSelect: e2.dragSelect ?? true
}, nr = (e2) => ({
  ...Object.fromEntries(
    Object.keys(e2).map((r) => {
      const a = r, n = e2[a], u = typeof e2[a] == "string" ? { [n]: true } : Object.fromEntries(n.map((c) => [c, true]));
      return [r, u];
    })
  )
}), Ye = (e2) => {
  const t2 = () => {
    const H = e2.enableSeconds ? ":ss" : "", D = e2.enableMinutes ? ":mm" : "";
    return e2.is24 ? `HH${D}${H}` : `hh${D}${H} aa`;
  }, r = () => {
    var H;
    return e2.format ? e2.format : e2.monthPicker ? "MM/yyyy" : e2.timePicker ? t2() : e2.weekPicker ? `${((H = _.value) == null ? void 0 : H.type) === "iso" ? "II" : "ww"}-RR` : e2.yearPicker ? "yyyy" : e2.quarterPicker ? "QQQ/yyyy" : e2.enableTimePicker ? `MM/dd/yyyy, ${t2()}` : "MM/dd/yyyy";
  }, a = (H) => En(H, e2.enableSeconds), n = () => j.value.enabled ? e2.startTime && Array.isArray(e2.startTime) ? [a(e2.startTime[0]), a(e2.startTime[1])] : null : e2.startTime && !Array.isArray(e2.startTime) ? a(e2.startTime) : null, u = computed(() => Ul(e2.multiCalendars)), c = computed(() => n()), p = computed(() => Hl(e2.ariaLabels)), d = computed(() => Kl(e2.filters)), Y = computed(() => Vl(e2.transitions)), f = computed(() => Gl(e2.actionRow)), O = computed(
    () => Wl(e2.previewFormat, e2.format, r())
  ), m = computed(() => jl(e2.textInput)), P = computed(() => Ql(e2.inline)), F = computed(() => ql(e2.config)), L = computed(() => Xl(e2.highlight)), _ = computed(() => Jl(e2.weekNumbers)), h2 = computed(() => xl(e2.timezone)), R = computed(() => ar(e2.multiDates)), b = computed(
    () => tr({
      minDate: e2.minDate,
      maxDate: e2.maxDate,
      disabledDates: e2.disabledDates,
      allowedDates: e2.allowedDates,
      highlight: L.value,
      markers: e2.markers,
      timezone: h2.value,
      isSpecific: e2.monthPicker || e2.yearPicker || e2.quarterPicker,
      isMonthPicker: e2.monthPicker,
      isYearPicker: e2.yearPicker
    })
  ), j = computed(() => Zl(e2.range)), z = computed(() => nr(e2.ui));
  return {
    defaultedTransitions: Y,
    defaultedMultiCalendars: u,
    defaultedStartTime: c,
    defaultedAriaLabels: p,
    defaultedFilters: d,
    defaultedActionRow: f,
    defaultedPreviewFormat: O,
    defaultedTextInput: m,
    defaultedInline: P,
    defaultedConfig: F,
    defaultedHighlight: L,
    defaultedWeekNumbers: _,
    defaultedRange: j,
    propDates: b,
    defaultedTz: h2,
    defaultedMultiDates: R,
    defaultedUI: z,
    getDefaultPattern: r,
    getDefaultStartTime: n,
    handleEventPropagation: (H) => {
      F.value.allowStopPropagation && H.stopPropagation(), F.value.allowPreventDefault && H.preventDefault();
    }
  };
}, lr = (e2, t2, r) => {
  const a = ref(), { defaultedTextInput: n, defaultedRange: u, defaultedTz: c, defaultedMultiDates: p, getDefaultPattern: d } = Ye(t2), Y = ref(""), f = toRef(t2, "format"), O = toRef(t2, "formatLocale");
  watch(
    a,
    () => {
      typeof t2.onInternalModelChange == "function" && e2("internal-model-change", a.value, T(true));
    },
    { deep: true }
  ), watch(u, (l, w) => {
    l.enabled !== w.enabled && (a.value = null);
  }), watch(f, () => {
    U();
  });
  const m = (l) => c.value.timezone && c.value.convertModel ? tt(l, c.value.timezone) : l, P = (l) => {
    if (c.value.timezone && c.value.convertModel) {
      const w = Dl(c.value.timezone, l);
      return addHours(l, w);
    }
    return l;
  }, F = (l, w, oe = false) => Ln(
    l,
    t2.format,
    t2.formatLocale,
    n.value.rangeSeparator,
    t2.modelAuto,
    w ?? d(),
    oe
  ), L = (l) => l ? t2.modelType ? Z(l) : {
    hours: getHours(l),
    minutes: getMinutes(l),
    seconds: t2.enableSeconds ? getSeconds(l) : 0
  } : null, _ = (l) => t2.modelType ? Z(l) : { month: getMonth(l), year: getYear(l) }, h2 = (l) => Array.isArray(l) ? p.value.enabled ? l.map((w) => R(w, setYear(K(), w))) : sa(
    () => [
      setYear(K(), l[0]),
      l[1] ? setYear(K(), l[1]) : Nt(u.value.partialRange)
    ],
    u.value.enabled
  ) : setYear(K(), +l), R = (l, w) => (typeof l == "string" || typeof l == "number") && t2.modelType ? S(l) : w, b = (l) => Array.isArray(l) ? [
    R(
      l[0],
      At(null, +l[0].hours, +l[0].minutes, l[0].seconds)
    ),
    R(
      l[1],
      At(null, +l[1].hours, +l[1].minutes, l[1].seconds)
    )
  ] : R(l, At(null, l.hours, l.minutes, l.seconds)), j = (l) => {
    const w = set(K(), { date: 1 });
    return Array.isArray(l) ? p.value.enabled ? l.map((oe) => R(oe, ht(w, +oe.month, +oe.year))) : sa(
      () => [
        R(l[0], ht(w, +l[0].month, +l[0].year)),
        R(
          l[1],
          l[1] ? ht(w, +l[1].month, +l[1].year) : Nt(u.value.partialRange)
        )
      ],
      u.value.enabled
    ) : R(l, ht(w, +l.month, +l.year));
  }, z = (l) => {
    if (Array.isArray(l))
      return l.map((w) => S(w));
    throw new Error(Xa.dateArr("multi-dates"));
  }, ae = (l) => {
    if (Array.isArray(l) && u.value.enabled) {
      const w = l[0], oe = l[1];
      return [
        K(Array.isArray(w) ? w[0] : null),
        Array.isArray(oe) && oe.length ? K(oe[0]) : null
      ];
    }
    return K(l[0]);
  }, H = (l) => t2.modelAuto ? Array.isArray(l) ? [S(l[0]), S(l[1])] : t2.autoApply ? [S(l)] : [S(l), null] : Array.isArray(l) ? sa(
    () => l[1] ? [
      S(l[0]),
      l[1] ? S(l[1]) : Nt(u.value.partialRange)
    ] : [S(l[0])],
    u.value.enabled
  ) : S(l), D = () => {
    Array.isArray(a.value) && u.value.enabled && a.value.length === 1 && a.value.push(Nt(u.value.partialRange));
  }, Q = () => {
    const l = a.value;
    return [
      Z(l[0]),
      l[1] ? Z(l[1]) : Nt(u.value.partialRange)
    ];
  }, B = () => Array.isArray(a.value) ? a.value[1] ? Q() : Z(ze(a.value[0])) : [], q = () => (a.value || []).map((l) => Z(l)), ve = (l = false) => (l || D(), t2.modelAuto ? B() : p.value.enabled ? q() : Array.isArray(a.value) ? sa(() => Q(), u.value.enabled) : Z(ze(a.value))), pe = (l) => !l || Array.isArray(l) && !l.length ? null : t2.timePicker ? b(ze(l)) : t2.monthPicker ? j(ze(l)) : t2.yearPicker ? h2(ze(l)) : p.value.enabled ? z(ze(l)) : t2.weekPicker ? ae(ze(l)) : H(ze(l)), v2 = (l) => {
    const w = pe(l);
    za(ze(w)) ? (a.value = ze(w), U()) : (a.value = null, Y.value = "");
  }, N = () => {
    const l = (w) => format(w, n.value.format);
    return `${l(a.value[0])} ${n.value.rangeSeparator} ${a.value[1] ? l(a.value[1]) : ""}`;
  }, ee = () => r.value && a.value ? Array.isArray(a.value) ? N() : format(a.value, n.value.format) : F(a.value), y = () => a.value ? p.value.enabled ? a.value.map((l) => F(l)).join("; ") : n.value.enabled && typeof n.value.format == "string" ? ee() : F(a.value) : "", U = () => {
    !t2.format || typeof t2.format == "string" || n.value.enabled && typeof n.value.format == "string" ? Y.value = y() : Y.value = t2.format(a.value);
  }, S = (l) => {
    if (t2.utc) {
      const w = new Date(l);
      return t2.utc === "preserve" ? new Date(w.getTime() + w.getTimezoneOffset() * 6e4) : w;
    }
    return t2.modelType ? Ml.includes(t2.modelType) ? m(new Date(l)) : t2.modelType === "format" && (typeof t2.format == "string" || !t2.format) ? m(
      parse$1(l, d(), /* @__PURE__ */ new Date(), { locale: O.value })
    ) : m(
      parse$1(l, t2.modelType, /* @__PURE__ */ new Date(), { locale: O.value })
    ) : m(new Date(l));
  }, Z = (l) => l ? t2.utc ? Yl(l, t2.utc === "preserve", t2.enableSeconds) : t2.modelType ? t2.modelType === "timestamp" ? +P(l) : t2.modelType === "iso" ? P(l).toISOString() : t2.modelType === "format" && (typeof t2.format == "string" || !t2.format) ? F(P(l)) : F(P(l), t2.modelType, true) : P(l) : "", A = (l, w = false, oe = false) => {
    if (oe) return l;
    if (e2("update:model-value", l), c.value.emitTimezone && w) {
      const M = Array.isArray(l) ? l.map((he) => tt(ze(he), c.value.emitTimezone)) : tt(ze(l), c.value.emitTimezone);
      e2("update:model-timezone-value", M);
    }
  }, ie = (l) => Array.isArray(a.value) ? p.value.enabled ? a.value.map((w) => l(w)) : [
    l(a.value[0]),
    a.value[1] ? l(a.value[1]) : Nt(u.value.partialRange)
  ] : l(ze(a.value)), i = () => {
    if (Array.isArray(a.value)) {
      const l = gt(a.value[0], t2.weekStart), w = a.value[1] ? gt(a.value[1], t2.weekStart) : [];
      return [l.map((oe) => K(oe)), w.map((oe) => K(oe))];
    }
    return gt(a.value, t2.weekStart).map((l) => K(l));
  }, W = (l, w) => A(ze(ie(l)), false, w), se = (l) => {
    const w = i();
    return l ? w : e2("update:model-value", i());
  }, T = (l = false) => (l || U(), t2.monthPicker ? W(_, l) : t2.timePicker ? W(L, l) : t2.yearPicker ? W(getYear, l) : t2.weekPicker ? se(l) : A(ve(l), true, l));
  return {
    inputValue: Y,
    internalModelValue: a,
    checkBeforeEmit: () => a.value ? u.value.enabled ? u.value.partialRange ? a.value.length >= 1 : a.value.length === 2 : !!a.value : false,
    parseExternalModelValue: v2,
    formatInputValue: U,
    emitModelValue: T
  };
}, rr = (e2, t2) => {
  const { defaultedFilters: r, propDates: a } = Ye(e2), { validateMonthYearInRange: n } = Pt(e2), u = (f, O) => {
    let m = f;
    return r.value.months.includes(getMonth(m)) ? (m = O ? addMonths(f, 1) : subMonths(f, 1), u(m, O)) : m;
  }, c = (f, O) => {
    let m = f;
    return r.value.years.includes(getYear(m)) ? (m = O ? addYears(f, 1) : subYears(f, 1), c(m, O)) : m;
  }, p = (f, O = false) => {
    const m = set(K(), { month: e2.month, year: e2.year });
    let P = f ? addMonths(m, 1) : subMonths(m, 1);
    e2.disableYearSelect && (P = setYear(P, e2.year));
    let F = getMonth(P), L = getYear(P);
    r.value.months.includes(F) && (P = u(P, f), F = getMonth(P), L = getYear(P)), r.value.years.includes(L) && (P = c(P, f), L = getYear(P)), n(F, L, f, e2.preventMinMaxNavigation) && d(F, L, O);
  }, d = (f, O, m) => {
    t2("update-month-year", { month: f, year: O, fromNav: m });
  }, Y = computed(() => (f) => Nn(
    set(K(), { month: e2.month, year: e2.year }),
    a.value.maxDate,
    a.value.minDate,
    e2.preventMinMaxNavigation,
    f
  ));
  return { handleMonthYearChange: p, isDisabled: Y, updateMonthYear: d };
}, pa = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: false },
  format: {
    type: [String, Function],
    default: () => null
  },
  autoPosition: { type: [Boolean, String], default: true },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: true },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: false },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: [String, Object], default: null },
  vertical: { type: Boolean, default: false },
  disableMonthYearSelect: { type: Boolean, default: false },
  disableYearSelect: { type: Boolean, default: false },
  dayClass: {
    type: Function,
    default: null
  },
  yearRange: { type: Array, default: () => [1900, 2100] },
  enableTimePicker: { type: Boolean, default: true },
  autoApply: { type: Boolean, default: false },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: false },
  noToday: { type: Boolean, default: false },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  escClose: { type: Boolean, default: true },
  spaceConfirm: { type: Boolean, default: true },
  monthChangeOnArrows: { type: Boolean, default: true },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: false },
  preventMinMaxNavigation: { type: Boolean, default: false },
  reverseYears: { type: Boolean, default: false },
  weekPicker: { type: Boolean, default: false },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: false },
  highlight: {
    type: [Function, Object],
    default: null
  },
  teleport: { type: [Boolean, String, Object], default: null },
  teleportCenter: { type: Boolean, default: false },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function, Object],
    default: null
  },
  monthChangeOnScroll: { type: [Boolean, String], default: true },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: false },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: false },
  modelAuto: { type: Boolean, default: false },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: [Object, Boolean], default: false },
  ignoreTimeValidation: { type: Boolean, default: false },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: false },
  clearable: { type: Boolean, default: true },
  alwaysClearable: { type: Boolean, default: false },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: false },
  autocomplete: { type: String, default: "off" },
  timePicker: { type: Boolean, default: false },
  enableSeconds: { type: Boolean, default: false },
  is24: { type: Boolean, default: true },
  noHoursOverlay: { type: Boolean, default: false },
  noMinutesOverlay: { type: Boolean, default: false },
  noSecondsOverlay: { type: Boolean, default: false },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: [Boolean, Object], default: false },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false },
  inline: { type: [Boolean, Object], default: false },
  textInput: { type: [Boolean, Object], default: false },
  sixWeeks: { type: [Boolean, String], default: false },
  actionRow: { type: Object, default: () => ({}) },
  focusStartDate: { type: Boolean, default: false },
  disabledTimes: { type: [Function, Array], default: void 0 },
  timePickerInline: { type: Boolean, default: false },
  calendar: { type: Function, default: null },
  config: { type: Object, default: void 0 },
  quarterPicker: { type: Boolean, default: false },
  yearFirst: { type: Boolean, default: false },
  loading: { type: Boolean, default: false },
  onInternalModelChange: { type: [Function, Object], default: null },
  enableMinutes: { type: Boolean, default: true },
  ui: { type: Object, default: () => ({}) }
}, ct = {
  ...pa,
  shadow: { type: Boolean, default: false },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  noOverlayFocus: { type: Boolean, default: false },
  collapse: { type: Boolean, default: false },
  menuWrapRef: { type: Object, default: null },
  getInputRect: { type: Function, default: () => ({}) },
  isTextInputDate: { type: Boolean, default: false },
  isMobile: { type: Boolean, default: void 0 }
}, or = ["title"], sr = ["disabled"], ur = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: false },
    calendarWidth: { type: Number, default: 0 },
    ...ct
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e2, { emit: t2 }) {
    const r = t2, a = e2, {
      defaultedActionRow: n,
      defaultedPreviewFormat: u,
      defaultedMultiCalendars: c,
      defaultedTextInput: p,
      defaultedInline: d,
      defaultedRange: Y,
      defaultedMultiDates: f
    } = Ye(a), { isTimeValid: O, isMonthValid: m } = Pt(a), { buildMatrix: P } = St(), F = ref(null), L = ref(null), _ = ref(false), h2 = ref({}), R = ref(null), b = ref(null);
    onMounted(() => {
      a.arrowNavigation && P([He(F), He(L)], "actionRow"), j(), window.addEventListener("resize", j);
    }), onUnmounted(() => {
      window.removeEventListener("resize", j);
    });
    const j = () => {
      _.value = false, setTimeout(() => {
        var ee, y;
        const v2 = (ee = R.value) == null ? void 0 : ee.getBoundingClientRect(), N = (y = b.value) == null ? void 0 : y.getBoundingClientRect();
        v2 && N && (h2.value.maxWidth = `${N.width - v2.width - 20}px`), _.value = true;
      }, 0);
    }, z = computed(() => Y.value.enabled && !Y.value.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : true), ae = computed(
      () => !O.value(a.internalModelValue) || !m.value(a.internalModelValue) || !z.value
    ), H = () => {
      const v2 = u.value;
      return a.timePicker || a.monthPicker, v2(ze(a.internalModelValue));
    }, D = () => {
      const v2 = a.internalModelValue;
      return c.value.count > 0 ? `${Q(v2[0])} - ${Q(v2[1])}` : [Q(v2[0]), Q(v2[1])];
    }, Q = (v2) => Ln(
      v2,
      u.value,
      a.formatLocale,
      p.value.rangeSeparator,
      a.modelAuto,
      u.value
    ), B = computed(() => !a.internalModelValue || !a.menuMount ? "" : typeof u.value == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? D() : f.value.enabled ? a.internalModelValue.map((v2) => `${Q(v2)}`) : a.modelAuto ? `${Q(a.internalModelValue[0])}` : `${Q(a.internalModelValue[0])} -` : Q(a.internalModelValue) : H()), q = () => f.value.enabled ? "; " : " - ", ve = computed(
      () => Array.isArray(B.value) ? B.value.join(q()) : B.value
    ), pe = () => {
      O.value(a.internalModelValue) && m.value(a.internalModelValue) && z.value ? r("select-date") : r("invalid-select");
    };
    return (v2, N) => (openBlock(), createElementBlock("div", {
      ref_key: "actionRowRef",
      ref: b,
      class: "dp__action_row"
    }, [
      v2.$slots["action-row"] ? renderSlot(v2.$slots, "action-row", normalizeProps(mergeProps({ key: 0 }, {
        internalModelValue: v2.internalModelValue,
        disabled: ae.value,
        selectDate: () => v2.$emit("select-date"),
        closePicker: () => v2.$emit("close-picker")
      }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        unref(n).showPreview ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "dp__selection_preview",
          title: ve.value,
          style: normalizeStyle(h2.value)
        }, [
          v2.$slots["action-preview"] && _.value ? renderSlot(v2.$slots, "action-preview", {
            key: 0,
            value: v2.internalModelValue
          }) : createCommentVNode("", true),
          !v2.$slots["action-preview"] && _.value ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(ve.value), 1)
          ], 64)) : createCommentVNode("", true)
        ], 12, or)) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "actionBtnContainer",
          ref: R,
          class: "dp__action_buttons",
          "data-dp-element": "action-row"
        }, [
          v2.$slots["action-buttons"] ? renderSlot(v2.$slots, "action-buttons", {
            key: 0,
            value: v2.internalModelValue
          }) : createCommentVNode("", true),
          v2.$slots["action-buttons"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !unref(d).enabled && unref(n).showCancel ? (openBlock(), createElementBlock("button", {
              key: 0,
              ref_key: "cancelButtonRef",
              ref: F,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: N[0] || (N[0] = (ee) => v2.$emit("close-picker")),
              onKeydown: N[1] || (N[1] = (ee) => unref(xe)(ee, () => v2.$emit("close-picker")))
            }, toDisplayString(v2.cancelText), 545)) : createCommentVNode("", true),
            unref(n).showNow ? (openBlock(), createElementBlock("button", {
              key: 1,
              type: "button",
              class: "dp__action_button dp__action_cancel",
              onClick: N[2] || (N[2] = (ee) => v2.$emit("select-now")),
              onKeydown: N[3] || (N[3] = (ee) => unref(xe)(ee, () => v2.$emit("select-now")))
            }, toDisplayString(v2.nowButtonLabel), 33)) : createCommentVNode("", true),
            unref(n).showSelect ? (openBlock(), createElementBlock("button", {
              key: 2,
              ref_key: "selectButtonRef",
              ref: L,
              type: "button",
              class: "dp__action_button dp__action_select",
              disabled: ae.value,
              "data-test-id": "select-button",
              onKeydown: N[4] || (N[4] = (ee) => unref(xe)(ee, () => pe())),
              onClick: pe
            }, toDisplayString(v2.selectText), 41, sr)) : createCommentVNode("", true)
          ], 64))
        ], 512)
      ], 64))
    ], 512));
  }
}), ir = ["role", "aria-label", "tabindex"], dr = { class: "dp__selection_grid_header" }, cr = ["aria-selected", "aria-disabled", "data-test-id", "onClick", "onKeydown", "onMouseover"], fr = ["aria-label"], aa = /* @__PURE__ */ defineComponent({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] },
    config: {},
    noOverlayFocus: { type: Boolean },
    focusValue: {},
    menuWrapRef: {},
    ariaLabels: {},
    overlayLabel: {}
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e2, { expose: t2, emit: r }) {
    const { setSelectionGrid: a, buildMultiLevelMatrix: n, setMonthPicker: u } = St(), c = r, p = e2, { defaultedAriaLabels: d, defaultedTextInput: Y, defaultedConfig: f, handleEventPropagation: O } = Ye(
      p
    ), { hideNavigationButtons: m } = ha(), P = ref(false), F = ref(null), L = ref(null), _ = ref([]), h2 = ref(), R = ref(null), b = ref(0), j = ref(null);
    onBeforeUpdate(() => {
      F.value = null;
    }), onMounted(() => {
      nextTick().then(() => ve()), p.noOverlayFocus || ae(), z(true);
    }), onUnmounted(() => z(false));
    const z = (i) => {
      var W;
      p.arrowNavigation && ((W = p.headerRefs) != null && W.length ? u(i) : a(i));
    }, ae = () => {
      var W;
      const i = He(L);
      i && (Y.value.enabled || (F.value ? (W = F.value) == null || W.focus({ preventScroll: true }) : i.focus({ preventScroll: true })), P.value = i.clientHeight < i.scrollHeight);
    }, H = computed(
      () => ({
        dp__overlay: true,
        "dp--overlay-absolute": !p.useRelative,
        "dp--overlay-relative": p.useRelative
      })
    ), D = computed(
      () => p.useRelative ? { height: `${p.height}px`, width: "var(--dp-menu-min-width)" } : void 0
    ), Q = computed(() => ({
      dp__overlay_col: true
    })), B = computed(
      () => ({
        dp__btn: true,
        dp__button: true,
        dp__overlay_action: true,
        dp__over_action_scroll: P.value,
        dp__button_bottom: p.isLast
      })
    ), q = computed(() => {
      var i, W;
      return {
        dp__overlay_container: true,
        dp__container_flex: ((i = p.items) == null ? void 0 : i.length) <= 6,
        dp__container_block: ((W = p.items) == null ? void 0 : W.length) > 6
      };
    });
    watch(
      () => p.items,
      () => ve(false),
      { deep: true }
    );
    const ve = (i = true) => {
      nextTick().then(() => {
        const W = He(F), se = He(L), T = He(R), re = He(j), l = T ? T.getBoundingClientRect().height : 0;
        se && (se.getBoundingClientRect().height ? b.value = se.getBoundingClientRect().height - l : b.value = f.value.modeHeight - l), W && re && i && (re.scrollTop = W.offsetTop - re.offsetTop - (b.value / 2 - W.getBoundingClientRect().height) - l);
      });
    }, pe = (i) => {
      i.disabled || c("selected", i.value);
    }, v2 = () => {
      c("toggle"), c("reset-flow");
    }, N = (i) => {
      p.escClose && (v2(), O(i));
    }, ee = (i, W, se, T) => {
      i && ((W.active || W.value === p.focusValue) && (F.value = i), p.arrowNavigation && (Array.isArray(_.value[se]) ? _.value[se][T] = i : _.value[se] = [i], y()));
    }, y = () => {
      var W, se;
      const i = (W = p.headerRefs) != null && W.length ? [p.headerRefs].concat(_.value) : _.value.concat([p.skipButtonRef ? [] : [R.value]]);
      n(ze(i), (se = p.headerRefs) != null && se.length ? "monthPicker" : "selectionGrid");
    }, U = (i) => {
      p.arrowNavigation || $t(i, f.value, true);
    }, S = (i) => {
      h2.value = i, c("hover-value", i);
    }, Z = () => {
      if (v2(), !p.isLast) {
        const i = Fa(p.menuWrapRef ?? null, "action-row");
        if (i) {
          const W = Rn(i);
          W == null || W.focus();
        }
      }
    }, A = (i) => {
      switch (i.key) {
        case Oe.esc:
          return N(i);
        case Oe.arrowLeft:
          return U(i);
        case Oe.arrowRight:
          return U(i);
        case Oe.arrowUp:
          return U(i);
        case Oe.arrowDown:
          return U(i);
        default:
          return;
      }
    }, ie = (i) => {
      if (i.key === Oe.enter) return v2();
      if (i.key === Oe.tab) return Z();
    };
    return t2({ focusGrid: ae }), (i, W) => {
      var se;
      return openBlock(), createElementBlock("div", {
        ref_key: "gridWrapRef",
        ref: L,
        class: normalizeClass(H.value),
        style: normalizeStyle(D.value),
        role: i.useRelative ? void 0 : "dialog",
        "aria-label": i.overlayLabel,
        tabindex: i.useRelative ? void 0 : "0",
        onKeydown: A,
        onClick: W[0] || (W[0] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createBaseVNode("div", {
          ref_key: "containerRef",
          ref: j,
          class: normalizeClass(q.value),
          style: normalizeStyle({ "--dp-overlay-height": `${b.value}px` }),
          role: "grid"
        }, [
          createBaseVNode("div", dr, [
            renderSlot(i.$slots, "header")
          ]),
          i.$slots.overlay ? renderSlot(i.$slots, "overlay", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(i.items, (T, re) => (openBlock(), createElementBlock("div", {
            key: re,
            class: normalizeClass(["dp__overlay_row", { dp__flex_row: i.items.length >= 3 }]),
            role: "row"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(T, (l, w) => (openBlock(), createElementBlock("div", {
              key: l.value,
              ref_for: true,
              ref: (oe) => ee(oe, l, re, w),
              role: "gridcell",
              class: normalizeClass(Q.value),
              "aria-selected": l.active || void 0,
              "aria-disabled": l.disabled || void 0,
              tabindex: "0",
              "data-test-id": l.text,
              onClick: withModifiers((oe) => pe(l), ["prevent"]),
              onKeydown: (oe) => unref(xe)(oe, () => pe(l), true),
              onMouseover: (oe) => S(l.value)
            }, [
              createBaseVNode("div", {
                class: normalizeClass(l.className)
              }, [
                i.$slots.item ? renderSlot(i.$slots, "item", {
                  key: 0,
                  item: l
                }) : createCommentVNode("", true),
                i.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(l.text), 1)
                ], 64))
              ], 2)
            ], 42, cr))), 128))
          ], 2))), 128))
        ], 6),
        i.$slots["button-icon"] ? withDirectives((openBlock(), createElementBlock("button", {
          key: 0,
          ref_key: "toggleButton",
          ref: R,
          type: "button",
          "aria-label": (se = unref(d)) == null ? void 0 : se.toggleOverlay,
          class: normalizeClass(B.value),
          tabindex: "0",
          onClick: v2,
          onKeydown: ie
        }, [
          renderSlot(i.$slots, "button-icon")
        ], 42, fr)), [
          [vShow, !unref(m)(i.hideNavigation, i.type)]
        ]) : createCommentVNode("", true)
      ], 46, ir);
    };
  }
}), vr = ["data-dp-mobile"], ya = /* @__PURE__ */ defineComponent({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean },
    collapse: { type: Boolean },
    isMobile: { type: Boolean }
  },
  setup(e2) {
    const t2 = e2, r = computed(
      () => t2.multiCalendars > 0 ? [...Array(t2.multiCalendars).keys()] : [0]
    ), a = computed(() => ({
      dp__instance_calendar: t2.multiCalendars > 0
    }));
    return (n, u) => (openBlock(), createElementBlock("div", {
      class: normalizeClass({
        dp__menu_inner: !n.stretch,
        "dp--menu--inner-stretched": n.stretch,
        dp__flex_display: n.multiCalendars > 0,
        "dp--flex-display-collapsed": n.collapse
      }),
      "data-dp-mobile": n.isMobile
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (c, p) => (openBlock(), createElementBlock("div", {
        key: c,
        class: normalizeClass(a.value)
      }, [
        renderSlot(n.$slots, "default", {
          instance: c,
          index: p
        })
      ], 2))), 128))
    ], 10, vr));
  }
}), mr = ["data-dp-element", "aria-label", "aria-disabled"], qt = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    elName: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e2, { emit: t2 }) {
    const r = t2, a = ref(null);
    return onMounted(() => r("set-ref", a)), (n, u) => (openBlock(), createElementBlock("button", {
      ref_key: "elRef",
      ref: a,
      type: "button",
      "data-dp-element": n.elName,
      class: "dp__btn dp--arrow-btn-nav",
      tabindex: "0",
      "aria-label": n.ariaLabel,
      "aria-disabled": n.disabled || void 0,
      onClick: u[0] || (u[0] = (c) => n.$emit("activate")),
      onKeydown: u[1] || (u[1] = (c) => unref(xe)(c, () => n.$emit("activate"), true))
    }, [
      createBaseVNode("span", {
        class: normalizeClass(["dp__inner_nav", { dp__inner_nav_disabled: n.disabled }])
      }, [
        renderSlot(n.$slots, "default")
      ], 2)
    ], 40, mr));
  }
}), pr = ["aria-label", "data-test-id"], Hn = /* @__PURE__ */ defineComponent({
  __name: "YearModePicker",
  props: {
    ...ct,
    showYearPicker: { type: Boolean, default: false },
    items: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    isDisabled: { type: Function, default: () => false }
  },
  emits: ["toggle-year-picker", "year-select", "handle-year"],
  setup(e2, { emit: t2 }) {
    const r = t2, a = e2, { showRightIcon: n, showLeftIcon: u } = ha(), { defaultedConfig: c, defaultedMultiCalendars: p, defaultedAriaLabels: d, defaultedTransitions: Y, defaultedUI: f } = Ye(a), { showTransition: O, transitionName: m } = na(Y), P = ref(false), F = (h2 = false, R) => {
      P.value = !P.value, r("toggle-year-picker", { flow: h2, show: R });
    }, L = (h2) => {
      P.value = false, r("year-select", h2);
    }, _ = (h2 = false) => {
      r("handle-year", h2);
    };
    return (h2, R) => {
      var b, j, z, ae, H;
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          class: normalizeClass(["dp--year-mode-picker", { "dp--hidden-el": P.value }])
        }, [
          unref(u)(unref(p), e2.instance) ? (openBlock(), createBlock(qt, {
            key: 0,
            ref: "mpPrevIconRef",
            "aria-label": (b = unref(d)) == null ? void 0 : b.prevYear,
            disabled: e2.isDisabled(false),
            class: normalizeClass((j = unref(f)) == null ? void 0 : j.navBtnPrev),
            onActivate: R[0] || (R[0] = (D) => _(false))
          }, {
            default: withCtx(() => [
              h2.$slots["arrow-left"] ? renderSlot(h2.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
              h2.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wa), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
          createBaseVNode("button", {
            ref: "mpYearButtonRef",
            class: "dp__btn dp--year-select",
            type: "button",
            "aria-label": `${e2.year}-${(z = unref(d)) == null ? void 0 : z.openYearsOverlay}`,
            "data-test-id": `year-mode-btn-${e2.instance}`,
            onClick: R[1] || (R[1] = () => F(false)),
            onKeydown: R[2] || (R[2] = withKeys(() => F(false), ["enter"]))
          }, [
            h2.$slots.year ? renderSlot(h2.$slots, "year", {
              key: 0,
              year: e2.year
            }) : createCommentVNode("", true),
            h2.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(e2.year), 1)
            ], 64))
          ], 40, pr),
          unref(n)(unref(p), e2.instance) ? (openBlock(), createBlock(qt, {
            key: 1,
            ref: "mpNextIconRef",
            "aria-label": (ae = unref(d)) == null ? void 0 : ae.nextYear,
            disabled: e2.isDisabled(true),
            class: normalizeClass((H = unref(f)) == null ? void 0 : H.navBtnNext),
            onActivate: R[3] || (R[3] = (D) => _(true))
          }, {
            default: withCtx(() => [
              h2.$slots["arrow-right"] ? renderSlot(h2.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
              h2.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Va), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true)
        ], 2),
        createVNode(Transition, {
          name: unref(m)(e2.showYearPicker),
          css: unref(O)
        }, {
          default: withCtx(() => {
            var D, Q;
            return [
              e2.showYearPicker ? (openBlock(), createBlock(aa, {
                key: 0,
                items: e2.items,
                "text-input": h2.textInput,
                "esc-close": h2.escClose,
                config: h2.config,
                "is-last": h2.autoApply && !unref(c).keepActionRow,
                "hide-navigation": h2.hideNavigation,
                "aria-labels": h2.ariaLabels,
                "overlay-label": (Q = (D = unref(d)) == null ? void 0 : D.yearPicker) == null ? void 0 : Q.call(D, true),
                type: "year",
                onToggle: F,
                onSelected: R[4] || (R[4] = (B) => L(B))
              }, createSlots({
                "button-icon": withCtx(() => [
                  h2.$slots["calendar-icon"] ? renderSlot(h2.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                  h2.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Gt), { key: 1 }))
                ]),
                _: 2
              }, [
                h2.$slots["year-overlay-value"] ? {
                  name: "item",
                  fn: withCtx(({ item: B }) => [
                    renderSlot(h2.$slots, "year-overlay-value", {
                      text: B.text,
                      value: B.value
                    })
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels", "overlay-label"])) : createCommentVNode("", true)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 64);
    };
  }
}), xa = (e2, t2, r) => {
  if (t2.value && Array.isArray(t2.value))
    if (t2.value.some((a) => Te(e2, a))) {
      const a = t2.value.filter((n) => !Te(n, e2));
      t2.value = a.length ? a : null;
    } else (r && +r > t2.value.length || !r) && t2.value.push(e2);
  else
    t2.value = [e2];
}, en = (e2, t2, r) => {
  let a = e2.value ? e2.value.slice() : [];
  return a.length === 2 && a[1] !== null && (a = []), a.length ? (Ne(t2, a[0]) ? a.unshift(t2) : a[1] = t2, r("range-end", t2)) : (a = [t2], r("range-start", t2)), a;
}, ga = (e2, t2, r, a) => {
  e2 && (e2[0] && e2[1] && r && t2("auto-apply"), e2[0] && !e2[1] && a && r && t2("auto-apply"));
}, Un = (e2) => {
  Array.isArray(e2.value) && e2.value.length <= 2 && e2.range ? e2.modelValue.value = e2.value.map((t2) => tt(K(t2), e2.timezone)) : Array.isArray(e2.value) || (e2.modelValue.value = tt(K(e2.value), e2.timezone));
}, Wn = (e2, t2, r, a) => Array.isArray(t2.value) && (t2.value.length === 2 || t2.value.length === 1 && a.value.partialRange) ? a.value.fixedStart && (Fe(e2, t2.value[0]) || Te(e2, t2.value[0])) ? [t2.value[0], e2] : a.value.fixedEnd && (Ne(e2, t2.value[1]) || Te(e2, t2.value[1])) ? [e2, t2.value[1]] : (r("invalid-fixed-range", e2), t2.value) : [], Vn = ({
  multiCalendars: e2,
  range: t2,
  highlight: r,
  propDates: a,
  calendars: n,
  modelValue: u,
  props: c,
  filters: p,
  year: d,
  month: Y,
  emit: f
}) => {
  const O = computed(() => qa(c.yearRange, c.locale, c.reverseYears)), m = ref([false]), P = computed(() => (B, q) => {
    const ve = set(dt(/* @__PURE__ */ new Date()), {
      month: Y.value(B),
      year: d.value(B)
    }), pe = q ? endOfYear(ve) : startOfYear(ve);
    return Nn(
      pe,
      a.value.maxDate,
      a.value.minDate,
      c.preventMinMaxNavigation,
      q
    );
  }), F = () => Array.isArray(u.value) && e2.value.solo && u.value[1], L = () => {
    for (let B = 0; B < e2.value.count; B++)
      if (B === 0)
        n.value[B] = n.value[0];
      else if (B === e2.value.count - 1 && F())
        n.value[B] = {
          month: getMonth(u.value[1]),
          year: getYear(u.value[1])
        };
      else {
        const q = set(K(), n.value[B - 1]);
        n.value[B] = { month: getMonth(q), year: getYear(addYears(q, 1)) };
      }
  }, _ = (B) => {
    if (!B) return L();
    const q = set(K(), n.value[B]);
    return n.value[0].year = getYear(subYears(q, e2.value.count - 1)), L();
  }, h2 = (B, q) => {
    const ve = differenceInYears(q, B);
    return t2.value.showLastInRange && ve > 1 ? q : B;
  }, R = (B) => c.focusStartDate || e2.value.solo ? B[0] : B[1] ? h2(B[0], B[1]) : B[0], b = () => {
    if (u.value) {
      const B = Array.isArray(u.value) ? R(u.value) : u.value;
      n.value[0] = { month: getMonth(B), year: getYear(B) };
    }
  }, j = () => {
    b(), e2.value.count && L();
  };
  watch(u, (B, q) => {
    c.isTextInputDate && JSON.stringify(B ?? {}) !== JSON.stringify(q ?? {}) && j();
  }), onMounted(() => {
    j();
  });
  const z = (B, q) => {
    n.value[q].year = B, f("update-month-year", { instance: q, year: B, month: n.value[q].month }), e2.value.count && !e2.value.solo && _(q);
  }, ae = computed(() => (B) => Wt(O.value, (q) => {
    var N;
    const ve = d.value(B) === q.value, pe = xt(
      q.value,
      Vt(a.value.minDate),
      Vt(a.value.maxDate)
    ) || ((N = p.value.years) == null ? void 0 : N.includes(d.value(B))), v2 = Za(r.value, q.value);
    return { active: ve, disabled: pe, highlighted: v2 };
  })), H = (B, q) => {
    z(B, q), Q(q);
  }, D = (B, q = false) => {
    if (!P.value(B, q)) {
      const ve = q ? d.value(B) + 1 : d.value(B) - 1;
      z(ve, B);
    }
  }, Q = (B, q = false, ve) => {
    q || f("reset-flow"), ve !== void 0 ? m.value[B] = ve : m.value[B] = !m.value[B], m.value[B] ? f("overlay-toggle", { open: true, overlay: qe.year }) : (f("overlay-closed"), f("overlay-toggle", { open: false, overlay: qe.year }));
  };
  return {
    isDisabled: P,
    groupedYears: ae,
    showYearPicker: m,
    selectYear: z,
    toggleYearPicker: Q,
    handleYearSelect: H,
    handleYear: D
  };
}, yr = (e2, t2) => {
  const {
    defaultedMultiCalendars: r,
    defaultedAriaLabels: a,
    defaultedTransitions: n,
    defaultedConfig: u,
    defaultedRange: c,
    defaultedHighlight: p,
    propDates: d,
    defaultedTz: Y,
    defaultedFilters: f,
    defaultedMultiDates: O
  } = Ye(e2), m = () => {
    e2.isTextInputDate && j(getYear(K(e2.startDate)), 0);
  }, { modelValue: P, year: F, month: L, calendars: _ } = la(e2, t2, m), h2 = computed(() => Sn(e2.formatLocale, e2.locale, e2.monthNameFormat)), R = ref(null), { checkMinMaxRange: b } = Pt(e2), {
    selectYear: j,
    groupedYears: z,
    showYearPicker: ae,
    toggleYearPicker: H,
    handleYearSelect: D,
    handleYear: Q,
    isDisabled: B
  } = Vn({
    modelValue: P,
    multiCalendars: r,
    range: c,
    highlight: p,
    calendars: _,
    year: F,
    propDates: d,
    month: L,
    filters: f,
    props: e2,
    emit: t2
  });
  onMounted(() => {
    e2.startDate && (P.value && e2.focusStartDate || !P.value) && j(getYear(K(e2.startDate)), 0);
  });
  const q = (T) => T ? { month: getMonth(T), year: getYear(T) } : { month: null, year: null }, ve = () => P.value ? Array.isArray(P.value) ? P.value.map((T) => q(T)) : q(P.value) : q(), pe = (T, re) => {
    const l = _.value[T], w = ve();
    return Array.isArray(w) ? w.some((oe) => oe.year === (l == null ? void 0 : l.year) && oe.month === re) : (l == null ? void 0 : l.year) === w.year && re === w.month;
  }, v2 = (T, re, l) => {
    var oe, M;
    const w = ve();
    return Array.isArray(w) ? F.value(re) === ((oe = w[l]) == null ? void 0 : oe.year) && T === ((M = w[l]) == null ? void 0 : M.month) : false;
  }, N = (T, re) => {
    if (c.value.enabled) {
      const l = ve();
      if (Array.isArray(P.value) && Array.isArray(l)) {
        const w = v2(T, re, 0) || v2(T, re, 1), oe = ht(dt(K()), T, F.value(re));
        return ea(P.value, R.value, oe) && !w;
      }
      return false;
    }
    return false;
  }, ee = computed(() => (T) => Wt(h2.value, (re) => {
    var he;
    const l = pe(T, re.value), w = xt(
      re.value,
      _n(F.value(T), d.value.minDate),
      Yn(F.value(T), d.value.maxDate)
    ) || Fl(d.value.disabledDates, F.value(T), re.value) || ((he = f.value.months) == null ? void 0 : he.includes(re.value)) || !zl(d.value.allowedDates, F.value(T), re.value), oe = N(re.value, T), M = Fn(p.value, re.value, F.value(T));
    return { active: l, disabled: w, isBetween: oe, highlighted: M };
  })), y = (T, re) => ht(dt(K()), T, F.value(re)), U = (T, re) => {
    const l = P.value ? P.value : dt(/* @__PURE__ */ new Date());
    P.value = ht(l, T, F.value(re)), t2("auto-apply"), t2("update-flow-step");
  }, S = (T, re) => {
    const l = y(T, re);
    c.value.fixedEnd || c.value.fixedStart ? P.value = Wn(l, P, t2, c) : P.value ? b(l, P.value) && (P.value = en(P, y(T, re), t2)) : P.value = [y(T, re)], nextTick().then(() => {
      ga(P.value, t2, e2.autoApply, e2.modelAuto);
    });
  }, Z = (T, re) => {
    xa(y(T, re), P, O.value.limit), t2("auto-apply", true);
  }, A = (T, re) => (_.value[re].month = T, i(re, _.value[re].year, T), O.value.enabled ? Z(T, re) : c.value.enabled ? S(T, re) : U(T, re)), ie = (T, re) => {
    j(T, re), i(re, T, null);
  }, i = (T, re, l) => {
    let w = l;
    if (!w && w !== 0) {
      const oe = ve();
      w = Array.isArray(oe) ? oe[T].month : oe.month;
    }
    t2("update-month-year", { instance: T, year: re, month: w });
  };
  return {
    groupedMonths: ee,
    groupedYears: z,
    year: F,
    isDisabled: B,
    defaultedMultiCalendars: r,
    defaultedAriaLabels: a,
    defaultedTransitions: n,
    defaultedConfig: u,
    showYearPicker: ae,
    modelValue: P,
    presetDate: (T, re) => {
      Un({
        value: T,
        modelValue: P,
        range: c.value.enabled,
        timezone: re ? void 0 : Y.value.timezone
      }), t2("auto-apply");
    },
    setHoverDate: (T, re) => {
      R.value = y(T, re);
    },
    selectMonth: A,
    selectYear: ie,
    toggleYearPicker: H,
    handleYearSelect: D,
    handleYear: Q,
    getModelMonthYear: ve
  };
}, gr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...ct
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year",
    "update-flow-step",
    "mount",
    "invalid-fixed-range",
    "overlay-toggle"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = useSlots(), u = at(n, "yearMode"), c = e2;
    onMounted(() => {
      c.shadow || a("mount", null);
    });
    const {
      groupedMonths: p,
      groupedYears: d,
      year: Y,
      isDisabled: f,
      defaultedMultiCalendars: O,
      defaultedConfig: m,
      showYearPicker: P,
      modelValue: F,
      presetDate: L,
      setHoverDate: _,
      selectMonth: h2,
      selectYear: R,
      toggleYearPicker: b,
      handleYearSelect: j,
      handleYear: z,
      getModelMonthYear: ae
    } = yr(c, a);
    return t2({ getSidebarProps: () => ({
      modelValue: F,
      year: Y,
      getModelMonthYear: ae,
      selectMonth: h2,
      selectYear: R,
      handleYear: z
    }), presetDate: L, toggleYearPicker: (D) => b(0, D) }), (D, Q) => (openBlock(), createBlock(ya, {
      "multi-calendars": unref(O).count,
      collapse: D.collapse,
      stretch: "",
      "is-mobile": D.isMobile
    }, {
      default: withCtx(({ instance: B }) => [
        D.$slots["top-extra"] ? renderSlot(D.$slots, "top-extra", {
          key: 0,
          value: D.internalModelValue
        }) : createCommentVNode("", true),
        D.$slots["month-year"] ? renderSlot(D.$slots, "month-year", normalizeProps(mergeProps({ key: 1 }, {
          year: unref(Y),
          months: unref(p)(B),
          years: unref(d)(B),
          selectMonth: unref(h2),
          selectYear: unref(R),
          instance: B
        }))) : (openBlock(), createBlock(aa, {
          key: 2,
          items: unref(p)(B),
          "arrow-navigation": D.arrowNavigation,
          "is-last": D.autoApply && !unref(m).keepActionRow,
          "esc-close": D.escClose,
          height: unref(m).modeHeight,
          config: D.config,
          "no-overlay-focus": !!(D.noOverlayFocus || D.textInput),
          "use-relative": "",
          type: "month",
          onSelected: (q) => unref(h2)(q, B),
          onHoverValue: (q) => unref(_)(q, B)
        }, createSlots({
          header: withCtx(() => [
            createVNode(Hn, mergeProps(D.$props, {
              items: unref(d)(B),
              instance: B,
              "show-year-picker": unref(P)[B],
              year: unref(Y)(B),
              "is-disabled": (q) => unref(f)(B, q),
              onHandleYear: (q) => unref(z)(B, q),
              onYearSelect: (q) => unref(j)(q, B),
              onToggleYearPicker: (q) => unref(b)(B, q == null ? void 0 : q.flow, q == null ? void 0 : q.show)
            }), createSlots({ _: 2 }, [
              renderList(unref(u), (q, ve) => ({
                name: q,
                fn: withCtx((pe) => [
                  renderSlot(D.$slots, q, normalizeProps(guardReactiveProps(pe)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          _: 2
        }, [
          D.$slots["month-overlay-value"] ? {
            name: "item",
            fn: withCtx(({ item: q }) => [
              renderSlot(D.$slots, "month-overlay-value", {
                text: q.text,
                value: q.value
              })
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), hr = (e2, t2) => {
  const r = () => {
    e2.isTextInputDate && (f.value = getYear(K(e2.startDate)));
  }, { modelValue: a } = la(e2, t2, r), n = ref(null), { defaultedHighlight: u, defaultedMultiDates: c, defaultedFilters: p, defaultedRange: d, propDates: Y } = Ye(e2), f = ref();
  onMounted(() => {
    e2.startDate && (a.value && e2.focusStartDate || !a.value) && (f.value = getYear(K(e2.startDate)));
  });
  const O = (b) => Array.isArray(a.value) ? a.value.some((j) => getYear(j) === b) : a.value ? getYear(a.value) === b : false, m = (b) => d.value.enabled && Array.isArray(a.value) ? ea(a.value, n.value, _(b)) : false, P = (b) => Y.value.allowedDates instanceof Map ? Y.value.allowedDates.size ? Y.value.allowedDates.has(`${b}`) : false : true, F = (b) => Y.value.disabledDates instanceof Map ? Y.value.disabledDates.size ? Y.value.disabledDates.has(`${b}`) : false : true, L = computed(() => Wt(qa(e2.yearRange, e2.locale, e2.reverseYears), (b) => {
    const j = O(b.value), z = xt(
      b.value,
      Vt(Y.value.minDate),
      Vt(Y.value.maxDate)
    ) || p.value.years.includes(b.value) || !P(b.value) || F(b.value), ae = m(b.value) && !j, H = Za(u.value, b.value);
    return { active: j, disabled: z, isBetween: ae, highlighted: H };
  })), _ = (b) => setYear(dt(startOfYear(/* @__PURE__ */ new Date())), b);
  return {
    groupedYears: L,
    modelValue: a,
    focusYear: f,
    setHoverValue: (b) => {
      n.value = setYear(dt(/* @__PURE__ */ new Date()), b);
    },
    selectYear: (b) => {
      var j;
      if (t2("update-month-year", { instance: 0, year: b }), c.value.enabled)
        return a.value ? Array.isArray(a.value) && (((j = a.value) == null ? void 0 : j.map((ae) => getYear(ae))).includes(b) ? a.value = a.value.filter((ae) => getYear(ae) !== b) : a.value.push(setYear(je(K()), b))) : a.value = [setYear(je(startOfYear(K())), b)], t2("auto-apply", true);
      d.value.enabled ? (a.value = en(a, _(b), t2), nextTick().then(() => {
        ga(a.value, t2, e2.autoApply, e2.modelAuto);
      })) : (a.value = _(b), t2("auto-apply"));
    }
  };
}, br = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...ct
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, { groupedYears: u, modelValue: c, focusYear: p, selectYear: d, setHoverValue: Y } = hr(n, a), { defaultedConfig: f } = Ye(n);
    return t2({ getSidebarProps: () => ({
      modelValue: c,
      selectYear: d
    }) }), (m, P) => (openBlock(), createElementBlock("div", null, [
      m.$slots["top-extra"] ? renderSlot(m.$slots, "top-extra", {
        key: 0,
        value: m.internalModelValue
      }) : createCommentVNode("", true),
      m.$slots["month-year"] ? renderSlot(m.$slots, "month-year", normalizeProps(mergeProps({ key: 1 }, {
        years: unref(u),
        selectYear: unref(d)
      }))) : (openBlock(), createBlock(aa, {
        key: 2,
        items: unref(u),
        "is-last": m.autoApply && !unref(f).keepActionRow,
        height: unref(f).modeHeight,
        config: m.config,
        "no-overlay-focus": !!(m.noOverlayFocus || m.textInput),
        "focus-value": unref(p),
        type: "year",
        "use-relative": "",
        onSelected: unref(d),
        onHoverValue: unref(Y)
      }, createSlots({ _: 2 }, [
        m.$slots["year-overlay-value"] ? {
          name: "item",
          fn: withCtx(({ item: F }) => [
            renderSlot(m.$slots, "year-overlay-value", {
              text: F.text,
              value: F.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))
    ]));
  }
}), kr = {
  key: 0,
  class: "dp__time_input"
}, wr = ["data-compact", "data-collapsed"], Dr = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], Mr = ["aria-label", "disabled", "data-test-id", "onKeydown", "onClick"], $r = ["data-test-id", "aria-label", "onKeydown", "onClick", "onMousedown"], Ar = { key: 0 }, Tr = ["aria-label", "data-compact"], Sr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: { type: Function, default: () => false },
    ...ct
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "overlay-opened",
    "am-pm-change"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, { setTimePickerElements: u, setTimePickerBackRef: c } = St(), {
      defaultedAriaLabels: p,
      defaultedTransitions: d,
      defaultedFilters: Y,
      defaultedConfig: f,
      defaultedRange: O,
      defaultedMultiCalendars: m
    } = Ye(n), { transitionName: P, showTransition: F } = na(d), L = reactive({
      hours: false,
      minutes: false,
      seconds: false
    }), _ = ref("AM"), h2 = ref(null), R = ref([]), b = ref(), j = ref(false);
    onMounted(() => {
      a("mounted");
    });
    const z = (o) => set(/* @__PURE__ */ new Date(), {
      hours: o.hours,
      minutes: o.minutes,
      seconds: n.enableSeconds ? o.seconds : 0,
      milliseconds: 0
    }), ae = computed(
      () => (o) => S(o, n[o]) || D(o, n[o])
    ), H = computed(() => ({ hours: n.hours, minutes: n.minutes, seconds: n.seconds })), D = (o, E) => O.value.enabled && !O.value.disableTimeRangeValidation ? !n.validateTime(o, E) : false, Q = (o, E) => {
      if (O.value.enabled && !O.value.disableTimeRangeValidation) {
        const fe = E ? +n[`${o}Increment`] : -+n[`${o}Increment`], I = n[o] + fe;
        return !n.validateTime(o, I);
      }
      return false;
    }, B = computed(() => (o) => !W(+n[o] + +n[`${o}Increment`], o) || Q(o, true)), q = computed(() => (o) => !W(+n[o] - +n[`${o}Increment`], o) || Q(o, false)), ve = (o, E) => add(set(K(), o), E), pe = (o, E) => sub(set(K(), o), E), v2 = computed(
      () => ({
        dp__time_col: true,
        dp__time_col_block: !n.timePickerInline,
        dp__time_col_reg_block: !n.enableSeconds && n.is24 && !n.timePickerInline,
        dp__time_col_reg_inline: !n.enableSeconds && n.is24 && n.timePickerInline,
        dp__time_col_reg_with_button: !n.enableSeconds && !n.is24,
        dp__time_col_sec: n.enableSeconds && n.is24,
        dp__time_col_sec_with_button: n.enableSeconds && !n.is24
      })
    ), N = computed(
      () => n.timePickerInline && O.value.enabled && !m.value.count
    ), ee = computed(() => {
      const o = [{ type: "hours" }];
      return n.enableMinutes && o.push({ type: "", separator: true }, {
        type: "minutes"
      }), n.enableSeconds && o.push({ type: "", separator: true }, {
        type: "seconds"
      }), o;
    }), y = computed(() => ee.value.filter((o) => !o.separator)), U = computed(() => (o) => {
      if (o === "hours") {
        const E = oe(+n.hours);
        return { text: E < 10 ? `0${E}` : `${E}`, value: E };
      }
      return { text: n[o] < 10 ? `0${n[o]}` : `${n[o]}`, value: n[o] };
    }), S = (o, E) => {
      var I;
      if (!n.disabledTimesConfig) return false;
      const fe = n.disabledTimesConfig(n.order, o === "hours" ? E : void 0);
      return fe[o] ? !!((I = fe[o]) != null && I.includes(E)) : true;
    }, Z = (o, E) => E !== "hours" || _.value === "AM" ? o : o + 12, A = (o) => {
      const E = n.is24 ? 24 : 12, fe = o === "hours" ? E : 60, I = +n[`${o}GridIncrement`], $e = o === "hours" && !n.is24 ? I : 0, be = [];
      for (let Pe2 = $e; Pe2 < fe; Pe2 += I)
        be.push({ value: n.is24 ? Pe2 : Z(Pe2, o), text: Pe2 < 10 ? `0${Pe2}` : `${Pe2}` });
      return o === "hours" && !n.is24 && be.unshift({ value: _.value === "PM" ? 12 : 0, text: "12" }), Wt(be, (Pe2) => ({ active: false, disabled: Y.value.times[o].includes(Pe2.value) || !W(Pe2.value, o) || S(o, Pe2.value) || D(o, Pe2.value) }));
    }, ie = (o) => o >= 0 ? o : 59, i = (o) => o >= 0 ? o : 23, W = (o, E) => {
      const fe = n.minTime ? z(Sa(n.minTime)) : null, I = n.maxTime ? z(Sa(n.maxTime)) : null, $e = z(
        Sa(
          H.value,
          E,
          E === "minutes" || E === "seconds" ? ie(o) : i(o)
        )
      );
      return fe && I ? (isBefore($e, I) || isEqual($e, I)) && (isAfter($e, fe) || isEqual($e, fe)) : fe ? isAfter($e, fe) || isEqual($e, fe) : I ? isBefore($e, I) || isEqual($e, I) : true;
    }, se = (o) => n[`no${o[0].toUpperCase() + o.slice(1)}Overlay`], T = (o) => {
      se(o) || (L[o] = !L[o], L[o] ? (j.value = true, a("overlay-opened", o)) : (j.value = false, a("overlay-closed", o)));
    }, re = (o) => o === "hours" ? getHours : o === "minutes" ? getMinutes : getSeconds, l = () => {
      b.value && clearTimeout(b.value);
    }, w = (o, E = true, fe) => {
      const I = E ? ve : pe, $e = E ? +n[`${o}Increment`] : -+n[`${o}Increment`];
      W(+n[o] + $e, o) && a(
        `update:${o}`,
        re(o)(I({ [o]: +n[o] }, { [o]: +n[`${o}Increment`] }))
      ), !(fe != null && fe.keyboard) && f.value.timeArrowHoldThreshold && (b.value = setTimeout(() => {
        w(o, E);
      }, f.value.timeArrowHoldThreshold));
    }, oe = (o) => n.is24 ? o : (o >= 12 ? _.value = "PM" : _.value = "AM", Tl(o)), M = () => {
      _.value === "PM" ? (_.value = "AM", a("update:hours", n.hours - 12)) : (_.value = "PM", a("update:hours", n.hours + 12)), a("am-pm-change", _.value);
    }, he = (o) => {
      L[o] = true;
    }, ke = (o, E, fe) => {
      if (o && n.arrowNavigation) {
        Array.isArray(R.value[E]) ? R.value[E][fe] = o : R.value[E] = [o];
        const I = R.value.reduce(
          ($e, be) => be.map((Pe2, Ee) => [...$e[Ee] || [], be[Ee]]),
          []
        );
        c(n.closeTimePickerBtn), h2.value && (I[1] = I[1].concat(h2.value)), u(I, n.order);
      }
    }, le = (o, E) => (T(o), a(`update:${o}`, E));
    return t2({ openChildCmp: he }), (o, E) => {
      var fe;
      return o.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", kr, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(ee.value, (I, $e) => {
          var be, Pe2, Ee;
          return openBlock(), createElementBlock("div", {
            key: $e,
            class: normalizeClass(v2.value),
            "data-compact": N.value && !o.enableSeconds,
            "data-collapsed": N.value && o.enableSeconds
          }, [
            I.separator ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              j.value ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(":")
              ], 64))
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("button", {
                ref_for: true,
                ref: (Be) => ke(Be, $e, 0),
                type: "button",
                class: normalizeClass({
                  dp__btn: true,
                  dp__inc_dec_button: !o.timePickerInline,
                  dp__inc_dec_button_inline: o.timePickerInline,
                  dp__tp_inline_btn_top: o.timePickerInline,
                  dp__inc_dec_button_disabled: B.value(I.type),
                  "dp--hidden-el": j.value
                }),
                "data-test-id": `${I.type}-time-inc-btn-${n.order}`,
                "aria-label": (be = unref(p)) == null ? void 0 : be.incrementValue(I.type),
                tabindex: "0",
                onKeydown: (Be) => unref(xe)(Be, () => w(I.type, true, { keyboard: true }), true),
                onClick: (Be) => unref(f).timeArrowHoldThreshold ? void 0 : w(I.type, true),
                onMousedown: (Be) => unref(f).timeArrowHoldThreshold ? w(I.type, true) : void 0,
                onMouseup: l
              }, [
                n.timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  o.$slots["tp-inline-arrow-up"] ? renderSlot(o.$slots, "tp-inline-arrow-up", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    E[2] || (E[2] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    E[3] || (E[3] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  o.$slots["arrow-up"] ? renderSlot(o.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                  o.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ka), { key: 1 }))
                ], 64))
              ], 42, Dr),
              createBaseVNode("button", {
                ref_for: true,
                ref: (Be) => ke(Be, $e, 1),
                type: "button",
                "aria-label": `${U.value(I.type).text}-${(Pe2 = unref(p)) == null ? void 0 : Pe2.openTpOverlay(I.type)}`,
                class: normalizeClass({
                  dp__time_display: true,
                  dp__time_display_block: !o.timePickerInline,
                  dp__time_display_inline: o.timePickerInline,
                  "dp--time-invalid": ae.value(I.type),
                  "dp--time-overlay-btn": !ae.value(I.type),
                  "dp--hidden-el": j.value
                }),
                disabled: se(I.type),
                tabindex: "0",
                "data-test-id": `${I.type}-toggle-overlay-btn-${n.order}`,
                onKeydown: (Be) => unref(xe)(Be, () => T(I.type), true),
                onClick: (Be) => T(I.type)
              }, [
                o.$slots[I.type] ? renderSlot(o.$slots, I.type, {
                  key: 0,
                  text: U.value(I.type).text,
                  value: U.value(I.type).value
                }) : createCommentVNode("", true),
                o.$slots[I.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(U.value(I.type).text), 1)
                ], 64))
              ], 42, Mr),
              createBaseVNode("button", {
                ref_for: true,
                ref: (Be) => ke(Be, $e, 2),
                type: "button",
                class: normalizeClass({
                  dp__btn: true,
                  dp__inc_dec_button: !o.timePickerInline,
                  dp__inc_dec_button_inline: o.timePickerInline,
                  dp__tp_inline_btn_bottom: o.timePickerInline,
                  dp__inc_dec_button_disabled: q.value(I.type),
                  "dp--hidden-el": j.value
                }),
                "data-test-id": `${I.type}-time-dec-btn-${n.order}`,
                "aria-label": (Ee = unref(p)) == null ? void 0 : Ee.decrementValue(I.type),
                tabindex: "0",
                onKeydown: (Be) => unref(xe)(Be, () => w(I.type, false, { keyboard: true }), true),
                onClick: (Be) => unref(f).timeArrowHoldThreshold ? void 0 : w(I.type, false),
                onMousedown: (Be) => unref(f).timeArrowHoldThreshold ? w(I.type, false) : void 0,
                onMouseup: l
              }, [
                n.timePickerInline ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  o.$slots["tp-inline-arrow-down"] ? renderSlot(o.$slots, "tp-inline-arrow-down", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    E[4] || (E[4] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1)),
                    E[5] || (E[5] = createBaseVNode("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1))
                  ], 64))
                ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  o.$slots["arrow-down"] ? renderSlot(o.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
                  o.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ga), { key: 1 }))
                ], 64))
              ], 42, $r)
            ], 64))
          ], 10, wr);
        }), 128)),
        o.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Ar, [
          o.$slots["am-pm-button"] ? renderSlot(o.$slots, "am-pm-button", {
            key: 0,
            toggle: M,
            value: _.value
          }) : createCommentVNode("", true),
          o.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: h2,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (fe = unref(p)) == null ? void 0 : fe.amPmButton,
            tabindex: "0",
            "data-compact": N.value,
            onClick: M,
            onKeydown: E[0] || (E[0] = (I) => unref(xe)(I, () => M(), true))
          }, toDisplayString(_.value), 41, Tr))
        ])),
        (openBlock(true), createElementBlock(Fragment, null, renderList(y.value, (I, $e) => (openBlock(), createBlock(Transition, {
          key: $e,
          name: unref(P)(L[I.type]),
          css: unref(F)
        }, {
          default: withCtx(() => {
            var be, Pe2;
            return [
              L[I.type] ? (openBlock(), createBlock(aa, {
                key: 0,
                items: A(I.type),
                "is-last": o.autoApply && !unref(f).keepActionRow,
                "esc-close": o.escClose,
                type: I.type,
                "text-input": o.textInput,
                config: o.config,
                "arrow-navigation": o.arrowNavigation,
                "aria-labels": o.ariaLabels,
                "overlay-label": (Pe2 = (be = unref(p)).timeOverlay) == null ? void 0 : Pe2.call(be, I.type),
                onSelected: (Ee) => le(I.type, Ee),
                onToggle: (Ee) => T(I.type),
                onResetFlow: E[1] || (E[1] = (Ee) => o.$emit("reset-flow"))
              }, createSlots({
                "button-icon": withCtx(() => [
                  o.$slots["clock-icon"] ? renderSlot(o.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
                  o.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(o.timePickerInline ? unref(Gt) : unref(ja)), { key: 1 }))
                ]),
                _: 2
              }, [
                o.$slots[`${I.type}-overlay-value`] ? {
                  name: "item",
                  fn: withCtx(({ item: Ee }) => [
                    renderSlot(o.$slots, `${I.type}-overlay-value`, {
                      text: Ee.text,
                      value: Ee.value
                    })
                  ]),
                  key: "0"
                } : void 0,
                o.$slots[`${I.type}-overlay-header`] ? {
                  name: "header",
                  fn: withCtx(() => [
                    renderSlot(o.$slots, `${I.type}-overlay-header`, {
                      toggle: () => T(I.type)
                    })
                  ]),
                  key: "1"
                } : void 0
              ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : createCommentVNode("", true)
            ];
          }),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), Pr = ["data-dp-mobile"], Rr = ["aria-label", "tabindex"], Cr = ["role", "aria-label", "tabindex"], Or = ["aria-label"], jn = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: {
      type: Function,
      default: () => false
    },
    ...ct
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, { buildMatrix: u, setTimePicker: c } = St(), p = useSlots(), { defaultedTransitions: d, defaultedAriaLabels: Y, defaultedTextInput: f, defaultedConfig: O, defaultedRange: m } = Ye(n), { transitionName: P, showTransition: F } = na(d), { hideNavigationButtons: L } = ha(), _ = ref(null), h2 = ref(null), R = ref([]), b = ref(null), j = ref(false);
    onMounted(() => {
      a("mount"), !n.timePicker && n.arrowNavigation ? u([He(_.value)], "time") : c(true, n.timePicker);
    });
    const z = computed(() => m.value.enabled && n.modelAuto ? Pn(n.internalModelValue) : true), ae = ref(false), H = (S) => ({
      hours: Array.isArray(n.hours) ? n.hours[S] : n.hours,
      minutes: Array.isArray(n.minutes) ? n.minutes[S] : n.minutes,
      seconds: Array.isArray(n.seconds) ? n.seconds[S] : n.seconds
    }), D = computed(() => {
      const S = [];
      if (m.value.enabled)
        for (let Z = 0; Z < 2; Z++)
          S.push(H(Z));
      else
        S.push(H(0));
      return S;
    }), Q = (S, Z = false, A = "") => {
      Z || a("reset-flow"), ae.value = S, a(S ? "overlay-opened" : "overlay-closed", qe.time), n.arrowNavigation && c(S), nextTick(() => {
        A !== "" && R.value[0] && R.value[0].openChildCmp(A);
      });
    }, B = computed(() => ({
      dp__btn: true,
      dp__button: true,
      dp__button_bottom: n.autoApply && !O.value.keepActionRow
    })), q = at(p, "timePicker"), ve = (S, Z, A) => m.value.enabled ? Z === 0 ? [S, D.value[1][A]] : [D.value[0][A], S] : S, pe = (S) => {
      a("update:hours", S);
    }, v2 = (S) => {
      a("update:minutes", S);
    }, N = (S) => {
      a("update:seconds", S);
    }, ee = () => {
      if (b.value && !f.value.enabled && !n.noOverlayFocus) {
        const S = Rn(b.value);
        S && S.focus({ preventScroll: true });
      }
    }, y = (S) => {
      j.value = false, a("overlay-closed", S);
    }, U = (S) => {
      j.value = true, a("overlay-opened", S);
    };
    return t2({ toggleTimePicker: Q }), (S, Z) => {
      var A;
      return openBlock(), createElementBlock("div", {
        class: "dp--tp-wrap",
        "data-dp-mobile": S.isMobile
      }, [
        !S.timePicker && !S.timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
          key: 0,
          ref_key: "openTimePickerBtn",
          ref: _,
          type: "button",
          class: normalizeClass({ ...B.value, "dp--hidden-el": ae.value }),
          "aria-label": (A = unref(Y)) == null ? void 0 : A.openTimePicker,
          tabindex: S.noOverlayFocus ? void 0 : 0,
          "data-test-id": "open-time-picker-btn",
          onKeydown: Z[0] || (Z[0] = (ie) => unref(xe)(ie, () => Q(true))),
          onClick: Z[1] || (Z[1] = (ie) => Q(true))
        }, [
          S.$slots["clock-icon"] ? renderSlot(S.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
          S.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(ja), { key: 1 }))
        ], 42, Rr)), [
          [vShow, !unref(L)(S.hideNavigation, "time")]
        ]) : createCommentVNode("", true),
        createVNode(Transition, {
          name: unref(P)(ae.value),
          css: unref(F) && !S.timePickerInline
        }, {
          default: withCtx(() => {
            var ie, i;
            return [
              ae.value || S.timePicker || S.timePickerInline ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref_key: "overlayRef",
                ref: b,
                role: S.timePickerInline ? void 0 : "dialog",
                class: normalizeClass({
                  dp__overlay: !S.timePickerInline,
                  "dp--overlay-absolute": !n.timePicker && !S.timePickerInline,
                  "dp--overlay-relative": n.timePicker
                }),
                style: normalizeStyle(S.timePicker ? { height: `${unref(O).modeHeight}px` } : void 0),
                "aria-label": (ie = unref(Y)) == null ? void 0 : ie.timePicker,
                tabindex: S.timePickerInline ? void 0 : 0
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(
                    S.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  S.$slots["time-picker-overlay"] ? renderSlot(S.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e2.hours,
                    minutes: e2.minutes,
                    seconds: e2.seconds,
                    setHours: pe,
                    setMinutes: v2,
                    setSeconds: N
                  }) : createCommentVNode("", true),
                  S.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
                    key: 1,
                    class: normalizeClass(S.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(D.value, (W, se) => withDirectives((openBlock(), createBlock(Sr, mergeProps({
                      key: se,
                      ref_for: true
                    }, {
                      ...S.$props,
                      order: se,
                      hours: W.hours,
                      minutes: W.minutes,
                      seconds: W.seconds,
                      closeTimePickerBtn: h2.value,
                      disabledTimesConfig: e2.disabledTimesConfig,
                      disabled: se === 0 ? unref(m).fixedStart : unref(m).fixedEnd
                    }, {
                      ref_for: true,
                      ref_key: "timeInputRefs",
                      ref: R,
                      "validate-time": (T, re) => e2.validateTime(T, ve(re, se, T)),
                      "onUpdate:hours": (T) => pe(ve(T, se, "hours")),
                      "onUpdate:minutes": (T) => v2(ve(T, se, "minutes")),
                      "onUpdate:seconds": (T) => N(ve(T, se, "seconds")),
                      onMounted: ee,
                      onOverlayClosed: y,
                      onOverlayOpened: U,
                      onAmPmChange: Z[2] || (Z[2] = (T) => S.$emit("am-pm-change", T))
                    }), createSlots({ _: 2 }, [
                      renderList(unref(q), (T, re) => ({
                        name: T,
                        fn: withCtx((l) => [
                          renderSlot(S.$slots, T, mergeProps({ ref_for: true }, l))
                        ])
                      }))
                    ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [vShow, se === 0 ? true : z.value]
                    ])), 128))
                  ], 2)),
                  !S.timePicker && !S.timePickerInline ? withDirectives((openBlock(), createElementBlock("button", {
                    key: 2,
                    ref_key: "closeTimePickerBtn",
                    ref: h2,
                    type: "button",
                    class: normalizeClass({ ...B.value, "dp--hidden-el": j.value }),
                    "aria-label": (i = unref(Y)) == null ? void 0 : i.closeTimePicker,
                    tabindex: "0",
                    onKeydown: Z[3] || (Z[3] = (W) => unref(xe)(W, () => Q(false))),
                    onClick: Z[4] || (Z[4] = (W) => Q(false))
                  }, [
                    S.$slots["calendar-icon"] ? renderSlot(S.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                    S.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Gt), { key: 1 }))
                  ], 42, Or)), [
                    [vShow, !unref(L)(S.hideNavigation, "time")]
                  ]) : createCommentVNode("", true)
                ], 2)
              ], 14, Cr)) : createCommentVNode("", true)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ], 8, Pr);
    };
  }
}), Kn = (e2, t2, r, a) => {
  const { defaultedRange: n } = Ye(e2), u = (b, j) => Array.isArray(t2[b]) ? t2[b][j] : t2[b], c = (b) => e2.enableSeconds ? Array.isArray(t2.seconds) ? t2.seconds[b] : t2.seconds : 0, p = (b, j) => b ? j !== void 0 ? At(b, u("hours", j), u("minutes", j), c(j)) : At(b, t2.hours, t2.minutes, c()) : setSeconds(K(), c(j)), d = (b, j) => {
    t2[b] = j;
  }, Y = computed(() => e2.modelAuto && n.value.enabled ? Array.isArray(r.value) ? r.value.length > 1 : false : n.value.enabled), f = (b, j) => {
    const z = Object.fromEntries(
      Object.keys(t2).map((ae) => ae === b ? [ae, j] : [ae, t2[ae]].slice())
    );
    if (Y.value && !n.value.disableTimeRangeValidation) {
      const ae = (D) => r.value ? At(
        r.value[D],
        z.hours[D],
        z.minutes[D],
        z.seconds[D]
      ) : null, H = (D) => setMilliseconds(r.value[D], 0);
      return !(Te(ae(0), ae(1)) && (isAfter(ae(0), H(1)) || isBefore(ae(1), H(0))));
    }
    return true;
  }, O = (b, j) => {
    f(b, j) && (d(b, j), a && a());
  }, m = (b) => {
    O("hours", b);
  }, P = (b) => {
    O("minutes", b);
  }, F = (b) => {
    O("seconds", b);
  }, L = (b, j, z, ae) => {
    j && m(b), !j && !z && P(b), z && F(b), r.value && ae(r.value);
  }, _ = (b) => {
    if (b) {
      const j = Array.isArray(b), z = j ? [+b[0].hours, +b[1].hours] : +b.hours, ae = j ? [+b[0].minutes, +b[1].minutes] : +b.minutes, H = j ? [+b[0].seconds, +b[1].seconds] : +b.seconds;
      d("hours", z), d("minutes", ae), e2.enableSeconds && d("seconds", H);
    }
  }, h2 = (b, j) => {
    const z = {
      hours: Array.isArray(t2.hours) ? t2.hours[b] : t2.hours,
      disabledArr: []
    };
    return (j || j === 0) && (z.hours = j), Array.isArray(e2.disabledTimes) && (z.disabledArr = n.value.enabled && Array.isArray(e2.disabledTimes[b]) ? e2.disabledTimes[b] : e2.disabledTimes), z;
  }, R = computed(() => (b, j) => {
    var z;
    if (Array.isArray(e2.disabledTimes)) {
      const { disabledArr: ae, hours: H } = h2(b, j), D = ae.filter((Q) => +Q.hours === H);
      return ((z = D[0]) == null ? void 0 : z.minutes) === "*" ? { hours: [H], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (D == null ? void 0 : D.map((Q) => +Q.minutes)) ?? [],
        seconds: (D == null ? void 0 : D.map((Q) => Q.seconds ? +Q.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: d,
    updateHours: m,
    updateMinutes: P,
    updateSeconds: F,
    getSetDateTime: p,
    updateTimeValues: L,
    getSecondsValue: c,
    assignStartTime: _,
    validateTime: f,
    disabledTimesConfig: R
  };
}, Br = (e2, t2) => {
  const r = () => {
    e2.isTextInputDate && j();
  }, { modelValue: a, time: n } = la(e2, t2, r), { defaultedStartTime: u, defaultedRange: c, defaultedTz: p } = Ye(e2), { updateTimeValues: d, getSetDateTime: Y, setTime: f, assignStartTime: O, disabledTimesConfig: m, validateTime: P } = Kn(e2, n, a, F);
  function F() {
    t2("update-flow-step");
  }
  const L = (H) => {
    const { hours: D, minutes: Q, seconds: B } = H;
    return { hours: +D, minutes: +Q, seconds: B ? +B : 0 };
  }, _ = () => {
    if (e2.startTime) {
      if (Array.isArray(e2.startTime)) {
        const D = L(e2.startTime[0]), Q = L(e2.startTime[1]);
        return [set(K(), D), set(K(), Q)];
      }
      const H = L(e2.startTime);
      return set(K(), H);
    }
    return c.value.enabled ? [null, null] : null;
  }, h2 = () => {
    if (c.value.enabled) {
      const [H, D] = _();
      a.value = [
        tt(Y(H, 0), p.value.timezone),
        tt(Y(D, 1), p.value.timezone)
      ];
    } else
      a.value = tt(Y(_()), p.value.timezone);
  }, R = (H) => Array.isArray(H) ? [Yt(K(H[0])), Yt(K(H[1]))] : [Yt(H ?? K())], b = (H, D, Q) => {
    f("hours", H), f("minutes", D), f("seconds", e2.enableSeconds ? Q : 0);
  }, j = () => {
    const [H, D] = R(a.value);
    return c.value.enabled ? b(
      [H.hours, D.hours],
      [H.minutes, D.minutes],
      [H.seconds, D.seconds]
    ) : b(H.hours, H.minutes, H.seconds);
  };
  onMounted(() => {
    if (!e2.shadow)
      return O(u.value), a.value ? j() : h2();
  });
  const z = () => {
    Array.isArray(a.value) ? a.value = a.value.map((H, D) => H && Y(H, D)) : a.value = Y(a.value), t2("time-update");
  };
  return {
    modelValue: a,
    time: n,
    disabledTimesConfig: m,
    updateTime: (H, D = true, Q = false) => {
      d(H, D, Q, z);
    },
    validateTime: P
  };
}, _r = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...ct
  },
  emits: [
    "update:internal-model-value",
    "time-update",
    "am-pm-change",
    "mount",
    "reset-flow",
    "update-flow-step",
    "overlay-toggle"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, u = useSlots(), c = at(u, "timePicker"), p = ref(null), { time: d, modelValue: Y, disabledTimesConfig: f, updateTime: O, validateTime: m } = Br(n, a);
    return onMounted(() => {
      n.shadow || a("mount", null);
    }), t2({ getSidebarProps: () => ({
      modelValue: Y,
      time: d,
      updateTime: O
    }), toggleTimePicker: (L, _ = false, h2 = "") => {
      var R;
      (R = p.value) == null || R.toggleTimePicker(L, _, h2);
    } }), (L, _) => (openBlock(), createBlock(ya, {
      "multi-calendars": 0,
      stretch: "",
      "is-mobile": L.isMobile
    }, {
      default: withCtx(() => [
        createVNode(jn, mergeProps({
          ref_key: "tpRef",
          ref: p
        }, L.$props, {
          hours: unref(d).hours,
          minutes: unref(d).minutes,
          seconds: unref(d).seconds,
          "internal-model-value": L.internalModelValue,
          "disabled-times-config": unref(f),
          "validate-time": unref(m),
          "onUpdate:hours": _[0] || (_[0] = (h2) => unref(O)(h2)),
          "onUpdate:minutes": _[1] || (_[1] = (h2) => unref(O)(h2, false)),
          "onUpdate:seconds": _[2] || (_[2] = (h2) => unref(O)(h2, false, true)),
          onAmPmChange: _[3] || (_[3] = (h2) => L.$emit("am-pm-change", h2)),
          onResetFlow: _[4] || (_[4] = (h2) => L.$emit("reset-flow")),
          onOverlayClosed: _[5] || (_[5] = (h2) => L.$emit("overlay-toggle", { open: false, overlay: h2 })),
          onOverlayOpened: _[6] || (_[6] = (h2) => L.$emit("overlay-toggle", { open: true, overlay: h2 }))
        }), createSlots({ _: 2 }, [
          renderList(unref(c), (h2, R) => ({
            name: h2,
            fn: withCtx((b) => [
              renderSlot(L.$slots, h2, normalizeProps(guardReactiveProps(b)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
      ]),
      _: 3
    }, 8, ["is-mobile"]));
  }
}), Yr = { class: "dp--header-wrap" }, Ir = {
  key: 0,
  class: "dp__month_year_wrap"
}, Er = { key: 0 }, Nr = { class: "dp__month_year_wrap" }, Lr = ["data-dp-element", "aria-label", "data-test-id", "onClick", "onKeydown"], Fr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...ct
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed", "overlay-opened"],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, {
      defaultedTransitions: u,
      defaultedAriaLabels: c,
      defaultedMultiCalendars: p,
      defaultedFilters: d,
      defaultedConfig: Y,
      defaultedHighlight: f,
      propDates: O,
      defaultedUI: m
    } = Ye(n), { transitionName: P, showTransition: F } = na(u), { buildMatrix: L } = St(), { handleMonthYearChange: _, isDisabled: h2, updateMonthYear: R } = rr(n, a), { showLeftIcon: b, showRightIcon: j } = ha(), z = ref(false), ae = ref(false), H = ref(false), D = ref([null, null, null, null]);
    onMounted(() => {
      a("mount");
    });
    const Q = (i) => ({
      get: () => n[i],
      set: (W) => {
        const se = i === ut.month ? ut.year : ut.month;
        a("update-month-year", { [i]: W, [se]: n[se] }), i === ut.month ? y(true) : U(true);
      }
    }), B = computed(Q(ut.month)), q = computed(Q(ut.year)), ve = computed(() => (i) => ({
      month: n.month,
      year: n.year,
      items: i === ut.month ? n.months : n.years,
      instance: n.instance,
      updateMonthYear: R,
      toggle: i === ut.month ? y : U
    })), pe = computed(() => {
      const i = n.months.find((W) => W.value === n.month);
      return i || { text: "", value: 0 };
    }), v2 = computed(() => Wt(n.months, (i) => {
      const W = n.month === i.value, se = xt(
        i.value,
        _n(n.year, O.value.minDate),
        Yn(n.year, O.value.maxDate)
      ) || d.value.months.includes(i.value), T = Fn(f.value, i.value, n.year);
      return { active: W, disabled: se, highlighted: T };
    })), N = computed(() => Wt(n.years, (i) => {
      const W = n.year === i.value, se = xt(
        i.value,
        Vt(O.value.minDate),
        Vt(O.value.maxDate)
      ) || d.value.years.includes(i.value), T = Za(f.value, i.value);
      return { active: W, disabled: se, highlighted: T };
    })), ee = (i, W, se) => {
      se !== void 0 ? i.value = se : i.value = !i.value, i.value ? (H.value = true, a("overlay-opened", W)) : (H.value = false, a("overlay-closed", W));
    }, y = (i = false, W) => {
      S(i), ee(z, qe.month, W);
    }, U = (i = false, W) => {
      S(i), ee(ae, qe.year, W);
    }, S = (i) => {
      i || a("reset-flow");
    }, Z = (i, W) => {
      n.arrowNavigation && (D.value[W] = He(i), L(D.value, "monthYear"));
    }, A = computed(() => {
      var i, W, se, T, re, l;
      return [
        {
          type: ut.month,
          index: 1,
          toggle: y,
          modelValue: B.value,
          updateModelValue: (w) => B.value = w,
          text: pe.value.text,
          showSelectionGrid: z.value,
          items: v2.value,
          ariaLabel: (i = c.value) == null ? void 0 : i.openMonthsOverlay,
          overlayLabel: ((se = (W = c.value).monthPicker) == null ? void 0 : se.call(W, true)) ?? void 0
        },
        {
          type: ut.year,
          index: 2,
          toggle: U,
          modelValue: q.value,
          updateModelValue: (w) => q.value = w,
          text: Cn(n.year, n.locale),
          showSelectionGrid: ae.value,
          items: N.value,
          ariaLabel: (T = c.value) == null ? void 0 : T.openYearsOverlay,
          overlayLabel: ((l = (re = c.value).yearPicker) == null ? void 0 : l.call(re, true)) ?? void 0
        }
      ];
    }), ie = computed(() => n.disableYearSelect ? [A.value[0]] : n.yearFirst ? [...A.value].reverse() : A.value);
    return t2({
      toggleMonthPicker: y,
      toggleYearPicker: U,
      handleMonthYearChange: _
    }), (i, W) => {
      var se, T, re, l, w, oe;
      return openBlock(), createElementBlock("div", Yr, [
        i.$slots["month-year"] ? (openBlock(), createElementBlock("div", Ir, [
          renderSlot(i.$slots, "month-year", normalizeProps(guardReactiveProps({
            month: e2.month,
            year: e2.year,
            months: e2.months,
            years: e2.years,
            updateMonthYear: unref(R),
            handleMonthYearChange: unref(_),
            instance: e2.instance,
            isDisabled: unref(h2)
          })))
        ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          i.$slots["top-extra"] ? (openBlock(), createElementBlock("div", Er, [
            renderSlot(i.$slots, "top-extra", { value: i.internalModelValue })
          ])) : createCommentVNode("", true),
          createBaseVNode("div", Nr, [
            unref(b)(unref(p), e2.instance) && !i.vertical ? (openBlock(), createBlock(qt, {
              key: 0,
              "aria-label": (se = unref(c)) == null ? void 0 : se.prevMonth,
              disabled: unref(h2)(false),
              class: normalizeClass((T = unref(m)) == null ? void 0 : T.navBtnPrev),
              "el-name": "action-prev",
              onActivate: W[0] || (W[0] = (M) => unref(_)(false, true)),
              onSetRef: W[1] || (W[1] = (M) => Z(M, 0))
            }, {
              default: withCtx(() => [
                i.$slots["arrow-left"] ? renderSlot(i.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                i.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Wa), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(["dp__month_year_wrap", {
                dp__year_disable_select: i.disableYearSelect
              }])
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(ie.value, (M, he) => (openBlock(), createElementBlock(Fragment, {
                key: M.type
              }, [
                createBaseVNode("button", {
                  ref_for: true,
                  ref: (ke) => Z(ke, he + 1),
                  type: "button",
                  "data-dp-element": `overlay-${M.type}`,
                  class: normalizeClass(["dp__btn dp__month_year_select", { "dp--hidden-el": H.value }]),
                  "aria-label": `${M.text}-${M.ariaLabel}`,
                  "data-test-id": `${M.type}-toggle-overlay-${e2.instance}`,
                  onClick: M.toggle,
                  onKeydown: (ke) => unref(xe)(ke, () => M.toggle(), true)
                }, [
                  i.$slots[M.type] ? renderSlot(i.$slots, M.type, {
                    key: 0,
                    text: M.text,
                    value: n[M.type]
                  }) : createCommentVNode("", true),
                  i.$slots[M.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(M.text), 1)
                  ], 64))
                ], 42, Lr),
                createVNode(Transition, {
                  name: unref(P)(M.showSelectionGrid),
                  css: unref(F)
                }, {
                  default: withCtx(() => [
                    M.showSelectionGrid ? (openBlock(), createBlock(aa, {
                      key: 0,
                      items: M.items,
                      "arrow-navigation": i.arrowNavigation,
                      "hide-navigation": i.hideNavigation,
                      "is-last": i.autoApply && !unref(Y).keepActionRow,
                      "skip-button-ref": false,
                      config: i.config,
                      type: M.type,
                      "header-refs": [],
                      "esc-close": i.escClose,
                      "menu-wrap-ref": i.menuWrapRef,
                      "text-input": i.textInput,
                      "aria-labels": i.ariaLabels,
                      "overlay-label": M.overlayLabel,
                      onSelected: M.updateModelValue,
                      onToggle: M.toggle
                    }, createSlots({
                      "button-icon": withCtx(() => [
                        i.$slots["calendar-icon"] ? renderSlot(i.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                        i.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Gt), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      i.$slots[`${M.type}-overlay-value`] ? {
                        name: "item",
                        fn: withCtx(({ item: ke }) => [
                          renderSlot(i.$slots, `${M.type}-overlay-value`, {
                            text: ke.text,
                            value: ke.value
                          })
                        ]),
                        key: "0"
                      } : void 0,
                      i.$slots[`${M.type}-overlay`] ? {
                        name: "overlay",
                        fn: withCtx(() => [
                          renderSlot(i.$slots, `${M.type}-overlay`, mergeProps({ ref_for: true }, ve.value(M.type)))
                        ]),
                        key: "1"
                      } : void 0,
                      i.$slots[`${M.type}-overlay-header`] ? {
                        name: "header",
                        fn: withCtx(() => [
                          renderSlot(i.$slots, `${M.type}-overlay-header`, {
                            toggle: M.toggle
                          })
                        ]),
                        key: "2"
                      } : void 0
                    ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["name", "css"])
              ], 64))), 128))
            ], 2),
            unref(b)(unref(p), e2.instance) && i.vertical ? (openBlock(), createBlock(qt, {
              key: 1,
              "aria-label": (re = unref(c)) == null ? void 0 : re.prevMonth,
              "el-name": "action-prev",
              disabled: unref(h2)(false),
              class: normalizeClass((l = unref(m)) == null ? void 0 : l.navBtnPrev),
              onActivate: W[2] || (W[2] = (M) => unref(_)(false, true))
            }, {
              default: withCtx(() => [
                i.$slots["arrow-up"] ? renderSlot(i.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                i.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Ka), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled", "class"])) : createCommentVNode("", true),
            unref(j)(unref(p), e2.instance) ? (openBlock(), createBlock(qt, {
              key: 2,
              ref: "rightIcon",
              "el-name": "action-next",
              disabled: unref(h2)(true),
              "aria-label": (w = unref(c)) == null ? void 0 : w.nextMonth,
              class: normalizeClass((oe = unref(m)) == null ? void 0 : oe.navBtnNext),
              onActivate: W[3] || (W[3] = (M) => unref(_)(true, true)),
              onSetRef: W[4] || (W[4] = (M) => Z(M, i.disableYearSelect ? 2 : 3))
            }, {
              default: withCtx(() => [
                i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(i.$slots, i.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
                i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(i.vertical ? unref(Ga) : unref(Va)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label", "class"])) : createCommentVNode("", true)
          ])
        ], 64))
      ]);
    };
  }
}), zr = {
  class: "dp__calendar_header",
  role: "row"
}, Hr = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, Ur = ["aria-label"], Wr = {
  key: 0,
  class: "dp__calendar_item dp__week_num",
  role: "gridcell"
}, Vr = { class: "dp__cell_inner" }, jr = ["id", "aria-pressed", "aria-disabled", "aria-label", "tabindex", "data-test-id", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"], Kr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...ct
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, { buildMultiLevelMatrix: u } = St(), {
      defaultedTransitions: c,
      defaultedConfig: p,
      defaultedAriaLabels: d,
      defaultedMultiCalendars: Y,
      defaultedWeekNumbers: f,
      defaultedMultiDates: O,
      defaultedUI: m
    } = Ye(n), P = ref(null), F = ref({
      bottom: "",
      left: "",
      transform: ""
    }), L = ref([]), _ = ref(null), h2 = ref(true), R = ref(""), b = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), j = ref([]), z = ref({ left: "50%" }), ae = ref(false), H = computed(() => n.calendar ? n.calendar(n.mappedDates) : n.mappedDates), D = computed(() => n.dayNames ? Array.isArray(n.dayNames) ? n.dayNames : n.dayNames(n.locale, +n.weekStart) : Al(n.formatLocale, n.locale, +n.weekStart));
    onMounted(() => {
      a("mount", { cmp: "calendar", refs: L }), p.value.noSwipe || _.value && (_.value.addEventListener("touchstart", Z, { passive: false }), _.value.addEventListener("touchend", A, { passive: false }), _.value.addEventListener("touchmove", ie, { passive: false })), n.monthChangeOnScroll && _.value && _.value.addEventListener("wheel", se, { passive: false });
    }), onUnmounted(() => {
      p.value.noSwipe || _.value && (_.value.removeEventListener("touchstart", Z), _.value.removeEventListener("touchend", A), _.value.removeEventListener("touchmove", ie)), n.monthChangeOnScroll && _.value && _.value.removeEventListener("wheel", se);
    });
    const Q = (M) => M ? n.vertical ? "vNext" : "next" : n.vertical ? "vPrevious" : "previous", B = (M, he) => {
      if (n.transitions) {
        const ke = je(ht(K(), n.month, n.year));
        R.value = Fe(je(ht(K(), M, he)), ke) ? c.value[Q(true)] : c.value[Q(false)], h2.value = false, nextTick(() => {
          h2.value = true;
        });
      }
    }, q = computed(
      () => ({
        ...m.value.calendar ?? {}
      })
    ), ve = computed(() => (M) => {
      const he = Sl(M);
      return {
        dp__marker_dot: he.type === "dot",
        dp__marker_line: he.type === "line"
      };
    }), pe = computed(() => (M) => Te(M, P.value)), v2 = computed(() => ({
      dp__calendar: true,
      dp__calendar_next: Y.value.count > 0 && n.instance !== 0
    })), N = computed(() => (M) => n.hideOffsetDates ? M.current : true), ee = async (M, he) => {
      const { width: ke, height: le } = M.getBoundingClientRect();
      P.value = he.value;
      let o = { left: `${ke / 2}px` }, E = -50;
      if (await nextTick(), j.value[0]) {
        const { left: fe, width: I } = j.value[0].getBoundingClientRect();
        fe < 0 && (o = { left: "0" }, E = 0, z.value.left = `${ke / 2}px`), window.innerWidth < fe + I && (o = { right: "0" }, E = 0, z.value.left = `${I - ke / 2}px`);
      }
      F.value = {
        bottom: `${le}px`,
        ...o,
        transform: `translateX(${E}%)`
      };
    }, y = async (M, he, ke) => {
      var o, E, fe;
      const le = He(L.value[he][ke]);
      le && ((o = M.marker) != null && o.customPosition && ((fe = (E = M.marker) == null ? void 0 : E.tooltip) != null && fe.length) ? F.value = M.marker.customPosition(le) : await ee(le, M), a("tooltip-open", M.marker));
    }, U = async (M, he, ke) => {
      var le, o;
      if (ae.value && O.value.enabled && O.value.dragSelect)
        return a("select-date", M);
      if (a("set-hover-date", M), (o = (le = M.marker) == null ? void 0 : le.tooltip) != null && o.length) {
        if (n.hideOffsetDates && !M.current) return;
        await y(M, he, ke);
      }
    }, S = (M) => {
      P.value && (P.value = null, F.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", M.marker));
    }, Z = (M) => {
      b.value.startX = M.changedTouches[0].screenX, b.value.startY = M.changedTouches[0].screenY;
    }, A = (M) => {
      b.value.endX = M.changedTouches[0].screenX, b.value.endY = M.changedTouches[0].screenY, i();
    }, ie = (M) => {
      n.vertical && !n.inline && M.preventDefault();
    }, i = () => {
      const M = n.vertical ? "Y" : "X";
      Math.abs(b.value[`start${M}`] - b.value[`end${M}`]) > 10 && a("handle-swipe", b.value[`start${M}`] > b.value[`end${M}`] ? "right" : "left");
    }, W = (M, he, ke) => {
      M && (Array.isArray(L.value[he]) ? L.value[he][ke] = M : L.value[he] = [M]), n.arrowNavigation && u(L.value, "calendar");
    }, se = (M) => {
      n.monthChangeOnScroll && (M.preventDefault(), a("handle-scroll", M));
    }, T = (M) => f.value.type === "local" ? getWeek(M.value, { weekStartsOn: +n.weekStart }) : f.value.type === "iso" ? getISOWeek(M.value) : typeof f.value.type == "function" ? f.value.type(M.value) : "", re = (M) => {
      const he = M[0];
      return f.value.hideOnOffsetDates ? M.some((ke) => ke.current) ? T(he) : "" : T(he);
    }, l = (M, he, ke = true) => {
      !ke && Bl() || (!O.value.enabled || p.value.allowPreventDefault) && ($t(M, p.value), a("select-date", he));
    }, w = (M) => {
      $t(M, p.value);
    }, oe = (M) => {
      O.value.enabled && O.value.dragSelect ? (ae.value = true, a("select-date", M)) : O.value.enabled && a("select-date", M);
    };
    return t2({ triggerTransition: B }), (M, he) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(v2.value)
    }, [
      createBaseVNode("div", {
        ref_key: "calendarWrapRef",
        ref: _,
        class: normalizeClass(q.value),
        role: "grid"
      }, [
        createBaseVNode("div", zr, [
          M.weekNumbers ? (openBlock(), createElementBlock("div", Hr, toDisplayString(M.weekNumName), 1)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(D.value, (ke, le) => {
            var o, E;
            return openBlock(), createElementBlock("div", {
              key: le,
              class: "dp__calendar_header_item",
              role: "gridcell",
              "data-test-id": "calendar-header",
              "aria-label": (E = (o = unref(d)) == null ? void 0 : o.weekDay) == null ? void 0 : E.call(o, le)
            }, [
              M.$slots["calendar-header"] ? renderSlot(M.$slots, "calendar-header", {
                key: 0,
                day: ke,
                index: le
              }) : createCommentVNode("", true),
              M.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(ke), 1)
              ], 64))
            ], 8, Ur);
          }), 128))
        ]),
        he[2] || (he[2] = createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1)),
        createVNode(Transition, {
          name: R.value,
          css: !!M.transitions
        }, {
          default: withCtx(() => [
            h2.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "dp__calendar",
              role: "rowgroup",
              onMouseleave: he[1] || (he[1] = (ke) => ae.value = false)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(H.value, (ke, le) => (openBlock(), createElementBlock("div", {
                key: le,
                class: "dp__calendar_row",
                role: "row"
              }, [
                M.weekNumbers ? (openBlock(), createElementBlock("div", Wr, [
                  createBaseVNode("div", Vr, toDisplayString(re(ke.days)), 1)
                ])) : createCommentVNode("", true),
                (openBlock(true), createElementBlock(Fragment, null, renderList(ke.days, (o, E) => {
                  var fe, I, $e;
                  return openBlock(), createElementBlock("div", {
                    id: unref(Ha)(o.value),
                    ref_for: true,
                    ref: (be) => W(be, le, E),
                    key: E + le,
                    role: "gridcell",
                    class: "dp__calendar_item",
                    "aria-pressed": (o.classData.dp__active_date || o.classData.dp__range_start || o.classData.dp__range_start) ?? void 0,
                    "aria-disabled": o.classData.dp__cell_disabled || void 0,
                    "aria-label": (I = (fe = unref(d)) == null ? void 0 : fe.day) == null ? void 0 : I.call(fe, o),
                    tabindex: !o.current && M.hideOffsetDates ? void 0 : 0,
                    "data-test-id": unref(Ha)(o.value),
                    onClick: withModifiers((be) => l(be, o), ["prevent"]),
                    onTouchend: (be) => l(be, o, false),
                    onKeydown: (be) => unref(xe)(be, () => M.$emit("select-date", o)),
                    onMouseenter: (be) => U(o, le, E),
                    onMouseleave: (be) => S(o),
                    onMousedown: (be) => oe(o),
                    onMouseup: he[0] || (he[0] = (be) => ae.value = false)
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["dp__cell_inner", o.classData])
                    }, [
                      M.$slots.day && N.value(o) ? renderSlot(M.$slots, "day", {
                        key: 0,
                        day: +o.text,
                        date: o.value
                      }) : createCommentVNode("", true),
                      M.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString(o.text), 1)
                      ], 64)),
                      o.marker && N.value(o) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                        M.$slots.marker ? renderSlot(M.$slots, "marker", {
                          key: 0,
                          marker: o.marker,
                          day: +o.text,
                          date: o.value
                        }) : (openBlock(), createElementBlock("div", {
                          key: 1,
                          class: normalizeClass(ve.value(o.marker)),
                          style: normalizeStyle(o.marker.color ? { backgroundColor: o.marker.color } : {})
                        }, null, 6))
                      ], 64)) : createCommentVNode("", true),
                      pe.value(o.value) ? (openBlock(), createElementBlock("div", {
                        key: 3,
                        ref_for: true,
                        ref_key: "activeTooltip",
                        ref: j,
                        class: "dp__marker_tooltip",
                        style: normalizeStyle(F.value)
                      }, [
                        ($e = o.marker) != null && $e.tooltip ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "dp__tooltip_content",
                          onClick: w
                        }, [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(o.marker.tooltip, (be, Pe2) => (openBlock(), createElementBlock("div", {
                            key: Pe2,
                            class: "dp__tooltip_text"
                          }, [
                            M.$slots["marker-tooltip"] ? renderSlot(M.$slots, "marker-tooltip", {
                              key: 0,
                              tooltip: be,
                              day: o.value
                            }) : createCommentVNode("", true),
                            M.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createBaseVNode("div", {
                                class: "dp__tooltip_mark",
                                style: normalizeStyle(be.color ? { backgroundColor: be.color } : {})
                              }, null, 4),
                              createBaseVNode("div", null, toDisplayString(be.text), 1)
                            ], 64))
                          ]))), 128)),
                          createBaseVNode("div", {
                            class: "dp__arrow_bottom_tp",
                            style: normalizeStyle(z.value)
                          }, null, 4)
                        ])) : createCommentVNode("", true)
                      ], 4)) : createCommentVNode("", true)
                    ], 2)
                  ], 40, jr);
                }), 128))
              ]))), 128))
            ], 32)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ], 2)
    ], 2));
  }
}), yn = (e2) => Array.isArray(e2), Gr = (e2, t2, r, a) => {
  const n = ref([]), u = ref(/* @__PURE__ */ new Date()), c = ref(), p = () => A(e2.isTextInputDate), { modelValue: d, calendars: Y, time: f, today: O } = la(e2, t2, p), {
    defaultedMultiCalendars: m,
    defaultedStartTime: P,
    defaultedRange: F,
    defaultedConfig: L,
    defaultedTz: _,
    propDates: h2,
    defaultedMultiDates: R
  } = Ye(e2), { validateMonthYearInRange: b, isDisabled: j, isDateRangeAllowed: z, checkMinMaxRange: ae } = Pt(e2), { updateTimeValues: H, getSetDateTime: D, setTime: Q, assignStartTime: B, validateTime: q, disabledTimesConfig: ve } = Kn(e2, f, d, a), pe = computed(
    () => (g) => Y.value[g] ? Y.value[g].month : 0
  ), v2 = computed(
    () => (g) => Y.value[g] ? Y.value[g].year : 0
  ), N = (g) => !L.value.keepViewOnOffsetClick || g ? true : !c.value, ee = (g, ne, me, C = false) => {
    var te, ce;
    N(C) && (Y.value[g] || (Y.value[g] = { month: 0, year: 0 }), Y.value[g].month = dn(ne) ? (te = Y.value[g]) == null ? void 0 : te.month : ne, Y.value[g].year = dn(me) ? (ce = Y.value[g]) == null ? void 0 : ce.year : me);
  }, y = () => {
    e2.autoApply && t2("select-date");
  }, U = () => {
    P.value && B(P.value);
  };
  onMounted(() => {
    e2.shadow || (d.value || (he(), U()), A(true), e2.focusStartDate && e2.startDate && he());
  });
  const S = computed(() => {
    var g;
    return (g = e2.flow) != null && g.length && !e2.partialFlow ? e2.flowStep === e2.flow.length : true;
  }), Z = () => {
    e2.autoApply && S.value && t2("auto-apply", e2.partialFlow ? e2.flowStep !== e2.flow.length : false);
  }, A = (g = false) => {
    if (d.value)
      return Array.isArray(d.value) ? (n.value = d.value, l(g)) : W(d.value, g);
    if (m.value.count && g && !e2.startDate)
      return i(K(), g);
  }, ie = () => Array.isArray(d.value) && F.value.enabled ? getMonth(d.value[0]) === getMonth(d.value[1] ?? d.value[0]) : false, i = (g = /* @__PURE__ */ new Date(), ne = false) => {
    if ((!m.value.count || !m.value.static || ne) && ee(0, getMonth(g), getYear(g)), m.value.count && (!d.value || ie() || !m.value.solo) && (!m.value.solo || ne))
      for (let me = 1; me < m.value.count; me++) {
        const C = set(K(), { month: pe.value(me - 1), year: v2.value(me - 1) }), te = add(C, { months: 1 });
        Y.value[me] = { month: getMonth(te), year: getYear(te) };
      }
  }, W = (g, ne) => {
    i(g), Q("hours", getHours(g)), Q("minutes", getMinutes(g)), Q("seconds", getSeconds(g)), m.value.count && ne && M();
  }, se = (g) => {
    if (m.value.count) {
      if (m.value.solo) return 0;
      const ne = getMonth(g[0]), me = getMonth(g[1]);
      return Math.abs(me - ne) < m.value.count ? 0 : 1;
    }
    return 1;
  }, T = (g, ne) => {
    g[1] && F.value.showLastInRange ? i(g[se(g)], ne) : i(g[0], ne);
    const me = (C, te) => [
      C(g[0]),
      g[1] ? C(g[1]) : f[te][1]
    ];
    Q("hours", me(getHours, "hours")), Q("minutes", me(getMinutes, "minutes")), Q("seconds", me(getSeconds, "seconds"));
  }, re = (g, ne) => {
    if ((F.value.enabled || e2.weekPicker) && !R.value.enabled)
      return T(g, ne);
    if (R.value.enabled && ne) {
      const me = g[g.length - 1];
      return W(me, ne);
    }
  }, l = (g) => {
    const ne = d.value;
    re(ne, g), m.value.count && m.value.solo && M();
  }, w = (g, ne) => {
    const me = set(K(), { month: pe.value(ne), year: v2.value(ne) }), C = g < 0 ? addMonths(me, 1) : subMonths(me, 1);
    b(getMonth(C), getYear(C), g < 0, e2.preventMinMaxNavigation) && (ee(ne, getMonth(C), getYear(C)), t2("update-month-year", { instance: ne, month: getMonth(C), year: getYear(C) }), m.value.count && !m.value.solo && oe(ne), r());
  }, oe = (g) => {
    for (let ne = g - 1; ne >= 0; ne--) {
      const me = subMonths(set(K(), { month: pe.value(ne + 1), year: v2.value(ne + 1) }), 1);
      ee(ne, getMonth(me), getYear(me));
    }
    for (let ne = g + 1; ne <= m.value.count - 1; ne++) {
      const me = addMonths(set(K(), { month: pe.value(ne - 1), year: v2.value(ne - 1) }), 1);
      ee(ne, getMonth(me), getYear(me));
    }
  }, M = () => {
    if (Array.isArray(d.value) && d.value.length === 2) {
      const g = K(
        K(d.value[1] ? d.value[1] : addMonths(d.value[0], 1))
      ), [ne, me] = [getMonth(d.value[0]), getYear(d.value[0])], [C, te] = [getMonth(d.value[1]), getYear(d.value[1])];
      (ne !== C || ne === C && me !== te) && m.value.solo && ee(1, getMonth(g), getYear(g));
    } else d.value && !Array.isArray(d.value) && (ee(0, getMonth(d.value), getYear(d.value)), i(K()));
  }, he = () => {
    e2.startDate && (ee(0, getMonth(K(e2.startDate)), getYear(K(e2.startDate))), m.value.count && oe(0));
  }, ke = (g, ne) => {
    if (e2.monthChangeOnScroll) {
      const me = (/* @__PURE__ */ new Date()).getTime() - u.value.getTime(), C = Math.abs(g.deltaY);
      let te = 500;
      C > 1 && (te = 100), C > 100 && (te = 0), me > te && (u.value = /* @__PURE__ */ new Date(), w(e2.monthChangeOnScroll !== "inverse" ? -g.deltaY : g.deltaY, ne));
    }
  }, le = (g, ne, me = false) => {
    e2.monthChangeOnArrows && e2.vertical === me && o(g, ne);
  }, o = (g, ne) => {
    w(g === "right" ? -1 : 1, ne);
  }, E = (g) => {
    if (h2.value.markers)
      return va(g.value, h2.value.markers);
  }, fe = (g, ne) => {
    switch (e2.sixWeeks === true ? "append" : e2.sixWeeks) {
      case "prepend":
        return [true, false];
      case "center":
        return [g == 0, true];
      case "fair":
        return [g == 0 || ne > g, true];
      case "append":
        return [false, false];
      default:
        return [false, false];
    }
  }, I = (g, ne, me, C) => {
    if (e2.sixWeeks && g.length < 6) {
      const te = 6 - g.length, ce = (ne.getDay() + 7 - C) % 7, vt = 6 - (me.getDay() + 7 - C) % 7, [Ct, $a] = fe(ce, vt);
      for (let Ot = 1; Ot <= te; Ot++)
        if ($a ? !!(Ot % 2) == Ct : Ct) {
          const oa = g[0].days[0], Aa = $e(addDays(oa.value, -7), getMonth(ne));
          g.unshift({ days: Aa });
        } else {
          const oa = g[g.length - 1], Aa = oa.days[oa.days.length - 1], qn = $e(addDays(Aa.value, 1), getMonth(ne));
          g.push({ days: qn });
        }
    }
    return g;
  }, $e = (g, ne) => {
    const me = K(g), C = [];
    for (let te = 0; te < 7; te++) {
      const ce = addDays(me, te), yt = getMonth(ce) !== ne;
      C.push({
        text: e2.hideOffsetDates && yt ? "" : ce.getDate(),
        value: ce,
        current: !yt,
        classData: {}
      });
    }
    return C;
  }, be = (g, ne) => {
    const me = [], C = new Date(ne, g), te = new Date(ne, g + 1, 0), ce = e2.weekStart, yt = startOfWeek(C, { weekStartsOn: ce }), vt = (Ct) => {
      const $a = $e(Ct, g);
      if (me.push({ days: $a }), !me[me.length - 1].days.some(
        (Ot) => Te(je(Ot.value), je(te))
      )) {
        const Ot = addDays(Ct, 7);
        vt(Ot);
      }
    };
    return vt(yt), I(me, C, te, ce);
  }, Pe2 = (g) => {
    const ne = At(K(g.value), f.hours, f.minutes, rt());
    t2("date-update", ne), R.value.enabled ? xa(ne, d, R.value.limit) : d.value = ne, a(), nextTick().then(() => {
      Z();
    });
  }, Ee = (g) => F.value.noDisabledRange ? In(n.value[0], g).some((me) => j(me)) : false, Be = () => {
    n.value = d.value ? d.value.slice() : [], n.value.length === 2 && !(F.value.fixedStart || F.value.fixedEnd) && (n.value = []);
  }, k = (g, ne) => {
    const me = [
      K(g.value),
      addDays(K(g.value), +F.value.autoRange)
    ];
    z(me) ? (ne && x(g.value), n.value = me) : t2("invalid-date", g.value);
  }, x = (g) => {
    const ne = getMonth(K(g)), me = getYear(K(g));
    if (ee(0, ne, me), m.value.count > 0)
      for (let C = 1; C < m.value.count; C++) {
        const te = Il(
          set(K(g), { year: v2.value(C - 1), month: pe.value(C - 1) })
        );
        ee(C, te.month, te.year);
      }
  }, Ie = (g) => {
    if (Ee(g.value) || !ae(g.value, d.value, F.value.fixedStart ? 0 : 1))
      return t2("invalid-date", g.value);
    n.value = Wn(K(g.value), d, t2, F);
  }, Ue = (g, ne) => {
    if (Be(), F.value.autoRange) return k(g, ne);
    if (F.value.fixedStart || F.value.fixedEnd) return Ie(g);
    n.value[0] ? ae(K(g.value), d.value) && !Ee(g.value) ? Ne(K(g.value), K(n.value[0])) ? (n.value.unshift(K(g.value)), t2("range-end", n.value[0])) : (n.value[1] = K(g.value), t2("range-end", n.value[1])) : (e2.autoApply && t2("auto-apply-invalid", g.value), t2("invalid-date", g.value)) : (n.value[0] = K(g.value), t2("range-start", n.value[0]));
  }, rt = (g = true) => e2.enableSeconds ? Array.isArray(f.seconds) ? g ? f.seconds[0] : f.seconds[1] : f.seconds : 0, de = (g) => {
    n.value[g] = At(
      n.value[g],
      f.hours[g],
      f.minutes[g],
      rt(g !== 1)
    );
  }, Rt = () => {
    var g, ne;
    n.value[0] && n.value[1] && +((g = n.value) == null ? void 0 : g[0]) > +((ne = n.value) == null ? void 0 : ne[1]) && (n.value.reverse(), t2("range-start", n.value[0]), t2("range-end", n.value[1]));
  }, ft = () => {
    n.value.length && (n.value[0] && !n.value[1] ? de(0) : (de(0), de(1), a()), Rt(), d.value = n.value.slice(), ga(n.value, t2, e2.autoApply, e2.modelAuto));
  }, ra = (g, ne = false) => {
    if (j(g.value) || !g.current && e2.hideOffsetDates) return t2("invalid-date", g.value);
    if (c.value = JSON.parse(JSON.stringify(g)), !F.value.enabled) return Pe2(g);
    yn(f.hours) && yn(f.minutes) && !R.value.enabled && (Ue(g, ne), ft());
  }, ba = (g, ne) => {
    var C;
    ee(g, ne.month, ne.year, true), m.value.count && !m.value.solo && oe(g), t2("update-month-year", { instance: g, month: ne.month, year: ne.year }), r(m.value.solo ? g : void 0);
    const me = (C = e2.flow) != null && C.length ? e2.flow[e2.flowStep] : void 0;
    !ne.fromNav && (me === qe.month || me === qe.year) && a();
  }, ka = (g, ne) => {
    Un({
      value: g,
      modelValue: d,
      range: F.value.enabled,
      timezone: ne ? void 0 : _.value.timezone
    }), y(), e2.multiCalendars && nextTick().then(() => A(true));
  }, wa = () => {
    const g = Qa(K(), _.value);
    !F.value.enabled && !R.value.enabled ? d.value = g : d.value && Array.isArray(d.value) && d.value[0] ? R.value.enabled ? d.value = [...d.value, g] : d.value = Ne(g, d.value[0]) ? [g, d.value[0]] : [d.value[0], g] : d.value = [g], y();
  }, Da = () => {
    if (Array.isArray(d.value))
      if (R.value.enabled) {
        const g = Ma();
        d.value[d.value.length - 1] = D(g);
      } else
        d.value = d.value.map((g, ne) => g && D(g, ne));
    else
      d.value = D(d.value);
    t2("time-update");
  }, Ma = () => Array.isArray(d.value) && d.value.length ? d.value[d.value.length - 1] : null;
  return {
    calendars: Y,
    modelValue: d,
    month: pe,
    year: v2,
    time: f,
    disabledTimesConfig: ve,
    today: O,
    validateTime: q,
    getCalendarDays: be,
    getMarker: E,
    handleScroll: ke,
    handleSwipe: o,
    handleArrow: le,
    selectDate: ra,
    updateMonthYear: ba,
    presetDate: ka,
    selectCurrentDate: wa,
    updateTime: (g, ne = true, me = false) => {
      H(g, ne, me, Da);
    },
    assignMonthAndYear: i,
    setStartTime: U
  };
}, Qr = { key: 0 }, qr = /* @__PURE__ */ defineComponent({
  __name: "DatePicker",
  props: {
    ...ct
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, {
      calendars: u,
      month: c,
      year: p,
      modelValue: d,
      time: Y,
      disabledTimesConfig: f,
      today: O,
      validateTime: m,
      getCalendarDays: P,
      getMarker: F,
      handleArrow: L,
      handleScroll: _,
      handleSwipe: h2,
      selectDate: R,
      updateMonthYear: b,
      presetDate: j,
      selectCurrentDate: z,
      updateTime: ae,
      assignMonthAndYear: H,
      setStartTime: D
    } = Gr(n, a, ie, i), Q = useSlots(), { setHoverDate: B, getDayClassData: q, clearHoverDate: ve } = vo(d, n), { defaultedMultiCalendars: pe } = Ye(n), v2 = ref([]), N = ref([]), ee = ref(null), y = at(Q, "calendar"), U = at(Q, "monthYear"), S = at(Q, "timePicker"), Z = (le) => {
      n.shadow || a("mount", le);
    };
    watch(
      u,
      () => {
        n.shadow || setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: true }
    ), watch(
      pe,
      (le, o) => {
        le.count - o.count > 0 && H();
      },
      { deep: true }
    );
    const A = computed(() => (le) => P(c.value(le), p.value(le)).map((o) => ({
      ...o,
      days: o.days.map((E) => (E.marker = F(E), E.classData = q(E), E))
    })));
    function ie(le) {
      var o;
      le || le === 0 ? (o = N.value[le]) == null || o.triggerTransition(c.value(le), p.value(le)) : N.value.forEach((E, fe) => E.triggerTransition(c.value(fe), p.value(fe)));
    }
    function i() {
      a("update-flow-step");
    }
    const W = (le, o = false) => {
      R(le, o), n.spaceConfirm && a("select-date");
    }, se = (le, o, E = 0) => {
      var fe;
      (fe = v2.value[E]) == null || fe.toggleMonthPicker(le, o);
    }, T = (le, o, E = 0) => {
      var fe;
      (fe = v2.value[E]) == null || fe.toggleYearPicker(le, o);
    }, re = (le, o, E) => {
      var fe;
      (fe = ee.value) == null || fe.toggleTimePicker(le, o, E);
    }, l = (le, o) => {
      var E;
      if (!n.range) {
        const fe = d.value ? d.value : O, I = o ? new Date(o) : fe, $e = le ? startOfWeek(I, { weekStartsOn: 1 }) : endOfWeek(I, { weekStartsOn: 1 });
        R({
          value: $e,
          current: getMonth(I) === c.value(0),
          text: "",
          classData: {}
        }), (E = document.getElementById(Ha($e))) == null || E.focus();
      }
    }, w = (le) => {
      var o;
      (o = v2.value[0]) == null || o.handleMonthYearChange(le, true);
    }, oe = (le) => {
      b(0, { month: c.value(0), year: p.value(0) + (le ? 1 : -1), fromNav: true });
    }, M = (le, o) => {
      le === qe.time && a(`time-picker-${o ? "open" : "close"}`), a("overlay-toggle", { open: o, overlay: le });
    }, he = (le) => {
      a("overlay-toggle", { open: false, overlay: le }), a("focus-menu");
    };
    return t2({
      clearHoverDate: ve,
      presetDate: j,
      selectCurrentDate: z,
      toggleMonthPicker: se,
      toggleYearPicker: T,
      toggleTimePicker: re,
      handleArrow: L,
      updateMonthYear: b,
      getSidebarProps: () => ({
        modelValue: d,
        month: c,
        year: p,
        time: Y,
        updateTime: ae,
        updateMonthYear: b,
        selectDate: R,
        presetDate: j
      }),
      changeMonth: w,
      changeYear: oe,
      selectWeekDate: l,
      setStartTime: D
    }), (le, o) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(ya, {
        "multi-calendars": unref(pe).count,
        collapse: le.collapse,
        "is-mobile": le.isMobile
      }, {
        default: withCtx(({ instance: E, index: fe }) => [
          le.disableMonthYearSelect ? createCommentVNode("", true) : (openBlock(), createBlock(Fr, mergeProps({
            key: 0,
            ref: (I) => {
              I && (v2.value[fe] = I);
            },
            months: unref(Sn)(le.formatLocale, le.locale, le.monthNameFormat),
            years: unref(qa)(le.yearRange, le.locale, le.reverseYears),
            month: unref(c)(E),
            year: unref(p)(E),
            instance: E
          }, le.$props, {
            onMount: o[0] || (o[0] = (I) => Z(unref(_t).header)),
            onResetFlow: o[1] || (o[1] = (I) => le.$emit("reset-flow")),
            onUpdateMonthYear: (I) => unref(b)(E, I),
            onOverlayClosed: he,
            onOverlayOpened: o[2] || (o[2] = (I) => le.$emit("overlay-toggle", { open: true, overlay: I }))
          }), createSlots({ _: 2 }, [
            renderList(unref(U), (I, $e) => ({
              name: I,
              fn: withCtx((be) => [
                renderSlot(le.$slots, I, normalizeProps(guardReactiveProps(be)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          createVNode(Kr, mergeProps({
            ref: (I) => {
              I && (N.value[fe] = I);
            },
            "mapped-dates": A.value(E),
            month: unref(c)(E),
            year: unref(p)(E),
            instance: E
          }, le.$props, {
            onSelectDate: (I) => unref(R)(I, E !== 1),
            onHandleSpace: (I) => W(I, E !== 1),
            onSetHoverDate: o[3] || (o[3] = (I) => unref(B)(I)),
            onHandleScroll: (I) => unref(_)(I, E),
            onHandleSwipe: (I) => unref(h2)(I, E),
            onMount: o[4] || (o[4] = (I) => Z(unref(_t).calendar)),
            onResetFlow: o[5] || (o[5] = (I) => le.$emit("reset-flow")),
            onTooltipOpen: o[6] || (o[6] = (I) => le.$emit("tooltip-open", I)),
            onTooltipClose: o[7] || (o[7] = (I) => le.$emit("tooltip-close", I))
          }), createSlots({ _: 2 }, [
            renderList(unref(y), (I, $e) => ({
              name: I,
              fn: withCtx((be) => [
                renderSlot(le.$slots, I, normalizeProps(guardReactiveProps({ ...be })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars", "collapse", "is-mobile"]),
      le.enableTimePicker ? (openBlock(), createElementBlock("div", Qr, [
        le.$slots["time-picker"] ? renderSlot(le.$slots, "time-picker", normalizeProps(mergeProps({ key: 0 }, { time: unref(Y), updateTime: unref(ae) }))) : (openBlock(), createBlock(jn, mergeProps({
          key: 1,
          ref_key: "timePickerRef",
          ref: ee
        }, le.$props, {
          hours: unref(Y).hours,
          minutes: unref(Y).minutes,
          seconds: unref(Y).seconds,
          "internal-model-value": le.internalModelValue,
          "disabled-times-config": unref(f),
          "validate-time": unref(m),
          onMount: o[8] || (o[8] = (E) => Z(unref(_t).timePicker)),
          "onUpdate:hours": o[9] || (o[9] = (E) => unref(ae)(E)),
          "onUpdate:minutes": o[10] || (o[10] = (E) => unref(ae)(E, false)),
          "onUpdate:seconds": o[11] || (o[11] = (E) => unref(ae)(E, false, true)),
          onResetFlow: o[12] || (o[12] = (E) => le.$emit("reset-flow")),
          onOverlayClosed: o[13] || (o[13] = (E) => M(E, false)),
          onOverlayOpened: o[14] || (o[14] = (E) => M(E, true)),
          onAmPmChange: o[15] || (o[15] = (E) => le.$emit("am-pm-change", E))
        }), createSlots({ _: 2 }, [
          renderList(unref(S), (E, fe) => ({
            name: E,
            fn: withCtx((I) => [
              renderSlot(le.$slots, E, normalizeProps(guardReactiveProps(I)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
      ])) : createCommentVNode("", true)
    ], 64));
  }
}), Xr = (e2, t2) => {
  const r = ref(), {
    defaultedMultiCalendars: a,
    defaultedConfig: n,
    defaultedHighlight: u,
    defaultedRange: c,
    propDates: p,
    defaultedFilters: d,
    defaultedMultiDates: Y
  } = Ye(e2), { modelValue: f, year: O, month: m, calendars: P } = la(e2, t2), { isDisabled: F } = Pt(e2), { selectYear: L, groupedYears: _, showYearPicker: h2, isDisabled: R, toggleYearPicker: b, handleYearSelect: j, handleYear: z } = Vn({
    modelValue: f,
    multiCalendars: a,
    range: c,
    highlight: u,
    calendars: P,
    propDates: p,
    month: m,
    year: O,
    filters: d,
    props: e2,
    emit: t2
  }), ae = (y, U) => [y, U].map((S) => format(S, "MMMM", { locale: e2.formatLocale })).join("-"), H = computed(() => (y) => f.value ? Array.isArray(f.value) ? f.value.some((U) => isSameQuarter(y, U)) : isSameQuarter(f.value, y) : false), D = (y) => {
    if (c.value.enabled) {
      if (Array.isArray(f.value)) {
        const U = Te(y, f.value[0]) || Te(y, f.value[1]);
        return ea(f.value, r.value, y) && !U;
      }
      return false;
    }
    return false;
  }, Q = (y, U) => y.quarter === getQuarter(U) && y.year === getYear(U), B = (y) => typeof u.value == "function" ? u.value({ quarter: getQuarter(y), year: getYear(y) }) : !!u.value.quarters.find((U) => Q(U, y)), q = computed(() => (y) => {
    const U = set(/* @__PURE__ */ new Date(), { year: O.value(y) });
    return eachQuarterOfInterval({
      start: startOfYear(U),
      end: endOfYear(U)
    }).map((S) => {
      const Z = startOfQuarter(S), A = endOfQuarter(S), ie = F(S), i = D(Z), W = B(Z);
      return {
        text: ae(Z, A),
        value: Z,
        active: H.value(Z),
        highlighted: W,
        disabled: ie,
        isBetween: i
      };
    });
  }), ve = (y) => {
    xa(y, f, Y.value.limit), t2("auto-apply", true);
  }, pe = (y) => {
    f.value = en(f, y, t2), ga(f.value, t2, e2.autoApply, e2.modelAuto);
  }, v2 = (y) => {
    f.value = y, t2("auto-apply");
  };
  return {
    defaultedConfig: n,
    defaultedMultiCalendars: a,
    groupedYears: _,
    year: O,
    isDisabled: R,
    quarters: q,
    showYearPicker: h2,
    modelValue: f,
    setHoverDate: (y) => {
      r.value = y;
    },
    selectYear: L,
    selectQuarter: (y, U, S) => {
      if (!S)
        return P.value[U].month = getMonth(endOfQuarter(y)), Y.value.enabled ? ve(y) : c.value.enabled ? pe(y) : v2(y);
    },
    toggleYearPicker: b,
    handleYearSelect: j,
    handleYear: z
  };
}, Jr = { class: "dp--quarter-items" }, Zr = ["data-test-id", "disabled", "onClick", "onMouseover"], xr = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "QuarterPicker",
  props: {
    ...ct
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "overlay-closed",
    "auto-apply",
    "range-start",
    "range-end",
    "overlay-toggle",
    "update-month-year"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, u = useSlots(), c = at(u, "yearMode"), {
      defaultedMultiCalendars: p,
      defaultedConfig: d,
      groupedYears: Y,
      year: f,
      isDisabled: O,
      quarters: m,
      modelValue: P,
      showYearPicker: F,
      setHoverDate: L,
      selectQuarter: _,
      toggleYearPicker: h2,
      handleYearSelect: R,
      handleYear: b
    } = Xr(n, a);
    return t2({ getSidebarProps: () => ({
      modelValue: P,
      year: f,
      selectQuarter: _,
      handleYearSelect: R,
      handleYear: b
    }) }), (z, ae) => (openBlock(), createBlock(ya, {
      "multi-calendars": unref(p).count,
      collapse: z.collapse,
      stretch: "",
      "is-mobile": z.isMobile
    }, {
      default: withCtx(({ instance: H }) => [
        createBaseVNode("div", {
          class: "dp-quarter-picker-wrap",
          style: normalizeStyle({ minHeight: `${unref(d).modeHeight}px` })
        }, [
          z.$slots["top-extra"] ? renderSlot(z.$slots, "top-extra", {
            key: 0,
            value: z.internalModelValue
          }) : createCommentVNode("", true),
          createBaseVNode("div", null, [
            createVNode(Hn, mergeProps(z.$props, {
              items: unref(Y)(H),
              instance: H,
              "show-year-picker": unref(F)[H],
              year: unref(f)(H),
              "is-disabled": (D) => unref(O)(H, D),
              onHandleYear: (D) => unref(b)(H, D),
              onYearSelect: (D) => unref(R)(D, H),
              onToggleYearPicker: (D) => unref(h2)(H, D == null ? void 0 : D.flow, D == null ? void 0 : D.show)
            }), createSlots({ _: 2 }, [
              renderList(unref(c), (D, Q) => ({
                name: D,
                fn: withCtx((B) => [
                  renderSlot(z.$slots, D, normalizeProps(guardReactiveProps(B)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          createBaseVNode("div", Jr, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(m)(H), (D, Q) => (openBlock(), createElementBlock("div", { key: Q }, [
              createBaseVNode("button", {
                type: "button",
                class: normalizeClass(["dp--qr-btn", {
                  "dp--qr-btn-active": D.active,
                  "dp--qr-btn-between": D.isBetween,
                  "dp--qr-btn-disabled": D.disabled,
                  "dp--highlighted": D.highlighted
                }]),
                "data-test-id": D.value,
                disabled: D.disabled,
                onClick: (B) => unref(_)(D.value, H, D.disabled),
                onMouseover: (B) => unref(L)(D.value)
              }, [
                z.$slots.quarter ? renderSlot(z.$slots, "quarter", {
                  key: 0,
                  value: D.value,
                  text: D.text
                }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(D.text), 1)
                ], 64))
              ], 42, Zr)
            ]))), 128))
          ])
        ], 4)
      ]),
      _: 3
    }, 8, ["multi-calendars", "collapse", "is-mobile"]));
  }
}), Gn = (e2, t2) => {
  const r = ref(0);
  onMounted(() => {
    a(), window.addEventListener("resize", a, { passive: true });
  }), onUnmounted(() => {
    window.removeEventListener("resize", a);
  });
  const a = () => {
    r.value = window.document.documentElement.clientWidth;
  };
  return {
    isMobile: computed(
      () => r.value <= e2.value.mobileBreakpoint && !t2 ? true : void 0
    )
  };
}, eo = ["id", "tabindex", "role", "aria-label"], to = {
  key: 0,
  class: "dp--menu-load-container"
}, ao = {
  key: 1,
  class: "dp--menu-header"
}, no = ["data-dp-mobile"], lo = {
  key: 0,
  class: "dp__sidebar_left"
}, ro = ["data-dp-mobile"], oo = ["data-test-id", "data-dp-mobile", "onClick", "onKeydown"], so = {
  key: 2,
  class: "dp__sidebar_right"
}, uo = {
  key: 3,
  class: "dp__action_extra"
}, gn = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...pa,
    shadow: { type: Boolean, default: false },
    openOnTop: { type: Boolean, default: false },
    internalModelValue: { type: [Date, Array], default: null },
    noOverlayFocus: { type: Boolean, default: false },
    collapse: { type: Boolean, default: false },
    getInputRect: { type: Function, default: () => ({}) },
    isTextInputDate: { type: Boolean, default: false }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "auto-apply-invalid",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "menu-blur"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, u = ref(null), c = computed(() => {
      const { openOnTop: k, ...x } = n;
      return {
        ...x,
        isMobile: _.value,
        flowStep: pe.value,
        menuWrapRef: u.value
      };
    }), { setMenuFocused: p, setShiftKey: d, control: Y } = zn(), f = useSlots(), { defaultedTextInput: O, defaultedInline: m, defaultedConfig: P, defaultedUI: F, handleEventPropagation: L } = Ye(n), { isMobile: _ } = Gn(P, n.shadow), h2 = ref(null), R = ref(0), b = ref(null), j = ref(false), z = ref(null), ae = ref(false), H = (k) => {
      ae.value = true, P.value.allowPreventDefault && k.preventDefault(), $t(k, P.value, true);
    };
    onMounted(() => {
      if (!n.shadow) {
        j.value = true, D(), window.addEventListener("resize", D);
        const k = He(u);
        k && !O.value.enabled && !m.value.enabled && (p(true), Z()), k && (k.addEventListener("pointerdown", H), k.addEventListener("mousedown", H));
      }
      document.addEventListener("mousedown", Ee);
    }), onUnmounted(() => {
      window.removeEventListener("resize", D), document.removeEventListener("mousedown", Ee);
      const k = He(u);
      k && (k.removeEventListener("pointerdown", H), k.removeEventListener("mousedown", H));
    });
    const D = () => {
      const k = He(b);
      k && (R.value = k.getBoundingClientRect().width);
    }, { arrowRight: Q, arrowLeft: B, arrowDown: q, arrowUp: ve } = St(), { flowStep: pe, updateFlowStep: v2, childMount: N, resetFlow: ee, handleFlow: y } = mo(n, a, z), U = computed(() => n.monthPicker ? gr : n.yearPicker ? br : n.timePicker ? _r : n.quarterPicker ? xr : qr), S = computed(() => {
      var Ie;
      if (P.value.arrowLeft) return P.value.arrowLeft;
      const k = (Ie = u.value) == null ? void 0 : Ie.getBoundingClientRect(), x = n.getInputRect();
      return (x == null ? void 0 : x.width) < (R == null ? void 0 : R.value) && (x == null ? void 0 : x.left) <= ((k == null ? void 0 : k.left) ?? 0) ? `${(x == null ? void 0 : x.width) / 2}px` : (x == null ? void 0 : x.right) >= ((k == null ? void 0 : k.right) ?? 0) && (x == null ? void 0 : x.width) < (R == null ? void 0 : R.value) ? `${(R == null ? void 0 : R.value) - (x == null ? void 0 : x.width) / 2}px` : "50%";
    }), Z = () => {
      const k = He(u);
      k && k.focus({ preventScroll: true });
    }, A = computed(() => {
      var k;
      return ((k = z.value) == null ? void 0 : k.getSidebarProps()) || {};
    }), ie = () => {
      n.openOnTop && a("recalculate-position");
    }, i = at(f, "action"), W = computed(() => n.monthPicker || n.yearPicker ? at(f, "monthYear") : n.timePicker ? at(f, "timePicker") : at(f, "shared")), se = computed(() => n.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), T = computed(() => ({
      dp__menu_disabled: n.disabled,
      dp__menu_readonly: n.readonly,
      "dp-menu-loading": n.loading
    })), re = computed(
      () => ({
        dp__menu: true,
        dp__menu_index: !m.value.enabled,
        dp__relative: m.value.enabled,
        ...F.value.menu ?? {}
      })
    ), l = (k) => {
      $t(k, P.value, true);
    }, w = (k) => {
      n.escClose && (a("close-picker"), L(k));
    }, oe = (k) => {
      if (n.arrowNavigation) {
        if (k === Ze.up) return ve();
        if (k === Ze.down) return q();
        if (k === Ze.left) return B();
        if (k === Ze.right) return Q();
      } else k === Ze.left || k === Ze.up ? o("handleArrow", Ze.left, 0, k === Ze.up) : o("handleArrow", Ze.right, 0, k === Ze.down);
    }, M = (k) => {
      d(k.shiftKey), !n.disableMonthYearSelect && k.code === Oe.tab && k.target.classList.contains("dp__menu") && Y.value.shiftKeyInMenu && (k.preventDefault(), $t(k, P.value, true), a("close-picker"));
    }, he = () => {
      Z(), a("time-picker-close");
    }, ke = (k) => {
      var x, Ie, Ue;
      (x = z.value) == null || x.toggleTimePicker(false, false), (Ie = z.value) == null || Ie.toggleMonthPicker(false, false, k), (Ue = z.value) == null || Ue.toggleYearPicker(false, false, k);
    }, le = (k, x = 0) => {
      var Ie, Ue, rt;
      return k === "month" ? (Ie = z.value) == null ? void 0 : Ie.toggleMonthPicker(false, true, x) : k === "year" ? (Ue = z.value) == null ? void 0 : Ue.toggleYearPicker(false, true, x) : k === "time" ? (rt = z.value) == null ? void 0 : rt.toggleTimePicker(true, false) : ke(x);
    }, o = (k, ...x) => {
      var Ie, Ue;
      (Ie = z.value) != null && Ie[k] && ((Ue = z.value) == null || Ue[k](...x));
    }, E = () => {
      o("selectCurrentDate");
    }, fe = (k, x) => {
      o("presetDate", toValue(k), x);
    }, I = () => {
      o("clearHoverDate");
    }, $e = (k, x) => {
      o("updateMonthYear", k, x);
    }, be = (k, x) => {
      k.preventDefault(), oe(x);
    }, Pe2 = (k) => {
      var x, Ie, Ue;
      if (M(k), k.key === Oe.home || k.key === Oe.end)
        return o(
          "selectWeekDate",
          k.key === Oe.home,
          k.target.getAttribute("id")
        );
      switch ((k.key === Oe.pageUp || k.key === Oe.pageDown) && (k.shiftKey ? (o("changeYear", k.key === Oe.pageUp), (x = Fa(u.value, "overlay-year")) == null || x.focus()) : (o("changeMonth", k.key === Oe.pageUp), (Ie = Fa(u.value, k.key === Oe.pageUp ? "action-prev" : "action-next")) == null || Ie.focus()), k.target.getAttribute("id") && ((Ue = u.value) == null || Ue.focus({ preventScroll: true }))), k.key) {
        case Oe.esc:
          return w(k);
        case Oe.arrowLeft:
          return be(k, Ze.left);
        case Oe.arrowRight:
          return be(k, Ze.right);
        case Oe.arrowUp:
          return be(k, Ze.up);
        case Oe.arrowDown:
          return be(k, Ze.down);
        default:
          return;
      }
    }, Ee = (k) => {
      var x;
      m.value.enabled && !m.value.input && !((x = u.value) != null && x.contains(k.target)) && ae.value && (ae.value = false, a("menu-blur"));
    };
    return t2({
      updateMonthYear: $e,
      switchView: le,
      handleFlow: y,
      onValueCleared: () => {
        var k, x;
        (x = (k = z.value) == null ? void 0 : k.setStartTime) == null || x.call(k);
      }
    }), (k, x) => {
      var Ie, Ue, rt;
      return openBlock(), createElementBlock("div", {
        id: k.uid ? `dp-menu-${k.uid}` : void 0,
        ref_key: "dpMenuRef",
        ref: u,
        tabindex: unref(m).enabled ? void 0 : "0",
        role: unref(m).enabled ? void 0 : "dialog",
        "aria-label": (Ie = k.ariaLabels) == null ? void 0 : Ie.menu,
        class: normalizeClass(re.value),
        style: normalizeStyle({ "--dp-arrow-left": S.value }),
        onMouseleave: I,
        onClick: l,
        onKeydown: Pe2
      }, [
        (k.disabled || k.readonly) && unref(m).enabled || k.loading ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(T.value)
        }, [
          k.loading ? (openBlock(), createElementBlock("div", to, x[19] || (x[19] = [
            createBaseVNode("span", { class: "dp--menu-loader" }, null, -1)
          ]))) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        k.$slots["menu-header"] ? (openBlock(), createElementBlock("div", ao, [
          renderSlot(k.$slots, "menu-header")
        ])) : createCommentVNode("", true),
        !unref(m).enabled && !k.teleportCenter ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(se.value)
        }, null, 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "innerMenuRef",
          ref: b,
          class: normalizeClass({
            dp__menu_content_wrapper: ((Ue = k.presetDates) == null ? void 0 : Ue.length) || !!k.$slots["left-sidebar"] || !!k.$slots["right-sidebar"],
            "dp--menu-content-wrapper-collapsed": e2.collapse && (((rt = k.presetDates) == null ? void 0 : rt.length) || !!k.$slots["left-sidebar"] || !!k.$slots["right-sidebar"])
          }),
          "data-dp-mobile": unref(_),
          style: normalizeStyle({ "--dp-menu-width": `${R.value}px` })
        }, [
          k.$slots["left-sidebar"] ? (openBlock(), createElementBlock("div", lo, [
            renderSlot(k.$slots, "left-sidebar", normalizeProps(guardReactiveProps(A.value)))
          ])) : createCommentVNode("", true),
          k.presetDates.length ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass({ "dp--preset-dates-collapsed": e2.collapse, "dp--preset-dates": true }),
            "data-dp-mobile": unref(_)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(k.presetDates, (de, Rt) => (openBlock(), createElementBlock(Fragment, { key: Rt }, [
              de.slot ? renderSlot(k.$slots, de.slot, {
                key: 0,
                presetDate: fe,
                label: de.label,
                value: de.value
              }) : (openBlock(), createElementBlock("button", {
                key: 1,
                type: "button",
                style: normalizeStyle(de.style || {}),
                class: normalizeClass(["dp__btn dp--preset-range", { "dp--preset-range-collapsed": e2.collapse }]),
                "data-test-id": de.testId ?? void 0,
                "data-dp-mobile": unref(_),
                onClick: withModifiers((ft) => fe(de.value, de.noTz), ["prevent"]),
                onKeydown: (ft) => unref(xe)(ft, () => fe(de.value, de.noTz), true)
              }, toDisplayString(de.label), 47, oo))
            ], 64))), 128))
          ], 10, ro)) : createCommentVNode("", true),
          createBaseVNode("div", {
            ref_key: "calendarWrapperRef",
            ref: h2,
            class: "dp__instance_calendar",
            role: "document"
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(U.value), mergeProps({
              ref_key: "dynCmpRef",
              ref: z
            }, c.value, {
              "flow-step": unref(pe),
              onMount: unref(N),
              onUpdateFlowStep: unref(v2),
              onResetFlow: unref(ee),
              onFocusMenu: Z,
              onSelectDate: x[0] || (x[0] = (de) => k.$emit("select-date")),
              onDateUpdate: x[1] || (x[1] = (de) => k.$emit("date-update", de)),
              onTooltipOpen: x[2] || (x[2] = (de) => k.$emit("tooltip-open", de)),
              onTooltipClose: x[3] || (x[3] = (de) => k.$emit("tooltip-close", de)),
              onAutoApply: x[4] || (x[4] = (de) => k.$emit("auto-apply", de)),
              onRangeStart: x[5] || (x[5] = (de) => k.$emit("range-start", de)),
              onRangeEnd: x[6] || (x[6] = (de) => k.$emit("range-end", de)),
              onInvalidFixedRange: x[7] || (x[7] = (de) => k.$emit("invalid-fixed-range", de)),
              onTimeUpdate: x[8] || (x[8] = (de) => k.$emit("time-update")),
              onAmPmChange: x[9] || (x[9] = (de) => k.$emit("am-pm-change", de)),
              onTimePickerOpen: x[10] || (x[10] = (de) => k.$emit("time-picker-open", de)),
              onTimePickerClose: he,
              onRecalculatePosition: ie,
              onUpdateMonthYear: x[11] || (x[11] = (de) => k.$emit("update-month-year", de)),
              onAutoApplyInvalid: x[12] || (x[12] = (de) => k.$emit("auto-apply-invalid", de)),
              onInvalidDate: x[13] || (x[13] = (de) => k.$emit("invalid-date", de)),
              onOverlayToggle: x[14] || (x[14] = (de) => k.$emit("overlay-toggle", de)),
              "onUpdate:internalModelValue": x[15] || (x[15] = (de) => k.$emit("update:internal-model-value", de))
            }), createSlots({ _: 2 }, [
              renderList(W.value, (de, Rt) => ({
                name: de,
                fn: withCtx((ft) => [
                  renderSlot(k.$slots, de, normalizeProps(guardReactiveProps({ ...ft })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          k.$slots["right-sidebar"] ? (openBlock(), createElementBlock("div", so, [
            renderSlot(k.$slots, "right-sidebar", normalizeProps(guardReactiveProps(A.value)))
          ])) : createCommentVNode("", true),
          k.$slots["action-extra"] ? (openBlock(), createElementBlock("div", uo, [
            k.$slots["action-extra"] ? renderSlot(k.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: E
            }) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ], 14, no),
        !k.autoApply || unref(P).keepActionRow ? (openBlock(), createBlock(ur, mergeProps({
          key: 3,
          "menu-mount": j.value
        }, c.value, {
          "calendar-width": R.value,
          onClosePicker: x[16] || (x[16] = (de) => k.$emit("close-picker")),
          onSelectDate: x[17] || (x[17] = (de) => k.$emit("select-date")),
          onInvalidSelect: x[18] || (x[18] = (de) => k.$emit("invalid-select")),
          onSelectNow: E
        }), createSlots({ _: 2 }, [
          renderList(unref(i), (de, Rt) => ({
            name: de,
            fn: withCtx((ft) => [
              renderSlot(k.$slots, de, normalizeProps(guardReactiveProps({ ...ft })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : createCommentVNode("", true)
      ], 46, eo);
    };
  }
});
var Lt = /* @__PURE__ */ ((e2) => (e2.center = "center", e2.left = "left", e2.right = "right", e2))(Lt || {});
const io = ({
  menuRef: e2,
  menuRefInner: t2,
  inputRef: r,
  pickerWrapperRef: a,
  inline: n,
  emit: u,
  props: c,
  slots: p
}) => {
  const { defaultedConfig: d } = Ye(c), Y = ref({}), f = ref(false), O = ref({
    top: "0",
    left: "0"
  }), m = ref(false), P = toRef(c, "teleportCenter");
  watch(P, () => {
    O.value = JSON.parse(JSON.stringify({})), z();
  });
  const F = (y) => {
    if (c.teleport) {
      const U = y.getBoundingClientRect();
      return {
        left: U.left + window.scrollX,
        top: U.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, L = (y, U) => {
    O.value.left = `${y + U - Y.value.width}px`;
  }, _ = (y) => {
    O.value.left = `${y}px`;
  }, h$1 = (y, U) => {
    c.position === Lt.left && _(y), c.position === Lt.right && L(y, U), c.position === Lt.center && (O.value.left = `${y + U / 2 - Y.value.width / 2}px`);
  }, R = (y) => {
    const { width: U, height: S } = y.getBoundingClientRect(), { top: Z, left: A } = F(y);
    return { top: +Z, left: +A, width: U, height: S };
  }, b = () => {
    O.value.left = "50%", O.value.top = "50%", O.value.transform = "translate(-50%, -50%)", O.value.position = "fixed", delete O.value.opacity;
  }, j = () => {
    const y = He(r);
    O.value = c.altPosition(y);
  }, z = (y = true) => {
    var U;
    if (!n.value.enabled) {
      if (P.value) return b();
      if (c.altPosition !== null) return j();
      if (y) {
        const S = c.teleport ? (U = t2.value) == null ? void 0 : U.$el : e2.value;
        S && (Y.value = S.getBoundingClientRect()), u("recalculate-position");
      }
      return ve();
    }
  }, ae = ({ inputEl: y, left: U, width: S }) => {
    window.screen.width > 768 && !f.value && h$1(U, S), Q(y);
  }, H = (y) => {
    const { top: U, left: S, height: Z, width: A } = R(y);
    O.value.top = `${Z + U + +c.offset}px`, m.value = false, f.value || (O.value.left = `${S + A / 2 - Y.value.width / 2}px`), ae({ inputEl: y, left: S, width: A });
  }, D = (y) => {
    const { top: U, left: S, width: Z } = R(y);
    O.value.top = `${U - +c.offset - Y.value.height}px`, m.value = true, ae({ inputEl: y, left: S, width: Z });
  }, Q = (y) => {
    if (c.autoPosition) {
      const { left: U, width: S } = R(y), { left: Z, right: A } = Y.value;
      if (!f.value) {
        if (Math.abs(Z) !== Math.abs(A)) {
          if (Z <= 0)
            return f.value = true, _(U);
          if (A >= document.documentElement.clientWidth)
            return f.value = true, L(U, S);
        }
        return h$1(U, S);
      }
    }
  }, B = () => {
    const y = He(r);
    if (y) {
      if (c.autoPosition === it.top) return it.top;
      if (c.autoPosition === it.bottom) return it.bottom;
      const { height: U } = Y.value, { top: S, height: Z } = y.getBoundingClientRect(), ie = window.innerHeight - S - Z, i = S;
      return U <= ie ? it.bottom : U > ie && U <= i ? it.top : ie >= i ? it.bottom : it.top;
    }
    return it.bottom;
  }, q = (y) => B() === it.bottom ? H(y) : D(y), ve = () => {
    const y = He(r);
    if (y)
      return c.autoPosition ? q(y) : H(y);
  }, pe = function(y) {
    if (y) {
      const U = y.scrollHeight > y.clientHeight, Z = window.getComputedStyle(y).overflowY.indexOf("hidden") !== -1;
      return U && !Z;
    }
    return true;
  }, v2 = function(y) {
    return !y || y === document.body || y.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : pe(y) ? y : v2(
      y.assignedSlot && d.value.shadowDom ? y.assignedSlot.parentNode : y.parentNode
    );
  }, N = (y) => {
    if (y)
      switch (c.position) {
        case Lt.left:
          return { left: 0, transform: "translateX(0)" };
        case Lt.right:
          return { left: `${y.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${y.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: m,
    menuStyle: O,
    xCorrect: f,
    setMenuPosition: z,
    getScrollableParent: v2,
    shadowRender: (y, U, S) => {
      var T, re, l;
      const Z = document.createElement("div"), A = (T = He(r)) == null ? void 0 : T.getBoundingClientRect();
      Z.setAttribute("id", "dp--temp-container");
      const ie = (re = a.value) != null && re.clientWidth ? a.value : document.body;
      ie.append(Z);
      const i = N(A), W = d.value.shadowDom ? Object.keys(p).filter(
        (w) => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(w)
      ) : Object.keys(p), se = h(
        U,
        {
          ...S,
          shadow: true,
          style: { opacity: 0, position: "absolute", ...i }
        },
        Object.fromEntries(W.map((w) => [w, p[w]]))
      );
      y != null && (se.appContext = y.appContext), render$6(se, Z), Y.value = (l = se.el) == null ? void 0 : l.getBoundingClientRect(), render$6(null, Z), ie.removeChild(Z);
    }
  };
}, wt = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-header", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] },
  { name: "top-extra", use: ["shared", "month-year"] },
  { name: "tp-inline-arrow-up", use: ["shared", "time"] },
  { name: "tp-inline-arrow-down", use: ["shared", "time"] },
  { name: "menu-header", use: ["menu"] }
], co = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], fo = {
  all: () => wt,
  monthYear: () => wt.filter((e2) => e2.use.includes("month-year")),
  input: () => co,
  timePicker: () => wt.filter((e2) => e2.use.includes("time")),
  action: () => wt.filter((e2) => e2.use.includes("action")),
  calendar: () => wt.filter((e2) => e2.use.includes("calendar")),
  menu: () => wt.filter((e2) => e2.use.includes("menu")),
  shared: () => wt.filter((e2) => e2.use.includes("shared")),
  yearMode: () => wt.filter((e2) => e2.use.includes("year-mode"))
}, at = (e2, t2, r) => {
  const a = [];
  return fo[t2]().forEach((n) => {
    e2[n.name] && a.push(n.name);
  }), r != null && r.length && r.forEach((n) => {
    n.slot && a.push(n.slot);
  }), a;
}, na = (e2) => {
  const t2 = computed(() => (a) => e2.value ? a ? e2.value.open : e2.value.close : ""), r = computed(() => (a) => e2.value ? a ? e2.value.menuAppearTop : e2.value.menuAppearBottom : "");
  return { transitionName: t2, showTransition: !!e2.value, menuTransition: r };
}, la = (e2, t2, r) => {
  const { defaultedRange: a, defaultedTz: n } = Ye(e2), u = K(tt(K(), n.value.timezone)), c = ref([{ month: getMonth(u), year: getYear(u) }]), p = (m) => {
    const P = {
      hours: getHours(u),
      minutes: getMinutes(u),
      seconds: 0
    };
    return a.value.enabled ? [P[m], P[m]] : P[m];
  }, d = reactive({
    hours: p("hours"),
    minutes: p("minutes"),
    seconds: p("seconds")
  });
  watch(
    a,
    (m, P) => {
      m.enabled !== P.enabled && (d.hours = p("hours"), d.minutes = p("minutes"), d.seconds = p("seconds"));
    },
    { deep: true }
  );
  const Y = computed({
    get: () => e2.internalModelValue,
    set: (m) => {
      !e2.readonly && !e2.disabled && t2("update:internal-model-value", m);
    }
  }), f = computed(
    () => (m) => c.value[m] ? c.value[m].month : 0
  ), O = computed(
    () => (m) => c.value[m] ? c.value[m].year : 0
  );
  return watch(
    Y,
    (m, P) => {
      r && JSON.stringify(m ?? {}) !== JSON.stringify(P ?? {}) && r();
    },
    { deep: true }
  ), {
    calendars: c,
    time: d,
    modelValue: Y,
    month: f,
    year: O,
    today: u
  };
}, vo = (e2, t2) => {
  const {
    defaultedMultiCalendars: r,
    defaultedMultiDates: a,
    defaultedUI: n,
    defaultedHighlight: u,
    defaultedTz: c,
    propDates: p,
    defaultedRange: d
  } = Ye(t2), { isDisabled: Y } = Pt(t2), f = ref(null), O = ref(tt(/* @__PURE__ */ new Date(), c.value.timezone)), m = (l) => {
    !l.current && t2.hideOffsetDates || (f.value = l.value);
  }, P = () => {
    f.value = null;
  }, F = (l) => Array.isArray(e2.value) && d.value.enabled && e2.value[0] && f.value ? l ? Fe(f.value, e2.value[0]) : Ne(f.value, e2.value[0]) : true, L = (l, w) => {
    const oe = () => e2.value ? w ? e2.value[0] || null : e2.value[1] : null, M = e2.value && Array.isArray(e2.value) ? oe() : null;
    return Te(K(l.value), M);
  }, _ = (l) => {
    const w = Array.isArray(e2.value) ? e2.value[0] : null;
    return l ? !Ne(f.value ?? null, w) : true;
  }, h2 = (l, w = true) => (d.value.enabled || t2.weekPicker) && Array.isArray(e2.value) && e2.value.length === 2 ? t2.hideOffsetDates && !l.current ? false : Te(K(l.value), e2.value[w ? 0 : 1]) : d.value.enabled ? L(l, w) && _(w) || Te(l.value, Array.isArray(e2.value) ? e2.value[0] : null) && F(w) : false, R = (l, w) => {
    if (Array.isArray(e2.value) && e2.value[0] && e2.value.length === 1) {
      const oe = Te(l.value, f.value);
      return w ? Fe(e2.value[0], l.value) && oe : Ne(e2.value[0], l.value) && oe;
    }
    return false;
  }, b = (l) => !e2.value || t2.hideOffsetDates && !l.current ? false : d.value.enabled ? t2.modelAuto && Array.isArray(e2.value) ? Te(l.value, e2.value[0] ? e2.value[0] : O.value) : false : a.value.enabled && Array.isArray(e2.value) ? e2.value.some((w) => Te(w, l.value)) : Te(l.value, e2.value ? e2.value : O.value), j = (l) => {
    if (d.value.autoRange || t2.weekPicker) {
      if (f.value) {
        if (t2.hideOffsetDates && !l.current) return false;
        const w = addDays(f.value, +d.value.autoRange), oe = gt(K(f.value), t2.weekStart);
        return t2.weekPicker ? Te(oe[1], K(l.value)) : Te(w, K(l.value));
      }
      return false;
    }
    return false;
  }, z = (l) => {
    if (d.value.autoRange || t2.weekPicker) {
      if (f.value) {
        const w = addDays(f.value, +d.value.autoRange);
        if (t2.hideOffsetDates && !l.current) return false;
        const oe = gt(K(f.value), t2.weekStart);
        return t2.weekPicker ? Fe(l.value, oe[0]) && Ne(l.value, oe[1]) : Fe(l.value, f.value) && Ne(l.value, w);
      }
      return false;
    }
    return false;
  }, ae = (l) => {
    if (d.value.autoRange || t2.weekPicker) {
      if (f.value) {
        if (t2.hideOffsetDates && !l.current) return false;
        const w = gt(K(f.value), t2.weekStart);
        return t2.weekPicker ? Te(w[0], l.value) : Te(f.value, l.value);
      }
      return false;
    }
    return false;
  }, H = (l) => ea(e2.value, f.value, l.value), D = () => t2.modelAuto && Array.isArray(t2.internalModelValue) ? !!t2.internalModelValue[0] : false, Q = () => t2.modelAuto ? Pn(t2.internalModelValue) : true, B = (l) => {
    if (t2.weekPicker) return false;
    const w = d.value.enabled ? !h2(l) && !h2(l, false) : true;
    return !Y(l.value) && !b(l) && !(!l.current && t2.hideOffsetDates) && w;
  }, q = (l) => d.value.enabled ? t2.modelAuto ? D() && b(l) : false : b(l), ve = (l) => u.value ? Ol(l.value, p.value.highlight) : false, pe = (l) => {
    const w = Y(l.value);
    return w && (typeof u.value == "function" ? !u.value(l.value, w) : !u.value.options.highlightDisabled);
  }, v2 = (l) => {
    var w;
    return typeof u.value == "function" ? u.value(l.value) : (w = u.value.weekdays) == null ? void 0 : w.includes(l.value.getDay());
  }, N = (l) => (d.value.enabled || t2.weekPicker) && (!(r.value.count > 0) || l.current) && Q() && !(!l.current && t2.hideOffsetDates) && !b(l) ? H(l) : false, ee = (l) => {
    if (Array.isArray(e2.value) && e2.value.length === 1) {
      const { before: w, after: oe } = vn(+d.value.maxRange, e2.value[0]);
      return isBefore(l.value, w) || isAfter(l.value, oe);
    }
    return false;
  }, y = (l) => {
    if (Array.isArray(e2.value) && e2.value.length === 1) {
      const { before: w, after: oe } = vn(+d.value.minRange, e2.value[0]);
      return ea([w, oe], e2.value[0], l.value);
    }
    return false;
  }, U = (l) => d.value.enabled && (d.value.maxRange || d.value.minRange) ? d.value.maxRange && d.value.minRange ? ee(l) || y(l) : d.value.maxRange ? ee(l) : y(l) : false, S = (l) => {
    const { isRangeStart: w, isRangeEnd: oe } = i(l), M = d.value.enabled ? w || oe : false;
    return {
      dp__cell_offset: !l.current,
      dp__pointer: !t2.disabled && !(!l.current && t2.hideOffsetDates) && !Y(l.value) && !U(l),
      dp__cell_disabled: Y(l.value) || U(l),
      dp__cell_highlight: !pe(l) && (ve(l) || v2(l)) && !q(l) && !M && !ae(l) && !(N(l) && t2.weekPicker) && !oe,
      dp__cell_highlight_active: !pe(l) && (ve(l) || v2(l)) && q(l),
      dp__today: !t2.noToday && Te(l.value, O.value) && l.current,
      "dp--past": Ne(l.value, O.value),
      "dp--future": Fe(l.value, O.value)
    };
  }, Z = (l) => ({
    dp__active_date: q(l),
    dp__date_hover: B(l)
  }), A = (l) => {
    if (e2.value && !Array.isArray(e2.value)) {
      const w = gt(e2.value, t2.weekStart);
      return {
        ...se(l),
        dp__range_start: Te(w[0], l.value),
        dp__range_end: Te(w[1], l.value),
        dp__range_between_week: Fe(l.value, w[0]) && Ne(l.value, w[1])
      };
    }
    return {
      ...se(l)
    };
  }, ie = (l) => {
    if (e2.value && Array.isArray(e2.value)) {
      const w = gt(e2.value[0], t2.weekStart), oe = e2.value[1] ? gt(e2.value[1], t2.weekStart) : [];
      return {
        ...se(l),
        dp__range_start: Te(w[0], l.value) || Te(oe[0], l.value),
        dp__range_end: Te(w[1], l.value) || Te(oe[1], l.value),
        dp__range_between_week: Fe(l.value, w[0]) && Ne(l.value, w[1]) || Fe(l.value, oe[0]) && Ne(l.value, oe[1]),
        dp__range_between: Fe(l.value, w[1]) && Ne(l.value, oe[0])
      };
    }
    return {
      ...se(l)
    };
  }, i = (l) => {
    const w = r.value.count > 0 ? l.current && h2(l) && Q() : h2(l) && Q(), oe = r.value.count > 0 ? l.current && h2(l, false) && Q() : h2(l, false) && Q();
    return { isRangeStart: w, isRangeEnd: oe };
  }, W = (l) => {
    const { isRangeStart: w, isRangeEnd: oe } = i(l);
    return {
      dp__range_start: w,
      dp__range_end: oe,
      dp__range_between: N(l),
      dp__date_hover: Te(l.value, f.value) && !w && !oe && !t2.weekPicker,
      dp__date_hover_start: R(l, true),
      dp__date_hover_end: R(l, false)
    };
  }, se = (l) => ({
    ...W(l),
    dp__cell_auto_range: z(l),
    dp__cell_auto_range_start: ae(l),
    dp__cell_auto_range_end: j(l)
  }), T = (l) => d.value.enabled ? d.value.autoRange ? se(l) : t2.modelAuto ? { ...Z(l), ...W(l) } : t2.weekPicker ? ie(l) : W(l) : t2.weekPicker ? A(l) : Z(l);
  return {
    setHoverDate: m,
    clearHoverDate: P,
    getDayClassData: (l) => t2.hideOffsetDates && !l.current ? {} : {
      ...S(l),
      ...T(l),
      [t2.dayClass ? t2.dayClass(l.value, t2.internalModelValue) : ""]: true,
      ...n.value.calendarCell ?? {}
    }
  };
}, Pt = (e2) => {
  const { defaultedFilters: t2, defaultedRange: r, propDates: a, defaultedMultiDates: n } = Ye(e2), u = (v2) => a.value.disabledDates ? typeof a.value.disabledDates == "function" ? a.value.disabledDates(K(v2)) : !!va(v2, a.value.disabledDates) : false, c = (v2) => a.value.maxDate ? e2.yearPicker ? getYear(v2) > getYear(a.value.maxDate) : Fe(v2, a.value.maxDate) : false, p = (v2) => a.value.minDate ? e2.yearPicker ? getYear(v2) < getYear(a.value.minDate) : Ne(v2, a.value.minDate) : false, d = (v2) => {
    const N = c(v2), ee = p(v2), y = u(v2), S = t2.value.months.map((W) => +W).includes(getMonth(v2)), Z = e2.disabledWeekDays.length ? e2.disabledWeekDays.some((W) => +W === getDay(v2)) : false, A = P(v2), ie = getYear(v2), i = ie < +e2.yearRange[0] || ie > +e2.yearRange[1];
    return !(N || ee || y || S || i || Z || A);
  }, Y = (v2, N) => Ne(...Mt(a.value.minDate, v2, N)) || Te(...Mt(a.value.minDate, v2, N)), f = (v2, N) => Fe(...Mt(a.value.maxDate, v2, N)) || Te(...Mt(a.value.maxDate, v2, N)), O = (v2, N, ee) => {
    let y = false;
    return a.value.maxDate && ee && f(v2, N) && (y = true), a.value.minDate && !ee && Y(v2, N) && (y = true), y;
  }, m = (v2, N, ee, y) => {
    let U = false;
    return y && (a.value.minDate || a.value.maxDate) ? a.value.minDate && a.value.maxDate ? U = O(v2, N, ee) : (a.value.minDate && Y(v2, N) || a.value.maxDate && f(v2, N)) && (U = true) : U = true, U;
  }, P = (v2) => Array.isArray(a.value.allowedDates) && !a.value.allowedDates.length ? true : a.value.allowedDates ? !va(v2, a.value.allowedDates, On(e2.monthPicker, e2.yearPicker)) : false, F = (v2) => !d(v2), L = (v2) => r.value.noDisabledRange ? !eachDayOfInterval({ start: v2[0], end: v2[1] }).some((ee) => F(ee)) : true, _ = (v2) => {
    if (v2) {
      const N = getYear(v2);
      return N >= +e2.yearRange[0] && N <= e2.yearRange[1];
    }
    return true;
  }, h2 = (v2, N) => !!(Array.isArray(v2) && v2[N] && (r.value.maxRange || r.value.minRange) && _(v2[N])), R = (v2, N, ee = 0) => {
    if (h2(N, ee) && _(v2)) {
      const y = differenceInCalendarDays(v2, N[ee]), U = In(N[ee], v2), S = U.length === 1 ? 0 : U.filter((A) => F(A)).length, Z = Math.abs(y) - (r.value.minMaxRawRange ? 0 : S);
      if (r.value.minRange && r.value.maxRange)
        return Z >= +r.value.minRange && Z <= +r.value.maxRange;
      if (r.value.minRange) return Z >= +r.value.minRange;
      if (r.value.maxRange) return Z <= +r.value.maxRange;
    }
    return true;
  }, b = () => !e2.enableTimePicker || e2.monthPicker || e2.yearPicker || e2.ignoreTimeValidation, j = (v2) => Array.isArray(v2) ? [v2[0] ? Ca(v2[0]) : null, v2[1] ? Ca(v2[1]) : null] : Ca(v2), z = (v2, N, ee) => v2.find(
    (y) => +y.hours === getHours(N) && y.minutes === "*" ? true : +y.minutes === getMinutes(N) && +y.hours === getHours(N)
  ) && ee, ae = (v2, N, ee) => {
    const [y, U] = v2, [S, Z] = N;
    return !z(y, S, ee) && !z(U, Z, ee) && ee;
  }, H = (v2, N) => {
    const ee = Array.isArray(N) ? N : [N];
    return Array.isArray(e2.disabledTimes) ? Array.isArray(e2.disabledTimes[0]) ? ae(e2.disabledTimes, ee, v2) : !ee.some((y) => z(e2.disabledTimes, y, v2)) : v2;
  }, D = (v2, N) => {
    const ee = Array.isArray(N) ? [Yt(N[0]), N[1] ? Yt(N[1]) : void 0] : Yt(N), y = !e2.disabledTimes(ee);
    return v2 && y;
  }, Q = (v2, N) => e2.disabledTimes ? Array.isArray(e2.disabledTimes) ? H(N, v2) : D(N, v2) : N, B = (v2) => {
    let N = true;
    if (!v2 || b()) return true;
    const ee = !a.value.minDate && !a.value.maxDate ? j(v2) : v2;
    return (e2.maxTime || a.value.maxDate) && (N = fn(
      e2.maxTime,
      a.value.maxDate,
      "max",
      ze(ee),
      N
    )), (e2.minTime || a.value.minDate) && (N = fn(
      e2.minTime,
      a.value.minDate,
      "min",
      ze(ee),
      N
    )), Q(v2, N);
  }, q = (v2) => {
    if (!e2.monthPicker) return true;
    let N = true;
    const ee = K(dt(v2));
    if (a.value.minDate && a.value.maxDate) {
      const y = K(dt(a.value.minDate)), U = K(dt(a.value.maxDate));
      return Fe(ee, y) && Ne(ee, U) || Te(ee, y) || Te(ee, U);
    }
    if (a.value.minDate) {
      const y = K(dt(a.value.minDate));
      N = Fe(ee, y) || Te(ee, y);
    }
    if (a.value.maxDate) {
      const y = K(dt(a.value.maxDate));
      N = Ne(ee, y) || Te(ee, y);
    }
    return N;
  }, ve = computed(() => (v2) => !e2.enableTimePicker || e2.ignoreTimeValidation ? true : B(v2)), pe = computed(() => (v2) => e2.monthPicker ? Array.isArray(v2) && (r.value.enabled || n.value.enabled) ? !v2.filter((ee) => !q(ee)).length : q(v2) : true);
  return {
    isDisabled: F,
    validateDate: d,
    validateMonthYearInRange: m,
    isDateRangeAllowed: L,
    checkMinMaxRange: R,
    isValidTime: B,
    isTimeValid: ve,
    isMonthValid: pe
  };
}, ha = () => {
  const e2 = computed(() => (a, n) => a == null ? void 0 : a.includes(n)), t2 = computed(() => (a, n) => a.count ? a.solo ? true : n === 0 : true), r = computed(() => (a, n) => a.count ? a.solo ? true : n === a.count - 1 : true);
  return { hideNavigationButtons: e2, showLeftIcon: t2, showRightIcon: r };
}, mo = (e2, t2, r) => {
  const a = ref(0), n = reactive({
    [_t.timePicker]: !e2.enableTimePicker || e2.timePicker || e2.monthPicker,
    [_t.calendar]: false,
    [_t.header]: false
  }), u = computed(() => e2.monthPicker || e2.timePicker), c = (O) => {
    var m;
    if ((m = e2.flow) != null && m.length) {
      if (!O && u.value) return f();
      n[O] = true, Object.keys(n).filter((P) => !n[P]).length || f();
    }
  }, p = () => {
    var O, m;
    (O = e2.flow) != null && O.length && a.value !== -1 && (a.value += 1, t2("flow-step", a.value), f()), ((m = e2.flow) == null ? void 0 : m.length) === a.value && nextTick().then(() => d());
  }, d = () => {
    a.value = -1;
  }, Y = (O, m, ...P) => {
    var F, L;
    e2.flow[a.value] === O && r.value && ((L = (F = r.value)[m]) == null || L.call(F, ...P));
  }, f = (O = 0) => {
    O && (a.value += O), Y(qe.month, "toggleMonthPicker", true), Y(qe.year, "toggleYearPicker", true), Y(qe.calendar, "toggleTimePicker", false, true), Y(qe.time, "toggleTimePicker", true, true);
    const m = e2.flow[a.value];
    (m === qe.hours || m === qe.minutes || m === qe.seconds) && Y(m, "toggleTimePicker", true, true, m);
  };
  return { childMount: c, updateFlowStep: p, resetFlow: d, handleFlow: f, flowStep: a };
}, po = {
  key: 1,
  class: "dp__input_wrap"
}, yo = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid"], go = {
  key: 2,
  class: "dp--clear-btn"
}, ho = ["aria-label"], bo = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: false },
    inputValue: { type: String, default: "" },
    ...pa
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur",
    "text-input"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, {
      defaultedTextInput: u,
      defaultedAriaLabels: c,
      defaultedInline: p,
      defaultedConfig: d,
      defaultedRange: Y,
      defaultedMultiDates: f,
      defaultedUI: O,
      getDefaultPattern: m,
      getDefaultStartTime: P
    } = Ye(n), { checkMinMaxRange: F } = Pt(n), L = ref(), _ = ref(null), h2 = ref(false), R = ref(false), b = computed(
      () => ({
        dp__pointer: !n.disabled && !n.readonly && !u.value.enabled,
        dp__disabled: n.disabled,
        dp__input_readonly: !u.value.enabled,
        dp__input: true,
        dp__input_icon_pad: !n.hideInputIcon,
        dp__input_valid: typeof n.state == "boolean" ? n.state : false,
        dp__input_invalid: typeof n.state == "boolean" ? !n.state : false,
        dp__input_focus: h2.value || n.isMenuOpen,
        dp__input_reg: !u.value.enabled,
        ...O.value.input ?? {}
      })
    ), j = () => {
      a("set-input-date", null), n.clearable && n.autoApply && (a("set-empty-date"), L.value = null);
    }, z = (A) => {
      const ie = P();
      return _l(
        A,
        u.value.format ?? m(),
        ie ?? En({}, n.enableSeconds),
        n.inputValue,
        R.value,
        n.formatLocale
      );
    }, ae = (A) => {
      const { rangeSeparator: ie } = u.value, [i, W] = A.split(`${ie}`);
      if (i) {
        const se = z(i.trim()), T = W ? z(W.trim()) : void 0;
        if (isAfter(se, T)) return;
        const re = se && T ? [se, T] : [se];
        F(T, re, 0) && (L.value = se ? re : null);
      }
    }, H = () => {
      R.value = true;
    }, D = (A) => {
      if (Y.value.enabled)
        ae(A);
      else if (f.value.enabled) {
        const ie = A.split(";");
        L.value = ie.map((i) => z(i.trim())).filter((i) => i);
      } else
        L.value = z(A);
    }, Q = (A) => {
      var i;
      const ie = typeof A == "string" ? A : (i = A.target) == null ? void 0 : i.value;
      ie !== "" ? (u.value.openMenu && !n.isMenuOpen && a("open"), D(ie), a("set-input-date", L.value)) : j(), R.value = false, a("update:input-value", ie), a("text-input", A, L.value);
    }, B = (A) => {
      u.value.enabled ? (D(A.target.value), u.value.enterSubmit && za(L.value) && n.inputValue !== "" ? (a("set-input-date", L.value, true), L.value = null) : u.value.enterSubmit && n.inputValue === "" && (L.value = null, a("clear"))) : pe(A);
    }, q = (A, ie) => {
      u.value.enabled && u.value.tabSubmit && !ie && D(A.target.value), u.value.tabSubmit && za(L.value) && n.inputValue !== "" ? (a("set-input-date", L.value, true, true), L.value = null) : u.value.tabSubmit && n.inputValue === "" && (L.value = null, a("clear", true));
    }, ve = () => {
      h2.value = true, a("focus"), nextTick().then(() => {
        var A;
        u.value.enabled && u.value.selectOnFocus && ((A = _.value) == null || A.select());
      });
    }, pe = (A) => {
      if ($t(A, d.value, true), u.value.enabled && u.value.openMenu && !p.value.input) {
        if (u.value.openMenu === "open" && !n.isMenuOpen) return a("open");
        if (u.value.openMenu === "toggle") return a("toggle");
      } else u.value.enabled || a("toggle");
    }, v2 = () => {
      a("real-blur"), h2.value = false, (!n.isMenuOpen || p.value.enabled && p.value.input) && a("blur"), n.autoApply && u.value.enabled && L.value && !n.isMenuOpen && (a("set-input-date", L.value), a("select-date"), L.value = null);
    }, N = (A) => {
      $t(A, d.value, true), a("clear");
    }, ee = () => {
      a("close");
    }, y = (A) => {
      if (A.key === "Tab" && q(A), A.key === "Enter" && B(A), A.key === "Escape" && u.value.escClose && ee(), !u.value.enabled) {
        if (A.code === "Tab") return;
        A.preventDefault();
      }
    }, U = () => {
      var A;
      (A = _.value) == null || A.focus({ preventScroll: true });
    }, S = (A) => {
      L.value = A;
    }, Z = (A) => {
      A.key === Oe.tab && q(A, true);
    };
    return t2({
      focusInput: U,
      setParsedDate: S
    }), (A, ie) => {
      var i, W, se;
      return openBlock(), createElementBlock("div", { onClick: pe }, [
        A.$slots.trigger && !A.$slots["dp-input"] && !unref(p).enabled ? renderSlot(A.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
        !A.$slots.trigger && (!unref(p).enabled || unref(p).input) ? (openBlock(), createElementBlock("div", po, [
          A.$slots["dp-input"] && !A.$slots.trigger && (!unref(p).enabled || unref(p).enabled && unref(p).input) ? renderSlot(A.$slots, "dp-input", {
            key: 0,
            value: e2.inputValue,
            isMenuOpen: e2.isMenuOpen,
            onInput: Q,
            onEnter: B,
            onTab: q,
            onClear: N,
            onBlur: v2,
            onKeypress: y,
            onPaste: H,
            onFocus: ve,
            openMenu: () => A.$emit("open"),
            closeMenu: () => A.$emit("close"),
            toggleMenu: () => A.$emit("toggle")
          }) : createCommentVNode("", true),
          A.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", {
            key: 1,
            id: A.uid ? `dp-input-${A.uid}` : void 0,
            ref_key: "inputRef",
            ref: _,
            "data-test-id": "dp-input",
            name: A.name,
            class: normalizeClass(b.value),
            inputmode: unref(u).enabled ? "text" : "none",
            placeholder: A.placeholder,
            disabled: A.disabled,
            readonly: A.readonly,
            required: A.required,
            value: e2.inputValue,
            autocomplete: A.autocomplete,
            "aria-label": (i = unref(c)) == null ? void 0 : i.input,
            "aria-disabled": A.disabled || void 0,
            "aria-invalid": A.state === false ? true : void 0,
            onInput: Q,
            onBlur: v2,
            onFocus: ve,
            onKeypress: y,
            onKeydown: ie[0] || (ie[0] = (T) => y(T)),
            onPaste: H
          }, null, 42, yo)),
          createBaseVNode("div", {
            onClick: ie[3] || (ie[3] = (T) => a("toggle"))
          }, [
            A.$slots["input-icon"] && !A.hideInputIcon ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: ie[1] || (ie[1] = (T) => a("toggle"))
            }, [
              renderSlot(A.$slots, "input-icon")
            ])) : createCommentVNode("", true),
            !A.$slots["input-icon"] && !A.hideInputIcon && !A.$slots["dp-input"] ? (openBlock(), createBlock(unref(Gt), {
              key: 1,
              "aria-label": (W = unref(c)) == null ? void 0 : W.calendarIcon,
              class: "dp__input_icon dp__input_icons",
              onClick: ie[2] || (ie[2] = (T) => a("toggle"))
            }, null, 8, ["aria-label"])) : createCommentVNode("", true)
          ]),
          A.$slots["clear-icon"] && (A.alwaysClearable || e2.inputValue && A.clearable && !A.disabled && !A.readonly) ? (openBlock(), createElementBlock("span", go, [
            renderSlot(A.$slots, "clear-icon", { clear: N })
          ])) : createCommentVNode("", true),
          !A.$slots["clear-icon"] && (A.alwaysClearable || A.clearable && e2.inputValue && !A.disabled && !A.readonly) ? (openBlock(), createElementBlock("button", {
            key: 3,
            "aria-label": (se = unref(c)) == null ? void 0 : se.clearInput,
            class: "dp--clear-btn",
            type: "button",
            onKeydown: ie[4] || (ie[4] = (T) => unref(xe)(T, () => N(T), true, Z)),
            onClick: ie[5] || (ie[5] = withModifiers((T) => N(T), ["prevent"]))
          }, [
            createVNode(unref(Tn), {
              class: "dp__input_icons",
              "data-test-id": "clear-icon"
            })
          ], 40, ho)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    };
  }
}), ko = typeof window < "u" ? window : void 0, Ea = () => {
}, wo = (e2) => getCurrentScope() ? (onScopeDispose(e2), true) : false, Do = (e2, t2, r, a) => {
  if (!e2) return Ea;
  let n = Ea;
  const u = watch(
    () => unref(e2),
    (p) => {
      n(), p && (p.removeEventListener(t2, r), p.addEventListener(t2, r, a), n = () => {
        p.removeEventListener(t2, r, a), n = Ea;
      });
    },
    { immediate: true, flush: "post" }
  ), c = () => {
    u(), n();
  };
  return wo(c), c;
}, Mo = (e2, t2, r, a = {}) => {
  const { window: n = ko, event: u = "pointerdown" } = a;
  return n ? Do(n, u, (p) => {
    const d = He(e2), Y = He(t2);
    !d || !Y || d === p.target || p.composedPath().includes(d) || p.composedPath().includes(Y) || r(p);
  }, { passive: true }) : void 0;
}, $o = ["data-dp-mobile"], Ao = /* @__PURE__ */ defineComponent({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...pa
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "date-update",
    "invalid-date",
    "overlay-toggle",
    "text-input"
  ],
  setup(e2, { expose: t2, emit: r }) {
    const a = r, n = e2, u = useSlots(), c = ref(false), p = toRef(n, "modelValue"), d = toRef(n, "timezone"), Y = ref(null), f = ref(null), O = ref(null), m = ref(false), P = ref(null), F = ref(false), L = ref(false), _ = ref(false), h2 = ref(false), { setMenuFocused: R, setShiftKey: b } = zn(), { clearArrowNav: j } = St(), { validateDate: z, isValidTime: ae } = Pt(n), {
      defaultedTransitions: H,
      defaultedTextInput: D,
      defaultedInline: Q,
      defaultedConfig: B,
      defaultedRange: q,
      defaultedMultiDates: ve
    } = Ye(n), { menuTransition: pe, showTransition: v2 } = na(H), { isMobile: N } = Gn(B), ee = getCurrentInstance();
    onMounted(() => {
      re(n.modelValue), nextTick().then(() => {
        if (!Q.value.enabled) {
          const C = i(P.value);
          C == null || C.addEventListener("scroll", fe), window == null || window.addEventListener("resize", I);
        }
      }), Q.value.enabled && (c.value = true), window == null || window.addEventListener("keyup", $e), window == null || window.addEventListener("keydown", be);
    }), onUnmounted(() => {
      if (!Q.value.enabled) {
        const C = i(P.value);
        C == null || C.removeEventListener("scroll", fe), window == null || window.removeEventListener("resize", I);
      }
      window == null || window.removeEventListener("keyup", $e), window == null || window.removeEventListener("keydown", be);
    });
    const y = at(u, "all", n.presetDates), U = at(u, "input");
    watch(
      [p, d],
      () => {
        re(p.value);
      },
      { deep: true }
    );
    const { openOnTop: S, menuStyle: Z, xCorrect: A, setMenuPosition: ie, getScrollableParent: i, shadowRender: W } = io({
      menuRef: Y,
      menuRefInner: f,
      inputRef: O,
      pickerWrapperRef: P,
      inline: Q,
      emit: a,
      props: n,
      slots: u
    }), {
      inputValue: se,
      internalModelValue: T,
      parseExternalModelValue: re,
      emitModelValue: l,
      formatInputValue: w,
      checkBeforeEmit: oe
    } = lr(a, n, m), M = computed(
      () => ({
        dp__main: true,
        dp__theme_dark: n.dark,
        dp__theme_light: !n.dark,
        dp__flex_display: Q.value.enabled,
        "dp--flex-display-collapsed": _.value,
        dp__flex_display_with_input: Q.value.input
      })
    ), he = computed(() => n.dark ? "dp__theme_dark" : "dp__theme_light"), ke = computed(() => n.teleport ? {
      to: typeof n.teleport == "boolean" ? "body" : n.teleport,
      disabled: !n.teleport || Q.value.enabled
    } : {}), le = computed(() => ({ class: "dp__outer_menu_wrap" })), o = computed(() => Q.value.enabled && (n.timePicker || n.monthPicker || n.yearPicker || n.quarterPicker)), E = () => {
      var C, te;
      return ((te = (C = O.value) == null ? void 0 : C.$el) == null ? void 0 : te.getBoundingClientRect()) ?? { width: 0, left: 0, right: 0 };
    }, fe = () => {
      c.value && (B.value.closeOnScroll ? de() : ie());
    }, I = () => {
      var te;
      c.value && ie();
      const C = ((te = f.value) == null ? void 0 : te.$el.getBoundingClientRect().width) ?? 0;
      _.value = document.body.offsetWidth <= C;
    }, $e = (C) => {
      C.key === "Tab" && !Q.value.enabled && !n.teleport && B.value.tabOutClosesMenu && (P.value.contains(document.activeElement) || de()), L.value = C.shiftKey;
    }, be = (C) => {
      L.value = C.shiftKey;
    }, Pe2 = () => {
      !n.disabled && !n.readonly && (W(ee, gn, n), ie(false), c.value = true, c.value && a("open"), c.value || rt(), re(n.modelValue));
    }, Ee = () => {
      var C, te;
      se.value = "", rt(), (C = f.value) == null || C.onValueCleared(), (te = O.value) == null || te.setParsedDate(null), a("update:model-value", null), a("update:model-timezone-value", null), a("cleared"), B.value.closeOnClearValue && de();
    }, Be = () => {
      const C = T.value;
      return !C || !Array.isArray(C) && z(C) ? true : Array.isArray(C) ? ve.value.enabled || C.length === 2 && z(C[0]) && z(C[1]) ? true : q.value.partialRange && !n.timePicker ? z(C[0]) : false : false;
    }, k = () => {
      oe() && Be() ? (l(), de()) : a("invalid-select", T.value);
    }, x = (C) => {
      Ie(), l(), B.value.closeOnAutoApply && !C && de();
    }, Ie = () => {
      O.value && D.value.enabled && O.value.setParsedDate(T.value);
    }, Ue = (C = false) => {
      n.autoApply && ae(T.value) && Be() && (q.value.enabled && Array.isArray(T.value) ? (q.value.partialRange || T.value.length === 2) && x(C) : x(C));
    }, rt = () => {
      D.value.enabled || (T.value = null);
    }, de = (C = false) => {
      var te, ce;
      C && T.value && B.value.setDateOnMenuClose && k(), Q.value.enabled || (c.value && (c.value = false, A.value = false, R(false), b(false), j(), a("closed"), se.value && re(p.value)), rt(), a("blur"), (ce = (te = f.value) == null ? void 0 : te.$el) == null || ce.remove());
    }, Rt = (C, te, ce = false) => {
      if (!C) {
        T.value = null;
        return;
      }
      const yt = Array.isArray(C) ? !C.some((Ct) => !z(Ct)) : z(C), vt = ae(C);
      yt && vt ? (h2.value = true, T.value = C, te ? (F.value = ce, k(), a("text-submit")) : n.autoApply && Ue(), nextTick().then(() => {
        h2.value = false;
      })) : a("invalid-date", C);
    }, ft = () => {
      n.autoApply && ae(T.value) && l(), Ie();
    }, ra = () => c.value ? de() : Pe2(), ba = (C) => {
      T.value = C;
    }, ka = () => {
      D.value.enabled && (m.value = true, w()), a("focus");
    }, wa = () => {
      if (D.value.enabled && (m.value = false, re(n.modelValue), F.value)) {
        const C = Cl(P.value, L.value);
        C == null || C.focus();
      }
      a("blur");
    }, Da = (C) => {
      f.value && f.value.updateMonthYear(0, {
        month: un(C.month),
        year: un(C.year)
      });
    }, Ma = (C) => {
      re(C ?? n.modelValue);
    }, tn = (C, te) => {
      var ce;
      (ce = f.value) == null || ce.switchView(C, te);
    }, g = (C, te) => B.value.onClickOutside ? B.value.onClickOutside(C, te) : de(true), ne = (C = 0) => {
      var te;
      (te = f.value) == null || te.handleFlow(C);
    }, me = () => Y;
    return Mo(
      Y,
      O,
      (C) => g(Be, C)
    ), t2({
      closeMenu: de,
      selectDate: k,
      clearValue: Ee,
      openMenu: Pe2,
      onScroll: fe,
      formatInputValue: w,
      // exposed for testing purposes
      updateInternalModelValue: ba,
      // modify internal modelValue
      setMonthYear: Da,
      parseModel: Ma,
      switchView: tn,
      toggleMenu: ra,
      handleFlow: ne,
      getDpWrapMenuRef: me
    }), (C, te) => (openBlock(), createElementBlock("div", {
      ref_key: "pickerWrapperRef",
      ref: P,
      class: normalizeClass(M.value),
      "data-datepicker-instance": "",
      "data-dp-mobile": unref(N)
    }, [
      createVNode(bo, mergeProps({
        ref_key: "inputRef",
        ref: O,
        "input-value": unref(se),
        "onUpdate:inputValue": te[0] || (te[0] = (ce) => isRef(se) ? se.value = ce : null),
        "is-menu-open": c.value
      }, C.$props, {
        onClear: Ee,
        onOpen: Pe2,
        onSetInputDate: Rt,
        onSetEmptyDate: unref(l),
        onSelectDate: k,
        onToggle: ra,
        onClose: de,
        onFocus: ka,
        onBlur: wa,
        onRealBlur: te[1] || (te[1] = (ce) => m.value = false),
        onTextInput: te[2] || (te[2] = (ce) => C.$emit("text-input", ce))
      }), createSlots({ _: 2 }, [
        renderList(unref(U), (ce, yt) => ({
          name: ce,
          fn: withCtx((vt) => [
            renderSlot(C.$slots, ce, normalizeProps(guardReactiveProps(vt)))
          ])
        }))
      ]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]),
      (openBlock(), createBlock(resolveDynamicComponent(C.teleport ? Teleport : "div"), normalizeProps(guardReactiveProps(ke.value)), {
        default: withCtx(() => [
          createVNode(Transition, {
            name: unref(pe)(unref(S)),
            css: unref(v2) && !unref(Q).enabled
          }, {
            default: withCtx(() => [
              c.value ? (openBlock(), createElementBlock("div", mergeProps({
                key: 0,
                ref_key: "dpWrapMenuRef",
                ref: Y
              }, le.value, {
                class: { "dp--menu-wrapper": !unref(Q).enabled },
                style: unref(Q).enabled ? void 0 : unref(Z)
              }), [
                createVNode(gn, mergeProps({
                  ref_key: "dpMenuRef",
                  ref: f
                }, C.$props, {
                  "internal-model-value": unref(T),
                  "onUpdate:internalModelValue": te[3] || (te[3] = (ce) => isRef(T) ? T.value = ce : null),
                  class: { [he.value]: true, "dp--menu-wrapper": C.teleport },
                  "open-on-top": unref(S),
                  "no-overlay-focus": o.value,
                  collapse: _.value,
                  "get-input-rect": E,
                  "is-text-input-date": h2.value,
                  onClosePicker: de,
                  onSelectDate: k,
                  onAutoApply: Ue,
                  onTimeUpdate: ft,
                  onFlowStep: te[4] || (te[4] = (ce) => C.$emit("flow-step", ce)),
                  onUpdateMonthYear: te[5] || (te[5] = (ce) => C.$emit("update-month-year", ce)),
                  onInvalidSelect: te[6] || (te[6] = (ce) => C.$emit("invalid-select", unref(T))),
                  onAutoApplyInvalid: te[7] || (te[7] = (ce) => C.$emit("invalid-select", ce)),
                  onInvalidFixedRange: te[8] || (te[8] = (ce) => C.$emit("invalid-fixed-range", ce)),
                  onRecalculatePosition: unref(ie),
                  onTooltipOpen: te[9] || (te[9] = (ce) => C.$emit("tooltip-open", ce)),
                  onTooltipClose: te[10] || (te[10] = (ce) => C.$emit("tooltip-close", ce)),
                  onTimePickerOpen: te[11] || (te[11] = (ce) => C.$emit("time-picker-open", ce)),
                  onTimePickerClose: te[12] || (te[12] = (ce) => C.$emit("time-picker-close", ce)),
                  onAmPmChange: te[13] || (te[13] = (ce) => C.$emit("am-pm-change", ce)),
                  onRangeStart: te[14] || (te[14] = (ce) => C.$emit("range-start", ce)),
                  onRangeEnd: te[15] || (te[15] = (ce) => C.$emit("range-end", ce)),
                  onDateUpdate: te[16] || (te[16] = (ce) => C.$emit("date-update", ce)),
                  onInvalidDate: te[17] || (te[17] = (ce) => C.$emit("invalid-date", ce)),
                  onOverlayToggle: te[18] || (te[18] = (ce) => C.$emit("overlay-toggle", ce)),
                  onMenuBlur: te[19] || (te[19] = (ce) => C.$emit("blur"))
                }), createSlots({ _: 2 }, [
                  renderList(unref(y), (ce, yt) => ({
                    name: ce,
                    fn: withCtx((vt) => [
                      renderSlot(C.$slots, ce, normalizeProps(guardReactiveProps({ ...vt })))
                    ])
                  }))
                ]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "is-text-input-date", "onRecalculatePosition"])
              ], 16)) : createCommentVNode("", true)
            ]),
            _: 3
          }, 8, ["name", "css"])
        ]),
        _: 3
      }, 16))
    ], 10, $o));
  }
}), Qn = /* @__PURE__ */ (() => {
  const e2 = Ao;
  return e2.install = (t2) => {
    t2.component("Vue3DatePicker", e2);
  }, e2;
})(), To = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Qn
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(To).forEach(([e2, t2]) => {
  e2 !== "default" && (Qn[e2] = t2);
});
class Binary {
  /**
   * Creates a binary value from the given string.
   *
   * @param {String} aString        The binary value string
   * @return {Binary}               The binary value instance
   */
  static fromString(aString) {
    return new Binary(aString);
  }
  /**
   * Creates a new ICAL.Binary instance
   *
   * @param {String} aValue     The binary data for this value
   */
  constructor(aValue) {
    this.value = aValue;
  }
  /**
   * The type name, to be used in the jCal object.
   * @default "binary"
   * @constant
   */
  icaltype = "binary";
  /**
   * Base64 decode the current value
   *
   * @return {String}         The base64-decoded value
   */
  decodeValue() {
    return this._b64_decode(this.value);
  }
  /**
   * Encodes the passed parameter with base64 and sets the internal
   * value to the result.
   *
   * @param {String} aValue      The raw binary value to encode
   */
  setEncodedValue(aValue) {
    this.value = this._b64_encode(aValue);
  }
  _b64_encode(data) {
    let b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc = "", tmp_arr = [];
    if (!data) {
      return data;
    }
    do {
      o1 = data.charCodeAt(i++);
      o2 = data.charCodeAt(i++);
      o3 = data.charCodeAt(i++);
      bits = o1 << 16 | o2 << 8 | o3;
      h1 = bits >> 18 & 63;
      h2 = bits >> 12 & 63;
      h3 = bits >> 6 & 63;
      h4 = bits & 63;
      tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);
    enc = tmp_arr.join("");
    let r = data.length % 3;
    return (r ? enc.slice(0, r - 3) : enc) + "===".slice(r || 3);
  }
  _b64_decode(data) {
    let b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, dec = "", tmp_arr = [];
    if (!data) {
      return data;
    }
    data += "";
    do {
      h1 = b64.indexOf(data.charAt(i++));
      h2 = b64.indexOf(data.charAt(i++));
      h3 = b64.indexOf(data.charAt(i++));
      h4 = b64.indexOf(data.charAt(i++));
      bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;
      o1 = bits >> 16 & 255;
      o2 = bits >> 8 & 255;
      o3 = bits & 255;
      if (h3 == 64) {
        tmp_arr[ac++] = String.fromCharCode(o1);
      } else if (h4 == 64) {
        tmp_arr[ac++] = String.fromCharCode(o1, o2);
      } else {
        tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
      }
    } while (i < data.length);
    dec = tmp_arr.join("");
    return dec;
  }
  /**
   * The string representation of this value
   * @return {String}
   */
  toString() {
    return this.value;
  }
}
const DURATION_LETTERS = /([PDWHMTS]{1,1})/;
const DATA_PROPS_TO_COPY = ["weeks", "days", "hours", "minutes", "seconds", "isNegative"];
class Duration {
  /**
   * Returns a new ICAL.Duration instance from the passed seconds value.
   *
   * @param {Number} aSeconds       The seconds to create the instance from
   * @return {Duration}             The newly created duration instance
   */
  static fromSeconds(aSeconds) {
    return new Duration().fromSeconds(aSeconds);
  }
  /**
   * Checks if the given string is an iCalendar duration value.
   *
   * @param {String} value      The raw ical value
   * @return {Boolean}          True, if the given value is of the
   *                              duration ical type
   */
  static isValueString(string) {
    return string[0] === "P" || string[1] === "P";
  }
  /**
   * Creates a new {@link ICAL.Duration} instance from the passed string.
   *
   * @param {String} aStr       The string to parse
   * @return {Duration}         The created duration instance
   */
  static fromString(aStr) {
    let pos = 0;
    let dict = /* @__PURE__ */ Object.create(null);
    let chunks = 0;
    while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
      let type = aStr[pos];
      let numeric2 = aStr.slice(0, Math.max(0, pos));
      aStr = aStr.slice(pos + 1);
      chunks += parseDurationChunk(type, numeric2, dict);
    }
    if (chunks < 2) {
      throw new Error(
        'invalid duration value: Not enough duration components in "' + aStr + '"'
      );
    }
    return new Duration(dict);
  }
  /**
   * Creates a new ICAL.Duration instance from the given data object.
   *
   * @param {Object} aData                An object with members of the duration
   * @param {Number=} aData.weeks         Duration in weeks
   * @param {Number=} aData.days          Duration in days
   * @param {Number=} aData.hours         Duration in hours
   * @param {Number=} aData.minutes       Duration in minutes
   * @param {Number=} aData.seconds       Duration in seconds
   * @param {Boolean=} aData.isNegative   If true, the duration is negative
   * @return {Duration}                   The createad duration instance
   */
  static fromData(aData) {
    return new Duration(aData);
  }
  /**
   * Creates a new ICAL.Duration instance.
   *
   * @param {Object} data                 An object with members of the duration
   * @param {Number=} data.weeks          Duration in weeks
   * @param {Number=} data.days           Duration in days
   * @param {Number=} data.hours          Duration in hours
   * @param {Number=} data.minutes        Duration in minutes
   * @param {Number=} data.seconds        Duration in seconds
   * @param {Boolean=} data.isNegative    If true, the duration is negative
   */
  constructor(data) {
    this.wrappedJSObject = this;
    this.fromData(data);
  }
  /**
   * The weeks in this duration
   * @type {Number}
   * @default 0
   */
  weeks = 0;
  /**
   * The days in this duration
   * @type {Number}
   * @default 0
   */
  days = 0;
  /**
   * The days in this duration
   * @type {Number}
   * @default 0
   */
  hours = 0;
  /**
   * The minutes in this duration
   * @type {Number}
   * @default 0
   */
  minutes = 0;
  /**
   * The seconds in this duration
   * @type {Number}
   * @default 0
   */
  seconds = 0;
  /**
   * The seconds in this duration
   * @type {Boolean}
   * @default false
   */
  isNegative = false;
  /**
   * The class identifier.
   * @constant
   * @type {String}
   * @default "icalduration"
   */
  icalclass = "icalduration";
  /**
   * The type name, to be used in the jCal object.
   * @constant
   * @type {String}
   * @default "duration"
   */
  icaltype = "duration";
  /**
   * Returns a clone of the duration object.
   *
   * @return {Duration}      The cloned object
   */
  clone() {
    return Duration.fromData(this);
  }
  /**
   * The duration value expressed as a number of seconds.
   *
   * @return {Number}             The duration value in seconds
   */
  toSeconds() {
    let seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;
    return this.isNegative ? -seconds : seconds;
  }
  /**
   * Reads the passed seconds value into this duration object. Afterwards,
   * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up
   * accordingly.
   *
   * @param {Number} aSeconds     The duration value in seconds
   * @return {Duration}           Returns this instance
   */
  fromSeconds(aSeconds) {
    let secs = Math.abs(aSeconds);
    this.isNegative = aSeconds < 0;
    this.days = trunc(secs / 86400);
    if (this.days % 7 == 0) {
      this.weeks = this.days / 7;
      this.days = 0;
    } else {
      this.weeks = 0;
    }
    secs -= (this.days + 7 * this.weeks) * 86400;
    this.hours = trunc(secs / 3600);
    secs -= this.hours * 3600;
    this.minutes = trunc(secs / 60);
    secs -= this.minutes * 60;
    this.seconds = secs;
    return this;
  }
  /**
   * Sets up the current instance using members from the passed data object.
   *
   * @param {Object} aData                An object with members of the duration
   * @param {Number=} aData.weeks         Duration in weeks
   * @param {Number=} aData.days          Duration in days
   * @param {Number=} aData.hours         Duration in hours
   * @param {Number=} aData.minutes       Duration in minutes
   * @param {Number=} aData.seconds       Duration in seconds
   * @param {Boolean=} aData.isNegative   If true, the duration is negative
   */
  fromData(aData) {
    for (let prop of DATA_PROPS_TO_COPY) {
      if (aData && prop in aData) {
        this[prop] = aData[prop];
      } else {
        this[prop] = 0;
      }
    }
  }
  /**
   * Resets the duration instance to the default values, i.e. PT0S
   */
  reset() {
    this.isNegative = false;
    this.weeks = 0;
    this.days = 0;
    this.hours = 0;
    this.minutes = 0;
    this.seconds = 0;
  }
  /**
   * Compares the duration instance with another one.
   *
   * @param {Duration} aOther             The instance to compare with
   * @return {Number}                     -1, 0 or 1 for less/equal/greater
   */
  compare(aOther) {
    let thisSeconds = this.toSeconds();
    let otherSeconds = aOther.toSeconds();
    return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
  }
  /**
   * Normalizes the duration instance. For example, a duration with a value
   * of 61 seconds will be normalized to 1 minute and 1 second.
   */
  normalize() {
    this.fromSeconds(this.toSeconds());
  }
  /**
   * The string representation of this duration.
   * @return {String}
   */
  toString() {
    if (this.toSeconds() == 0) {
      return "PT0S";
    } else {
      let str = "";
      if (this.isNegative) str += "-";
      str += "P";
      let hasWeeks = false;
      if (this.weeks) {
        if (this.days || this.hours || this.minutes || this.seconds) {
          str += this.weeks * 7 + this.days + "D";
        } else {
          str += this.weeks + "W";
          hasWeeks = true;
        }
      } else if (this.days) {
        str += this.days + "D";
      }
      if (!hasWeeks) {
        if (this.hours || this.minutes || this.seconds) {
          str += "T";
          if (this.hours) {
            str += this.hours + "H";
          }
          if (this.minutes) {
            str += this.minutes + "M";
          }
          if (this.seconds) {
            str += this.seconds + "S";
          }
        }
      }
      return str;
    }
  }
  /**
   * The iCalendar string representation of this duration.
   * @return {String}
   */
  toICALString() {
    return this.toString();
  }
}
function parseDurationChunk(letter, number, object) {
  let type;
  switch (letter) {
    case "P":
      if (number && number === "-") {
        object.isNegative = true;
      } else {
        object.isNegative = false;
      }
      break;
    case "D":
      type = "days";
      break;
    case "W":
      type = "weeks";
      break;
    case "H":
      type = "hours";
      break;
    case "M":
      type = "minutes";
      break;
    case "S":
      type = "seconds";
      break;
    default:
      return 0;
  }
  if (type) {
    if (!number && number !== 0) {
      throw new Error(
        'invalid duration value: Missing number before "' + letter + '"'
      );
    }
    let num = parseInt(number, 10);
    if (isStrictlyNaN(num)) {
      throw new Error(
        'invalid duration value: Invalid number "' + number + '" before "' + letter + '"'
      );
    }
    object[type] = num;
  }
  return 1;
}
class Period {
  /**
   * Creates a new {@link ICAL.Period} instance from the passed string.
   *
   * @param {String} str            The string to parse
   * @param {Property} prop         The property this period will be on
   * @return {Period}               The created period instance
   */
  static fromString(str, prop) {
    let parts = str.split("/");
    if (parts.length !== 2) {
      throw new Error(
        'Invalid string value: "' + str + '" must contain a "/" char.'
      );
    }
    let options = {
      start: Time.fromDateTimeString(parts[0], prop)
    };
    let end = parts[1];
    if (Duration.isValueString(end)) {
      options.duration = Duration.fromString(end);
    } else {
      options.end = Time.fromDateTimeString(end, prop);
    }
    return new Period(options);
  }
  /**
   * Creates a new {@link ICAL.Period} instance from the given data object.
   * The passed data object cannot contain both and end date and a duration.
   *
   * @param {Object} aData                  An object with members of the period
   * @param {Time=} aData.start             The start of the period
   * @param {Time=} aData.end               The end of the period
   * @param {Duration=} aData.duration      The duration of the period
   * @return {Period}                       The period instance
   */
  static fromData(aData) {
    return new Period(aData);
  }
  /**
   * Returns a new period instance from the given jCal data array. The first
   * member is always the start date string, the second member is either a
   * duration or end date string.
   *
   * @param {jCalComponent} aData           The jCal data array
   * @param {Property} aProp                The property this jCal data is on
   * @param {Boolean} aLenient              If true, data value can be both date and date-time
   * @return {Period}                       The period instance
   */
  static fromJSON(aData, aProp, aLenient) {
    function fromDateOrDateTimeString(aValue, dateProp) {
      if (aLenient) {
        return Time.fromString(aValue, dateProp);
      } else {
        return Time.fromDateTimeString(aValue, dateProp);
      }
    }
    if (Duration.isValueString(aData[1])) {
      return Period.fromData({
        start: fromDateOrDateTimeString(aData[0], aProp),
        duration: Duration.fromString(aData[1])
      });
    } else {
      return Period.fromData({
        start: fromDateOrDateTimeString(aData[0], aProp),
        end: fromDateOrDateTimeString(aData[1], aProp)
      });
    }
  }
  /**
   * Creates a new ICAL.Period instance. The passed data object cannot contain both and end date and
   * a duration.
   *
   * @param {Object} aData                  An object with members of the period
   * @param {Time=} aData.start             The start of the period
   * @param {Time=} aData.end               The end of the period
   * @param {Duration=} aData.duration      The duration of the period
   */
  constructor(aData) {
    this.wrappedJSObject = this;
    if (aData && "start" in aData) {
      if (aData.start && !(aData.start instanceof Time)) {
        throw new TypeError(".start must be an instance of ICAL.Time");
      }
      this.start = aData.start;
    }
    if (aData && aData.end && aData.duration) {
      throw new Error("cannot accept both end and duration");
    }
    if (aData && "end" in aData) {
      if (aData.end && !(aData.end instanceof Time)) {
        throw new TypeError(".end must be an instance of ICAL.Time");
      }
      this.end = aData.end;
    }
    if (aData && "duration" in aData) {
      if (aData.duration && !(aData.duration instanceof Duration)) {
        throw new TypeError(".duration must be an instance of ICAL.Duration");
      }
      this.duration = aData.duration;
    }
  }
  /**
   * The start of the period
   * @type {Time}
   */
  start = null;
  /**
   * The end of the period
   * @type {Time}
   */
  end = null;
  /**
   * The duration of the period
   * @type {Duration}
   */
  duration = null;
  /**
   * The class identifier.
   * @constant
   * @type {String}
   * @default "icalperiod"
   */
  icalclass = "icalperiod";
  /**
   * The type name, to be used in the jCal object.
   * @constant
   * @type {String}
   * @default "period"
   */
  icaltype = "period";
  /**
   * Returns a clone of the duration object.
   *
   * @return {Period}      The cloned object
   */
  clone() {
    return Period.fromData({
      start: this.start ? this.start.clone() : null,
      end: this.end ? this.end.clone() : null,
      duration: this.duration ? this.duration.clone() : null
    });
  }
  /**
   * Calculates the duration of the period, either directly or by subtracting
   * start from end date.
   *
   * @return {Duration}      The calculated duration
   */
  getDuration() {
    if (this.duration) {
      return this.duration;
    } else {
      return this.end.subtractDate(this.start);
    }
  }
  /**
   * Calculates the end date of the period, either directly or by adding
   * duration to start date.
   *
   * @return {Time}          The calculated end date
   */
  getEnd() {
    if (this.end) {
      return this.end;
    } else {
      let end = this.start.clone();
      end.addDuration(this.duration);
      return end;
    }
  }
  /**
   * Compare this period with a date or other period. To maintain the logic where a.compare(b)
   * returns 1 when a > b, this function will return 1 when the period is after the date, 0 when the
   * date is within the period, and -1 when the period is before the date. When comparing two
   * periods, as soon as they overlap in any way this will return 0.
   *
   * @param {Time|Period} dt    The date or other period to compare with
   */
  compare(dt2) {
    if (dt2.compare(this.start) < 0) {
      return 1;
    } else if (dt2.compare(this.getEnd()) > 0) {
      return -1;
    } else {
      return 0;
    }
  }
  /**
   * The string representation of this period.
   * @return {String}
   */
  toString() {
    return this.start + "/" + (this.end || this.duration);
  }
  /**
   * The jCal representation of this period type.
   * @return {Object}
   */
  toJSON() {
    return [this.start.toString(), (this.end || this.duration).toString()];
  }
  /**
   * The iCalendar string representation of this period.
   * @return {String}
   */
  toICALString() {
    return this.start.toICALString() + "/" + (this.end || this.duration).toICALString();
  }
}
class Time {
  static _dowCache = {};
  static _wnCache = {};
  /**
   * Returns the days in the given month
   *
   * @param {Number} month      The month to check
   * @param {Number} year       The year to check
   * @return {Number}           The number of days in the month
   */
  static daysInMonth(month, year) {
    let _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    let days = 30;
    if (month < 1 || month > 12) return days;
    days = _daysInMonth[month];
    if (month == 2) {
      days += Time.isLeapYear(year);
    }
    return days;
  }
  /**
   * Checks if the year is a leap year
   *
   * @param {Number} year       The year to check
   * @return {Boolean}          True, if the year is a leap year
   */
  static isLeapYear(year) {
    if (year <= 1752) {
      return year % 4 == 0;
    } else {
      return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
    }
  }
  /**
   * Create a new ICAL.Time from the day of year and year. The date is returned
   * in floating timezone.
   *
   * @param {Number} aDayOfYear     The day of year
   * @param {Number} aYear          The year to create the instance in
   * @return {Time}                 The created instance with the calculated date
   */
  static fromDayOfYear(aDayOfYear, aYear) {
    let year = aYear;
    let doy = aDayOfYear;
    let tt2 = new Time();
    tt2.auto_normalize = false;
    let is_leap = Time.isLeapYear(year) ? 1 : 0;
    if (doy < 1) {
      year--;
      is_leap = Time.isLeapYear(year) ? 1 : 0;
      doy += Time.daysInYearPassedMonth[is_leap][12];
      return Time.fromDayOfYear(doy, year);
    } else if (doy > Time.daysInYearPassedMonth[is_leap][12]) {
      is_leap = Time.isLeapYear(year) ? 1 : 0;
      doy -= Time.daysInYearPassedMonth[is_leap][12];
      year++;
      return Time.fromDayOfYear(doy, year);
    }
    tt2.year = year;
    tt2.isDate = true;
    for (let month = 11; month >= 0; month--) {
      if (doy > Time.daysInYearPassedMonth[is_leap][month]) {
        tt2.month = month + 1;
        tt2.day = doy - Time.daysInYearPassedMonth[is_leap][month];
        break;
      }
    }
    tt2.auto_normalize = true;
    return tt2;
  }
  /**
   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.
   *
   * @deprecated                Use {@link ICAL.Time.fromDateString} instead
   * @param {String} str        The string to create from
   * @return {Time}             The date/time instance
   */
  static fromStringv2(str) {
    return new Time({
      year: parseInt(str.slice(0, 4), 10),
      month: parseInt(str.slice(5, 7), 10),
      day: parseInt(str.slice(8, 10), 10),
      isDate: true
    });
  }
  /**
   * Returns a new ICAL.Time instance from a date string, e.g 2015-01-02.
   *
   * @param {String} aValue     The string to create from
   * @return {Time}             The date/time instance
   */
  static fromDateString(aValue) {
    return new Time({
      year: strictParseInt(aValue.slice(0, 4)),
      month: strictParseInt(aValue.slice(5, 7)),
      day: strictParseInt(aValue.slice(8, 10)),
      isDate: true
    });
  }
  /**
   * Returns a new ICAL.Time instance from a date-time string, e.g
   * 2015-01-02T03:04:05. If a property is specified, the timezone is set up
   * from the property's TZID parameter.
   *
   * @param {String} aValue         The string to create from
   * @param {Property=} prop        The property the date belongs to
   * @return {Time}                 The date/time instance
   */
  static fromDateTimeString(aValue, prop) {
    if (aValue.length < 19) {
      throw new Error(
        'invalid date-time value: "' + aValue + '"'
      );
    }
    let zone;
    let zoneId;
    if (aValue.slice(-1) === "Z") {
      zone = Timezone$1.utcTimezone;
    } else if (prop) {
      zoneId = prop.getParameter("tzid");
      if (prop.parent) {
        if (prop.parent.name === "standard" || prop.parent.name === "daylight") {
          zone = Timezone$1.localTimezone;
        } else if (zoneId) {
          zone = prop.parent.getTimeZoneByID(zoneId);
        }
      }
    }
    const timeData = {
      year: strictParseInt(aValue.slice(0, 4)),
      month: strictParseInt(aValue.slice(5, 7)),
      day: strictParseInt(aValue.slice(8, 10)),
      hour: strictParseInt(aValue.slice(11, 13)),
      minute: strictParseInt(aValue.slice(14, 16)),
      second: strictParseInt(aValue.slice(17, 19))
    };
    if (zoneId && !zone) {
      timeData.timezone = zoneId;
    }
    return new Time(timeData, zone);
  }
  /**
   * Returns a new ICAL.Time instance from a date or date-time string,
   *
   * @param {String} aValue         The string to create from
   * @param {Property=} prop        The property the date belongs to
   * @return {Time}                 The date/time instance
   */
  static fromString(aValue, aProperty) {
    if (aValue.length > 10) {
      return Time.fromDateTimeString(aValue, aProperty);
    } else {
      return Time.fromDateString(aValue);
    }
  }
  /**
   * Creates a new ICAL.Time instance from the given Javascript Date.
   *
   * @param {?Date} aDate             The Javascript Date to read, or null to reset
   * @param {Boolean} [useUTC=false]  If true, the UTC values of the date will be used
   */
  static fromJSDate(aDate, useUTC) {
    let tt2 = new Time();
    return tt2.fromJSDate(aDate, useUTC);
  }
  /**
   * Creates a new ICAL.Time instance from the the passed data object.
   *
   * @param {timeInit} aData          Time initialization
   * @param {Timezone=} aZone         Timezone this position occurs in
   */
  static fromData = function fromData(aData, aZone) {
    let t2 = new Time();
    return t2.fromData(aData, aZone);
  };
  /**
   * Creates a new ICAL.Time instance from the current moment.
   * The instance is “floating” - has no timezone relation.
   * To create an instance considering the time zone, call
   * ICAL.Time.fromJSDate(new Date(), true)
   * @return {Time}
   */
  static now() {
    return Time.fromJSDate(/* @__PURE__ */ new Date(), false);
  }
  /**
   * Returns the date on which ISO week number 1 starts.
   *
   * @see Time#weekNumber
   * @param {Number} aYear                  The year to search in
   * @param {weekDay=} aWeekStart           The week start weekday, used for calculation.
   * @return {Time}                         The date on which week number 1 starts
   */
  static weekOneStarts(aYear, aWeekStart) {
    let t2 = Time.fromData({
      year: aYear,
      month: 1,
      day: 1,
      isDate: true
    });
    let dow = t2.dayOfWeek();
    let wkst = aWeekStart || Time.DEFAULT_WEEK_START;
    if (dow > Time.THURSDAY) {
      t2.day += 7;
    }
    if (wkst > Time.THURSDAY) {
      t2.day -= 7;
    }
    t2.day -= dow - wkst;
    return t2;
  }
  /**
   * Get the dominical letter for the given year. Letters range from A - G for
   * common years, and AG to GF for leap years.
   *
   * @param {Number} yr           The year to retrieve the letter for
   * @return {String}             The dominical letter.
   */
  static getDominicalLetter(yr2) {
    let LTRS = "GFEDCBA";
    let dom = (yr2 + (yr2 / 4 | 0) + (yr2 / 400 | 0) - (yr2 / 100 | 0) - 1) % 7;
    let isLeap = Time.isLeapYear(yr2);
    if (isLeap) {
      return LTRS[(dom + 6) % 7] + LTRS[dom];
    } else {
      return LTRS[dom];
    }
  }
  static #epochTime = null;
  /**
   * January 1st, 1970 as an ICAL.Time.
   * @type {Time}
   * @constant
   * @instance
   */
  static get epochTime() {
    if (!this.#epochTime) {
      this.#epochTime = Time.fromData({
        year: 1970,
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        isDate: false,
        timezone: "Z"
      });
    }
    return this.#epochTime;
  }
  static _cmp_attr(a, b, attr) {
    if (a[attr] > b[attr]) return 1;
    if (a[attr] < b[attr]) return -1;
    return 0;
  }
  /**
   * The days that have passed in the year after a given month. The array has
   * two members, one being an array of passed days for non-leap years, the
   * other analog for leap years.
   * @example
   * var isLeapYear = ICAL.Time.isLeapYear(year);
   * var passedDays = ICAL.Time.daysInYearPassedMonth[isLeapYear][month];
   * @type {Array.<Array.<Number>>}
   */
  static daysInYearPassedMonth = [
    [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
    [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
  ];
  static SUNDAY = 1;
  static MONDAY = 2;
  static TUESDAY = 3;
  static WEDNESDAY = 4;
  static THURSDAY = 5;
  static FRIDAY = 6;
  static SATURDAY = 7;
  /**
   * The default weekday for the WKST part.
   * @constant
   * @default ICAL.Time.MONDAY
   */
  static DEFAULT_WEEK_START = 2;
  // MONDAY
  /**
   * Creates a new ICAL.Time instance.
   *
   * @param {timeInit} data           Time initialization
   * @param {Timezone} zone           timezone this position occurs in
   */
  constructor(data, zone) {
    this.wrappedJSObject = this;
    this._time = /* @__PURE__ */ Object.create(null);
    this._time.year = 0;
    this._time.month = 1;
    this._time.day = 1;
    this._time.hour = 0;
    this._time.minute = 0;
    this._time.second = 0;
    this._time.isDate = false;
    this.fromData(data, zone);
  }
  /**
   * The class identifier.
   * @constant
   * @type {String}
   * @default "icaltime"
   */
  icalclass = "icaltime";
  _cachedUnixTime = null;
  /**
   * The type name, to be used in the jCal object. This value may change and
   * is strictly defined by the {@link ICAL.Time#isDate isDate} member.
   * @type {String}
   * @default "date-time"
   */
  get icaltype() {
    return this.isDate ? "date" : "date-time";
  }
  /**
   * The timezone for this time.
   * @type {Timezone}
   */
  zone = null;
  /**
   * Internal uses to indicate that a change has been made and the next read
   * operation must attempt to normalize the value (for example changing the
   * day to 33).
   *
   * @type {Boolean}
   * @private
   */
  _pendingNormalization = false;
  /**
   * The year of this date.
   * @type {Number}
   */
  get year() {
    return this._getTimeAttr("year");
  }
  set year(val) {
    this._setTimeAttr("year", val);
  }
  /**
   * The month of this date.
   * @type {Number}
   */
  get month() {
    return this._getTimeAttr("month");
  }
  set month(val) {
    this._setTimeAttr("month", val);
  }
  /**
   * The day of this date.
   * @type {Number}
   */
  get day() {
    return this._getTimeAttr("day");
  }
  set day(val) {
    this._setTimeAttr("day", val);
  }
  /**
   * The hour of this date-time.
   * @type {Number}
   */
  get hour() {
    return this._getTimeAttr("hour");
  }
  set hour(val) {
    this._setTimeAttr("hour", val);
  }
  /**
   * The minute of this date-time.
   * @type {Number}
   */
  get minute() {
    return this._getTimeAttr("minute");
  }
  set minute(val) {
    this._setTimeAttr("minute", val);
  }
  /**
   * The second of this date-time.
   * @type {Number}
   */
  get second() {
    return this._getTimeAttr("second");
  }
  set second(val) {
    this._setTimeAttr("second", val);
  }
  /**
   * If true, the instance represents a date (as opposed to a date-time)
   * @type {Boolean}
   */
  get isDate() {
    return this._getTimeAttr("isDate");
  }
  set isDate(val) {
    this._setTimeAttr("isDate", val);
  }
  /**
   * @private
   * @param {String} attr             Attribute to get (one of: year, month,
   *                                  day, hour, minute, second, isDate)
   * @return {Number|Boolean}         Current value for the attribute
   */
  _getTimeAttr(attr) {
    if (this._pendingNormalization) {
      this._normalize();
      this._pendingNormalization = false;
    }
    return this._time[attr];
  }
  /**
   * @private
   * @param {String} attr             Attribute to set (one of: year, month,
   *                                  day, hour, minute, second, isDate)
   * @param {Number|Boolean} val      New value for the attribute
   */
  _setTimeAttr(attr, val) {
    if (attr === "isDate" && val && !this._time.isDate) {
      this.adjust(0, 0, 0, 0);
    }
    this._cachedUnixTime = null;
    this._pendingNormalization = true;
    this._time[attr] = val;
  }
  /**
   * Returns a clone of the time object.
   *
   * @return {Time}              The cloned object
   */
  clone() {
    return new Time(this._time, this.zone);
  }
  /**
   * Reset the time instance to epoch time
   */
  reset() {
    this.fromData(Time.epochTime);
    this.zone = Timezone$1.utcTimezone;
  }
  /**
   * Reset the time instance to the given date/time values.
   *
   * @param {Number} year             The year to set
   * @param {Number} month            The month to set
   * @param {Number} day              The day to set
   * @param {Number} hour             The hour to set
   * @param {Number} minute           The minute to set
   * @param {Number} second           The second to set
   * @param {Timezone} timezone       The timezone to set
   */
  resetTo(year, month, day, hour, minute, second, timezone) {
    this.fromData({
      year,
      month,
      day,
      hour,
      minute,
      second,
      zone: timezone
    });
  }
  /**
   * Set up the current instance from the Javascript date value.
   *
   * @param {?Date} aDate             The Javascript Date to read, or null to reset
   * @param {Boolean} [useUTC=false]  If true, the UTC values of the date will be used
   */
  fromJSDate(aDate, useUTC) {
    if (!aDate) {
      this.reset();
    } else {
      if (useUTC) {
        this.zone = Timezone$1.utcTimezone;
        this.year = aDate.getUTCFullYear();
        this.month = aDate.getUTCMonth() + 1;
        this.day = aDate.getUTCDate();
        this.hour = aDate.getUTCHours();
        this.minute = aDate.getUTCMinutes();
        this.second = aDate.getUTCSeconds();
      } else {
        this.zone = Timezone$1.localTimezone;
        this.year = aDate.getFullYear();
        this.month = aDate.getMonth() + 1;
        this.day = aDate.getDate();
        this.hour = aDate.getHours();
        this.minute = aDate.getMinutes();
        this.second = aDate.getSeconds();
      }
    }
    this._cachedUnixTime = null;
    return this;
  }
  /**
   * Sets up the current instance using members from the passed data object.
   *
   * @param {timeInit} aData          Time initialization
   * @param {Timezone=} aZone         Timezone this position occurs in
   */
  fromData(aData, aZone) {
    if (aData) {
      for (let [key, value] of Object.entries(aData)) {
        if (key === "icaltype") continue;
        this[key] = value;
      }
    }
    if (aZone) {
      this.zone = aZone;
    }
    if (aData && !("isDate" in aData)) {
      this.isDate = !("hour" in aData);
    } else if (aData && "isDate" in aData) {
      this.isDate = aData.isDate;
    }
    if (aData && "timezone" in aData) {
      let zone = TimezoneService.get(
        aData.timezone
      );
      this.zone = zone || Timezone$1.localTimezone;
    }
    if (aData && "zone" in aData) {
      this.zone = aData.zone;
    }
    if (!this.zone) {
      this.zone = Timezone$1.localTimezone;
    }
    this._cachedUnixTime = null;
    return this;
  }
  /**
   * Calculate the day of week.
   * @param {weekDay=} aWeekStart
   *        The week start weekday, defaults to SUNDAY
   * @return {weekDay}
   */
  dayOfWeek(aWeekStart) {
    let firstDow = aWeekStart || Time.SUNDAY;
    let dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
    if (dowCacheKey in Time._dowCache) {
      return Time._dowCache[dowCacheKey];
    }
    let q = this.day;
    let m = this.month + (this.month < 3 ? 12 : 0);
    let Y = this.year - (this.month < 3 ? 1 : 0);
    let h2 = q + Y + trunc((m + 1) * 26 / 10) + trunc(Y / 4);
    {
      h2 += trunc(Y / 100) * 6 + trunc(Y / 400);
    }
    h2 = (h2 + 7 - firstDow) % 7 + 1;
    Time._dowCache[dowCacheKey] = h2;
    return h2;
  }
  /**
   * Calculate the day of year.
   * @return {Number}
   */
  dayOfYear() {
    let is_leap = Time.isLeapYear(this.year) ? 1 : 0;
    let diypm = Time.daysInYearPassedMonth;
    return diypm[is_leap][this.month - 1] + this.day;
  }
  /**
   * Returns a copy of the current date/time, rewound to the start of the
   * week. The resulting ICAL.Time instance is of icaltype date, even if this
   * is a date-time.
   *
   * @param {weekDay=} aWeekStart
   *        The week start weekday, defaults to SUNDAY
   * @return {Time}      The start of the week (cloned)
   */
  startOfWeek(aWeekStart) {
    let firstDow = aWeekStart || Time.SUNDAY;
    let result = this.clone();
    result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;
    result.isDate = true;
    result.hour = 0;
    result.minute = 0;
    result.second = 0;
    return result;
  }
  /**
   * Returns a copy of the current date/time, shifted to the end of the week.
   * The resulting ICAL.Time instance is of icaltype date, even if this is a
   * date-time.
   *
   * @param {weekDay=} aWeekStart
   *        The week start weekday, defaults to SUNDAY
   * @return {Time}      The end of the week (cloned)
   */
  endOfWeek(aWeekStart) {
    let firstDow = aWeekStart || Time.SUNDAY;
    let result = this.clone();
    result.day += (7 - this.dayOfWeek() + firstDow - Time.SUNDAY) % 7;
    result.isDate = true;
    result.hour = 0;
    result.minute = 0;
    result.second = 0;
    return result;
  }
  /**
   * Returns a copy of the current date/time, rewound to the start of the
   * month. The resulting ICAL.Time instance is of icaltype date, even if
   * this is a date-time.
   *
   * @return {Time}      The start of the month (cloned)
   */
  startOfMonth() {
    let result = this.clone();
    result.day = 1;
    result.isDate = true;
    result.hour = 0;
    result.minute = 0;
    result.second = 0;
    return result;
  }
  /**
   * Returns a copy of the current date/time, shifted to the end of the
   * month.  The resulting ICAL.Time instance is of icaltype date, even if
   * this is a date-time.
   *
   * @return {Time}      The end of the month (cloned)
   */
  endOfMonth() {
    let result = this.clone();
    result.day = Time.daysInMonth(result.month, result.year);
    result.isDate = true;
    result.hour = 0;
    result.minute = 0;
    result.second = 0;
    return result;
  }
  /**
   * Returns a copy of the current date/time, rewound to the start of the
   * year. The resulting ICAL.Time instance is of icaltype date, even if
   * this is a date-time.
   *
   * @return {Time}      The start of the year (cloned)
   */
  startOfYear() {
    let result = this.clone();
    result.day = 1;
    result.month = 1;
    result.isDate = true;
    result.hour = 0;
    result.minute = 0;
    result.second = 0;
    return result;
  }
  /**
   * Returns a copy of the current date/time, shifted to the end of the
   * year.  The resulting ICAL.Time instance is of icaltype date, even if
   * this is a date-time.
   *
   * @return {Time}      The end of the year (cloned)
   */
  endOfYear() {
    let result = this.clone();
    result.day = 31;
    result.month = 12;
    result.isDate = true;
    result.hour = 0;
    result.minute = 0;
    result.second = 0;
    return result;
  }
  /**
   * First calculates the start of the week, then returns the day of year for
   * this date. If the day falls into the previous year, the day is zero or negative.
   *
   * @param {weekDay=} aFirstDayOfWeek
   *        The week start weekday, defaults to SUNDAY
   * @return {Number}     The calculated day of year
   */
  startDoyWeek(aFirstDayOfWeek) {
    let firstDow = aFirstDayOfWeek || Time.SUNDAY;
    let delta = this.dayOfWeek() - firstDow;
    if (delta < 0) delta += 7;
    return this.dayOfYear() - delta;
  }
  /**
   * Get the dominical letter for the current year. Letters range from A - G
   * for common years, and AG to GF for leap years.
   *
   * @param {Number} yr           The year to retrieve the letter for
   * @return {String}             The dominical letter.
   */
  getDominicalLetter() {
    return Time.getDominicalLetter(this.year);
  }
  /**
   * Finds the nthWeekDay relative to the current month (not day).  The
   * returned value is a day relative the month that this month belongs to so
   * 1 would indicate the first of the month and 40 would indicate a day in
   * the following month.
   *
   * @param {Number} aDayOfWeek   Day of the week see the day name constants
   * @param {Number} aPos         Nth occurrence of a given week day values
   *        of 1 and 0 both indicate the first weekday of that type. aPos may
   *        be either positive or negative
   *
   * @return {Number} numeric value indicating a day relative
   *                   to the current month of this time object
   */
  nthWeekDay(aDayOfWeek, aPos) {
    let daysInMonth = Time.daysInMonth(this.month, this.year);
    let weekday;
    let pos = aPos;
    let start = 0;
    let otherDay = this.clone();
    if (pos >= 0) {
      otherDay.day = 1;
      if (pos != 0) {
        pos--;
      }
      start = otherDay.day;
      let startDow = otherDay.dayOfWeek();
      let offset = aDayOfWeek - startDow;
      if (offset < 0)
        offset += 7;
      start += offset;
      start -= aDayOfWeek;
      weekday = aDayOfWeek;
    } else {
      otherDay.day = daysInMonth;
      let endDow = otherDay.dayOfWeek();
      pos++;
      weekday = endDow - aDayOfWeek;
      if (weekday < 0) {
        weekday += 7;
      }
      weekday = daysInMonth - weekday;
    }
    weekday += pos * 7;
    return start + weekday;
  }
  /**
   * Checks if current time is the nth weekday, relative to the current
   * month.  Will always return false when rule resolves outside of current
   * month.
   *
   * @param {weekDay} aDayOfWeek                 Day of week to check
   * @param {Number} aPos                        Relative position
   * @return {Boolean}                           True, if it is the nth weekday
   */
  isNthWeekDay(aDayOfWeek, aPos) {
    let dow = this.dayOfWeek();
    if (aPos === 0 && dow === aDayOfWeek) {
      return true;
    }
    let day = this.nthWeekDay(aDayOfWeek, aPos);
    if (day === this.day) {
      return true;
    }
    return false;
  }
  /**
   * Calculates the ISO 8601 week number. The first week of a year is the
   * week that contains the first Thursday. The year can have 53 weeks, if
   * January 1st is a Friday.
   *
   * Note there are regions where the first week of the year is the one that
   * starts on January 1st, which may offset the week number. Also, if a
   * different week start is specified, this will also affect the week
   * number.
   *
   * @see Time.weekOneStarts
   * @param {weekDay} aWeekStart                  The weekday the week starts with
   * @return {Number}                             The ISO week number
   */
  weekNumber(aWeekStart) {
    let wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
    if (wnCacheKey in Time._wnCache) {
      return Time._wnCache[wnCacheKey];
    }
    let week1;
    let dt2 = this.clone();
    dt2.isDate = true;
    let isoyear = this.year;
    if (dt2.month == 12 && dt2.day > 25) {
      week1 = Time.weekOneStarts(isoyear + 1, aWeekStart);
      if (dt2.compare(week1) < 0) {
        week1 = Time.weekOneStarts(isoyear, aWeekStart);
      } else {
        isoyear++;
      }
    } else {
      week1 = Time.weekOneStarts(isoyear, aWeekStart);
      if (dt2.compare(week1) < 0) {
        week1 = Time.weekOneStarts(--isoyear, aWeekStart);
      }
    }
    let daysBetween = dt2.subtractDate(week1).toSeconds() / 86400;
    let answer = trunc(daysBetween / 7) + 1;
    Time._wnCache[wnCacheKey] = answer;
    return answer;
  }
  /**
   * Adds the duration to the current time. The instance is modified in
   * place.
   *
   * @param {Duration} aDuration         The duration to add
   */
  addDuration(aDuration) {
    let mult = aDuration.isNegative ? -1 : 1;
    let second = this.second;
    let minute = this.minute;
    let hour = this.hour;
    let day = this.day;
    second += mult * aDuration.seconds;
    minute += mult * aDuration.minutes;
    hour += mult * aDuration.hours;
    day += mult * aDuration.days;
    day += mult * 7 * aDuration.weeks;
    this.second = second;
    this.minute = minute;
    this.hour = hour;
    this.day = day;
    this._cachedUnixTime = null;
  }
  /**
   * Subtract the date details (_excluding_ timezone).  Useful for finding
   * the relative difference between two time objects excluding their
   * timezone differences.
   *
   * @param {Time} aDate     The date to subtract
   * @return {Duration}      The difference as a duration
   */
  subtractDate(aDate) {
    let unixTime = this.toUnixTime() + this.utcOffset();
    let other = aDate.toUnixTime() + aDate.utcOffset();
    return Duration.fromSeconds(unixTime - other);
  }
  /**
   * Subtract the date details, taking timezones into account.
   *
   * @param {Time} aDate  The date to subtract
   * @return {Duration}   The difference in duration
   */
  subtractDateTz(aDate) {
    let unixTime = this.toUnixTime();
    let other = aDate.toUnixTime();
    return Duration.fromSeconds(unixTime - other);
  }
  /**
   * Compares the ICAL.Time instance with another one, or a period.
   *
   * @param {Time|Period} aOther                  The instance to compare with
   * @return {Number}                             -1, 0 or 1 for less/equal/greater
   */
  compare(other) {
    if (other instanceof Period) {
      return -1 * other.compare(this);
    } else {
      let a = this.toUnixTime();
      let b = other.toUnixTime();
      if (a > b) return 1;
      if (b > a) return -1;
      return 0;
    }
  }
  /**
   * Compares only the date part of this instance with another one.
   *
   * @param {Time} other                  The instance to compare with
   * @param {Timezone} tz                 The timezone to compare in
   * @return {Number}                     -1, 0 or 1 for less/equal/greater
   */
  compareDateOnlyTz(other, tz) {
    let a = this.convertToZone(tz);
    let b = other.convertToZone(tz);
    let rc = 0;
    if ((rc = Time._cmp_attr(a, b, "year")) != 0) return rc;
    if ((rc = Time._cmp_attr(a, b, "month")) != 0) return rc;
    if ((rc = Time._cmp_attr(a, b, "day")) != 0) return rc;
    return rc;
  }
  /**
   * Convert the instance into another timezone. The returned ICAL.Time
   * instance is always a copy.
   *
   * @param {Timezone} zone      The zone to convert to
   * @return {Time}              The copy, converted to the zone
   */
  convertToZone(zone) {
    let copy = this.clone();
    let zone_equals = this.zone.tzid == zone.tzid;
    if (!this.isDate && !zone_equals) {
      Timezone$1.convert_time(copy, this.zone, zone);
    }
    copy.zone = zone;
    return copy;
  }
  /**
   * Calculates the UTC offset of the current date/time in the timezone it is
   * in.
   *
   * @return {Number}     UTC offset in seconds
   */
  utcOffset() {
    if (this.zone == Timezone$1.localTimezone || this.zone == Timezone$1.utcTimezone) {
      return 0;
    } else {
      return this.zone.utcOffset(this);
    }
  }
  /**
   * Returns an RFC 5545 compliant ical representation of this object.
   *
   * @return {String} ical date/date-time
   */
  toICALString() {
    let string = this.toString();
    if (string.length > 10) {
      return design.icalendar.value["date-time"].toICAL(string);
    } else {
      return design.icalendar.value.date.toICAL(string);
    }
  }
  /**
   * The string representation of this date/time, in jCal form
   * (including : and - separators).
   * @return {String}
   */
  toString() {
    let result = this.year + "-" + pad2(this.month) + "-" + pad2(this.day);
    if (!this.isDate) {
      result += "T" + pad2(this.hour) + ":" + pad2(this.minute) + ":" + pad2(this.second);
      if (this.zone === Timezone$1.utcTimezone) {
        result += "Z";
      }
    }
    return result;
  }
  /**
   * Converts the current instance to a Javascript date
   * @return {Date}
   */
  toJSDate() {
    if (this.zone == Timezone$1.localTimezone) {
      if (this.isDate) {
        return new Date(this.year, this.month - 1, this.day);
      } else {
        return new Date(
          this.year,
          this.month - 1,
          this.day,
          this.hour,
          this.minute,
          this.second,
          0
        );
      }
    } else {
      return new Date(this.toUnixTime() * 1e3);
    }
  }
  _normalize() {
    if (this._time.isDate) {
      this._time.hour = 0;
      this._time.minute = 0;
      this._time.second = 0;
    }
    this.adjust(0, 0, 0, 0);
    return this;
  }
  /**
   * Adjust the date/time by the given offset
   *
   * @param {Number} aExtraDays       The extra amount of days
   * @param {Number} aExtraHours      The extra amount of hours
   * @param {Number} aExtraMinutes    The extra amount of minutes
   * @param {Number} aExtraSeconds    The extra amount of seconds
   * @param {Number=} aTime           The time to adjust, defaults to the
   *                                    current instance.
   */
  adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {
    let minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;
    let second, minute, hour, day;
    let daysInMonth;
    let time = aTime || this._time;
    if (!time.isDate) {
      second = time.second + aExtraSeconds;
      time.second = second % 60;
      minutesOverflow = trunc(second / 60);
      if (time.second < 0) {
        time.second += 60;
        minutesOverflow--;
      }
      minute = time.minute + aExtraMinutes + minutesOverflow;
      time.minute = minute % 60;
      hoursOverflow = trunc(minute / 60);
      if (time.minute < 0) {
        time.minute += 60;
        hoursOverflow--;
      }
      hour = time.hour + aExtraHours + hoursOverflow;
      time.hour = hour % 24;
      daysOverflow = trunc(hour / 24);
      if (time.hour < 0) {
        time.hour += 24;
        daysOverflow--;
      }
    }
    if (time.month > 12) {
      yearsOverflow = trunc((time.month - 1) / 12);
    } else if (time.month < 1) {
      yearsOverflow = trunc(time.month / 12) - 1;
    }
    time.year += yearsOverflow;
    time.month -= 12 * yearsOverflow;
    day = time.day + aExtraDays + daysOverflow;
    if (day > 0) {
      for (; ; ) {
        daysInMonth = Time.daysInMonth(time.month, time.year);
        if (day <= daysInMonth) {
          break;
        }
        time.month++;
        if (time.month > 12) {
          time.year++;
          time.month = 1;
        }
        day -= daysInMonth;
      }
    } else {
      while (day <= 0) {
        if (time.month == 1) {
          time.year--;
          time.month = 12;
        } else {
          time.month--;
        }
        day += Time.daysInMonth(time.month, time.year);
      }
    }
    time.day = day;
    this._cachedUnixTime = null;
    return this;
  }
  /**
   * Sets up the current instance from unix time, the number of seconds since
   * January 1st, 1970.
   *
   * @param {Number} seconds      The seconds to set up with
   */
  fromUnixTime(seconds) {
    this.zone = Timezone$1.utcTimezone;
    let date = new Date(seconds * 1e3);
    this.year = date.getUTCFullYear();
    this.month = date.getUTCMonth() + 1;
    this.day = date.getUTCDate();
    if (this._time.isDate) {
      this.hour = 0;
      this.minute = 0;
      this.second = 0;
    } else {
      this.hour = date.getUTCHours();
      this.minute = date.getUTCMinutes();
      this.second = date.getUTCSeconds();
    }
    this._cachedUnixTime = null;
  }
  /**
   * Converts the current instance to seconds since January 1st 1970.
   *
   * @return {Number}         Seconds since 1970
   */
  toUnixTime() {
    if (this._cachedUnixTime !== null) {
      return this._cachedUnixTime;
    }
    let offset = this.utcOffset();
    let ms = Date.UTC(
      this.year,
      this.month - 1,
      this.day,
      this.hour,
      this.minute,
      this.second - offset
    );
    this._cachedUnixTime = ms / 1e3;
    return this._cachedUnixTime;
  }
  /**
   * Converts time to into Object which can be serialized then re-created
   * using the constructor.
   *
   * @example
   * // toJSON will automatically be called
   * var json = JSON.stringify(mytime);
   *
   * var deserialized = JSON.parse(json);
   *
   * var time = new ICAL.Time(deserialized);
   *
   * @return {Object}
   */
  toJSON() {
    let copy = [
      "year",
      "month",
      "day",
      "hour",
      "minute",
      "second",
      "isDate"
    ];
    let result = /* @__PURE__ */ Object.create(null);
    let i = 0;
    let len = copy.length;
    let prop;
    for (; i < len; i++) {
      prop = copy[i];
      result[prop] = this[prop];
    }
    if (this.zone) {
      result.timezone = this.zone.tzid;
    }
    return result;
  }
}
const CHAR = /[^ \t]/;
const VALUE_DELIMITER = ":";
const PARAM_DELIMITER = ";";
const PARAM_NAME_DELIMITER = "=";
const DEFAULT_VALUE_TYPE$1 = "unknown";
const DEFAULT_PARAM_TYPE = "text";
const RFC6868_REPLACE_MAP$1 = { "^'": '"', "^n": "\n", "^^": "^" };
function parse(input) {
  let state = {};
  let root = state.component = [];
  state.stack = [root];
  parse._eachLine(input, function(err, line) {
    parse._handleContentLine(line, state);
  });
  if (state.stack.length > 1) {
    throw new ParserError(
      "invalid ical body. component began but did not end"
    );
  }
  state = null;
  return root.length == 1 ? root[0] : root;
}
parse.property = function(str, designSet) {
  let state = {
    component: [[], []],
    designSet: designSet || design.defaultSet
  };
  parse._handleContentLine(str, state);
  return state.component[1][0];
};
parse.component = function(str) {
  return parse(str);
};
class ParserError extends Error {
  name = this.constructor.name;
}
parse.ParserError = ParserError;
parse._handleContentLine = function(line, state) {
  let valuePos = line.indexOf(VALUE_DELIMITER);
  let paramPos = line.indexOf(PARAM_DELIMITER);
  let lastParamIndex;
  let lastValuePos;
  let name;
  let value;
  let params = {};
  if (paramPos !== -1 && valuePos !== -1) {
    if (paramPos > valuePos) {
      paramPos = -1;
    }
  }
  let parsedParams;
  if (paramPos !== -1) {
    name = line.slice(0, Math.max(0, paramPos)).toLowerCase();
    parsedParams = parse._parseParameters(line.slice(Math.max(0, paramPos)), 0, state.designSet);
    if (parsedParams[2] == -1) {
      throw new ParserError("Invalid parameters in '" + line + "'");
    }
    params = parsedParams[0];
    let parsedParamLength;
    if (typeof parsedParams[1] === "string") {
      parsedParamLength = parsedParams[1].length;
    } else {
      parsedParamLength = parsedParams[1].reduce((accumulator, currentValue) => {
        return accumulator + currentValue.length;
      }, 0);
    }
    lastParamIndex = parsedParamLength + parsedParams[2] + paramPos;
    if ((lastValuePos = line.slice(Math.max(0, lastParamIndex)).indexOf(VALUE_DELIMITER)) !== -1) {
      value = line.slice(Math.max(0, lastParamIndex + lastValuePos + 1));
    } else {
      throw new ParserError("Missing parameter value in '" + line + "'");
    }
  } else if (valuePos !== -1) {
    name = line.slice(0, Math.max(0, valuePos)).toLowerCase();
    value = line.slice(Math.max(0, valuePos + 1));
    if (name === "begin") {
      let newComponent = [value.toLowerCase(), [], []];
      if (state.stack.length === 1) {
        state.component.push(newComponent);
      } else {
        state.component[2].push(newComponent);
      }
      state.stack.push(state.component);
      state.component = newComponent;
      if (!state.designSet) {
        state.designSet = design.getDesignSet(state.component[0]);
      }
      return;
    } else if (name === "end") {
      state.component = state.stack.pop();
      return;
    }
  } else {
    throw new ParserError(
      'invalid line (no token ";" or ":") "' + line + '"'
    );
  }
  let valueType;
  let multiValue = false;
  let structuredValue = false;
  let propertyDetails;
  let splitName;
  let ungroupedName;
  if (state.designSet.propertyGroups && name.indexOf(".") !== -1) {
    splitName = name.split(".");
    params.group = splitName[0];
    ungroupedName = splitName[1];
  } else {
    ungroupedName = name;
  }
  if (ungroupedName in state.designSet.property) {
    propertyDetails = state.designSet.property[ungroupedName];
    if ("multiValue" in propertyDetails) {
      multiValue = propertyDetails.multiValue;
    }
    if ("structuredValue" in propertyDetails) {
      structuredValue = propertyDetails.structuredValue;
    }
    if (value && "detectType" in propertyDetails) {
      valueType = propertyDetails.detectType(value);
    }
  }
  if (!valueType) {
    if (!("value" in params)) {
      if (propertyDetails) {
        valueType = propertyDetails.defaultType;
      } else {
        valueType = DEFAULT_VALUE_TYPE$1;
      }
    } else {
      valueType = params.value.toLowerCase();
    }
  }
  delete params.value;
  let result;
  if (multiValue && structuredValue) {
    value = parse._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
    result = [ungroupedName, params, valueType, value];
  } else if (multiValue) {
    result = [ungroupedName, params, valueType];
    parse._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
  } else if (structuredValue) {
    value = parse._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
    result = [ungroupedName, params, valueType, value];
  } else {
    value = parse._parseValue(value, valueType, state.designSet, false);
    result = [ungroupedName, params, valueType, value];
  }
  if (state.component[0] === "vcard" && state.component[1].length === 0 && !(name === "version" && value === "4.0")) {
    state.designSet = design.getDesignSet("vcard3");
  }
  state.component[1].push(result);
};
parse._parseValue = function(value, type, designSet, structuredValue) {
  if (type in designSet.value && "fromICAL" in designSet.value[type]) {
    return designSet.value[type].fromICAL(value, structuredValue);
  }
  return value;
};
parse._parseParameters = function(line, start, designSet) {
  let lastParam = start;
  let pos = 0;
  let delim = PARAM_NAME_DELIMITER;
  let result = {};
  let name, lcname;
  let value, valuePos = -1;
  let type, multiValue, mvdelim;
  while (pos !== false && (pos = line.indexOf(delim, pos + 1)) !== -1) {
    name = line.slice(lastParam + 1, pos);
    if (name.length == 0) {
      throw new ParserError("Empty parameter name in '" + line + "'");
    }
    lcname = name.toLowerCase();
    mvdelim = false;
    multiValue = false;
    if (lcname in designSet.param && designSet.param[lcname].valueType) {
      type = designSet.param[lcname].valueType;
    } else {
      type = DEFAULT_PARAM_TYPE;
    }
    if (lcname in designSet.param) {
      multiValue = designSet.param[lcname].multiValue;
      if (designSet.param[lcname].multiValueSeparateDQuote) {
        mvdelim = parse._rfc6868Escape('"' + multiValue + '"');
      }
    }
    let nextChar = line[pos + 1];
    if (nextChar === '"') {
      valuePos = pos + 2;
      pos = line.indexOf('"', valuePos);
      if (multiValue && pos != -1) {
        let extendedValue = true;
        while (extendedValue) {
          if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
            pos = line.indexOf('"', pos + 3);
          } else {
            extendedValue = false;
          }
        }
      }
      if (pos === -1) {
        throw new ParserError(
          'invalid line (no matching double quote) "' + line + '"'
        );
      }
      value = line.slice(valuePos, pos);
      lastParam = line.indexOf(PARAM_DELIMITER, pos);
      let propValuePos = line.indexOf(VALUE_DELIMITER, pos);
      if (lastParam === -1 || propValuePos !== -1 && lastParam > propValuePos) {
        pos = false;
      }
    } else {
      valuePos = pos + 1;
      let nextPos = line.indexOf(PARAM_DELIMITER, valuePos);
      let propValuePos = line.indexOf(VALUE_DELIMITER, valuePos);
      if (propValuePos !== -1 && nextPos > propValuePos) {
        nextPos = propValuePos;
        pos = false;
      } else if (nextPos === -1) {
        if (propValuePos === -1) {
          nextPos = line.length;
        } else {
          nextPos = propValuePos;
        }
        pos = false;
      } else {
        lastParam = nextPos;
        pos = nextPos;
      }
      value = line.slice(valuePos, nextPos);
    }
    const length_before = value.length;
    value = parse._rfc6868Escape(value);
    valuePos += length_before - value.length;
    if (multiValue) {
      let delimiter = mvdelim || multiValue;
      value = parse._parseMultiValue(value, delimiter, type, [], null, designSet);
    } else {
      value = parse._parseValue(value, type, designSet);
    }
    if (multiValue && lcname in result) {
      if (Array.isArray(result[lcname])) {
        result[lcname].push(value);
      } else {
        result[lcname] = [
          result[lcname],
          value
        ];
      }
    } else {
      result[lcname] = value;
    }
  }
  return [result, value, valuePos];
};
parse._rfc6868Escape = function(val) {
  return val.replace(/\^['n^]/g, function(x) {
    return RFC6868_REPLACE_MAP$1[x];
  });
};
parse._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
  let pos = 0;
  let lastPos = 0;
  let value;
  if (delim.length === 0) {
    return buffer;
  }
  while ((pos = unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
    value = buffer.slice(lastPos, pos);
    if (innerMulti) {
      value = parse._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
    } else {
      value = parse._parseValue(value, type, designSet, structuredValue);
    }
    result.push(value);
    lastPos = pos + delim.length;
  }
  value = buffer.slice(lastPos);
  if (innerMulti) {
    value = parse._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
  } else {
    value = parse._parseValue(value, type, designSet, structuredValue);
  }
  result.push(value);
  return result.length == 1 ? result[0] : result;
};
parse._eachLine = function(buffer, callback) {
  let len = buffer.length;
  let lastPos = buffer.search(CHAR);
  let pos = lastPos;
  let line;
  let firstChar;
  let newlineOffset;
  do {
    pos = buffer.indexOf("\n", lastPos) + 1;
    if (pos > 1 && buffer[pos - 2] === "\r") {
      newlineOffset = 2;
    } else {
      newlineOffset = 1;
    }
    if (pos === 0) {
      pos = len;
      newlineOffset = 0;
    }
    firstChar = buffer[lastPos];
    if (firstChar === " " || firstChar === "	") {
      line += buffer.slice(lastPos + 1, pos - newlineOffset);
    } else {
      if (line)
        callback(null, line);
      line = buffer.slice(lastPos, pos - newlineOffset);
    }
    lastPos = pos;
  } while (pos !== len);
  line = line.trim();
  if (line.length)
    callback(null, line);
};
const OPTIONS = ["tzid", "location", "tznames", "latitude", "longitude"];
let Timezone$1 = class Timezone {
  static _compare_change_fn(a, b) {
    if (a.year < b.year) return -1;
    else if (a.year > b.year) return 1;
    if (a.month < b.month) return -1;
    else if (a.month > b.month) return 1;
    if (a.day < b.day) return -1;
    else if (a.day > b.day) return 1;
    if (a.hour < b.hour) return -1;
    else if (a.hour > b.hour) return 1;
    if (a.minute < b.minute) return -1;
    else if (a.minute > b.minute) return 1;
    if (a.second < b.second) return -1;
    else if (a.second > b.second) return 1;
    return 0;
  }
  /**
   * Convert the date/time from one zone to the next.
   *
   * @param {Time} tt                  The time to convert
   * @param {Timezone} from_zone       The source zone to convert from
   * @param {Timezone} to_zone         The target zone to convert to
   * @return {Time}                    The converted date/time object
   */
  static convert_time(tt2, from_zone, to_zone) {
    if (tt2.isDate || from_zone.tzid == to_zone.tzid || from_zone == Timezone.localTimezone || to_zone == Timezone.localTimezone) {
      tt2.zone = to_zone;
      return tt2;
    }
    let utcOffset = from_zone.utcOffset(tt2);
    tt2.adjust(0, 0, 0, -utcOffset);
    utcOffset = to_zone.utcOffset(tt2);
    tt2.adjust(0, 0, 0, utcOffset);
    return null;
  }
  /**
   * Creates a new ICAL.Timezone instance from the passed data object.
   *
   * @param {Component|Object} aData options for class
   * @param {String|Component} aData.component
   *        If aData is a simple object, then this member can be set to either a
   *        string containing the component data, or an already parsed
   *        ICAL.Component
   * @param {String} aData.tzid      The timezone identifier
   * @param {String} aData.location  The timezone locationw
   * @param {String} aData.tznames   An alternative string representation of the
   *                                  timezone
   * @param {Number} aData.latitude  The latitude of the timezone
   * @param {Number} aData.longitude The longitude of the timezone
   */
  static fromData(aData) {
    let tt2 = new Timezone();
    return tt2.fromData(aData);
  }
  /**
   * The instance describing the UTC timezone
   * @type {Timezone}
   * @constant
   * @instance
   */
  static #utcTimezone = null;
  static get utcTimezone() {
    if (!this.#utcTimezone) {
      this.#utcTimezone = Timezone.fromData({
        tzid: "UTC"
      });
    }
    return this.#utcTimezone;
  }
  /**
   * The instance describing the local timezone
   * @type {Timezone}
   * @constant
   * @instance
   */
  static #localTimezone = null;
  static get localTimezone() {
    if (!this.#localTimezone) {
      this.#localTimezone = Timezone.fromData({
        tzid: "floating"
      });
    }
    return this.#localTimezone;
  }
  /**
   * Adjust a timezone change object.
   * @private
   * @param {Object} change     The timezone change object
   * @param {Number} days       The extra amount of days
   * @param {Number} hours      The extra amount of hours
   * @param {Number} minutes    The extra amount of minutes
   * @param {Number} seconds    The extra amount of seconds
   */
  static adjust_change(change, days, hours, minutes, seconds) {
    return Time.prototype.adjust.call(
      change,
      days,
      hours,
      minutes,
      seconds,
      change
    );
  }
  static _minimumExpansionYear = -1;
  static EXTRA_COVERAGE = 5;
  /**
   * Creates a new ICAL.Timezone instance, by passing in a tzid and component.
   *
   * @param {Component|Object} data options for class
   * @param {String|Component} data.component
   *        If data is a simple object, then this member can be set to either a
   *        string containing the component data, or an already parsed
   *        ICAL.Component
   * @param {String} data.tzid      The timezone identifier
   * @param {String} data.location  The timezone locationw
   * @param {String} data.tznames   An alternative string representation of the
   *                                  timezone
   * @param {Number} data.latitude  The latitude of the timezone
   * @param {Number} data.longitude The longitude of the timezone
   */
  constructor(data) {
    this.wrappedJSObject = this;
    this.fromData(data);
  }
  /**
   * Timezone identifier
   * @type {String}
   */
  tzid = "";
  /**
   * Timezone location
   * @type {String}
   */
  location = "";
  /**
   * Alternative timezone name, for the string representation
   * @type {String}
   */
  tznames = "";
  /**
   * The primary latitude for the timezone.
   * @type {Number}
   */
  latitude = 0;
  /**
   * The primary longitude for the timezone.
   * @type {Number}
   */
  longitude = 0;
  /**
   * The vtimezone component for this timezone.
   * @type {Component}
   */
  component = null;
  /**
   * The year this timezone has been expanded to. All timezone transition
   * dates until this year are known and can be used for calculation
   *
   * @private
   * @type {Number}
   */
  expandedUntilYear = 0;
  /**
   * The class identifier.
   * @constant
   * @type {String}
   * @default "icaltimezone"
   */
  icalclass = "icaltimezone";
  /**
   * Sets up the current instance using members from the passed data object.
   *
   * @param {Component|Object} aData options for class
   * @param {String|Component} aData.component
   *        If aData is a simple object, then this member can be set to either a
   *        string containing the component data, or an already parsed
   *        ICAL.Component
   * @param {String} aData.tzid      The timezone identifier
   * @param {String} aData.location  The timezone locationw
   * @param {String} aData.tznames   An alternative string representation of the
   *                                  timezone
   * @param {Number} aData.latitude  The latitude of the timezone
   * @param {Number} aData.longitude The longitude of the timezone
   */
  fromData(aData) {
    this.expandedUntilYear = 0;
    this.changes = [];
    if (aData instanceof Component) {
      this.component = aData;
    } else {
      if (aData && "component" in aData) {
        if (typeof aData.component == "string") {
          let jCal = parse(aData.component);
          this.component = new Component(jCal);
        } else if (aData.component instanceof Component) {
          this.component = aData.component;
        } else {
          this.component = null;
        }
      }
      for (let prop of OPTIONS) {
        if (aData && prop in aData) {
          this[prop] = aData[prop];
        }
      }
    }
    if (this.component instanceof Component && !this.tzid) {
      this.tzid = this.component.getFirstPropertyValue("tzid");
    }
    return this;
  }
  /**
   * Finds the utcOffset the given time would occur in this timezone.
   *
   * @param {Time} tt         The time to check for
   * @return {Number}         utc offset in seconds
   */
  utcOffset(tt2) {
    if (this == Timezone.utcTimezone || this == Timezone.localTimezone) {
      return 0;
    }
    this._ensureCoverage(tt2.year);
    if (!this.changes.length) {
      return 0;
    }
    let tt_change = {
      year: tt2.year,
      month: tt2.month,
      day: tt2.day,
      hour: tt2.hour,
      minute: tt2.minute,
      second: tt2.second
    };
    let change_num = this._findNearbyChange(tt_change);
    let change_num_to_use = -1;
    let step = 1;
    for (; ; ) {
      let change = clone(this.changes[change_num], true);
      if (change.utcOffset < change.prevUtcOffset) {
        Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
      } else {
        Timezone.adjust_change(
          change,
          0,
          0,
          0,
          change.prevUtcOffset
        );
      }
      let cmp = Timezone._compare_change_fn(tt_change, change);
      if (cmp >= 0) {
        change_num_to_use = change_num;
      } else {
        step = -1;
      }
      if (step == -1 && change_num_to_use != -1) {
        break;
      }
      change_num += step;
      if (change_num < 0) {
        return 0;
      }
      if (change_num >= this.changes.length) {
        break;
      }
    }
    let zone_change = this.changes[change_num_to_use];
    let utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;
    if (utcOffset_change < 0 && change_num_to_use > 0) {
      let tmp_change = clone(zone_change, true);
      Timezone.adjust_change(tmp_change, 0, 0, 0, tmp_change.prevUtcOffset);
      if (Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
        let prev_zone_change = this.changes[change_num_to_use - 1];
        let want_daylight = false;
        if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {
          zone_change = prev_zone_change;
        }
      }
    }
    return zone_change.utcOffset;
  }
  _findNearbyChange(change) {
    let idx = binsearchInsert(
      this.changes,
      change,
      Timezone._compare_change_fn
    );
    if (idx >= this.changes.length) {
      return this.changes.length - 1;
    }
    return idx;
  }
  _ensureCoverage(aYear) {
    if (Timezone._minimumExpansionYear == -1) {
      let today = Time.now();
      Timezone._minimumExpansionYear = today.year;
    }
    let changesEndYear = aYear;
    if (changesEndYear < Timezone._minimumExpansionYear) {
      changesEndYear = Timezone._minimumExpansionYear;
    }
    changesEndYear += Timezone.EXTRA_COVERAGE;
    if (!this.changes.length || this.expandedUntilYear < aYear) {
      let subcomps = this.component.getAllSubcomponents();
      let compLen = subcomps.length;
      let compIdx = 0;
      for (; compIdx < compLen; compIdx++) {
        this._expandComponent(
          subcomps[compIdx],
          changesEndYear,
          this.changes
        );
      }
      this.changes.sort(Timezone._compare_change_fn);
      this.expandedUntilYear = changesEndYear;
    }
  }
  _expandComponent(aComponent, aYear, changes) {
    if (!aComponent.hasProperty("dtstart") || !aComponent.hasProperty("tzoffsetto") || !aComponent.hasProperty("tzoffsetfrom")) {
      return null;
    }
    let dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
    let change;
    function convert_tzoffset(offset) {
      return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
    }
    function init_changes() {
      let changebase = {};
      changebase.is_daylight = aComponent.name == "daylight";
      changebase.utcOffset = convert_tzoffset(
        aComponent.getFirstProperty("tzoffsetto").getFirstValue()
      );
      changebase.prevUtcOffset = convert_tzoffset(
        aComponent.getFirstProperty("tzoffsetfrom").getFirstValue()
      );
      return changebase;
    }
    if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
      change = init_changes();
      change.year = dtstart.year;
      change.month = dtstart.month;
      change.day = dtstart.day;
      change.hour = dtstart.hour;
      change.minute = dtstart.minute;
      change.second = dtstart.second;
      Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);
      changes.push(change);
    } else {
      let props = aComponent.getAllProperties("rdate");
      for (let rdate of props) {
        let time = rdate.getFirstValue();
        change = init_changes();
        change.year = time.year;
        change.month = time.month;
        change.day = time.day;
        if (time.isDate) {
          change.hour = dtstart.hour;
          change.minute = dtstart.minute;
          change.second = dtstart.second;
          if (dtstart.zone != Timezone.utcTimezone) {
            Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);
          }
        } else {
          change.hour = time.hour;
          change.minute = time.minute;
          change.second = time.second;
          if (time.zone != Timezone.utcTimezone) {
            Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);
          }
        }
        changes.push(change);
      }
      let rrule = aComponent.getFirstProperty("rrule");
      if (rrule) {
        rrule = rrule.getFirstValue();
        change = init_changes();
        if (rrule.until && rrule.until.zone == Timezone.utcTimezone) {
          rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
          rrule.until.zone = Timezone.localTimezone;
        }
        let iterator = rrule.iterator(dtstart);
        let occ;
        while (occ = iterator.next()) {
          change = init_changes();
          if (occ.year > aYear || !occ) {
            break;
          }
          change.year = occ.year;
          change.month = occ.month;
          change.day = occ.day;
          change.hour = occ.hour;
          change.minute = occ.minute;
          change.second = occ.second;
          change.isDate = occ.isDate;
          Timezone.adjust_change(change, 0, 0, 0, -change.prevUtcOffset);
          changes.push(change);
        }
      }
    }
    return changes;
  }
  /**
   * The string representation of this timezone.
   * @return {String}
   */
  toString() {
    return this.tznames ? this.tznames : this.tzid;
  }
};
let zones$1 = null;
const TimezoneService = {
  get count() {
    if (zones$1 === null) {
      return 0;
    }
    return Object.keys(zones$1).length;
  },
  reset: function() {
    zones$1 = /* @__PURE__ */ Object.create(null);
    let utc = Timezone$1.utcTimezone;
    zones$1.Z = utc;
    zones$1.UTC = utc;
    zones$1.GMT = utc;
  },
  _hard_reset: function() {
    zones$1 = null;
  },
  /**
   * Checks if timezone id has been registered.
   *
   * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
   * @return {Boolean}        False, when not present
   */
  has: function(tzid) {
    if (zones$1 === null) {
      return false;
    }
    return !!zones$1[tzid];
  },
  /**
   * Returns a timezone by its tzid if present.
   *
   * @param {String} tzid               Timezone identifier (e.g. America/Los_Angeles)
   * @return {Timezone | undefined}     The timezone, or undefined if not found
   */
  get: function(tzid) {
    if (zones$1 === null) {
      this.reset();
    }
    return zones$1[tzid];
  },
  /**
   * Registers a timezone object or component.
   *
   * @param {Component|Timezone} timezone
   *        The initialized zone or vtimezone.
   *
   * @param {String=} name
   *        The name of the timezone. Defaults to the component's TZID if not
   *        passed.
   */
  register: function(timezone, name) {
    if (zones$1 === null) {
      this.reset();
    }
    if (typeof timezone === "string" && name instanceof Timezone$1) {
      [timezone, name] = [name, timezone];
    }
    if (!name) {
      if (timezone instanceof Timezone$1) {
        name = timezone.tzid;
      } else {
        if (timezone.name === "vtimezone") {
          timezone = new Timezone$1(timezone);
          name = timezone.tzid;
        }
      }
    }
    if (!name) {
      throw new TypeError("Neither a timezone nor a name was passed");
    }
    if (timezone instanceof Timezone$1) {
      zones$1[name] = timezone;
    } else {
      throw new TypeError("timezone must be ICAL.Timezone or ICAL.Component");
    }
  },
  /**
   * Removes a timezone by its tzid from the list.
   *
   * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
   * @return {?Timezone}      The removed timezone, or null if not registered
   */
  remove: function(tzid) {
    if (zones$1 === null) {
      return null;
    }
    return delete zones$1[tzid];
  }
};
function updateTimezones(vcal) {
  let allsubs, properties, vtimezones, reqTzid, i;
  if (!vcal || vcal.name !== "vcalendar") {
    return vcal;
  }
  allsubs = vcal.getAllSubcomponents();
  properties = [];
  vtimezones = {};
  for (i = 0; i < allsubs.length; i++) {
    if (allsubs[i].name === "vtimezone") {
      let tzid = allsubs[i].getFirstProperty("tzid").getFirstValue();
      vtimezones[tzid] = allsubs[i];
    } else {
      properties = properties.concat(allsubs[i].getAllProperties());
    }
  }
  reqTzid = {};
  for (i = 0; i < properties.length; i++) {
    let tzid = properties[i].getParameter("tzid");
    if (tzid) {
      reqTzid[tzid] = true;
    }
  }
  for (let [tzid, comp] of Object.entries(vtimezones)) {
    if (!reqTzid[tzid]) {
      vcal.removeSubcomponent(comp);
    }
  }
  for (let tzid of Object.keys(reqTzid)) {
    if (!vtimezones[tzid] && TimezoneService.has(tzid)) {
      vcal.addSubcomponent(TimezoneService.get(tzid).component);
    }
  }
  return vcal;
}
function isStrictlyNaN(number) {
  return typeof number === "number" && isNaN(number);
}
function strictParseInt(string) {
  let result = parseInt(string, 10);
  if (isStrictlyNaN(result)) {
    throw new Error(
      'Could not extract integer from "' + string + '"'
    );
  }
  return result;
}
function formatClassType(data, type) {
  if (typeof data === "undefined") {
    return void 0;
  }
  if (data instanceof type) {
    return data;
  }
  return new type(data);
}
function unescapedIndexOf(buffer, search, pos) {
  while ((pos = buffer.indexOf(search, pos)) !== -1) {
    if (pos > 0 && buffer[pos - 1] === "\\") {
      pos += 1;
    } else {
      return pos;
    }
  }
  return -1;
}
function binsearchInsert(list, seekVal, cmpfunc) {
  if (!list.length)
    return 0;
  let low = 0, high = list.length - 1, mid, cmpval;
  while (low <= high) {
    mid = low + Math.floor((high - low) / 2);
    cmpval = cmpfunc(seekVal, list[mid]);
    if (cmpval < 0)
      high = mid - 1;
    else if (cmpval > 0)
      low = mid + 1;
    else
      break;
  }
  if (cmpval < 0)
    return mid;
  else if (cmpval > 0)
    return mid + 1;
  else
    return mid;
}
function clone(aSrc, aDeep) {
  if (!aSrc || typeof aSrc != "object") {
    return aSrc;
  } else if (aSrc instanceof Date) {
    return new Date(aSrc.getTime());
  } else if ("clone" in aSrc) {
    return aSrc.clone();
  } else if (Array.isArray(aSrc)) {
    let arr = [];
    for (let i = 0; i < aSrc.length; i++) {
      arr.push(aDeep ? clone(aSrc[i], true) : aSrc[i]);
    }
    return arr;
  } else {
    let obj = {};
    for (let [name, value] of Object.entries(aSrc)) {
      if (aDeep) {
        obj[name] = clone(value, true);
      } else {
        obj[name] = value;
      }
    }
    return obj;
  }
}
function foldline(aLine) {
  let result = "";
  let line = aLine || "", pos = 0, line_length = 0;
  while (line.length) {
    let cp = line.codePointAt(pos);
    if (cp < 128) ++line_length;
    else if (cp < 2048) line_length += 2;
    else if (cp < 65536) line_length += 3;
    else line_length += 4;
    if (line_length < ICALmodule.foldLength + 1)
      pos += cp > 65535 ? 2 : 1;
    else {
      result += ICALmodule.newLineChar + " " + line.slice(0, Math.max(0, pos));
      line = line.slice(Math.max(0, pos));
      pos = line_length = 0;
    }
  }
  return result.slice(ICALmodule.newLineChar.length + 1);
}
function pad2(data) {
  if (typeof data !== "string") {
    if (typeof data === "number") {
      data = parseInt(data);
    }
    data = String(data);
  }
  let len = data.length;
  switch (len) {
    case 0:
      return "00";
    case 1:
      return "0" + data;
    default:
      return data;
  }
}
function trunc(number) {
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function extend(source, target) {
  for (let key in source) {
    let descr = Object.getOwnPropertyDescriptor(source, key);
    if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
      Object.defineProperty(target, key, descr);
    }
  }
  return target;
}
var helpers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  binsearchInsert,
  clone,
  extend,
  foldline,
  formatClassType,
  isStrictlyNaN,
  pad2,
  strictParseInt,
  trunc,
  unescapedIndexOf,
  updateTimezones
});
class UtcOffset {
  /**
   * Creates a new {@link ICAL.UtcOffset} instance from the passed string.
   *
   * @param {String} aString    The string to parse
   * @return {Duration}         The created utc-offset instance
   */
  static fromString(aString) {
    let options = {};
    options.factor = aString[0] === "+" ? 1 : -1;
    options.hours = strictParseInt(aString.slice(1, 3));
    options.minutes = strictParseInt(aString.slice(4, 6));
    return new UtcOffset(options);
  }
  /**
   * Creates a new {@link ICAL.UtcOffset} instance from the passed seconds
   * value.
   *
   * @param {Number} aSeconds       The number of seconds to convert
   */
  static fromSeconds(aSeconds) {
    let instance = new UtcOffset();
    instance.fromSeconds(aSeconds);
    return instance;
  }
  /**
   * Creates a new ICAL.UtcOffset instance.
   *
   * @param {Object} aData          An object with members of the utc offset
   * @param {Number=} aData.hours   The hours for the utc offset
   * @param {Number=} aData.minutes The minutes in the utc offset
   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
   */
  constructor(aData) {
    this.fromData(aData);
  }
  /**
   * The hours in the utc-offset
   * @type {Number}
   */
  hours = 0;
  /**
   * The minutes in the utc-offset
   * @type {Number}
   */
  minutes = 0;
  /**
   * The sign of the utc offset, 1 for positive offset, -1 for negative
   * offsets.
   * @type {Number}
   */
  factor = 1;
  /**
   * The type name, to be used in the jCal object.
   * @constant
   * @type {String}
   * @default "utc-offset"
   */
  icaltype = "utc-offset";
  /**
   * Returns a clone of the utc offset object.
   *
   * @return {UtcOffset}     The cloned object
   */
  clone() {
    return UtcOffset.fromSeconds(this.toSeconds());
  }
  /**
   * Sets up the current instance using members from the passed data object.
   *
   * @param {Object} aData          An object with members of the utc offset
   * @param {Number=} aData.hours   The hours for the utc offset
   * @param {Number=} aData.minutes The minutes in the utc offset
   * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
   */
  fromData(aData) {
    if (aData) {
      for (let [key, value] of Object.entries(aData)) {
        this[key] = value;
      }
    }
    this._normalize();
  }
  /**
   * Sets up the current instance from the given seconds value. The seconds
   * value is truncated to the minute. Offsets are wrapped when the world
   * ends, the hour after UTC+14:00 is UTC-12:00.
   *
   * @param {Number} aSeconds         The seconds to convert into an offset
   */
  fromSeconds(aSeconds) {
    let secs = Math.abs(aSeconds);
    this.factor = aSeconds < 0 ? -1 : 1;
    this.hours = trunc(secs / 3600);
    secs -= this.hours * 3600;
    this.minutes = trunc(secs / 60);
    return this;
  }
  /**
   * Convert the current offset to a value in seconds
   *
   * @return {Number}                 The offset in seconds
   */
  toSeconds() {
    return this.factor * (60 * this.minutes + 3600 * this.hours);
  }
  /**
   * Compare this utc offset with another one.
   *
   * @param {UtcOffset} other             The other offset to compare with
   * @return {Number}                     -1, 0 or 1 for less/equal/greater
   */
  compare(other) {
    let a = this.toSeconds();
    let b = other.toSeconds();
    return (a > b) - (b > a);
  }
  _normalize() {
    let secs = this.toSeconds();
    let factor = this.factor;
    while (secs < -43200) {
      secs += 97200;
    }
    while (secs > 50400) {
      secs -= 97200;
    }
    this.fromSeconds(secs);
    if (secs == 0) {
      this.factor = factor;
    }
  }
  /**
   * The iCalendar string representation of this utc-offset.
   * @return {String}
   */
  toICALString() {
    return design.icalendar.value["utc-offset"].toICAL(this.toString());
  }
  /**
   * The string representation of this utc-offset.
   * @return {String}
   */
  toString() {
    return (this.factor == 1 ? "+" : "-") + pad2(this.hours) + ":" + pad2(this.minutes);
  }
}
class VCardTime extends Time {
  /**
   * Returns a new ICAL.VCardTime instance from a date and/or time string.
   *
   * @param {String} aValue     The string to create from
   * @param {String} aIcalType  The type for this instance, e.g. date-and-or-time
   * @return {VCardTime}        The date/time instance
   */
  static fromDateAndOrTimeString(aValue, aIcalType) {
    function part(v2, s, e2) {
      return v2 ? strictParseInt(v2.slice(s, s + e2)) : null;
    }
    let parts = aValue.split("T");
    let dt2 = parts[0], tmz = parts[1];
    let splitzone = tmz ? design.vcard.value.time._splitZone(tmz) : [];
    let zone = splitzone[0], tm = splitzone[1];
    let dtlen = dt2 ? dt2.length : 0;
    let tmlen = tm ? tm.length : 0;
    let hasDashDate = dt2 && dt2[0] == "-" && dt2[1] == "-";
    let hasDashTime = tm && tm[0] == "-";
    let o = {
      year: hasDashDate ? null : part(dt2, 0, 4),
      month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt2, 2, 2) : dtlen == 7 ? part(dt2, 5, 2) : dtlen == 10 ? part(dt2, 5, 2) : null,
      day: dtlen == 5 ? part(dt2, 3, 2) : dtlen == 7 && hasDashDate ? part(dt2, 5, 2) : dtlen == 10 ? part(dt2, 8, 2) : null,
      hour: hasDashTime ? null : part(tm, 0, 2),
      minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
      second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
    };
    if (zone == "Z") {
      zone = Timezone$1.utcTimezone;
    } else if (zone && zone[3] == ":") {
      zone = UtcOffset.fromString(zone);
    } else {
      zone = null;
    }
    return new VCardTime(o, zone, aIcalType);
  }
  /**
   * Creates a new ICAL.VCardTime instance.
   *
   * @param {Object} data                           The data for the time instance
   * @param {Number=} data.year                     The year for this date
   * @param {Number=} data.month                    The month for this date
   * @param {Number=} data.day                      The day for this date
   * @param {Number=} data.hour                     The hour for this date
   * @param {Number=} data.minute                   The minute for this date
   * @param {Number=} data.second                   The second for this date
   * @param {Timezone|UtcOffset} zone               The timezone to use
   * @param {String} icaltype                       The type for this date/time object
   */
  constructor(data, zone, icaltype) {
    super(data, zone);
    this.icaltype = icaltype || "date-and-or-time";
  }
  /**
   * The class identifier.
   * @constant
   * @type {String}
   * @default "vcardtime"
   */
  icalclass = "vcardtime";
  /**
   * The type name, to be used in the jCal object.
   * @type {String}
   * @default "date-and-or-time"
   */
  icaltype = "date-and-or-time";
  /**
   * Returns a clone of the vcard date/time object.
   *
   * @return {VCardTime}     The cloned object
   */
  clone() {
    return new VCardTime(this._time, this.zone, this.icaltype);
  }
  _normalize() {
    return this;
  }
  /**
   * @inheritdoc
   */
  utcOffset() {
    if (this.zone instanceof UtcOffset) {
      return this.zone.toSeconds();
    } else {
      return Time.prototype.utcOffset.apply(this, arguments);
    }
  }
  /**
   * Returns an RFC 6350 compliant representation of this object.
   *
   * @return {String}         vcard date/time string
   */
  toICALString() {
    return design.vcard.value[this.icaltype].toICAL(this.toString());
  }
  /**
   * The string representation of this date/time, in jCard form
   * (including : and - separators).
   * @return {String}
   */
  toString() {
    let y = this.year, m = this.month, d = this.day;
    let h2 = this.hour, mm = this.minute, s = this.second;
    let hasYear = y !== null, hasMonth = m !== null, hasDay = d !== null;
    let hasHour = h2 !== null, hasMinute = mm !== null, hasSecond = s !== null;
    let datepart = (hasYear ? pad2(y) + (hasMonth || hasDay ? "-" : "") : hasMonth || hasDay ? "--" : "") + (hasMonth ? pad2(m) : "") + (hasDay ? "-" + pad2(d) : "");
    let timepart = (hasHour ? pad2(h2) : "-") + (hasHour && hasMinute ? ":" : "") + (hasMinute ? pad2(mm) : "") + (!hasHour && !hasMinute ? "-" : "") + (hasMinute && hasSecond ? ":" : "") + (hasSecond ? pad2(s) : "");
    let zone;
    if (this.zone === Timezone$1.utcTimezone) {
      zone = "Z";
    } else if (this.zone instanceof UtcOffset) {
      zone = this.zone.toString();
    } else if (this.zone === Timezone$1.localTimezone) {
      zone = "";
    } else if (this.zone instanceof Timezone$1) {
      let offset = UtcOffset.fromSeconds(this.zone.utcOffset(this));
      zone = offset.toString();
    } else {
      zone = "";
    }
    switch (this.icaltype) {
      case "time":
        return timepart + zone;
      case "date-and-or-time":
      case "date-time":
        return datepart + (timepart == "--" ? "" : "T" + timepart + zone);
      case "date":
        return datepart;
    }
    return null;
  }
}
class RecurIterator {
  static _indexMap = {
    "BYSECOND": 0,
    "BYMINUTE": 1,
    "BYHOUR": 2,
    "BYDAY": 3,
    "BYMONTHDAY": 4,
    "BYYEARDAY": 5,
    "BYWEEKNO": 6,
    "BYMONTH": 7,
    "BYSETPOS": 8
  };
  static _expandMap = {
    "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
    "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
    "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
    "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
    "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
    "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
    "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
  };
  static UNKNOWN = 0;
  static CONTRACT = 1;
  static EXPAND = 2;
  static ILLEGAL = 3;
  /**
   * Creates a new ICAL.RecurIterator instance. The options object may contain additional members
   * when resuming iteration from a previous run.
   *
   * @param {Object} options                The iterator options
   * @param {Recur} options.rule            The rule to iterate.
   * @param {Time} options.dtstart          The start date of the event.
   * @param {Boolean=} options.initialized  When true, assume that options are
   *        from a previously constructed iterator. Initialization will not be
   *        repeated.
   */
  constructor(options) {
    this.fromData(options);
  }
  /**
   * True when iteration is finished.
   * @type {Boolean}
   */
  completed = false;
  /**
   * The rule that is being iterated
   * @type {Recur}
   */
  rule = null;
  /**
   * The start date of the event being iterated.
   * @type {Time}
   */
  dtstart = null;
  /**
   * The last occurrence that was returned from the
   * {@link RecurIterator#next} method.
   * @type {Time}
   */
  last = null;
  /**
   * The sequence number from the occurrence
   * @type {Number}
   */
  occurrence_number = 0;
  /**
   * The indices used for the {@link ICAL.RecurIterator#by_data} object.
   * @type {Object}
   * @private
   */
  by_indices = null;
  /**
   * If true, the iterator has already been initialized
   * @type {Boolean}
   * @private
   */
  initialized = false;
  /**
   * The initializd by-data.
   * @type {Object}
   * @private
   */
  by_data = null;
  /**
   * The expanded yeardays
   * @type {Array}
   * @private
   */
  days = null;
  /**
   * The index in the {@link ICAL.RecurIterator#days} array.
   * @type {Number}
   * @private
   */
  days_index = 0;
  /**
   * Initialize the recurrence iterator from the passed data object. This
   * method is usually not called directly, you can initialize the iterator
   * through the constructor.
   *
   * @param {Object} options                The iterator options
   * @param {Recur} options.rule            The rule to iterate.
   * @param {Time} options.dtstart          The start date of the event.
   * @param {Boolean=} options.initialized  When true, assume that options are
   *        from a previously constructed iterator. Initialization will not be
   *        repeated.
   */
  fromData(options) {
    this.rule = formatClassType(options.rule, Recur);
    if (!this.rule) {
      throw new Error("iterator requires a (ICAL.Recur) rule");
    }
    this.dtstart = formatClassType(options.dtstart, Time);
    if (!this.dtstart) {
      throw new Error("iterator requires a (ICAL.Time) dtstart");
    }
    if (options.by_data) {
      this.by_data = options.by_data;
    } else {
      this.by_data = clone(this.rule.parts, true);
    }
    if (options.occurrence_number)
      this.occurrence_number = options.occurrence_number;
    this.days = options.days || [];
    if (options.last) {
      this.last = formatClassType(options.last, Time);
    }
    this.by_indices = options.by_indices;
    if (!this.by_indices) {
      this.by_indices = {
        "BYSECOND": 0,
        "BYMINUTE": 0,
        "BYHOUR": 0,
        "BYDAY": 0,
        "BYMONTH": 0,
        "BYWEEKNO": 0,
        "BYMONTHDAY": 0
      };
    }
    this.initialized = options.initialized || false;
    if (!this.initialized) {
      try {
        this.init();
      } catch (e2) {
        if (e2 instanceof InvalidRecurrenceRuleError) {
          this.completed = true;
        } else {
          throw e2;
        }
      }
    }
  }
  /**
   * Initialize the iterator
   * @private
   */
  init() {
    this.initialized = true;
    this.last = this.dtstart.clone();
    let parts = this.by_data;
    if ("BYDAY" in parts) {
      this.sort_byday_rules(parts.BYDAY);
    }
    if ("BYYEARDAY" in parts) {
      if ("BYMONTH" in parts || "BYWEEKNO" in parts || "BYMONTHDAY" in parts) {
        throw new Error("Invalid BYYEARDAY rule");
      }
    }
    if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
      throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
    }
    if (this.rule.freq == "MONTHLY" && ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
      throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
    }
    if (this.rule.freq == "WEEKLY" && ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
      throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
    }
    if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
      throw new Error("BYYEARDAY may only appear in YEARLY rules");
    }
    this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
    this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
    this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
    this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
    this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);
    if (this.rule.freq == "WEEKLY") {
      if ("BYDAY" in parts) {
        let [, dow] = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
        let wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
        if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {
          this.last.day += wkdy;
        }
      } else {
        let dayName = Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
        parts.BYDAY = [dayName];
      }
    }
    if (this.rule.freq == "YEARLY") {
      const untilYear = this.rule.until ? this.rule.until.year : 2e4;
      while (this.last.year <= untilYear) {
        this.expand_year_days(this.last.year);
        if (this.days.length > 0) {
          break;
        }
        this.increment_year(this.rule.interval);
      }
      if (this.days.length == 0) {
        throw new InvalidRecurrenceRuleError();
      }
      if (!this._nextByYearDay() && !this.next_year() && !this.next_year() && !this.next_year()) {
        throw new InvalidRecurrenceRuleError();
      }
    }
    if (this.rule.freq == "MONTHLY") {
      if (this.has_by_data("BYDAY")) {
        let tempLast = null;
        let initLast = this.last.clone();
        let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);
        for (let bydow of this.by_data.BYDAY) {
          this.last = initLast.clone();
          let [pos, dow] = this.ruleDayOfWeek(bydow);
          let dayOfMonth = this.last.nthWeekDay(dow, pos);
          if (pos >= 6 || pos <= -6) {
            throw new Error("Malformed values in BYDAY part");
          }
          if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
            if (tempLast && tempLast.month == initLast.month) {
              continue;
            }
            while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
              this.increment_month();
              daysInMonth = Time.daysInMonth(this.last.month, this.last.year);
              dayOfMonth = this.last.nthWeekDay(dow, pos);
            }
          }
          this.last.day = dayOfMonth;
          if (!tempLast || this.last.compare(tempLast) < 0) {
            tempLast = this.last.clone();
          }
        }
        this.last = tempLast.clone();
        if (this.has_by_data("BYMONTHDAY")) {
          this._byDayAndMonthDay(true);
        }
        if (this.last.day > daysInMonth || this.last.day == 0) {
          throw new Error("Malformed values in BYDAY part");
        }
      } else if (this.has_by_data("BYMONTHDAY")) {
        this.last.day = 1;
        let normalized = this.normalizeByMonthDayRules(
          this.last.year,
          this.last.month,
          this.rule.parts.BYMONTHDAY
        ).filter((d) => d >= this.last.day);
        if (normalized.length) {
          this.last.day = normalized[0];
          this.by_data.BYMONTHDAY = normalized;
        } else {
          if (!this.next_month() && !this.next_month() && !this.next_month()) {
            throw new InvalidRecurrenceRuleError();
          }
        }
      }
    }
  }
  /**
   * Retrieve the next occurrence from the iterator.
   * @return {Time}
   */
  next(again = false) {
    let before = this.last ? this.last.clone() : null;
    if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {
      this.completed = true;
    }
    if (this.completed) {
      return null;
    }
    if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
      this.occurrence_number++;
      return this.last;
    }
    let valid;
    let invalid_count = 0;
    do {
      valid = 1;
      switch (this.rule.freq) {
        case "SECONDLY":
          this.next_second();
          break;
        case "MINUTELY":
          this.next_minute();
          break;
        case "HOURLY":
          this.next_hour();
          break;
        case "DAILY":
          this.next_day();
          break;
        case "WEEKLY":
          this.next_week();
          break;
        case "MONTHLY":
          valid = this.next_month();
          if (valid) {
            invalid_count = 0;
          } else if (++invalid_count == 336) {
            this.completed = true;
            return null;
          }
          break;
        case "YEARLY":
          valid = this.next_year();
          if (valid) {
            invalid_count = 0;
          } else if (++invalid_count == 28) {
            this.completed = true;
            return null;
          }
          break;
        default:
          return null;
      }
    } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);
    if (this.last.compare(before) == 0) {
      if (again) {
        throw new Error("Same occurrence found twice, protecting you from death by recursion");
      }
      this.next(true);
    }
    if (this.rule.until && this.last.compare(this.rule.until) > 0) {
      this.completed = true;
      return null;
    } else {
      this.occurrence_number++;
      return this.last;
    }
  }
  next_second() {
    return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
  }
  increment_second(inc) {
    return this.increment_generic(inc, "second", 60, "minute");
  }
  next_minute() {
    return this.next_generic(
      "BYMINUTE",
      "MINUTELY",
      "minute",
      "hour",
      "next_second"
    );
  }
  increment_minute(inc) {
    return this.increment_generic(inc, "minute", 60, "hour");
  }
  next_hour() {
    return this.next_generic(
      "BYHOUR",
      "HOURLY",
      "hour",
      "monthday",
      "next_minute"
    );
  }
  increment_hour(inc) {
    this.increment_generic(inc, "hour", 24, "monthday");
  }
  next_day() {
    let this_freq = this.rule.freq == "DAILY";
    if (this.next_hour() == 0) {
      return 0;
    }
    if (this_freq) {
      this.increment_monthday(this.rule.interval);
    } else {
      this.increment_monthday(1);
    }
    return 0;
  }
  next_week() {
    let end_of_data = 0;
    if (this.next_weekday_by_week() == 0) {
      return end_of_data;
    }
    if (this.has_by_data("BYWEEKNO")) {
      this.by_indices.BYWEEKNO++;
      if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
        this.by_indices.BYWEEKNO = 0;
        end_of_data = 1;
      }
      this.last.month = 1;
      this.last.day = 1;
      let week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];
      this.last.day += 7 * week_no;
      if (end_of_data) {
        this.increment_year(1);
      }
    } else {
      this.increment_monthday(7 * this.rule.interval);
    }
    return end_of_data;
  }
  /**
   * Normalize each by day rule for a given year/month.
   * Takes into account ordering and negative rules
   *
   * @private
   * @param {Number} year         Current year.
   * @param {Number} month        Current month.
   * @param {Array}  rules        Array of rules.
   *
   * @return {Array} sorted and normalized rules.
   *                 Negative rules will be expanded to their
   *                 correct positive values for easier processing.
   */
  normalizeByMonthDayRules(year, month, rules) {
    let daysInMonth = Time.daysInMonth(month, year);
    let newRules = [];
    let ruleIdx = 0;
    let len = rules.length;
    let rule;
    for (; ruleIdx < len; ruleIdx++) {
      rule = parseInt(rules[ruleIdx], 10);
      if (isNaN(rule)) {
        throw new Error("Invalid BYMONTHDAY value");
      }
      if (Math.abs(rule) > daysInMonth) {
        continue;
      }
      if (rule < 0) {
        rule = daysInMonth + (rule + 1);
      } else if (rule === 0) {
        continue;
      }
      if (newRules.indexOf(rule) === -1) {
        newRules.push(rule);
      }
    }
    return newRules.sort(function(a, b) {
      return a - b;
    });
  }
  /**
   * NOTES:
   * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)
   * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when
   * both conditions match a given date (this.last.day) iteration stops.
   *
   * @private
   * @param {Boolean=} isInit     When given true will not increment the
   *                                current day (this.last).
   */
  _byDayAndMonthDay(isInit) {
    let byMonthDay;
    let byDay = this.by_data.BYDAY;
    let date;
    let dateIdx = 0;
    let dateLen;
    let dayLen = byDay.length;
    let dataIsValid = 0;
    let daysInMonth;
    let self2 = this;
    let lastDay = this.last.day;
    function initMonth() {
      daysInMonth = Time.daysInMonth(
        self2.last.month,
        self2.last.year
      );
      byMonthDay = self2.normalizeByMonthDayRules(
        self2.last.year,
        self2.last.month,
        self2.by_data.BYMONTHDAY
      );
      dateLen = byMonthDay.length;
      while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {
        dateIdx++;
      }
    }
    function nextMonth() {
      lastDay = 0;
      self2.increment_month();
      dateIdx = 0;
      initMonth();
    }
    initMonth();
    if (isInit) {
      lastDay -= 1;
    }
    let monthsCounter = 48;
    while (!dataIsValid && monthsCounter) {
      monthsCounter--;
      date = lastDay + 1;
      if (date > daysInMonth) {
        nextMonth();
        continue;
      }
      let next = byMonthDay[dateIdx++];
      if (next >= date) {
        lastDay = next;
      } else {
        nextMonth();
        continue;
      }
      for (let dayIdx = 0; dayIdx < dayLen; dayIdx++) {
        let parts = this.ruleDayOfWeek(byDay[dayIdx]);
        let pos = parts[0];
        let dow = parts[1];
        this.last.day = lastDay;
        if (this.last.isNthWeekDay(dow, pos)) {
          dataIsValid = 1;
          break;
        }
      }
      if (!dataIsValid && dateIdx === dateLen) {
        nextMonth();
        continue;
      }
    }
    if (monthsCounter <= 0) {
      throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
    }
    return dataIsValid;
  }
  next_month() {
    let data_valid = 1;
    if (this.next_hour() == 0) {
      return data_valid;
    }
    if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
      data_valid = this._byDayAndMonthDay();
    } else if (this.has_by_data("BYDAY")) {
      let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);
      let setpos = 0;
      let setpos_total = 0;
      if (this.has_by_data("BYSETPOS")) {
        let last_day = this.last.day;
        for (let day2 = 1; day2 <= daysInMonth; day2++) {
          this.last.day = day2;
          if (this.is_day_in_byday(this.last)) {
            setpos_total++;
            if (day2 <= last_day) {
              setpos++;
            }
          }
        }
        this.last.day = last_day;
      }
      data_valid = 0;
      let day;
      for (day = this.last.day + 1; day <= daysInMonth; day++) {
        this.last.day = day;
        if (this.is_day_in_byday(this.last)) {
          if (!this.has_by_data("BYSETPOS") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {
            data_valid = 1;
            break;
          }
        }
      }
      if (day > daysInMonth) {
        this.last.day = 1;
        this.increment_month();
        if (this.is_day_in_byday(this.last)) {
          if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
            data_valid = 1;
          }
        } else {
          data_valid = 0;
        }
      }
    } else if (this.has_by_data("BYMONTHDAY")) {
      this.by_indices.BYMONTHDAY++;
      if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
        this.by_indices.BYMONTHDAY = 0;
        this.increment_month();
        if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
          return 0;
        }
      }
      let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);
      let day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];
      if (day < 0) {
        day = daysInMonth + day + 1;
      }
      if (day > daysInMonth) {
        this.last.day = 1;
        data_valid = this.is_day_in_byday(this.last);
      } else {
        this.last.day = day;
      }
    } else {
      this.increment_month();
      let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);
      if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
        data_valid = 0;
      } else {
        this.last.day = this.by_data.BYMONTHDAY[0];
      }
    }
    return data_valid;
  }
  next_weekday_by_week() {
    let end_of_data = 0;
    if (this.next_hour() == 0) {
      return end_of_data;
    }
    if (!this.has_by_data("BYDAY")) {
      return 1;
    }
    for (; ; ) {
      let tt2 = new Time();
      this.by_indices.BYDAY++;
      if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
        this.by_indices.BYDAY = 0;
        end_of_data = 1;
      }
      let coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
      let parts = this.ruleDayOfWeek(coded_day);
      let dow = parts[1];
      dow -= this.rule.wkst;
      if (dow < 0) {
        dow += 7;
      }
      tt2.year = this.last.year;
      tt2.month = this.last.month;
      tt2.day = this.last.day;
      let startOfWeek2 = tt2.startDoyWeek(this.rule.wkst);
      if (dow + startOfWeek2 < 1) {
        if (!end_of_data) {
          continue;
        }
      }
      let next = Time.fromDayOfYear(startOfWeek2 + dow, this.last.year);
      this.last.year = next.year;
      this.last.month = next.month;
      this.last.day = next.day;
      return end_of_data;
    }
  }
  next_year() {
    if (this.next_hour() == 0) {
      return 0;
    }
    if (this.days.length == 0 || ++this.days_index == this.days.length) {
      this.days_index = 0;
      this.increment_year(this.rule.interval);
      if (this.has_by_data("BYMONTHDAY")) {
        this.by_data.BYMONTHDAY = this.normalizeByMonthDayRules(
          this.last.year,
          this.last.month,
          this.rule.parts.BYMONTHDAY
        );
      }
      this.expand_year_days(this.last.year);
      if (this.days.length == 0) {
        return 0;
      }
    }
    return this._nextByYearDay();
  }
  _nextByYearDay() {
    let doy = this.days[this.days_index];
    let year = this.last.year;
    if (Math.abs(doy) == 366 && !Time.isLeapYear(this.last.year)) {
      return 0;
    }
    if (doy < 1) {
      doy += 1;
      year += 1;
    }
    let next = Time.fromDayOfYear(doy, year);
    this.last.day = next.day;
    this.last.month = next.month;
    return 1;
  }
  /**
   * @param dow (eg: '1TU', '-1MO')
   * @param {weekDay=} aWeekStart The week start weekday
   * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart
   */
  ruleDayOfWeek(dow, aWeekStart) {
    let matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
    if (matches) {
      let pos = parseInt(matches[1] || 0, 10);
      dow = Recur.icalDayToNumericDay(matches[2], aWeekStart);
      return [pos, dow];
    } else {
      return [0, 0];
    }
  }
  next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {
    let has_by_rule = aRuleType in this.by_data;
    let this_freq = this.rule.freq == aInterval;
    let end_of_data = 0;
    if (aPreviousIncr && this[aPreviousIncr]() == 0) {
      return end_of_data;
    }
    if (has_by_rule) {
      this.by_indices[aRuleType]++;
      let dta = this.by_data[aRuleType];
      if (this.by_indices[aRuleType] == dta.length) {
        this.by_indices[aRuleType] = 0;
        end_of_data = 1;
      }
      this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
    } else if (this_freq) {
      this["increment_" + aDateAttr](this.rule.interval);
    }
    if (has_by_rule && end_of_data && this_freq) {
      this["increment_" + aFollowingAttr](1);
    }
    return end_of_data;
  }
  increment_monthday(inc) {
    for (let i = 0; i < inc; i++) {
      let daysInMonth = Time.daysInMonth(this.last.month, this.last.year);
      this.last.day++;
      if (this.last.day > daysInMonth) {
        this.last.day -= daysInMonth;
        this.increment_month();
      }
    }
  }
  increment_month() {
    this.last.day = 1;
    if (this.has_by_data("BYMONTH")) {
      this.by_indices.BYMONTH++;
      if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
        this.by_indices.BYMONTH = 0;
        this.increment_year(1);
      }
      this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
    } else {
      if (this.rule.freq == "MONTHLY") {
        this.last.month += this.rule.interval;
      } else {
        this.last.month++;
      }
      this.last.month--;
      let years = trunc(this.last.month / 12);
      this.last.month %= 12;
      this.last.month++;
      if (years != 0) {
        this.increment_year(years);
      }
    }
    if (this.has_by_data("BYMONTHDAY")) {
      this.by_data.BYMONTHDAY = this.normalizeByMonthDayRules(
        this.last.year,
        this.last.month,
        this.rule.parts.BYMONTHDAY
      );
    }
  }
  increment_year(inc) {
    this.last.day = 1;
    this.last.year += inc;
  }
  increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {
    this.last[aDateAttr] += inc;
    let nextunit = trunc(this.last[aDateAttr] / aFactor);
    this.last[aDateAttr] %= aFactor;
    if (nextunit != 0) {
      this["increment_" + aNextIncrement](nextunit);
    }
  }
  has_by_data(aRuleType) {
    return aRuleType in this.rule.parts;
  }
  expand_year_days(aYear) {
    let t2 = new Time();
    this.days = [];
    let parts = {};
    let rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
    for (let part of rules) {
      if (part in this.rule.parts) {
        parts[part] = this.rule.parts[part];
      }
    }
    if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
      let valid = 1;
      let validWeeks = {};
      t2.year = aYear;
      t2.isDate = true;
      for (let monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
        let month = this.by_data.BYMONTH[monthIdx];
        t2.month = month;
        t2.day = 1;
        let first_week = t2.weekNumber(this.rule.wkst);
        t2.day = Time.daysInMonth(month, aYear);
        let last_week = t2.weekNumber(this.rule.wkst);
        for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
          validWeeks[monthIdx] = 1;
        }
      }
      for (let weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
        let weekno = this.by_data.BYWEEKNO[weekIdx];
        if (weekno < 52) {
          valid &= validWeeks[weekIdx];
        } else {
          valid = 0;
        }
      }
      if (valid) {
        delete parts.BYMONTH;
      } else {
        delete parts.BYWEEKNO;
      }
    }
    let partCount = Object.keys(parts).length;
    if (partCount == 0) {
      let t1 = this.dtstart.clone();
      t1.year = this.last.year;
      this.days.push(t1.dayOfYear());
    } else if (partCount == 1 && "BYMONTH" in parts) {
      for (let month of this.by_data.BYMONTH) {
        let t22 = this.dtstart.clone();
        t22.year = aYear;
        t22.month = month;
        t22.isDate = true;
        this.days.push(t22.dayOfYear());
      }
    } else if (partCount == 1 && "BYMONTHDAY" in parts) {
      for (let monthday of this.by_data.BYMONTHDAY) {
        let t3 = this.dtstart.clone();
        if (monthday < 0) {
          let daysInMonth = Time.daysInMonth(t3.month, aYear);
          monthday = monthday + daysInMonth + 1;
        }
        t3.day = monthday;
        t3.year = aYear;
        t3.isDate = true;
        this.days.push(t3.dayOfYear());
      }
    } else if (partCount == 2 && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
      for (let month of this.by_data.BYMONTH) {
        let daysInMonth = Time.daysInMonth(month, aYear);
        for (let monthday of this.by_data.BYMONTHDAY) {
          if (monthday < 0) {
            monthday = monthday + daysInMonth + 1;
          }
          t2.day = monthday;
          t2.month = month;
          t2.year = aYear;
          t2.isDate = true;
          this.days.push(t2.dayOfYear());
        }
      }
    } else if (partCount == 1 && "BYWEEKNO" in parts) ;
    else if (partCount == 2 && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) ;
    else if (partCount == 1 && "BYDAY" in parts) {
      this.days = this.days.concat(this.expand_by_day(aYear));
    } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
      for (let month of this.by_data.BYMONTH) {
        let daysInMonth = Time.daysInMonth(month, aYear);
        t2.year = aYear;
        t2.month = month;
        t2.day = 1;
        t2.isDate = true;
        let first_dow = t2.dayOfWeek();
        let doy_offset = t2.dayOfYear() - 1;
        t2.day = daysInMonth;
        let last_dow = t2.dayOfWeek();
        if (this.has_by_data("BYSETPOS")) {
          let by_month_day = [];
          for (let day = 1; day <= daysInMonth; day++) {
            t2.day = day;
            if (this.is_day_in_byday(t2)) {
              by_month_day.push(day);
            }
          }
          for (let spIndex = 0; spIndex < by_month_day.length; spIndex++) {
            if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {
              this.days.push(doy_offset + by_month_day[spIndex]);
            }
          }
        } else {
          for (let coded_day of this.by_data.BYDAY) {
            let bydayParts = this.ruleDayOfWeek(coded_day);
            let pos = bydayParts[0];
            let dow = bydayParts[1];
            let month_day;
            let first_matching_day = (dow + 7 - first_dow) % 7 + 1;
            let last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;
            if (pos == 0) {
              for (let day = first_matching_day; day <= daysInMonth; day += 7) {
                this.days.push(doy_offset + day);
              }
            } else if (pos > 0) {
              month_day = first_matching_day + (pos - 1) * 7;
              if (month_day <= daysInMonth) {
                this.days.push(doy_offset + month_day);
              }
            } else {
              month_day = last_matching_day + (pos + 1) * 7;
              if (month_day > 0) {
                this.days.push(doy_offset + month_day);
              }
            }
          }
        }
      }
      this.days.sort(function(a, b) {
        return a - b;
      });
    } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
      let expandedDays = this.expand_by_day(aYear);
      for (let day of expandedDays) {
        let tt2 = Time.fromDayOfYear(day, aYear);
        if (this.by_data.BYMONTHDAY.indexOf(tt2.day) >= 0) {
          this.days.push(day);
        }
      }
    } else if (partCount == 3 && "BYDAY" in parts && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
      let expandedDays = this.expand_by_day(aYear);
      for (let day of expandedDays) {
        let tt2 = Time.fromDayOfYear(day, aYear);
        if (this.by_data.BYMONTH.indexOf(tt2.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt2.day) >= 0) {
          this.days.push(day);
        }
      }
    } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
      let expandedDays = this.expand_by_day(aYear);
      for (let day of expandedDays) {
        let tt2 = Time.fromDayOfYear(day, aYear);
        let weekno = tt2.weekNumber(this.rule.wkst);
        if (this.by_data.BYWEEKNO.indexOf(weekno)) {
          this.days.push(day);
        }
      }
    } else if (partCount == 3 && "BYDAY" in parts && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) ;
    else if (partCount == 1 && "BYYEARDAY" in parts) {
      this.days = this.days.concat(this.by_data.BYYEARDAY);
    } else if (partCount == 2 && "BYYEARDAY" in parts && "BYDAY" in parts) {
      let daysInYear2 = Time.isLeapYear(aYear) ? 366 : 365;
      let expandedDays = new Set(this.expand_by_day(aYear));
      for (let doy of this.by_data.BYYEARDAY) {
        if (doy < 0) {
          doy += daysInYear2 + 1;
        }
        if (expandedDays.has(doy)) {
          this.days.push(doy);
        }
      }
    } else {
      this.days = [];
    }
    let daysInYear = Time.isLeapYear(aYear) ? 366 : 365;
    this.days.sort((a, b) => {
      if (a < 0) a += daysInYear + 1;
      if (b < 0) b += daysInYear + 1;
      return a - b;
    });
    return 0;
  }
  expand_by_day(aYear) {
    let days_list = [];
    let tmp = this.last.clone();
    tmp.year = aYear;
    tmp.month = 1;
    tmp.day = 1;
    tmp.isDate = true;
    let start_dow = tmp.dayOfWeek();
    tmp.month = 12;
    tmp.day = 31;
    tmp.isDate = true;
    let end_dow = tmp.dayOfWeek();
    let end_year_day = tmp.dayOfYear();
    for (let day of this.by_data.BYDAY) {
      let parts = this.ruleDayOfWeek(day);
      let pos = parts[0];
      let dow = parts[1];
      if (pos == 0) {
        let tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;
        for (let doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
          days_list.push(doy);
        }
      } else if (pos > 0) {
        let first;
        if (dow >= start_dow) {
          first = dow - start_dow + 1;
        } else {
          first = dow - start_dow + 8;
        }
        days_list.push(first + (pos - 1) * 7);
      } else {
        let last;
        pos = -pos;
        if (dow <= end_dow) {
          last = end_year_day - end_dow + dow;
        } else {
          last = end_year_day - end_dow + dow - 7;
        }
        days_list.push(last - (pos - 1) * 7);
      }
    }
    return days_list;
  }
  is_day_in_byday(tt2) {
    if (this.by_data.BYDAY) {
      for (let day of this.by_data.BYDAY) {
        let parts = this.ruleDayOfWeek(day);
        let pos = parts[0];
        let dow = parts[1];
        let this_dow = tt2.dayOfWeek();
        if (pos == 0 && dow == this_dow || tt2.nthWeekDay(dow, pos) == tt2.day) {
          return 1;
        }
      }
    }
    return 0;
  }
  /**
   * Checks if given value is in BYSETPOS.
   *
   * @private
   * @param {Numeric} aPos position to check for.
   * @return {Boolean} false unless BYSETPOS rules exist
   *                   and the given value is present in rules.
   */
  check_set_position(aPos) {
    if (this.has_by_data("BYSETPOS")) {
      let idx = this.by_data.BYSETPOS.indexOf(aPos);
      return idx !== -1;
    }
    return false;
  }
  sort_byday_rules(aRules) {
    for (let i = 0; i < aRules.length; i++) {
      for (let j = 0; j < i; j++) {
        let one = this.ruleDayOfWeek(aRules[j], this.rule.wkst)[1];
        let two = this.ruleDayOfWeek(aRules[i], this.rule.wkst)[1];
        if (one > two) {
          let tmp = aRules[i];
          aRules[i] = aRules[j];
          aRules[j] = tmp;
        }
      }
    }
  }
  check_contract_restriction(aRuleType, v2) {
    let indexMapValue = RecurIterator._indexMap[aRuleType];
    let ruleMapValue = RecurIterator._expandMap[this.rule.freq][indexMapValue];
    let pass = false;
    if (aRuleType in this.by_data && ruleMapValue == RecurIterator.CONTRACT) {
      let ruleType = this.by_data[aRuleType];
      for (let bydata of ruleType) {
        if (bydata == v2) {
          pass = true;
          break;
        }
      }
    } else {
      pass = true;
    }
    return pass;
  }
  check_contracting_rules() {
    let dow = this.last.dayOfWeek();
    let weekNo = this.last.weekNumber(this.rule.wkst);
    let doy = this.last.dayOfYear();
    return this.check_contract_restriction("BYSECOND", this.last.second) && this.check_contract_restriction("BYMINUTE", this.last.minute) && this.check_contract_restriction("BYHOUR", this.last.hour) && this.check_contract_restriction("BYDAY", Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction("BYWEEKNO", weekNo) && this.check_contract_restriction("BYMONTHDAY", this.last.day) && this.check_contract_restriction("BYMONTH", this.last.month) && this.check_contract_restriction("BYYEARDAY", doy);
  }
  setup_defaults(aRuleType, req, deftime) {
    let indexMapValue = RecurIterator._indexMap[aRuleType];
    let ruleMapValue = RecurIterator._expandMap[this.rule.freq][indexMapValue];
    if (ruleMapValue != RecurIterator.CONTRACT) {
      if (!(aRuleType in this.by_data)) {
        this.by_data[aRuleType] = [deftime];
      }
      if (this.rule.freq != req) {
        return this.by_data[aRuleType][0];
      }
    }
    return deftime;
  }
  /**
   * Convert iterator into a serialize-able object.  Will preserve current
   * iteration sequence to ensure the seamless continuation of the recurrence
   * rule.
   * @return {Object}
   */
  toJSON() {
    let result = /* @__PURE__ */ Object.create(null);
    result.initialized = this.initialized;
    result.rule = this.rule.toJSON();
    result.dtstart = this.dtstart.toJSON();
    result.by_data = this.by_data;
    result.days = this.days;
    result.last = this.last.toJSON();
    result.by_indices = this.by_indices;
    result.occurrence_number = this.occurrence_number;
    return result;
  }
}
class InvalidRecurrenceRuleError extends Error {
  constructor() {
    super("Recurrence rule has no valid occurrences");
  }
}
const VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
const VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
const DOW_MAP = {
  SU: Time.SUNDAY,
  MO: Time.MONDAY,
  TU: Time.TUESDAY,
  WE: Time.WEDNESDAY,
  TH: Time.THURSDAY,
  FR: Time.FRIDAY,
  SA: Time.SATURDAY
};
const REVERSE_DOW_MAP = Object.fromEntries(Object.entries(DOW_MAP).map((entry) => entry.reverse()));
const ALLOWED_FREQ = [
  "SECONDLY",
  "MINUTELY",
  "HOURLY",
  "DAILY",
  "WEEKLY",
  "MONTHLY",
  "YEARLY"
];
class Recur {
  /**
   * Creates a new {@link ICAL.Recur} instance from the passed string.
   *
   * @param {String} string         The string to parse
   * @return {Recur}                The created recurrence instance
   */
  static fromString(string) {
    let data = this._stringToData(string, false);
    return new Recur(data);
  }
  /**
   * Creates a new {@link ICAL.Recur} instance using members from the passed
   * data object.
   *
   * @param {Object} aData                              An object with members of the recurrence
   * @param {frequencyValues=} aData.freq               The frequency value
   * @param {Number=} aData.interval                    The INTERVAL value
   * @param {weekDay=} aData.wkst                       The week start value
   * @param {Time=} aData.until                         The end of the recurrence set
   * @param {Number=} aData.count                       The number of occurrences
   * @param {Array.<Number>=} aData.bysecond            The seconds for the BYSECOND part
   * @param {Array.<Number>=} aData.byminute            The minutes for the BYMINUTE part
   * @param {Array.<Number>=} aData.byhour              The hours for the BYHOUR part
   * @param {Array.<String>=} aData.byday               The BYDAY values
   * @param {Array.<Number>=} aData.bymonthday          The days for the BYMONTHDAY part
   * @param {Array.<Number>=} aData.byyearday           The days for the BYYEARDAY part
   * @param {Array.<Number>=} aData.byweekno            The weeks for the BYWEEKNO part
   * @param {Array.<Number>=} aData.bymonth             The month for the BYMONTH part
   * @param {Array.<Number>=} aData.bysetpos            The positionals for the BYSETPOS part
   */
  static fromData(aData) {
    return new Recur(aData);
  }
  /**
   * Converts a recurrence string to a data object, suitable for the fromData
   * method.
   *
   * @private
   * @param {String} string     The string to parse
   * @param {Boolean} fmtIcal   If true, the string is considered to be an
   *                              iCalendar string
   * @return {Recur}            The recurrence instance
   */
  static _stringToData(string, fmtIcal) {
    let dict = /* @__PURE__ */ Object.create(null);
    let values = string.split(";");
    let len = values.length;
    for (let i = 0; i < len; i++) {
      let parts = values[i].split("=");
      let ucname = parts[0].toUpperCase();
      let lcname = parts[0].toLowerCase();
      let name = fmtIcal ? lcname : ucname;
      let value = parts[1];
      if (ucname in partDesign) {
        let partArr = value.split(",");
        let partSet = /* @__PURE__ */ new Set();
        for (let part of partArr) {
          partSet.add(partDesign[ucname](part));
        }
        partArr = [...partSet];
        dict[name] = partArr.length == 1 ? partArr[0] : partArr;
      } else if (ucname in optionDesign) {
        optionDesign[ucname](value, dict, fmtIcal);
      } else {
        dict[lcname] = value;
      }
    }
    return dict;
  }
  /**
   * Convert an ical representation of a day (SU, MO, etc..)
   * into a numeric value of that day.
   *
   * @param {String} string     The iCalendar day name
   * @param {weekDay=} aWeekStart
   *        The week start weekday, defaults to SUNDAY
   * @return {Number}           Numeric value of given day
   */
  static icalDayToNumericDay(string, aWeekStart) {
    let firstDow = aWeekStart || Time.SUNDAY;
    return (DOW_MAP[string] - firstDow + 7) % 7 + 1;
  }
  /**
   * Convert a numeric day value into its ical representation (SU, MO, etc..)
   *
   * @param {Number} num        Numeric value of given day
   * @param {weekDay=} aWeekStart
   *        The week start weekday, defaults to SUNDAY
   * @return {String}           The ICAL day value, e.g SU,MO,...
   */
  static numericDayToIcalDay(num, aWeekStart) {
    let firstDow = aWeekStart || Time.SUNDAY;
    let dow = num + firstDow - Time.SUNDAY;
    if (dow > 7) {
      dow -= 7;
    }
    return REVERSE_DOW_MAP[dow];
  }
  /**
   * Create a new instance of the Recur class.
   *
   * @param {Object} data                               An object with members of the recurrence
   * @param {frequencyValues=} data.freq                The frequency value
   * @param {Number=} data.interval                     The INTERVAL value
   * @param {weekDay=} data.wkst                        The week start value
   * @param {Time=} data.until                          The end of the recurrence set
   * @param {Number=} data.count                        The number of occurrences
   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
   * @param {Array.<String>=} data.byday                The BYDAY values
   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
   */
  constructor(data) {
    this.wrappedJSObject = this;
    this.parts = {};
    if (data && typeof data === "object") {
      this.fromData(data);
    }
  }
  /**
   * An object holding the BY-parts of the recurrence rule
   * @memberof ICAL.Recur
   * @typedef {Object} byParts
   * @property {Array.<Number>=} BYSECOND            The seconds for the BYSECOND part
   * @property {Array.<Number>=} BYMINUTE            The minutes for the BYMINUTE part
   * @property {Array.<Number>=} BYHOUR              The hours for the BYHOUR part
   * @property {Array.<String>=} BYDAY               The BYDAY values
   * @property {Array.<Number>=} BYMONTHDAY          The days for the BYMONTHDAY part
   * @property {Array.<Number>=} BYYEARDAY           The days for the BYYEARDAY part
   * @property {Array.<Number>=} BYWEEKNO            The weeks for the BYWEEKNO part
   * @property {Array.<Number>=} BYMONTH             The month for the BYMONTH part
   * @property {Array.<Number>=} BYSETPOS            The positionals for the BYSETPOS part
   */
  /**
   * An object holding the BY-parts of the recurrence rule
   * @type {byParts}
   */
  parts = null;
  /**
   * The interval value for the recurrence rule.
   * @type {Number}
   */
  interval = 1;
  /**
   * The week start day
   *
   * @type {weekDay}
   * @default ICAL.Time.MONDAY
   */
  wkst = Time.MONDAY;
  /**
   * The end of the recurrence
   * @type {?Time}
   */
  until = null;
  /**
   * The maximum number of occurrences
   * @type {?Number}
   */
  count = null;
  /**
   * The frequency value.
   * @type {frequencyValues}
   */
  freq = null;
  /**
   * The class identifier.
   * @constant
   * @type {String}
   * @default "icalrecur"
   */
  icalclass = "icalrecur";
  /**
   * The type name, to be used in the jCal object.
   * @constant
   * @type {String}
   * @default "recur"
   */
  icaltype = "recur";
  /**
   * Create a new iterator for this recurrence rule. The passed start date
   * must be the start date of the event, not the start of the range to
   * search in.
   *
   * @example
   * let recur = comp.getFirstPropertyValue('rrule');
   * let dtstart = comp.getFirstPropertyValue('dtstart');
   * let iter = recur.iterator(dtstart);
   * for (let next = iter.next(); next; next = iter.next()) {
   *   if (next.compare(rangeStart) < 0) {
   *     continue;
   *   }
   *   console.log(next.toString());
   * }
   *
   * @param {Time} aStart        The item's start date
   * @return {RecurIterator}     The recurrence iterator
   */
  iterator(aStart) {
    return new RecurIterator({
      rule: this,
      dtstart: aStart
    });
  }
  /**
   * Returns a clone of the recurrence object.
   *
   * @return {Recur}      The cloned object
   */
  clone() {
    return new Recur(this.toJSON());
  }
  /**
   * Checks if the current rule is finite, i.e. has a count or until part.
   *
   * @return {Boolean}        True, if the rule is finite
   */
  isFinite() {
    return !!(this.count || this.until);
  }
  /**
   * Checks if the current rule has a count part, and not limited by an until
   * part.
   *
   * @return {Boolean}        True, if the rule is by count
   */
  isByCount() {
    return !!(this.count && !this.until);
  }
  /**
   * Adds a component (part) to the recurrence rule. This is not a component
   * in the sense of {@link ICAL.Component}, but a part of the recurrence
   * rule, i.e. BYMONTH.
   *
   * @param {String} aType            The name of the component part
   * @param {Array|String} aValue     The component value
   */
  addComponent(aType, aValue) {
    let ucname = aType.toUpperCase();
    if (ucname in this.parts) {
      this.parts[ucname].push(aValue);
    } else {
      this.parts[ucname] = [aValue];
    }
  }
  /**
   * Sets the component value for the given by-part.
   *
   * @param {String} aType        The component part name
   * @param {Array} aValues       The component values
   */
  setComponent(aType, aValues) {
    this.parts[aType.toUpperCase()] = aValues.slice();
  }
  /**
   * Gets (a copy) of the requested component value.
   *
   * @param {String} aType        The component part name
   * @return {Array}              The component part value
   */
  getComponent(aType) {
    let ucname = aType.toUpperCase();
    return ucname in this.parts ? this.parts[ucname].slice() : [];
  }
  /**
   * Retrieves the next occurrence after the given recurrence id. See the
   * guide on {@tutorial terminology} for more details.
   *
   * NOTE: Currently, this method iterates all occurrences from the start
   * date. It should not be called in a loop for performance reasons. If you
   * would like to get more than one occurrence, you can iterate the
   * occurrences manually, see the example on the
   * {@link ICAL.Recur#iterator iterator} method.
   *
   * @param {Time} aStartTime        The start of the event series
   * @param {Time} aRecurrenceId     The date of the last occurrence
   * @return {Time}                  The next occurrence after
   */
  getNextOccurrence(aStartTime, aRecurrenceId) {
    let iter = this.iterator(aStartTime);
    let next;
    do {
      next = iter.next();
    } while (next && next.compare(aRecurrenceId) <= 0);
    if (next && aRecurrenceId.zone) {
      next.zone = aRecurrenceId.zone;
    }
    return next;
  }
  /**
   * Sets up the current instance using members from the passed data object.
   *
   * @param {Object} data                               An object with members of the recurrence
   * @param {frequencyValues=} data.freq                The frequency value
   * @param {Number=} data.interval                     The INTERVAL value
   * @param {weekDay=} data.wkst                        The week start value
   * @param {Time=} data.until                          The end of the recurrence set
   * @param {Number=} data.count                        The number of occurrences
   * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
   * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
   * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
   * @param {Array.<String>=} data.byday                The BYDAY values
   * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
   * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
   * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
   * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
   * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
   */
  fromData(data) {
    for (let key in data) {
      let uckey = key.toUpperCase();
      if (uckey in partDesign) {
        if (Array.isArray(data[key])) {
          this.parts[uckey] = data[key];
        } else {
          this.parts[uckey] = [data[key]];
        }
      } else {
        this[key] = data[key];
      }
    }
    if (this.interval && typeof this.interval != "number") {
      optionDesign.INTERVAL(this.interval, this);
    }
    if (this.wkst && typeof this.wkst != "number") {
      this.wkst = Recur.icalDayToNumericDay(this.wkst);
    }
    if (this.until && !(this.until instanceof Time)) {
      this.until = Time.fromString(this.until);
    }
  }
  /**
   * The jCal representation of this recurrence type.
   * @return {Object}
   */
  toJSON() {
    let res = /* @__PURE__ */ Object.create(null);
    res.freq = this.freq;
    if (this.count) {
      res.count = this.count;
    }
    if (this.interval > 1) {
      res.interval = this.interval;
    }
    for (let [k, kparts] of Object.entries(this.parts)) {
      if (Array.isArray(kparts) && kparts.length == 1) {
        res[k.toLowerCase()] = kparts[0];
      } else {
        res[k.toLowerCase()] = clone(kparts);
      }
    }
    if (this.until) {
      res.until = this.until.toString();
    }
    if ("wkst" in this && this.wkst !== Time.DEFAULT_WEEK_START) {
      res.wkst = Recur.numericDayToIcalDay(this.wkst);
    }
    return res;
  }
  /**
   * The string representation of this recurrence rule.
   * @return {String}
   */
  toString() {
    let str = "FREQ=" + this.freq;
    if (this.count) {
      str += ";COUNT=" + this.count;
    }
    if (this.interval > 1) {
      str += ";INTERVAL=" + this.interval;
    }
    for (let [k, v2] of Object.entries(this.parts)) {
      str += ";" + k + "=" + v2;
    }
    if (this.until) {
      str += ";UNTIL=" + this.until.toICALString();
    }
    if ("wkst" in this && this.wkst !== Time.DEFAULT_WEEK_START) {
      str += ";WKST=" + Recur.numericDayToIcalDay(this.wkst);
    }
    return str;
  }
}
function parseNumericValue(type, min, max, value) {
  let result = value;
  if (value[0] === "+") {
    result = value.slice(1);
  }
  result = strictParseInt(result);
  if (min !== void 0 && value < min) {
    throw new Error(
      type + ': invalid value "' + value + '" must be > ' + min
    );
  }
  if (max !== void 0 && value > max) {
    throw new Error(
      type + ': invalid value "' + value + '" must be < ' + min
    );
  }
  return result;
}
const optionDesign = {
  FREQ: function(value, dict, fmtIcal) {
    if (ALLOWED_FREQ.indexOf(value) !== -1) {
      dict.freq = value;
    } else {
      throw new Error(
        'invalid frequency "' + value + '" expected: "' + ALLOWED_FREQ.join(", ") + '"'
      );
    }
  },
  COUNT: function(value, dict, fmtIcal) {
    dict.count = strictParseInt(value);
  },
  INTERVAL: function(value, dict, fmtIcal) {
    dict.interval = strictParseInt(value);
    if (dict.interval < 1) {
      dict.interval = 1;
    }
  },
  UNTIL: function(value, dict, fmtIcal) {
    if (value.length > 10) {
      dict.until = design.icalendar.value["date-time"].fromICAL(value);
    } else {
      dict.until = design.icalendar.value.date.fromICAL(value);
    }
    if (!fmtIcal) {
      dict.until = Time.fromString(dict.until);
    }
  },
  WKST: function(value, dict, fmtIcal) {
    if (VALID_DAY_NAMES.test(value)) {
      dict.wkst = Recur.icalDayToNumericDay(value);
    } else {
      throw new Error('invalid WKST value "' + value + '"');
    }
  }
};
const partDesign = {
  BYSECOND: parseNumericValue.bind(void 0, "BYSECOND", 0, 60),
  BYMINUTE: parseNumericValue.bind(void 0, "BYMINUTE", 0, 59),
  BYHOUR: parseNumericValue.bind(void 0, "BYHOUR", 0, 23),
  BYDAY: function(value) {
    if (VALID_BYDAY_PART.test(value)) {
      return value;
    } else {
      throw new Error('invalid BYDAY value "' + value + '"');
    }
  },
  BYMONTHDAY: parseNumericValue.bind(void 0, "BYMONTHDAY", -31, 31),
  BYYEARDAY: parseNumericValue.bind(void 0, "BYYEARDAY", -366, 366),
  BYWEEKNO: parseNumericValue.bind(void 0, "BYWEEKNO", -53, 53),
  BYMONTH: parseNumericValue.bind(void 0, "BYMONTH", 1, 12),
  BYSETPOS: parseNumericValue.bind(void 0, "BYSETPOS", -366, 366)
};
const FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
const TO_ICAL_NEWLINE = /\\|;|,|\n/g;
const FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
const TO_VCARD_NEWLINE = /\\|,|\n/g;
function createTextType(fromNewline, toNewline) {
  let result = {
    matches: /.*/,
    fromICAL: function(aValue, structuredEscape) {
      return replaceNewline(aValue, fromNewline, structuredEscape);
    },
    toICAL: function(aValue, structuredEscape) {
      let regEx = toNewline;
      if (structuredEscape)
        regEx = new RegExp(regEx.source + "|" + structuredEscape, regEx.flags);
      return aValue.replace(regEx, function(str) {
        switch (str) {
          case "\\":
            return "\\\\";
          case ";":
            return "\\;";
          case ",":
            return "\\,";
          case "\n":
            return "\\n";
          /* c8 ignore next 2 */
          default:
            return str;
        }
      });
    }
  };
  return result;
}
const DEFAULT_TYPE_TEXT = { defaultType: "text" };
const DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
const DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
const DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
const DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
const DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
const DEFAULT_TYPE_URI = { defaultType: "uri" };
const DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
const DEFAULT_TYPE_RECUR = { defaultType: "recur" };
const DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };
function replaceNewlineReplace(string) {
  switch (string) {
    case "\\\\":
      return "\\";
    case "\\;":
      return ";";
    case "\\,":
      return ",";
    case "\\n":
    case "\\N":
      return "\n";
    /* c8 ignore next 2 */
    default:
      return string;
  }
}
function replaceNewline(value, newline, structuredEscape) {
  if (value.indexOf("\\") === -1) {
    return value;
  }
  if (structuredEscape)
    newline = new RegExp(newline.source + "|\\\\" + structuredEscape, newline.flags);
  return value.replace(newline, replaceNewlineReplace);
}
let commonProperties = {
  "categories": DEFAULT_TYPE_TEXT_MULTI,
  "url": DEFAULT_TYPE_URI,
  "version": DEFAULT_TYPE_TEXT,
  "uid": DEFAULT_TYPE_TEXT
};
let commonValues = {
  "boolean": {
    values: ["TRUE", "FALSE"],
    fromICAL: function(aValue) {
      switch (aValue) {
        case "TRUE":
          return true;
        case "FALSE":
          return false;
        default:
          return false;
      }
    },
    toICAL: function(aValue) {
      if (aValue) {
        return "TRUE";
      }
      return "FALSE";
    }
  },
  float: {
    matches: /^[+-]?\d+\.\d+$/,
    fromICAL: function(aValue) {
      let parsed = parseFloat(aValue);
      if (isStrictlyNaN(parsed)) {
        return 0;
      }
      return parsed;
    },
    toICAL: function(aValue) {
      return String(aValue);
    }
  },
  integer: {
    fromICAL: function(aValue) {
      let parsed = parseInt(aValue);
      if (isStrictlyNaN(parsed)) {
        return 0;
      }
      return parsed;
    },
    toICAL: function(aValue) {
      return String(aValue);
    }
  },
  "utc-offset": {
    toICAL: function(aValue) {
      if (aValue.length < 7) {
        return aValue.slice(0, 3) + aValue.slice(4, 6);
      } else {
        return aValue.slice(0, 3) + aValue.slice(4, 6) + aValue.slice(7, 9);
      }
    },
    fromICAL: function(aValue) {
      if (aValue.length < 6) {
        return aValue.slice(0, 3) + ":" + aValue.slice(3, 5);
      } else {
        return aValue.slice(0, 3) + ":" + aValue.slice(3, 5) + ":" + aValue.slice(5, 7);
      }
    },
    decorate: function(aValue) {
      return UtcOffset.fromString(aValue);
    },
    undecorate: function(aValue) {
      return aValue.toString();
    }
  }
};
let icalParams = {
  // Although the syntax is DQUOTE uri DQUOTE, I don't think we should
  // enforce anything aside from it being a valid content line.
  //
  // At least some params require - if multi values are used - DQUOTEs
  // for each of its values - e.g. delegated-from="uri1","uri2"
  // To indicate this, I introduced the new k/v pair
  // multiValueSeparateDQuote: true
  //
  // "ALTREP": { ... },
  // CN just wants a param-value
  // "CN": { ... }
  "cutype": {
    values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
    allowXName: true,
    allowIanaToken: true
  },
  "delegated-from": {
    valueType: "cal-address",
    multiValue: ",",
    multiValueSeparateDQuote: true
  },
  "delegated-to": {
    valueType: "cal-address",
    multiValue: ",",
    multiValueSeparateDQuote: true
  },
  // "DIR": { ... }, // See ALTREP
  "encoding": {
    values: ["8BIT", "BASE64"]
  },
  // "FMTTYPE": { ... }, // See ALTREP
  "fbtype": {
    values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
    allowXName: true,
    allowIanaToken: true
  },
  // "LANGUAGE": { ... }, // See ALTREP
  "member": {
    valueType: "cal-address",
    multiValue: ",",
    multiValueSeparateDQuote: true
  },
  "partstat": {
    // TODO These values are actually different per-component
    values: [
      "NEEDS-ACTION",
      "ACCEPTED",
      "DECLINED",
      "TENTATIVE",
      "DELEGATED",
      "COMPLETED",
      "IN-PROCESS"
    ],
    allowXName: true,
    allowIanaToken: true
  },
  "range": {
    values: ["THISANDFUTURE"]
  },
  "related": {
    values: ["START", "END"]
  },
  "reltype": {
    values: ["PARENT", "CHILD", "SIBLING"],
    allowXName: true,
    allowIanaToken: true
  },
  "role": {
    values: [
      "REQ-PARTICIPANT",
      "CHAIR",
      "OPT-PARTICIPANT",
      "NON-PARTICIPANT"
    ],
    allowXName: true,
    allowIanaToken: true
  },
  "rsvp": {
    values: ["TRUE", "FALSE"]
  },
  "sent-by": {
    valueType: "cal-address"
  },
  "tzid": {
    matches: /^\//
  },
  "value": {
    // since the value here is a 'type' lowercase is used.
    values: [
      "binary",
      "boolean",
      "cal-address",
      "date",
      "date-time",
      "duration",
      "float",
      "integer",
      "period",
      "recur",
      "text",
      "time",
      "uri",
      "utc-offset"
    ],
    allowXName: true,
    allowIanaToken: true
  }
};
const icalValues = extend(commonValues, {
  text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),
  uri: {
    // TODO
    /* ... */
  },
  "binary": {
    decorate: function(aString) {
      return Binary.fromString(aString);
    },
    undecorate: function(aBinary) {
      return aBinary.toString();
    }
  },
  "cal-address": {
    // needs to be an uri
  },
  "date": {
    decorate: function(aValue, aProp) {
      {
        return Time.fromDateString(aValue, aProp);
      }
    },
    /**
     * undecorates a time object.
     */
    undecorate: function(aValue) {
      return aValue.toString();
    },
    fromICAL: function(aValue) {
      {
        return aValue.slice(0, 4) + "-" + aValue.slice(4, 6) + "-" + aValue.slice(6, 8);
      }
    },
    toICAL: function(aValue) {
      let len = aValue.length;
      if (len == 10) {
        return aValue.slice(0, 4) + aValue.slice(5, 7) + aValue.slice(8, 10);
      } else if (len >= 19) {
        return icalValues["date-time"].toICAL(aValue);
      } else {
        return aValue;
      }
    }
  },
  "date-time": {
    fromICAL: function(aValue) {
      {
        let result = aValue.slice(0, 4) + "-" + aValue.slice(4, 6) + "-" + aValue.slice(6, 8) + "T" + aValue.slice(9, 11) + ":" + aValue.slice(11, 13) + ":" + aValue.slice(13, 15);
        if (aValue[15] && aValue[15] === "Z") {
          result += "Z";
        }
        return result;
      }
    },
    toICAL: function(aValue) {
      let len = aValue.length;
      if (len >= 19) {
        let result = aValue.slice(0, 4) + aValue.slice(5, 7) + // grab the (DDTHH) segment
        aValue.slice(8, 13) + // MM
        aValue.slice(14, 16) + // SS
        aValue.slice(17, 19);
        if (aValue[19] && aValue[19] === "Z") {
          result += "Z";
        }
        return result;
      } else {
        return aValue;
      }
    },
    decorate: function(aValue, aProp) {
      {
        return Time.fromDateTimeString(aValue, aProp);
      }
    },
    undecorate: function(aValue) {
      return aValue.toString();
    }
  },
  duration: {
    decorate: function(aValue) {
      return Duration.fromString(aValue);
    },
    undecorate: function(aValue) {
      return aValue.toString();
    }
  },
  period: {
    fromICAL: function(string) {
      let parts = string.split("/");
      parts[0] = icalValues["date-time"].fromICAL(parts[0]);
      if (!Duration.isValueString(parts[1])) {
        parts[1] = icalValues["date-time"].fromICAL(parts[1]);
      }
      return parts;
    },
    toICAL: function(parts) {
      parts = parts.slice();
      {
        parts[0] = icalValues["date-time"].toICAL(parts[0]);
      }
      if (!Duration.isValueString(parts[1])) {
        {
          parts[1] = icalValues["date-time"].toICAL(parts[1]);
        }
      }
      return parts.join("/");
    },
    decorate: function(aValue, aProp) {
      return Period.fromJSON(aValue, aProp, false);
    },
    undecorate: function(aValue) {
      return aValue.toJSON();
    }
  },
  recur: {
    fromICAL: function(string) {
      return Recur._stringToData(string, true);
    },
    toICAL: function(data) {
      let str = "";
      for (let [k, val] of Object.entries(data)) {
        if (k == "until") {
          if (val.length > 10) {
            val = icalValues["date-time"].toICAL(val);
          } else {
            val = icalValues.date.toICAL(val);
          }
        } else if (k == "wkst") {
          if (typeof val === "number") {
            val = Recur.numericDayToIcalDay(val);
          }
        } else if (Array.isArray(val)) {
          val = val.join(",");
        }
        str += k.toUpperCase() + "=" + val + ";";
      }
      return str.slice(0, Math.max(0, str.length - 1));
    },
    decorate: function decorate(aValue) {
      return Recur.fromData(aValue);
    },
    undecorate: function(aRecur) {
      return aRecur.toJSON();
    }
  },
  time: {
    fromICAL: function(aValue) {
      if (aValue.length < 6) {
        return aValue;
      }
      let result = aValue.slice(0, 2) + ":" + aValue.slice(2, 4) + ":" + aValue.slice(4, 6);
      if (aValue[6] === "Z") {
        result += "Z";
      }
      return result;
    },
    toICAL: function(aValue) {
      if (aValue.length < 8) {
        return aValue;
      }
      let result = aValue.slice(0, 2) + aValue.slice(3, 5) + aValue.slice(6, 8);
      if (aValue[8] === "Z") {
        result += "Z";
      }
      return result;
    }
  }
});
let icalProperties = extend(commonProperties, {
  "action": DEFAULT_TYPE_TEXT,
  "attach": { defaultType: "uri" },
  "attendee": { defaultType: "cal-address" },
  "calscale": DEFAULT_TYPE_TEXT,
  "class": DEFAULT_TYPE_TEXT,
  "comment": DEFAULT_TYPE_TEXT,
  "completed": DEFAULT_TYPE_DATETIME,
  "contact": DEFAULT_TYPE_TEXT,
  "created": DEFAULT_TYPE_DATETIME,
  "description": DEFAULT_TYPE_TEXT,
  "dtend": DEFAULT_TYPE_DATETIME_DATE,
  "dtstamp": DEFAULT_TYPE_DATETIME,
  "dtstart": DEFAULT_TYPE_DATETIME_DATE,
  "due": DEFAULT_TYPE_DATETIME_DATE,
  "duration": { defaultType: "duration" },
  "exdate": {
    defaultType: "date-time",
    allowedTypes: ["date-time", "date"],
    multiValue: ","
  },
  "exrule": DEFAULT_TYPE_RECUR,
  "freebusy": { defaultType: "period", multiValue: "," },
  "geo": { defaultType: "float", structuredValue: ";" },
  "last-modified": DEFAULT_TYPE_DATETIME,
  "location": DEFAULT_TYPE_TEXT,
  "method": DEFAULT_TYPE_TEXT,
  "organizer": { defaultType: "cal-address" },
  "percent-complete": DEFAULT_TYPE_INTEGER,
  "priority": DEFAULT_TYPE_INTEGER,
  "prodid": DEFAULT_TYPE_TEXT,
  "related-to": DEFAULT_TYPE_TEXT,
  "repeat": DEFAULT_TYPE_INTEGER,
  "rdate": {
    defaultType: "date-time",
    allowedTypes: ["date-time", "date", "period"],
    multiValue: ",",
    detectType: function(string) {
      if (string.indexOf("/") !== -1) {
        return "period";
      }
      return string.indexOf("T") === -1 ? "date" : "date-time";
    }
  },
  "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
  "resources": DEFAULT_TYPE_TEXT_MULTI,
  "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
  "rrule": DEFAULT_TYPE_RECUR,
  "sequence": DEFAULT_TYPE_INTEGER,
  "status": DEFAULT_TYPE_TEXT,
  "summary": DEFAULT_TYPE_TEXT,
  "transp": DEFAULT_TYPE_TEXT,
  "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
  "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
  "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
  "tzurl": DEFAULT_TYPE_URI,
  "tzid": DEFAULT_TYPE_TEXT,
  "tzname": DEFAULT_TYPE_TEXT
});
const vcardValues = extend(commonValues, {
  text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
  uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
  date: {
    decorate: function(aValue) {
      return VCardTime.fromDateAndOrTimeString(aValue, "date");
    },
    undecorate: function(aValue) {
      return aValue.toString();
    },
    fromICAL: function(aValue) {
      if (aValue.length == 8) {
        return icalValues.date.fromICAL(aValue);
      } else if (aValue[0] == "-" && aValue.length == 6) {
        return aValue.slice(0, 4) + "-" + aValue.slice(4);
      } else {
        return aValue;
      }
    },
    toICAL: function(aValue) {
      if (aValue.length == 10) {
        return icalValues.date.toICAL(aValue);
      } else if (aValue[0] == "-" && aValue.length == 7) {
        return aValue.slice(0, 4) + aValue.slice(5);
      } else {
        return aValue;
      }
    }
  },
  time: {
    decorate: function(aValue) {
      return VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
    },
    undecorate: function(aValue) {
      return aValue.toString();
    },
    fromICAL: function(aValue) {
      let splitzone = vcardValues.time._splitZone(aValue, true);
      let zone = splitzone[0], value = splitzone[1];
      if (value.length == 6) {
        value = value.slice(0, 2) + ":" + value.slice(2, 4) + ":" + value.slice(4, 6);
      } else if (value.length == 4 && value[0] != "-") {
        value = value.slice(0, 2) + ":" + value.slice(2, 4);
      } else if (value.length == 5) {
        value = value.slice(0, 3) + ":" + value.slice(3, 5);
      }
      if (zone.length == 5 && (zone[0] == "-" || zone[0] == "+")) {
        zone = zone.slice(0, 3) + ":" + zone.slice(3);
      }
      return value + zone;
    },
    toICAL: function(aValue) {
      let splitzone = vcardValues.time._splitZone(aValue);
      let zone = splitzone[0], value = splitzone[1];
      if (value.length == 8) {
        value = value.slice(0, 2) + value.slice(3, 5) + value.slice(6, 8);
      } else if (value.length == 5 && value[0] != "-") {
        value = value.slice(0, 2) + value.slice(3, 5);
      } else if (value.length == 6) {
        value = value.slice(0, 3) + value.slice(4, 6);
      }
      if (zone.length == 6 && (zone[0] == "-" || zone[0] == "+")) {
        zone = zone.slice(0, 3) + zone.slice(4);
      }
      return value + zone;
    },
    _splitZone: function(aValue, isFromIcal) {
      let lastChar = aValue.length - 1;
      let signChar = aValue.length - (isFromIcal ? 5 : 6);
      let sign = aValue[signChar];
      let zone, value;
      if (aValue[lastChar] == "Z") {
        zone = aValue[lastChar];
        value = aValue.slice(0, Math.max(0, lastChar));
      } else if (aValue.length > 6 && (sign == "-" || sign == "+")) {
        zone = aValue.slice(signChar);
        value = aValue.slice(0, Math.max(0, signChar));
      } else {
        zone = "";
        value = aValue;
      }
      return [zone, value];
    }
  },
  "date-time": {
    decorate: function(aValue) {
      return VCardTime.fromDateAndOrTimeString(aValue, "date-time");
    },
    undecorate: function(aValue) {
      return aValue.toString();
    },
    fromICAL: function(aValue) {
      return vcardValues["date-and-or-time"].fromICAL(aValue);
    },
    toICAL: function(aValue) {
      return vcardValues["date-and-or-time"].toICAL(aValue);
    }
  },
  "date-and-or-time": {
    decorate: function(aValue) {
      return VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
    },
    undecorate: function(aValue) {
      return aValue.toString();
    },
    fromICAL: function(aValue) {
      let parts = aValue.split("T");
      return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : "") + (parts[1] ? "T" + vcardValues.time.fromICAL(parts[1]) : "");
    },
    toICAL: function(aValue) {
      let parts = aValue.split("T");
      return vcardValues.date.toICAL(parts[0]) + (parts[1] ? "T" + vcardValues.time.toICAL(parts[1]) : "");
    }
  },
  timestamp: icalValues["date-time"],
  "language-tag": {
    matches: /^[a-zA-Z0-9-]+$/
    // Could go with a more strict regex here
  },
  "phone-number": {
    fromICAL: function(aValue) {
      return Array.from(aValue).filter(function(c) {
        return c === "\\" ? void 0 : c;
      }).join("");
    },
    toICAL: function(aValue) {
      return Array.from(aValue).map(function(c) {
        return c === "," || c === ";" ? "\\" + c : c;
      }).join("");
    }
  }
});
let vcardParams = {
  "type": {
    valueType: "text",
    multiValue: ","
  },
  "value": {
    // since the value here is a 'type' lowercase is used.
    values: [
      "text",
      "uri",
      "date",
      "time",
      "date-time",
      "date-and-or-time",
      "timestamp",
      "boolean",
      "integer",
      "float",
      "utc-offset",
      "language-tag"
    ],
    allowXName: true,
    allowIanaToken: true
  }
};
let vcardProperties = extend(commonProperties, {
  "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
  "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
  "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
  "caladruri": DEFAULT_TYPE_URI,
  "caluri": DEFAULT_TYPE_URI,
  "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
  "email": DEFAULT_TYPE_TEXT,
  "fburl": DEFAULT_TYPE_URI,
  "fn": DEFAULT_TYPE_TEXT,
  "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
  "geo": DEFAULT_TYPE_URI,
  "impp": DEFAULT_TYPE_URI,
  "key": DEFAULT_TYPE_URI,
  "kind": DEFAULT_TYPE_TEXT,
  "lang": { defaultType: "language-tag" },
  "logo": DEFAULT_TYPE_URI,
  "member": DEFAULT_TYPE_URI,
  "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
  "nickname": DEFAULT_TYPE_TEXT_MULTI,
  "note": DEFAULT_TYPE_TEXT,
  "org": { defaultType: "text", structuredValue: ";" },
  "photo": DEFAULT_TYPE_URI,
  "related": DEFAULT_TYPE_URI,
  "rev": { defaultType: "timestamp" },
  "role": DEFAULT_TYPE_TEXT,
  "sound": DEFAULT_TYPE_URI,
  "source": DEFAULT_TYPE_URI,
  "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
  "title": DEFAULT_TYPE_TEXT,
  "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
  "xml": DEFAULT_TYPE_TEXT
});
let vcard3Values = extend(commonValues, {
  binary: icalValues.binary,
  date: vcardValues.date,
  "date-time": vcardValues["date-time"],
  "phone-number": vcardValues["phone-number"],
  uri: icalValues.uri,
  text: vcardValues.text,
  time: icalValues.time,
  vcard: icalValues.text,
  "utc-offset": {
    toICAL: function(aValue) {
      return aValue.slice(0, 7);
    },
    fromICAL: function(aValue) {
      return aValue.slice(0, 7);
    },
    decorate: function(aValue) {
      return UtcOffset.fromString(aValue);
    },
    undecorate: function(aValue) {
      return aValue.toString();
    }
  }
});
let vcard3Params = {
  "type": {
    valueType: "text",
    multiValue: ","
  },
  "value": {
    // since the value here is a 'type' lowercase is used.
    values: [
      "text",
      "uri",
      "date",
      "date-time",
      "phone-number",
      "time",
      "boolean",
      "integer",
      "float",
      "utc-offset",
      "vcard",
      "binary"
    ],
    allowXName: true,
    allowIanaToken: true
  }
};
let vcard3Properties = extend(commonProperties, {
  fn: DEFAULT_TYPE_TEXT,
  n: { defaultType: "text", structuredValue: ";", multiValue: "," },
  nickname: DEFAULT_TYPE_TEXT_MULTI,
  photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
  bday: {
    defaultType: "date-time",
    allowedTypes: ["date-time", "date"],
    detectType: function(string) {
      return string.indexOf("T") === -1 ? "date" : "date-time";
    }
  },
  adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
  label: DEFAULT_TYPE_TEXT,
  tel: { defaultType: "phone-number" },
  email: DEFAULT_TYPE_TEXT,
  mailer: DEFAULT_TYPE_TEXT,
  tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
  geo: { defaultType: "float", structuredValue: ";" },
  title: DEFAULT_TYPE_TEXT,
  role: DEFAULT_TYPE_TEXT,
  logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
  agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
  org: DEFAULT_TYPE_TEXT_STRUCTURED,
  note: DEFAULT_TYPE_TEXT_MULTI,
  prodid: DEFAULT_TYPE_TEXT,
  rev: {
    defaultType: "date-time",
    allowedTypes: ["date-time", "date"],
    detectType: function(string) {
      return string.indexOf("T") === -1 ? "date" : "date-time";
    }
  },
  "sort-string": DEFAULT_TYPE_TEXT,
  sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
  class: DEFAULT_TYPE_TEXT,
  key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
});
let icalSet = {
  name: "ical",
  value: icalValues,
  param: icalParams,
  property: icalProperties,
  propertyGroups: false
};
let vcardSet = {
  name: "vcard4",
  value: vcardValues,
  param: vcardParams,
  property: vcardProperties,
  propertyGroups: true
};
let vcard3Set = {
  name: "vcard3",
  value: vcard3Values,
  param: vcard3Params,
  property: vcard3Properties,
  propertyGroups: true
};
const design = {
  /**
   * Can be set to false to make the parser more lenient.
   */
  strict: true,
  /**
   * The default set for new properties and components if none is specified.
   * @type {designSet}
   */
  defaultSet: icalSet,
  /**
   * The default type for unknown properties
   * @type {String}
   */
  defaultType: "unknown",
  /**
   * Holds the design set for known top-level components
   *
   * @type {Object}
   * @property {designSet} vcard       vCard VCARD
   * @property {designSet} vevent      iCalendar VEVENT
   * @property {designSet} vtodo       iCalendar VTODO
   * @property {designSet} vjournal    iCalendar VJOURNAL
   * @property {designSet} valarm      iCalendar VALARM
   * @property {designSet} vtimezone   iCalendar VTIMEZONE
   * @property {designSet} daylight    iCalendar DAYLIGHT
   * @property {designSet} standard    iCalendar STANDARD
   *
   * @example
   * let propertyName = 'fn';
   * let componentDesign = ICAL.design.components.vcard;
   * let propertyDetails = componentDesign.property[propertyName];
   * if (propertyDetails.defaultType == 'text') {
   *   // Yep, sure is...
   * }
   */
  components: {
    vcard: vcardSet,
    vcard3: vcard3Set,
    vevent: icalSet,
    vtodo: icalSet,
    vjournal: icalSet,
    valarm: icalSet,
    vtimezone: icalSet,
    daylight: icalSet,
    standard: icalSet
  },
  /**
   * The design set for iCalendar (rfc5545/rfc7265) components.
   * @type {designSet}
   */
  icalendar: icalSet,
  /**
   * The design set for vCard (rfc6350/rfc7095) components.
   * @type {designSet}
   */
  vcard: vcardSet,
  /**
   * The design set for vCard (rfc2425/rfc2426/rfc7095) components.
   * @type {designSet}
   */
  vcard3: vcard3Set,
  /**
   * Gets the design set for the given component name.
   *
   * @param {String} componentName        The name of the component
   * @return {designSet}      The design set for the component
   */
  getDesignSet: function(componentName) {
    let isInDesign = componentName && componentName in design.components;
    return isInDesign ? design.components[componentName] : design.defaultSet;
  }
};
const LINE_ENDING = "\r\n";
const DEFAULT_VALUE_TYPE = "unknown";
const RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };
function stringify(jCal) {
  if (typeof jCal[0] == "string") {
    jCal = [jCal];
  }
  let i = 0;
  let len = jCal.length;
  let result = "";
  for (; i < len; i++) {
    result += stringify.component(jCal[i]) + LINE_ENDING;
  }
  return result;
}
stringify.component = function(component, designSet) {
  let name = component[0].toUpperCase();
  let result = "BEGIN:" + name + LINE_ENDING;
  let props = component[1];
  let propIdx = 0;
  let propLen = props.length;
  let designSetName = component[0];
  if (designSetName === "vcard" && component[1].length > 0 && !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
    designSetName = "vcard3";
  }
  designSet = designSet || design.getDesignSet(designSetName);
  for (; propIdx < propLen; propIdx++) {
    result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
  }
  let comps = component[2] || [];
  let compIdx = 0;
  let compLen = comps.length;
  for (; compIdx < compLen; compIdx++) {
    result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
  }
  result += "END:" + name;
  return result;
};
stringify.property = function(property, designSet, noFold) {
  let name = property[0].toUpperCase();
  let jsName = property[0];
  let params = property[1];
  if (!designSet) {
    designSet = design.defaultSet;
  }
  let groupName = params.group;
  let line;
  if (designSet.propertyGroups && groupName) {
    line = groupName.toUpperCase() + "." + name;
  } else {
    line = name;
  }
  for (let [paramName, value] of Object.entries(params)) {
    if (designSet.propertyGroups && paramName == "group") {
      continue;
    }
    let paramDesign = designSet.param[paramName];
    let multiValue2 = paramDesign && paramDesign.multiValue;
    if (multiValue2 && Array.isArray(value)) {
      value = value.map(function(val) {
        val = stringify._rfc6868Unescape(val);
        val = stringify.paramPropertyValue(val, paramDesign.multiValueSeparateDQuote);
        return val;
      });
      value = stringify.multiValue(value, multiValue2, "unknown", null, designSet);
    } else {
      value = stringify._rfc6868Unescape(value);
      value = stringify.paramPropertyValue(value);
    }
    line += ";" + paramName.toUpperCase() + "=" + value;
  }
  if (property.length === 3) {
    return line + ":";
  }
  let valueType = property[2];
  let propDetails;
  let multiValue = false;
  let structuredValue = false;
  let isDefault = false;
  if (jsName in designSet.property) {
    propDetails = designSet.property[jsName];
    if ("multiValue" in propDetails) {
      multiValue = propDetails.multiValue;
    }
    if ("structuredValue" in propDetails && Array.isArray(property[3])) {
      structuredValue = propDetails.structuredValue;
    }
    if ("defaultType" in propDetails) {
      if (valueType === propDetails.defaultType) {
        isDefault = true;
      }
    } else {
      if (valueType === DEFAULT_VALUE_TYPE) {
        isDefault = true;
      }
    }
  } else {
    if (valueType === DEFAULT_VALUE_TYPE) {
      isDefault = true;
    }
  }
  if (!isDefault) {
    line += ";VALUE=" + valueType.toUpperCase();
  }
  line += ":";
  if (multiValue && structuredValue) {
    line += stringify.multiValue(
      property[3],
      structuredValue,
      valueType,
      multiValue,
      designSet,
      structuredValue
    );
  } else if (multiValue) {
    line += stringify.multiValue(
      property.slice(3),
      multiValue,
      valueType,
      null,
      designSet,
      false
    );
  } else if (structuredValue) {
    line += stringify.multiValue(
      property[3],
      structuredValue,
      valueType,
      null,
      designSet,
      structuredValue
    );
  } else {
    line += stringify.value(property[3], valueType, designSet, false);
  }
  return noFold ? line : foldline(line);
};
stringify.paramPropertyValue = function(value, force) {
  if (!force && value.indexOf(",") === -1 && value.indexOf(":") === -1 && value.indexOf(";") === -1) {
    return value;
  }
  return '"' + value + '"';
};
stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
  let result = "";
  let len = values.length;
  let i = 0;
  for (; i < len; i++) {
    if (innerMulti && Array.isArray(values[i])) {
      result += stringify.multiValue(values[i], innerMulti, type, null, designSet, structuredValue);
    } else {
      result += stringify.value(values[i], type, designSet, structuredValue);
    }
    if (i !== len - 1) {
      result += delim;
    }
  }
  return result;
};
stringify.value = function(value, type, designSet, structuredValue) {
  if (type in designSet.value && "toICAL" in designSet.value[type]) {
    return designSet.value[type].toICAL(value, structuredValue);
  }
  return value;
};
stringify._rfc6868Unescape = function(val) {
  return val.replace(/[\n^"]/g, function(x) {
    return RFC6868_REPLACE_MAP[x];
  });
};
const NAME_INDEX$1 = 0;
const PROP_INDEX = 1;
const TYPE_INDEX = 2;
const VALUE_INDEX = 3;
class Property {
  /**
   * Create an {@link ICAL.Property} by parsing the passed iCalendar string.
   *
   * @param {String} str            The iCalendar string to parse
   * @param {designSet=} designSet  The design data to use for this property
   * @return {Property}             The created iCalendar property
   */
  static fromString(str, designSet) {
    return new Property(parse.property(str, designSet));
  }
  /**
   * Creates a new ICAL.Property instance.
   *
   * It is important to note that mutations done in the wrapper directly mutate the jCal object used
   * to initialize.
   *
   * Can also be used to create new properties by passing the name of the property (as a String).
   *
   * @param {Array|String} jCal         Raw jCal representation OR the new name of the property
   * @param {Component=} parent         Parent component
   */
  constructor(jCal, parent) {
    this._parent = parent || null;
    if (typeof jCal === "string") {
      this.jCal = [jCal, {}, design.defaultType];
      this.jCal[TYPE_INDEX] = this.getDefaultType();
    } else {
      this.jCal = jCal;
    }
    this._updateType();
  }
  /**
   * The value type for this property
   * @type {String}
   */
  get type() {
    return this.jCal[TYPE_INDEX];
  }
  /**
   * The name of this property, in lowercase.
   * @type {String}
   */
  get name() {
    return this.jCal[NAME_INDEX$1];
  }
  /**
   * The parent component for this property.
   * @type {Component}
   */
  get parent() {
    return this._parent;
  }
  set parent(p) {
    let designSetChanged = !this._parent || p && p._designSet != this._parent._designSet;
    this._parent = p;
    if (this.type == design.defaultType && designSetChanged) {
      this.jCal[TYPE_INDEX] = this.getDefaultType();
      this._updateType();
    }
  }
  /**
   * The design set for this property, e.g. icalendar vs vcard
   *
   * @type {designSet}
   * @private
   */
  get _designSet() {
    return this.parent ? this.parent._designSet : design.defaultSet;
  }
  /**
   * Updates the type metadata from the current jCal type and design set.
   *
   * @private
   */
  _updateType() {
    let designSet = this._designSet;
    if (this.type in designSet.value) {
      if ("decorate" in designSet.value[this.type]) {
        this.isDecorated = true;
      } else {
        this.isDecorated = false;
      }
      if (this.name in designSet.property) {
        this.isMultiValue = "multiValue" in designSet.property[this.name];
        this.isStructuredValue = "structuredValue" in designSet.property[this.name];
      }
    }
  }
  /**
   * Hydrate a single value. The act of hydrating means turning the raw jCal
   * value into a potentially wrapped object, for example {@link ICAL.Time}.
   *
   * @private
   * @param {Number} index        The index of the value to hydrate
   * @return {?Object}             The decorated value.
   */
  _hydrateValue(index2) {
    if (this._values && this._values[index2]) {
      return this._values[index2];
    }
    if (this.jCal.length <= VALUE_INDEX + index2) {
      return null;
    }
    if (this.isDecorated) {
      if (!this._values) {
        this._values = [];
      }
      return this._values[index2] = this._decorate(
        this.jCal[VALUE_INDEX + index2]
      );
    } else {
      return this.jCal[VALUE_INDEX + index2];
    }
  }
  /**
   * Decorate a single value, returning its wrapped object. This is used by
   * the hydrate function to actually wrap the value.
   *
   * @private
   * @param {?} value         The value to decorate
   * @return {Object}         The decorated value
   */
  _decorate(value) {
    return this._designSet.value[this.type].decorate(value, this);
  }
  /**
   * Undecorate a single value, returning its raw jCal data.
   *
   * @private
   * @param {Object} value         The value to undecorate
   * @return {?}                   The undecorated value
   */
  _undecorate(value) {
    return this._designSet.value[this.type].undecorate(value, this);
  }
  /**
   * Sets the value at the given index while also hydrating it. The passed
   * value can either be a decorated or undecorated value.
   *
   * @private
   * @param {?} value             The value to set
   * @param {Number} index        The index to set it at
   */
  _setDecoratedValue(value, index2) {
    if (!this._values) {
      this._values = [];
    }
    if (typeof value === "object" && "icaltype" in value) {
      this.jCal[VALUE_INDEX + index2] = this._undecorate(value);
      this._values[index2] = value;
    } else {
      this.jCal[VALUE_INDEX + index2] = value;
      this._values[index2] = this._decorate(value);
    }
  }
  /**
   * Gets a parameter on the property.
   *
   * @param {String}        name   Parameter name (lowercase)
   * @return {Array|String}        Parameter value
   */
  getParameter(name) {
    if (name in this.jCal[PROP_INDEX]) {
      return this.jCal[PROP_INDEX][name];
    } else {
      return void 0;
    }
  }
  /**
   * Gets first parameter on the property.
   *
   * @param {String}        name   Parameter name (lowercase)
   * @return {String}        Parameter value
   */
  getFirstParameter(name) {
    let parameters = this.getParameter(name);
    if (Array.isArray(parameters)) {
      return parameters[0];
    }
    return parameters;
  }
  /**
   * Sets a parameter on the property.
   *
   * @param {String}       name     The parameter name
   * @param {Array|String} value    The parameter value
   */
  setParameter(name, value) {
    let lcname = name.toLowerCase();
    if (typeof value === "string" && lcname in this._designSet.param && "multiValue" in this._designSet.param[lcname]) {
      value = [value];
    }
    this.jCal[PROP_INDEX][name] = value;
  }
  /**
   * Removes a parameter
   *
   * @param {String} name     The parameter name
   */
  removeParameter(name) {
    delete this.jCal[PROP_INDEX][name];
  }
  /**
   * Get the default type based on this property's name.
   *
   * @return {String}     The default type for this property
   */
  getDefaultType() {
    let name = this.jCal[NAME_INDEX$1];
    let designSet = this._designSet;
    if (name in designSet.property) {
      let details = designSet.property[name];
      if ("defaultType" in details) {
        return details.defaultType;
      }
    }
    return design.defaultType;
  }
  /**
   * Sets type of property and clears out any existing values of the current
   * type.
   *
   * @param {String} type     New iCAL type (see design.*.values)
   */
  resetType(type) {
    this.removeAllValues();
    this.jCal[TYPE_INDEX] = type;
    this._updateType();
  }
  /**
   * Finds the first property value.
   *
   * @return {Binary | Duration | Period |
   * Recur | Time | UtcOffset | Geo | string | null}         First property value
   */
  getFirstValue() {
    return this._hydrateValue(0);
  }
  /**
   * Gets all values on the property.
   *
   * NOTE: this creates an array during each call.
   *
   * @return {Array}          List of values
   */
  getValues() {
    let len = this.jCal.length - VALUE_INDEX;
    if (len < 1) {
      return [];
    }
    let i = 0;
    let result = [];
    for (; i < len; i++) {
      result[i] = this._hydrateValue(i);
    }
    return result;
  }
  /**
   * Removes all values from this property
   */
  removeAllValues() {
    if (this._values) {
      this._values.length = 0;
    }
    this.jCal.length = 3;
  }
  /**
   * Sets the values of the property.  Will overwrite the existing values.
   * This can only be used for multi-value properties.
   *
   * @param {Array} values    An array of values
   */
  setValues(values) {
    if (!this.isMultiValue) {
      throw new Error(
        this.name + ": does not not support mulitValue.\noverride isMultiValue"
      );
    }
    let len = values.length;
    let i = 0;
    this.removeAllValues();
    if (len > 0 && typeof values[0] === "object" && "icaltype" in values[0]) {
      this.resetType(values[0].icaltype);
    }
    if (this.isDecorated) {
      for (; i < len; i++) {
        this._setDecoratedValue(values[i], i);
      }
    } else {
      for (; i < len; i++) {
        this.jCal[VALUE_INDEX + i] = values[i];
      }
    }
  }
  /**
   * Sets the current value of the property. If this is a multi-value
   * property, all other values will be removed.
   *
   * @param {String|Object} value     New property value.
   */
  setValue(value) {
    this.removeAllValues();
    if (typeof value === "object" && "icaltype" in value) {
      this.resetType(value.icaltype);
    }
    if (this.isDecorated) {
      this._setDecoratedValue(value, 0);
    } else {
      this.jCal[VALUE_INDEX] = value;
    }
  }
  /**
   * Returns the Object representation of this component. The returned object
   * is a live jCal object and should be cloned if modified.
   * @return {Object}
   */
  toJSON() {
    return this.jCal;
  }
  /**
   * The string representation of this component.
   * @return {String}
   */
  toICALString() {
    return stringify.property(
      this.jCal,
      this._designSet,
      true
    );
  }
}
const NAME_INDEX = 0;
const PROPERTY_INDEX = 1;
const COMPONENT_INDEX = 2;
const PROPERTY_NAME_INDEX = 0;
const PROPERTY_VALUE_INDEX = 3;
class Component {
  /**
   * Create an {@link ICAL.Component} by parsing the passed iCalendar string.
   *
   * @param {String} str        The iCalendar string to parse
   */
  static fromString(str) {
    return new Component(parse.component(str));
  }
  /**
   * Creates a new Component instance.
   *
   * @param {Array|String} jCal         Raw jCal component data OR name of new
   *                                      component
   * @param {Component=} parent     Parent component to associate
   */
  constructor(jCal, parent) {
    if (typeof jCal === "string") {
      jCal = [jCal, [], []];
    }
    this.jCal = jCal;
    this.parent = parent || null;
    if (!this.parent && this.name === "vcalendar") {
      this._timezoneCache = /* @__PURE__ */ new Map();
    }
  }
  /**
   * Hydrated properties are inserted into the _properties array at the same
   * position as in the jCal array, so it is possible that the array contains
   * undefined values for unhydrdated properties. To avoid iterating the
   * array when checking if all properties have been hydrated, we save the
   * count here.
   *
   * @type {Number}
   * @private
   */
  _hydratedPropertyCount = 0;
  /**
   * The same count as for _hydratedPropertyCount, but for subcomponents
   *
   * @type {Number}
   * @private
   */
  _hydratedComponentCount = 0;
  /**
   * A cache of hydrated time zone objects which may be used by consumers, keyed
   * by time zone ID.
   *
   * @type {Map}
   * @private
   */
  _timezoneCache = null;
  /**
   * @private
   */
  _components = null;
  /**
   * @private
   */
  _properties = null;
  /**
   * The name of this component
   *
   * @type {String}
   */
  get name() {
    return this.jCal[NAME_INDEX];
  }
  /**
   * The design set for this component, e.g. icalendar vs vcard
   *
   * @type {designSet}
   * @private
   */
  get _designSet() {
    let parentDesign = this.parent && this.parent._designSet;
    if (!parentDesign && this.name == "vcard") {
      let versionProp = this.jCal[PROPERTY_INDEX]?.[0];
      if (versionProp && versionProp[PROPERTY_NAME_INDEX] == "version" && versionProp[PROPERTY_VALUE_INDEX] == "3.0") {
        return design.getDesignSet("vcard3");
      }
    }
    return parentDesign || design.getDesignSet(this.name);
  }
  /**
   * @private
   */
  _hydrateComponent(index2) {
    if (!this._components) {
      this._components = [];
      this._hydratedComponentCount = 0;
    }
    if (this._components[index2]) {
      return this._components[index2];
    }
    let comp = new Component(
      this.jCal[COMPONENT_INDEX][index2],
      this
    );
    this._hydratedComponentCount++;
    return this._components[index2] = comp;
  }
  /**
   * @private
   */
  _hydrateProperty(index2) {
    if (!this._properties) {
      this._properties = [];
      this._hydratedPropertyCount = 0;
    }
    if (this._properties[index2]) {
      return this._properties[index2];
    }
    let prop = new Property(
      this.jCal[PROPERTY_INDEX][index2],
      this
    );
    this._hydratedPropertyCount++;
    return this._properties[index2] = prop;
  }
  /**
   * Finds first sub component, optionally filtered by name.
   *
   * @param {String=} name        Optional name to filter by
   * @return {?Component}     The found subcomponent
   */
  getFirstSubcomponent(name) {
    if (name) {
      let i = 0;
      let comps = this.jCal[COMPONENT_INDEX];
      let len = comps.length;
      for (; i < len; i++) {
        if (comps[i][NAME_INDEX] === name) {
          let result = this._hydrateComponent(i);
          return result;
        }
      }
    } else {
      if (this.jCal[COMPONENT_INDEX].length) {
        return this._hydrateComponent(0);
      }
    }
    return null;
  }
  /**
   * Finds all sub components, optionally filtering by name.
   *
   * @param {String=} name            Optional name to filter by
   * @return {Component[]}       The found sub components
   */
  getAllSubcomponents(name) {
    let jCalLen = this.jCal[COMPONENT_INDEX].length;
    let i = 0;
    if (name) {
      let comps = this.jCal[COMPONENT_INDEX];
      let result = [];
      for (; i < jCalLen; i++) {
        if (name === comps[i][NAME_INDEX]) {
          result.push(
            this._hydrateComponent(i)
          );
        }
      }
      return result;
    } else {
      if (!this._components || this._hydratedComponentCount !== jCalLen) {
        for (; i < jCalLen; i++) {
          this._hydrateComponent(i);
        }
      }
      return this._components || [];
    }
  }
  /**
   * Returns true when a named property exists.
   *
   * @param {String} name     The property name
   * @return {Boolean}        True, when property is found
   */
  hasProperty(name) {
    let props = this.jCal[PROPERTY_INDEX];
    let len = props.length;
    let i = 0;
    for (; i < len; i++) {
      if (props[i][NAME_INDEX] === name) {
        return true;
      }
    }
    return false;
  }
  /**
   * Finds the first property, optionally with the given name.
   *
   * @param {String=} name        Lowercase property name
   * @return {?Property}     The found property
   */
  getFirstProperty(name) {
    if (name) {
      let i = 0;
      let props = this.jCal[PROPERTY_INDEX];
      let len = props.length;
      for (; i < len; i++) {
        if (props[i][NAME_INDEX] === name) {
          let result = this._hydrateProperty(i);
          return result;
        }
      }
    } else {
      if (this.jCal[PROPERTY_INDEX].length) {
        return this._hydrateProperty(0);
      }
    }
    return null;
  }
  /**
   * Returns first property's value, if available.
   *
   * @param {String=} name                    Lowercase property name
   * @return {Binary | Duration | Period |
   * Recur | Time | UtcOffset | Geo | string | null}         The found property value.
   */
  getFirstPropertyValue(name) {
    let prop = this.getFirstProperty(name);
    if (prop) {
      return prop.getFirstValue();
    }
    return null;
  }
  /**
   * Get all properties in the component, optionally filtered by name.
   *
   * @param {String=} name        Lowercase property name
   * @return {Property[]}    List of properties
   */
  getAllProperties(name) {
    let jCalLen = this.jCal[PROPERTY_INDEX].length;
    let i = 0;
    if (name) {
      let props = this.jCal[PROPERTY_INDEX];
      let result = [];
      for (; i < jCalLen; i++) {
        if (name === props[i][NAME_INDEX]) {
          result.push(
            this._hydrateProperty(i)
          );
        }
      }
      return result;
    } else {
      if (!this._properties || this._hydratedPropertyCount !== jCalLen) {
        for (; i < jCalLen; i++) {
          this._hydrateProperty(i);
        }
      }
      return this._properties || [];
    }
  }
  /**
   * @private
   */
  _removeObjectByIndex(jCalIndex, cache, index2) {
    cache = cache || [];
    if (cache[index2]) {
      let obj = cache[index2];
      if ("parent" in obj) {
        obj.parent = null;
      }
    }
    cache.splice(index2, 1);
    this.jCal[jCalIndex].splice(index2, 1);
  }
  /**
   * @private
   */
  _removeObject(jCalIndex, cache, nameOrObject) {
    let i = 0;
    let objects = this.jCal[jCalIndex];
    let len = objects.length;
    let cached = this[cache];
    if (typeof nameOrObject === "string") {
      for (; i < len; i++) {
        if (objects[i][NAME_INDEX] === nameOrObject) {
          this._removeObjectByIndex(jCalIndex, cached, i);
          return true;
        }
      }
    } else if (cached) {
      for (; i < len; i++) {
        if (cached[i] && cached[i] === nameOrObject) {
          this._removeObjectByIndex(jCalIndex, cached, i);
          return true;
        }
      }
    }
    return false;
  }
  /**
   * @private
   */
  _removeAllObjects(jCalIndex, cache, name) {
    let cached = this[cache];
    let objects = this.jCal[jCalIndex];
    let i = objects.length - 1;
    for (; i >= 0; i--) {
      if (!name || objects[i][NAME_INDEX] === name) {
        this._removeObjectByIndex(jCalIndex, cached, i);
      }
    }
  }
  /**
   * Adds a single sub component.
   *
   * @param {Component} component        The component to add
   * @return {Component}                 The passed in component
   */
  addSubcomponent(component) {
    if (!this._components) {
      this._components = [];
      this._hydratedComponentCount = 0;
    }
    if (component.parent) {
      component.parent.removeSubcomponent(component);
    }
    let idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
    this._components[idx - 1] = component;
    this._hydratedComponentCount++;
    component.parent = this;
    return component;
  }
  /**
   * Removes a single component by name or the instance of a specific
   * component.
   *
   * @param {Component|String} nameOrComp    Name of component, or component
   * @return {Boolean}                            True when comp is removed
   */
  removeSubcomponent(nameOrComp) {
    let removed = this._removeObject(COMPONENT_INDEX, "_components", nameOrComp);
    if (removed) {
      this._hydratedComponentCount--;
    }
    return removed;
  }
  /**
   * Removes all components or (if given) all components by a particular
   * name.
   *
   * @param {String=} name            Lowercase component name
   */
  removeAllSubcomponents(name) {
    let removed = this._removeAllObjects(COMPONENT_INDEX, "_components", name);
    this._hydratedComponentCount = 0;
    return removed;
  }
  /**
   * Adds an {@link ICAL.Property} to the component.
   *
   * @param {Property} property      The property to add
   * @return {Property}              The passed in property
   */
  addProperty(property) {
    if (!(property instanceof Property)) {
      throw new TypeError("must be instance of ICAL.Property");
    }
    if (!this._properties) {
      this._properties = [];
      this._hydratedPropertyCount = 0;
    }
    if (property.parent) {
      property.parent.removeProperty(property);
    }
    let idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
    this._properties[idx - 1] = property;
    this._hydratedPropertyCount++;
    property.parent = this;
    return property;
  }
  /**
   * Helper method to add a property with a value to the component.
   *
   * @param {String}               name         Property name to add
   * @param {String|Number|Object} value        Property value
   * @return {Property}                    The created property
   */
  addPropertyWithValue(name, value) {
    let prop = new Property(name);
    prop.setValue(value);
    this.addProperty(prop);
    return prop;
  }
  /**
   * Helper method that will update or create a property of the given name
   * and sets its value. If multiple properties with the given name exist,
   * only the first is updated.
   *
   * @param {String}               name         Property name to update
   * @param {String|Number|Object} value        Property value
   * @return {Property}                    The created property
   */
  updatePropertyWithValue(name, value) {
    let prop = this.getFirstProperty(name);
    if (prop) {
      prop.setValue(value);
    } else {
      prop = this.addPropertyWithValue(name, value);
    }
    return prop;
  }
  /**
   * Removes a single property by name or the instance of the specific
   * property.
   *
   * @param {String|Property} nameOrProp     Property name or instance to remove
   * @return {Boolean}                            True, when deleted
   */
  removeProperty(nameOrProp) {
    let removed = this._removeObject(PROPERTY_INDEX, "_properties", nameOrProp);
    if (removed) {
      this._hydratedPropertyCount--;
    }
    return removed;
  }
  /**
   * Removes all properties associated with this component, optionally
   * filtered by name.
   *
   * @param {String=} name        Lowercase property name
   * @return {Boolean}            True, when deleted
   */
  removeAllProperties(name) {
    let removed = this._removeAllObjects(PROPERTY_INDEX, "_properties", name);
    this._hydratedPropertyCount = 0;
    return removed;
  }
  /**
   * Returns the Object representation of this component. The returned object
   * is a live jCal object and should be cloned if modified.
   * @return {Object}
   */
  toJSON() {
    return this.jCal;
  }
  /**
   * The string representation of this component.
   * @return {String}
   */
  toString() {
    return stringify.component(
      this.jCal,
      this._designSet
    );
  }
  /**
   * Retrieve a time zone definition from the component tree, if any is present.
   * If the tree contains no time zone definitions or the TZID cannot be
   * matched, returns null.
   *
   * @param {String} tzid     The ID of the time zone to retrieve
   * @return {Timezone}  The time zone corresponding to the ID, or null
   */
  getTimeZoneByID(tzid) {
    if (this.parent) {
      return this.parent.getTimeZoneByID(tzid);
    }
    if (!this._timezoneCache) {
      return null;
    }
    if (this._timezoneCache.has(tzid)) {
      return this._timezoneCache.get(tzid);
    }
    const zones2 = this.getAllSubcomponents("vtimezone");
    for (const zone of zones2) {
      if (zone.getFirstProperty("tzid").getFirstValue() === tzid) {
        const hydratedZone = new Timezone$1({
          component: zone,
          tzid
        });
        this._timezoneCache.set(tzid, hydratedZone);
        return hydratedZone;
      }
    }
    return null;
  }
}
class RecurExpansion {
  /**
   * Creates a new ICAL.RecurExpansion instance.
   *
   * The options object can be filled with the specified initial values. It can also contain
   * additional members, as a result of serializing a previous expansion state, as shown in the
   * example.
   *
   * @param {Object} options
   *        Recurrence expansion options
   * @param {Time} options.dtstart
   *        Start time of the event
   * @param {Component=} options.component
   *        Component for expansion, required if not resuming.
   */
  constructor(options) {
    this.ruleDates = [];
    this.exDates = [];
    this.fromData(options);
  }
  /**
   * True when iteration is fully completed.
   * @type {Boolean}
   */
  complete = false;
  /**
   * Array of rrule iterators.
   *
   * @type {RecurIterator[]}
   * @private
   */
  ruleIterators = null;
  /**
   * Array of rdate instances.
   *
   * @type {Time[]}
   * @private
   */
  ruleDates = null;
  /**
   * Array of exdate instances.
   *
   * @type {Time[]}
   * @private
   */
  exDates = null;
  /**
   * Current position in ruleDates array.
   * @type {Number}
   * @private
   */
  ruleDateInc = 0;
  /**
   * Current position in exDates array
   * @type {Number}
   * @private
   */
  exDateInc = 0;
  /**
   * Current negative date.
   *
   * @type {Time}
   * @private
   */
  exDate = null;
  /**
   * Current additional date.
   *
   * @type {Time}
   * @private
   */
  ruleDate = null;
  /**
   * Start date of recurring rules.
   *
   * @type {Time}
   */
  dtstart = null;
  /**
   * Last expanded time
   *
   * @type {Time}
   */
  last = null;
  /**
   * Initialize the recurrence expansion from the data object. The options
   * object may also contain additional members, see the
   * {@link ICAL.RecurExpansion constructor} for more details.
   *
   * @param {Object} options
   *        Recurrence expansion options
   * @param {Time} options.dtstart
   *        Start time of the event
   * @param {Component=} options.component
   *        Component for expansion, required if not resuming.
   */
  fromData(options) {
    let start = formatClassType(options.dtstart, Time);
    if (!start) {
      throw new Error(".dtstart (ICAL.Time) must be given");
    } else {
      this.dtstart = start;
    }
    if (options.component) {
      this._init(options.component);
    } else {
      this.last = formatClassType(options.last, Time) || start.clone();
      if (!options.ruleIterators) {
        throw new Error(".ruleIterators or .component must be given");
      }
      this.ruleIterators = options.ruleIterators.map(function(item) {
        return formatClassType(item, RecurIterator);
      });
      this.ruleDateInc = options.ruleDateInc;
      this.exDateInc = options.exDateInc;
      if (options.ruleDates) {
        this.ruleDates = options.ruleDates.map((item) => formatClassType(item, Time));
        this.ruleDate = this.ruleDates[this.ruleDateInc];
      }
      if (options.exDates) {
        this.exDates = options.exDates.map((item) => formatClassType(item, Time));
        this.exDate = this.exDates[this.exDateInc];
      }
      if (typeof options.complete !== "undefined") {
        this.complete = options.complete;
      }
    }
  }
  /**
   * Compare two ICAL.Time objects.  When the second parameter is a DATE and the first parameter is
   * DATE-TIME, strip the time and compare only the days.
   *
   * @private
   * @param {Time} a   The one object to compare
   * @param {Time} b   The other object to compare
   */
  _compare_special(a, b) {
    if (!a.isDate && b.isDate)
      return new Time({ year: a.year, month: a.month, day: a.day }).compare(b);
    return a.compare(b);
  }
  /**
   * Retrieve the next occurrence in the series.
   * @return {Time}
   */
  next() {
    let iter;
    let next;
    let compare;
    let maxTries = 500;
    let currentTry = 0;
    while (true) {
      if (currentTry++ > maxTries) {
        throw new Error(
          "max tries have occurred, rule may be impossible to fulfill."
        );
      }
      next = this.ruleDate;
      iter = this._nextRecurrenceIter(this.last);
      if (!next && !iter) {
        this.complete = true;
        break;
      }
      if (!next || iter && next.compare(iter.last) > 0) {
        next = iter.last.clone();
        iter.next();
      }
      if (this.ruleDate === next) {
        this._nextRuleDay();
      }
      this.last = next;
      if (this.exDate) {
        compare = this._compare_special(this.last, this.exDate);
        if (compare > 0) {
          this._nextExDay();
        }
        if (compare === 0) {
          this._nextExDay();
          continue;
        }
      }
      return this.last;
    }
  }
  /**
   * Converts object into a serialize-able format. This format can be passed
   * back into the expansion to resume iteration.
   * @return {Object}
   */
  toJSON() {
    function toJSON(item) {
      return item.toJSON();
    }
    let result = /* @__PURE__ */ Object.create(null);
    result.ruleIterators = this.ruleIterators.map(toJSON);
    if (this.ruleDates) {
      result.ruleDates = this.ruleDates.map(toJSON);
    }
    if (this.exDates) {
      result.exDates = this.exDates.map(toJSON);
    }
    result.ruleDateInc = this.ruleDateInc;
    result.exDateInc = this.exDateInc;
    result.last = this.last.toJSON();
    result.dtstart = this.dtstart.toJSON();
    result.complete = this.complete;
    return result;
  }
  /**
   * Extract all dates from the properties in the given component. The
   * properties will be filtered by the property name.
   *
   * @private
   * @param {Component} component             The component to search in
   * @param {String} propertyName             The property name to search for
   * @return {Time[]}                         The extracted dates.
   */
  _extractDates(component, propertyName) {
    let result = [];
    let props = component.getAllProperties(propertyName);
    for (let i = 0, len = props.length; i < len; i++) {
      for (let prop of props[i].getValues()) {
        let idx = binsearchInsert(
          result,
          prop,
          (a, b) => a.compare(b)
        );
        result.splice(idx, 0, prop);
      }
    }
    return result;
  }
  /**
   * Initialize the recurrence expansion.
   *
   * @private
   * @param {Component} component    The component to initialize from.
   */
  _init(component) {
    this.ruleIterators = [];
    this.last = this.dtstart.clone();
    if (!component.hasProperty("rdate") && !component.hasProperty("rrule") && !component.hasProperty("recurrence-id")) {
      this.ruleDate = this.last.clone();
      this.complete = true;
      return;
    }
    if (component.hasProperty("rdate")) {
      this.ruleDates = this._extractDates(component, "rdate");
      if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {
        this.ruleDateInc = 0;
        this.last = this.ruleDates[0].clone();
      } else {
        this.ruleDateInc = binsearchInsert(
          this.ruleDates,
          this.last,
          (a, b) => a.compare(b)
        );
      }
      this.ruleDate = this.ruleDates[this.ruleDateInc];
    }
    if (component.hasProperty("rrule")) {
      let rules = component.getAllProperties("rrule");
      let i = 0;
      let len = rules.length;
      let rule;
      let iter;
      for (; i < len; i++) {
        rule = rules[i].getFirstValue();
        iter = rule.iterator(this.dtstart);
        this.ruleIterators.push(iter);
        iter.next();
      }
    }
    if (component.hasProperty("exdate")) {
      this.exDates = this._extractDates(component, "exdate");
      this.exDateInc = binsearchInsert(
        this.exDates,
        this.last,
        this._compare_special
      );
      this.exDate = this.exDates[this.exDateInc];
    }
  }
  /**
   * Advance to the next exdate
   * @private
   */
  _nextExDay() {
    this.exDate = this.exDates[++this.exDateInc];
  }
  /**
   * Advance to the next rule date
   * @private
   */
  _nextRuleDay() {
    this.ruleDate = this.ruleDates[++this.ruleDateInc];
  }
  /**
   * Find and return the recurrence rule with the most recent event and
   * return it.
   *
   * @private
   * @return {?RecurIterator}    Found iterator.
   */
  _nextRecurrenceIter() {
    let iters = this.ruleIterators;
    if (iters.length === 0) {
      return null;
    }
    let len = iters.length;
    let iter;
    let iterTime;
    let iterIdx = 0;
    let chosenIter;
    for (; iterIdx < len; iterIdx++) {
      iter = iters[iterIdx];
      iterTime = iter.last;
      if (iter.completed) {
        len--;
        if (iterIdx !== 0) {
          iterIdx--;
        }
        iters.splice(iterIdx, 1);
        continue;
      }
      if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
        chosenIter = iter;
      }
    }
    return chosenIter;
  }
}
class Event {
  /**
   * Creates a new ICAL.Event instance.
   *
   * @param {Component=} component              The ICAL.Component to base this event on
   * @param {Object} [options]                  Options for this event
   * @param {Boolean=} options.strictExceptions  When true, will verify exceptions are related by
   *                                              their UUID
   * @param {Array<Component|Event>=} options.exceptions
   *          Exceptions to this event, either as components or events. If not
   *            specified exceptions will automatically be set in relation of
   *            component's parent
   */
  constructor(component, options) {
    if (!(component instanceof Component)) {
      options = component;
      component = null;
    }
    if (component) {
      this.component = component;
    } else {
      this.component = new Component("vevent");
    }
    this._rangeExceptionCache = /* @__PURE__ */ Object.create(null);
    this.exceptions = /* @__PURE__ */ Object.create(null);
    this.rangeExceptions = [];
    if (options && options.strictExceptions) {
      this.strictExceptions = options.strictExceptions;
    }
    if (options && options.exceptions) {
      options.exceptions.forEach(this.relateException, this);
    } else if (this.component.parent && !this.isRecurrenceException()) {
      this.component.parent.getAllSubcomponents("vevent").forEach(function(event) {
        if (event.hasProperty("recurrence-id")) {
          this.relateException(event);
        }
      }, this);
    }
  }
  static THISANDFUTURE = "THISANDFUTURE";
  /**
   * List of related event exceptions.
   *
   * @type {Event[]}
   */
  exceptions = null;
  /**
   * When true, will verify exceptions are related by their UUID.
   *
   * @type {Boolean}
   */
  strictExceptions = false;
  /**
   * Relates a given event exception to this object.  If the given component
   * does not share the UID of this event it cannot be related and will throw
   * an exception.
   *
   * If this component is an exception it cannot have other exceptions
   * related to it.
   *
   * @param {Component|Event} obj       Component or event
   */
  relateException(obj) {
    if (this.isRecurrenceException()) {
      throw new Error("cannot relate exception to exceptions");
    }
    if (obj instanceof Component) {
      obj = new Event(obj);
    }
    if (this.strictExceptions && obj.uid !== this.uid) {
      throw new Error("attempted to relate unrelated exception");
    }
    let id = obj.recurrenceId.toString();
    this.exceptions[id] = obj;
    if (obj.modifiesFuture()) {
      let item = [
        obj.recurrenceId.toUnixTime(),
        id
      ];
      let idx = binsearchInsert(
        this.rangeExceptions,
        item,
        compareRangeException
      );
      this.rangeExceptions.splice(idx, 0, item);
    }
  }
  /**
   * Checks if this record is an exception and has the RANGE=THISANDFUTURE
   * value.
   *
   * @return {Boolean}        True, when exception is within range
   */
  modifiesFuture() {
    if (!this.component.hasProperty("recurrence-id")) {
      return false;
    }
    let range = this.component.getFirstProperty("recurrence-id").getParameter("range");
    return range === Event.THISANDFUTURE;
  }
  /**
   * Finds the range exception nearest to the given date.
   *
   * @param {Time} time   usually an occurrence time of an event
   * @return {?Event}     the related event/exception or null
   */
  findRangeException(time) {
    if (!this.rangeExceptions.length) {
      return null;
    }
    let utc = time.toUnixTime();
    let idx = binsearchInsert(
      this.rangeExceptions,
      [utc],
      compareRangeException
    );
    idx -= 1;
    if (idx < 0) {
      return null;
    }
    let rangeItem = this.rangeExceptions[idx];
    if (utc < rangeItem[0]) {
      return null;
    }
    return rangeItem[1];
  }
  /**
   * Returns the occurrence details based on its start time.  If the
   * occurrence has an exception will return the details for that exception.
   *
   * NOTE: this method is intend to be used in conjunction
   *       with the {@link ICAL.Event#iterator iterator} method.
   *
   * @param {Time} occurrence               time occurrence
   * @return {occurrenceDetails}            Information about the occurrence
   */
  getOccurrenceDetails(occurrence) {
    let id = occurrence.toString();
    let utcId = occurrence.convertToZone(Timezone$1.utcTimezone).toString();
    let item;
    let result = {
      //XXX: Clone?
      recurrenceId: occurrence
    };
    if (id in this.exceptions) {
      item = result.item = this.exceptions[id];
      result.startDate = item.startDate;
      result.endDate = item.endDate;
      result.item = item;
    } else if (utcId in this.exceptions) {
      item = this.exceptions[utcId];
      result.startDate = item.startDate;
      result.endDate = item.endDate;
      result.item = item;
    } else {
      let rangeExceptionId = this.findRangeException(
        occurrence
      );
      let end;
      if (rangeExceptionId) {
        let exception = this.exceptions[rangeExceptionId];
        result.item = exception;
        let startDiff = this._rangeExceptionCache[rangeExceptionId];
        if (!startDiff) {
          let original = exception.recurrenceId.clone();
          let newStart = exception.startDate.clone();
          original.zone = newStart.zone;
          startDiff = newStart.subtractDate(original);
          this._rangeExceptionCache[rangeExceptionId] = startDiff;
        }
        let start = occurrence.clone();
        start.zone = exception.startDate.zone;
        start.addDuration(startDiff);
        end = start.clone();
        end.addDuration(exception.duration);
        result.startDate = start;
        result.endDate = end;
      } else {
        end = occurrence.clone();
        end.addDuration(this.duration);
        result.endDate = end;
        result.startDate = occurrence;
        result.item = this;
      }
    }
    return result;
  }
  /**
   * Builds a recur expansion instance for a specific point in time (defaults
   * to startDate).
   *
   * @param {Time=} startTime     Starting point for expansion
   * @return {RecurExpansion}    Expansion object
   */
  iterator(startTime) {
    return new RecurExpansion({
      component: this.component,
      dtstart: startTime || this.startDate
    });
  }
  /**
   * Checks if the event is recurring
   *
   * @return {Boolean}        True, if event is recurring
   */
  isRecurring() {
    let comp = this.component;
    return comp.hasProperty("rrule") || comp.hasProperty("rdate");
  }
  /**
   * Checks if the event describes a recurrence exception. See
   * {@tutorial terminology} for details.
   *
   * @return {Boolean}    True, if the event describes a recurrence exception
   */
  isRecurrenceException() {
    return this.component.hasProperty("recurrence-id");
  }
  /**
   * Returns the types of recurrences this event may have.
   *
   * Returned as an object with the following possible keys:
   *
   *    - YEARLY
   *    - MONTHLY
   *    - WEEKLY
   *    - DAILY
   *    - MINUTELY
   *    - SECONDLY
   *
   * @return {Object.<frequencyValues, Boolean>}
   *          Object of recurrence flags
   */
  getRecurrenceTypes() {
    let rules = this.component.getAllProperties("rrule");
    let i = 0;
    let len = rules.length;
    let result = /* @__PURE__ */ Object.create(null);
    for (; i < len; i++) {
      let value = rules[i].getFirstValue();
      result[value.freq] = true;
    }
    return result;
  }
  /**
   * The uid of this event
   * @type {String}
   */
  get uid() {
    return this._firstProp("uid");
  }
  set uid(value) {
    this._setProp("uid", value);
  }
  /**
   * The start date
   * @type {Time}
   */
  get startDate() {
    return this._firstProp("dtstart");
  }
  set startDate(value) {
    this._setTime("dtstart", value);
  }
  /**
   * The end date. This can be the result directly from the property, or the
   * end date calculated from start date and duration. Setting the property
   * will remove any duration properties.
   * @type {Time}
   */
  get endDate() {
    let endDate = this._firstProp("dtend");
    if (!endDate) {
      let duration = this._firstProp("duration");
      endDate = this.startDate.clone();
      if (duration) {
        endDate.addDuration(duration);
      } else if (endDate.isDate) {
        endDate.day += 1;
      }
    }
    return endDate;
  }
  set endDate(value) {
    if (this.component.hasProperty("duration")) {
      this.component.removeProperty("duration");
    }
    this._setTime("dtend", value);
  }
  /**
   * The duration. This can be the result directly from the property, or the
   * duration calculated from start date and end date. Setting the property
   * will remove any `dtend` properties.
   * @type {Duration}
   */
  get duration() {
    let duration = this._firstProp("duration");
    if (!duration) {
      return this.endDate.subtractDateTz(this.startDate);
    }
    return duration;
  }
  set duration(value) {
    if (this.component.hasProperty("dtend")) {
      this.component.removeProperty("dtend");
    }
    this._setProp("duration", value);
  }
  /**
   * The location of the event.
   * @type {String}
   */
  get location() {
    return this._firstProp("location");
  }
  set location(value) {
    this._setProp("location", value);
  }
  /**
   * The attendees in the event
   * @type {Property[]}
   */
  get attendees() {
    return this.component.getAllProperties("attendee");
  }
  /**
   * The event summary
   * @type {String}
   */
  get summary() {
    return this._firstProp("summary");
  }
  set summary(value) {
    this._setProp("summary", value);
  }
  /**
   * The event description.
   * @type {String}
   */
  get description() {
    return this._firstProp("description");
  }
  set description(value) {
    this._setProp("description", value);
  }
  /**
   * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)
   * @type {String}
   */
  get color() {
    return this._firstProp("color");
  }
  set color(value) {
    this._setProp("color", value);
  }
  /**
   * The organizer value as an uri. In most cases this is a mailto: uri, but
   * it can also be something else, like urn:uuid:...
   * @type {String}
   */
  get organizer() {
    return this._firstProp("organizer");
  }
  set organizer(value) {
    this._setProp("organizer", value);
  }
  /**
   * The sequence value for this event. Used for scheduling
   * see {@tutorial terminology}.
   * @type {Number}
   */
  get sequence() {
    return this._firstProp("sequence");
  }
  set sequence(value) {
    this._setProp("sequence", value);
  }
  /**
   * The recurrence id for this event. See {@tutorial terminology} for details.
   * @type {Time}
   */
  get recurrenceId() {
    return this._firstProp("recurrence-id");
  }
  set recurrenceId(value) {
    this._setTime("recurrence-id", value);
  }
  /**
   * Set/update a time property's value.
   * This will also update the TZID of the property.
   *
   * TODO: this method handles the case where we are switching
   * from a known timezone to an implied timezone (one without TZID).
   * This does _not_ handle the case of moving between a known
   *  (by TimezoneService) timezone to an unknown timezone...
   *
   * We will not add/remove/update the VTIMEZONE subcomponents
   *  leading to invalid ICAL data...
   * @private
   * @param {String} propName     The property name
   * @param {Time} time           The time to set
   */
  _setTime(propName, time) {
    let prop = this.component.getFirstProperty(propName);
    if (!prop) {
      prop = new Property(propName);
      this.component.addProperty(prop);
    }
    if (time.zone === Timezone$1.localTimezone || time.zone === Timezone$1.utcTimezone) {
      prop.removeParameter("tzid");
    } else {
      prop.setParameter("tzid", time.zone.tzid);
    }
    prop.setValue(time);
  }
  _setProp(name, value) {
    this.component.updatePropertyWithValue(name, value);
  }
  _firstProp(name) {
    return this.component.getFirstPropertyValue(name);
  }
  /**
   * The string representation of this event.
   * @return {String}
   */
  toString() {
    return this.component.toString();
  }
}
function compareRangeException(a, b) {
  if (a[0] > b[0]) return 1;
  if (b[0] > a[0]) return -1;
  return 0;
}
class ComponentParser {
  /**
   * Creates a new ICAL.ComponentParser instance.
   *
   * @param {Object=} options                   Component parser options
   * @param {Boolean} options.parseEvent        Whether events should be parsed
   * @param {Boolean} options.parseTimezeone    Whether timezones should be parsed
   */
  constructor(options) {
    if (typeof options === "undefined") {
      options = {};
    }
    for (let [key, value] of Object.entries(options)) {
      this[key] = value;
    }
  }
  /**
   * When true, parse events
   *
   * @type {Boolean}
   */
  parseEvent = true;
  /**
   * When true, parse timezones
   *
   * @type {Boolean}
   */
  parseTimezone = true;
  /* SAX like events here for reference */
  /**
   * Fired when parsing is complete
   * @callback
   */
  oncomplete = (
    /* c8 ignore next */
    function() {
    }
  );
  /**
   * Fired if an error occurs during parsing.
   *
   * @callback
   * @param {Error} err details of error
   */
  onerror = (
    /* c8 ignore next */
    function(err) {
    }
  );
  /**
   * Fired when a top level component (VTIMEZONE) is found
   *
   * @callback
   * @param {Timezone} component     Timezone object
   */
  ontimezone = (
    /* c8 ignore next */
    function(component) {
    }
  );
  /**
   * Fired when a top level component (VEVENT) is found.
   *
   * @callback
   * @param {Event} component    Top level component
   */
  onevent = (
    /* c8 ignore next */
    function(component) {
    }
  );
  /**
   * Process a string or parse ical object.  This function itself will return
   * nothing but will start the parsing process.
   *
   * Events must be registered prior to calling this method.
   *
   * @param {Component|String|Object} ical      The component to process,
   *        either in its final form, as a jCal Object, or string representation
   */
  process(ical) {
    if (typeof ical === "string") {
      ical = parse(ical);
    }
    if (!(ical instanceof Component)) {
      ical = new Component(ical);
    }
    let components = ical.getAllSubcomponents();
    let i = 0;
    let len = components.length;
    let component;
    for (; i < len; i++) {
      component = components[i];
      switch (component.name) {
        case "vtimezone":
          if (this.parseTimezone) {
            let tzid = component.getFirstPropertyValue("tzid");
            if (tzid) {
              this.ontimezone(new Timezone$1({
                tzid,
                component
              }));
            }
          }
          break;
        case "vevent":
          if (this.parseEvent) {
            this.onevent(new Event(component));
          }
          break;
        default:
          continue;
      }
    }
    this.oncomplete();
  }
}
var ICALmodule = {
  /**
   * The number of characters before iCalendar line folding should occur
   * @type {Number}
   * @default 75
   */
  foldLength: 75,
  debug: false,
  /**
   * The character(s) to be used for a newline. The default value is provided by
   * rfc5545.
   * @type {String}
   * @default "\r\n"
   */
  newLineChar: "\r\n",
  Binary,
  Component,
  ComponentParser,
  Duration,
  Event,
  Period,
  Property,
  Recur,
  RecurExpansion,
  RecurIterator,
  Time,
  Timezone: Timezone$1,
  TimezoneService,
  UtcOffset,
  VCardTime,
  parse,
  stringify,
  design,
  helpers
};
function getSortedTimezoneList(timezoneList = [], additionalTimezones = [], globalTimezoneName = "Global") {
  const sortedByContinent = /* @__PURE__ */ new Map();
  for (const timezoneId of timezoneList) {
    const components = timezoneId.split("/");
    let [continent, name] = [components.shift(), components.join("/")];
    if (!name) {
      name = continent;
      continent = globalTimezoneName;
    }
    if (!sortedByContinent.has(continent)) {
      sortedByContinent.set(continent, {
        continent,
        regions: []
      });
    }
    sortedByContinent.get(continent).regions.push({
      label: getReadableTimezoneName(name),
      cities: [],
      timezoneId
    });
  }
  for (const { continent, label, timezoneId } of additionalTimezones) {
    if (!sortedByContinent.has(continent)) {
      sortedByContinent.set(continent, {
        continent,
        regions: []
      });
    }
    sortedByContinent.get(continent).regions.push({
      label,
      cities: [],
      timezoneId
    });
  }
  const sortedList = [...sortedByContinent.values()].sort((a, b) => a.continent.localeCompare(b.continent));
  for (const { regions } of sortedList) {
    regions.sort((a, b) => a.label.localeCompare(b.label));
  }
  return sortedList;
}
function getReadableTimezoneName(timezoneId) {
  return timezoneId.split("_").join(" ").replace("St ", "St. ").split("/").join(" - ");
}
class Timezone2 {
  /**
   * Id of the timezone.
   */
  _timezoneId;
  /**
   * ICS representation of the timezone
   */
  _ics;
  _timezone;
  _initialized;
  constructor(timezoneId, ics) {
    if (timezoneId instanceof ICALmodule.Timezone) {
      this._timezone = timezoneId;
      this._initialized = true;
    } else if (timezoneId instanceof ICALmodule.Component) {
      this._timezone = new ICALmodule.Timezone(timezoneId);
      this._initialized = true;
    } else {
      this._timezoneId = timezoneId;
      this._ics = ics;
      this._initialized = false;
    }
  }
  /**
   * Get the timezone id
   */
  get timezoneId() {
    if (this._initialized) {
      return this._timezone.tzid;
    }
    return this._timezoneId;
  }
  /**
   * Get the UTC Offset for a given date in this timezone.
   *
   * @param year - Year of the date
   * @param month - Month of the date (1-based)
   * @param day - Day of the date
   * @param hour - Hour of the date
   * @param minute - Minute of the date
   * @param second - Second of the date
   */
  offsetForArray(year, month, day, hour, minute, second) {
    const time = new ICALmodule.Time({
      year,
      month,
      day,
      hour,
      minute,
      second,
      isDate: false
    });
    return this.timezone.utcOffset(time);
  }
  /**
   * Converts a timestamp to an array of year, month, day, hour, minute, second.
   *
   * @param {number} ms Timestamp in milliseconds
   * @return {number[]}
   */
  timestampToArray(ms) {
    const time = ICALmodule.Time.fromData({
      year: 1970,
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0
    });
    time.fromUnixTime(Math.floor(ms / 1e3));
    const local = time.convertToZone(this.timezone);
    return [
      local.year,
      local.month,
      // THIS is 1-based !
      local.day,
      local.hour,
      local.minute,
      local.second
    ];
  }
  toICALTimezone() {
    return this.timezone;
  }
  /**
   * Returns the corresponding ICAL.
   */
  toICALJs() {
    return this.timezone.component;
  }
  /**
   * Initializes the inner ICAL.Timezone component if not already done.
   */
  get timezone() {
    if (!this._initialized) {
      const jCal = ICALmodule.parse(this._ics);
      const iCalComponent = new ICALmodule.Component(jCal);
      this._timezone = new ICALmodule.Timezone(iCalComponent);
      this._initialized = true;
    }
    return this._timezone;
  }
  static get utc() {
    return new Timezone2(ICALmodule.Timezone.utcTimezone);
  }
  static get floating() {
    return new Timezone2(ICALmodule.Timezone.localTimezone);
  }
}
const version$1 = "2.2024a";
const aliases = {
  "AUS Central Standard Time": {
    aliasTo: "Australia/Darwin"
  },
  "AUS Eastern Standard Time": {
    aliasTo: "Australia/Sydney"
  },
  "Afghanistan Standard Time": {
    aliasTo: "Asia/Kabul"
  },
  "Africa/Asmera": {
    aliasTo: "Africa/Asmara"
  },
  "Africa/Timbuktu": {
    aliasTo: "Africa/Bamako"
  },
  "Alaskan Standard Time": {
    aliasTo: "America/Anchorage"
  },
  "America/Argentina/ComodRivadavia": {
    aliasTo: "America/Argentina/Catamarca"
  },
  "America/Buenos_Aires": {
    aliasTo: "America/Argentina/Buenos_Aires"
  },
  "America/Louisville": {
    aliasTo: "America/Kentucky/Louisville"
  },
  "America/Montreal": {
    aliasTo: "America/Toronto"
  },
  "America/Santa_Isabel": {
    aliasTo: "America/Tijuana"
  },
  "Arab Standard Time": {
    aliasTo: "Asia/Riyadh"
  },
  "Arabian Standard Time": {
    aliasTo: "Asia/Dubai"
  },
  "Arabic Standard Time": {
    aliasTo: "Asia/Baghdad"
  },
  "Argentina Standard Time": {
    aliasTo: "America/Argentina/Buenos_Aires"
  },
  "Asia/Calcutta": {
    aliasTo: "Asia/Kolkata"
  },
  "Asia/Katmandu": {
    aliasTo: "Asia/Kathmandu"
  },
  "Asia/Rangoon": {
    aliasTo: "Asia/Yangon"
  },
  "Asia/Saigon": {
    aliasTo: "Asia/Ho_Chi_Minh"
  },
  "Atlantic Standard Time": {
    aliasTo: "America/Halifax"
  },
  "Atlantic/Faeroe": {
    aliasTo: "Atlantic/Faroe"
  },
  "Atlantic/Jan_Mayen": {
    aliasTo: "Europe/Oslo"
  },
  "Azerbaijan Standard Time": {
    aliasTo: "Asia/Baku"
  },
  "Azores Standard Time": {
    aliasTo: "Atlantic/Azores"
  },
  "Bahia Standard Time": {
    aliasTo: "America/Bahia"
  },
  "Bangladesh Standard Time": {
    aliasTo: "Asia/Dhaka"
  },
  "Belarus Standard Time": {
    aliasTo: "Europe/Minsk"
  },
  "Canada Central Standard Time": {
    aliasTo: "America/Regina"
  },
  "Cape Verde Standard Time": {
    aliasTo: "Atlantic/Cape_Verde"
  },
  "Caucasus Standard Time": {
    aliasTo: "Asia/Yerevan"
  },
  "Cen. Australia Standard Time": {
    aliasTo: "Australia/Adelaide"
  },
  "Central America Standard Time": {
    aliasTo: "America/Guatemala"
  },
  "Central Asia Standard Time": {
    aliasTo: "Asia/Almaty"
  },
  "Central Brazilian Standard Time": {
    aliasTo: "America/Cuiaba"
  },
  "Central Europe Standard Time": {
    aliasTo: "Europe/Budapest"
  },
  "Central European Standard Time": {
    aliasTo: "Europe/Warsaw"
  },
  "Central Pacific Standard Time": {
    aliasTo: "Pacific/Guadalcanal"
  },
  "Central Standard Time": {
    aliasTo: "America/Chicago"
  },
  "Central Standard Time (Mexico)": {
    aliasTo: "America/Mexico_City"
  },
  "China Standard Time": {
    aliasTo: "Asia/Shanghai"
  },
  "E. Africa Standard Time": {
    aliasTo: "Africa/Nairobi"
  },
  "E. Australia Standard Time": {
    aliasTo: "Australia/Brisbane"
  },
  "E. South America Standard Time": {
    aliasTo: "America/Sao_Paulo"
  },
  "Eastern Standard Time": {
    aliasTo: "America/New_York"
  },
  "Egypt Standard Time": {
    aliasTo: "Africa/Cairo"
  },
  "Ekaterinburg Standard Time": {
    aliasTo: "Asia/Yekaterinburg"
  },
  "Etc/GMT": {
    aliasTo: "UTC"
  },
  "Etc/GMT+0": {
    aliasTo: "UTC"
  },
  "Etc/UCT": {
    aliasTo: "UTC"
  },
  "Etc/UTC": {
    aliasTo: "UTC"
  },
  "Etc/Unversal": {
    aliasTo: "UTC"
  },
  "Etc/Zulu": {
    aliasTo: "UTC"
  },
  "Europe/Belfast": {
    aliasTo: "Europe/London"
  },
  "FLE Standard Time": {
    aliasTo: "Europe/Kiev"
  },
  "Fiji Standard Time": {
    aliasTo: "Pacific/Fiji"
  },
  GMT: {
    aliasTo: "UTC"
  },
  "GMT Standard Time": {
    aliasTo: "Europe/London"
  },
  "GMT+0": {
    aliasTo: "UTC"
  },
  GMT0: {
    aliasTo: "UTC"
  },
  "GTB Standard Time": {
    aliasTo: "Europe/Bucharest"
  },
  "Georgian Standard Time": {
    aliasTo: "Asia/Tbilisi"
  },
  "Greenland Standard Time": {
    aliasTo: "America/Godthab"
  },
  Greenwich: {
    aliasTo: "UTC"
  },
  "Greenwich Standard Time": {
    aliasTo: "Atlantic/Reykjavik"
  },
  "Hawaiian Standard Time": {
    aliasTo: "Pacific/Honolulu"
  },
  "India Standard Time": {
    aliasTo: "Asia/Calcutta"
  },
  "Iran Standard Time": {
    aliasTo: "Asia/Tehran"
  },
  "Israel Standard Time": {
    aliasTo: "Asia/Jerusalem"
  },
  "Jordan Standard Time": {
    aliasTo: "Asia/Amman"
  },
  "Kaliningrad Standard Time": {
    aliasTo: "Europe/Kaliningrad"
  },
  "Korea Standard Time": {
    aliasTo: "Asia/Seoul"
  },
  "Libya Standard Time": {
    aliasTo: "Africa/Tripoli"
  },
  "Line Islands Standard Time": {
    aliasTo: "Pacific/Kiritimati"
  },
  "Magadan Standard Time": {
    aliasTo: "Asia/Magadan"
  },
  "Mauritius Standard Time": {
    aliasTo: "Indian/Mauritius"
  },
  "Middle East Standard Time": {
    aliasTo: "Asia/Beirut"
  },
  "Montevideo Standard Time": {
    aliasTo: "America/Montevideo"
  },
  "Morocco Standard Time": {
    aliasTo: "Africa/Casablanca"
  },
  "Mountain Standard Time": {
    aliasTo: "America/Denver"
  },
  "Mountain Standard Time (Mexico)": {
    aliasTo: "America/Chihuahua"
  },
  "Myanmar Standard Time": {
    aliasTo: "Asia/Rangoon"
  },
  "N. Central Asia Standard Time": {
    aliasTo: "Asia/Novosibirsk"
  },
  "Namibia Standard Time": {
    aliasTo: "Africa/Windhoek"
  },
  "Nepal Standard Time": {
    aliasTo: "Asia/Katmandu"
  },
  "New Zealand Standard Time": {
    aliasTo: "Pacific/Auckland"
  },
  "Newfoundland Standard Time": {
    aliasTo: "America/St_Johns"
  },
  "North Asia East Standard Time": {
    aliasTo: "Asia/Irkutsk"
  },
  "North Asia Standard Time": {
    aliasTo: "Asia/Krasnoyarsk"
  },
  "Pacific SA Standard Time": {
    aliasTo: "America/Santiago"
  },
  "Pacific Standard Time": {
    aliasTo: "America/Los_Angeles"
  },
  "Pacific Standard Time (Mexico)": {
    aliasTo: "America/Santa_Isabel"
  },
  "Pacific/Johnston": {
    aliasTo: "Pacific/Honolulu"
  },
  "Pakistan Standard Time": {
    aliasTo: "Asia/Karachi"
  },
  "Paraguay Standard Time": {
    aliasTo: "America/Asuncion"
  },
  "Romance Standard Time": {
    aliasTo: "Europe/Paris"
  },
  "Russia Time Zone 10": {
    aliasTo: "Asia/Srednekolymsk"
  },
  "Russia Time Zone 11": {
    aliasTo: "Asia/Kamchatka"
  },
  "Russia Time Zone 3": {
    aliasTo: "Europe/Samara"
  },
  "Russian Standard Time": {
    aliasTo: "Europe/Moscow"
  },
  "SA Eastern Standard Time": {
    aliasTo: "America/Cayenne"
  },
  "SA Pacific Standard Time": {
    aliasTo: "America/Bogota"
  },
  "SA Western Standard Time": {
    aliasTo: "America/La_Paz"
  },
  "SE Asia Standard Time": {
    aliasTo: "Asia/Bangkok"
  },
  "Samoa Standard Time": {
    aliasTo: "Pacific/Apia"
  },
  "Singapore Standard Time": {
    aliasTo: "Asia/Singapore"
  },
  "South Africa Standard Time": {
    aliasTo: "Africa/Johannesburg"
  },
  "Sri Lanka Standard Time": {
    aliasTo: "Asia/Colombo"
  },
  "Syria Standard Time": {
    aliasTo: "Asia/Damascus"
  },
  "Taipei Standard Time": {
    aliasTo: "Asia/Taipei"
  },
  "Tasmania Standard Time": {
    aliasTo: "Australia/Hobart"
  },
  "Tokyo Standard Time": {
    aliasTo: "Asia/Tokyo"
  },
  "Tonga Standard Time": {
    aliasTo: "Pacific/Tongatapu"
  },
  "Turkey Standard Time": {
    aliasTo: "Europe/Istanbul"
  },
  UCT: {
    aliasTo: "UTC"
  },
  "US Eastern Standard Time": {
    aliasTo: "America/Indiana/Indianapolis"
  },
  "US Mountain Standard Time": {
    aliasTo: "America/Phoenix"
  },
  "US/Central": {
    aliasTo: "America/Chicago"
  },
  "US/Eastern": {
    aliasTo: "America/New_York"
  },
  "US/Mountain": {
    aliasTo: "America/Denver"
  },
  "US/Pacific": {
    aliasTo: "America/Los_Angeles"
  },
  "US/Pacific-New": {
    aliasTo: "America/Los_Angeles"
  },
  "Ulaanbaatar Standard Time": {
    aliasTo: "Asia/Ulaanbaatar"
  },
  Universal: {
    aliasTo: "UTC"
  },
  "Venezuela Standard Time": {
    aliasTo: "America/Caracas"
  },
  "Vladivostok Standard Time": {
    aliasTo: "Asia/Vladivostok"
  },
  "W. Australia Standard Time": {
    aliasTo: "Australia/Perth"
  },
  "W. Central Africa Standard Time": {
    aliasTo: "Africa/Lagos"
  },
  "W. Europe Standard Time": {
    aliasTo: "Europe/Berlin"
  },
  "West Asia Standard Time": {
    aliasTo: "Asia/Tashkent"
  },
  "West Pacific Standard Time": {
    aliasTo: "Pacific/Port_Moresby"
  },
  "Yakutsk Standard Time": {
    aliasTo: "Asia/Yakutsk"
  },
  Z: {
    aliasTo: "UTC"
  },
  Zulu: {
    aliasTo: "UTC"
  },
  utc: {
    aliasTo: "UTC"
  }
};
const zones = {
  "Africa/Abidjan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0051900",
    longitude: "-0040200"
  },
  "Africa/Accra": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Addis_Ababa": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Algiers": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0364700",
    longitude: "+0030300"
  },
  "Africa/Asmara": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Asmera": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Bamako": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Bangui": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Banjul": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Bissau": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0115100",
    longitude: "-0153500"
  },
  "Africa/Blantyre": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Brazzaville": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Bujumbura": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Cairo": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700424T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=-1FR\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701030T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1FR\r\nEND:STANDARD"
    ],
    latitude: "+0300300",
    longitude: "+0311500"
  },
  "Africa/Casablanca": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0333900",
    longitude: "-0073500"
  },
  "Africa/Ceuta": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0355300",
    longitude: "-0051900"
  },
  "Africa/Conakry": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Dakar": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Dar_es_Salaam": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Djibouti": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Douala": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/El_Aaiun": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:+01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0270900",
    longitude: "-0131200"
  },
  "Africa/Freetown": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Gaborone": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Harare": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Johannesburg": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0261500",
    longitude: "+0280000"
  },
  "Africa/Juba": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0045100",
    longitude: "+0313700"
  },
  "Africa/Kampala": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Khartoum": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0153600",
    longitude: "+0323200"
  },
  "Africa/Kigali": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Kinshasa": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Lagos": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0062700",
    longitude: "+0032400"
  },
  "Africa/Libreville": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Lome": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Luanda": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Lubumbashi": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Lusaka": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Malabo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Maputo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0255800",
    longitude: "+0323500"
  },
  "Africa/Maseru": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Mbabane": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:SAST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Mogadishu": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Monrovia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0061800",
    longitude: "-0104700"
  },
  "Africa/Nairobi": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0011700",
    longitude: "+0364900"
  },
  "Africa/Ndjamena": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0120700",
    longitude: "+0150300"
  },
  "Africa/Niamey": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Nouakchott": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Ouagadougou": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Porto-Novo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:WAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Sao_Tome": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0002000",
    longitude: "+0064400"
  },
  "Africa/Timbuktu": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Africa/Tripoli": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0325400",
    longitude: "+0131100"
  },
  "Africa/Tunis": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0364800",
    longitude: "+0101100"
  },
  "Africa/Windhoek": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:CAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0223400",
    longitude: "+0170600"
  },
  "America/Adak": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0515248",
    longitude: "-1763929"
  },
  "America/Anchorage": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0611305",
    longitude: "-1495401"
  },
  "America/Anguilla": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Antigua": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Araguaina": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0071200",
    longitude: "-0481200"
  },
  "America/Argentina/Buenos_Aires": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0343600",
    longitude: "-0582700"
  },
  "America/Argentina/Catamarca": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0282800",
    longitude: "-0654700"
  },
  "America/Argentina/ComodRivadavia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Argentina/Cordoba": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0312400",
    longitude: "-0641100"
  },
  "America/Argentina/Jujuy": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0241100",
    longitude: "-0651800"
  },
  "America/Argentina/La_Rioja": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0292600",
    longitude: "-0665100"
  },
  "America/Argentina/Mendoza": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0325300",
    longitude: "-0684900"
  },
  "America/Argentina/Rio_Gallegos": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0513800",
    longitude: "-0691300"
  },
  "America/Argentina/Salta": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0244700",
    longitude: "-0652500"
  },
  "America/Argentina/San_Juan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0313200",
    longitude: "-0683100"
  },
  "America/Argentina/San_Luis": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0331900",
    longitude: "-0662100"
  },
  "America/Argentina/Tucuman": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0264900",
    longitude: "-0651300"
  },
  "America/Argentina/Ushuaia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0544800",
    longitude: "-0681800"
  },
  "America/Aruba": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Asuncion": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701004T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700322T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=4SU\r\nEND:STANDARD"
    ],
    latitude: "-0251600",
    longitude: "-0574000"
  },
  "America/Atikokan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Atka": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Bahia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0125900",
    longitude: "-0383100"
  },
  "America/Bahia_Banderas": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0204800",
    longitude: "-1051500"
  },
  "America/Barbados": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0130600",
    longitude: "-0593700"
  },
  "America/Belem": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0012700",
    longitude: "-0482900"
  },
  "America/Belize": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0173000",
    longitude: "-0881200"
  },
  "America/Blanc-Sablon": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Boa_Vista": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0024900",
    longitude: "-0604000"
  },
  "America/Bogota": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0043600",
    longitude: "-0740500"
  },
  "America/Boise": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0433649",
    longitude: "-1161209"
  },
  "America/Buenos_Aires": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Cambridge_Bay": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0690650",
    longitude: "-1050310"
  },
  "America/Campo_Grande": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0202700",
    longitude: "-0543700"
  },
  "America/Cancun": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0210500",
    longitude: "-0864600"
  },
  "America/Caracas": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0103000",
    longitude: "-0665600"
  },
  "America/Catamarca": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Cayenne": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0045600",
    longitude: "-0522000"
  },
  "America/Cayman": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Chicago": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0415100",
    longitude: "-0873900"
  },
  "America/Chihuahua": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0283800",
    longitude: "-1060500"
  },
  "America/Ciudad_Juarez": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0314400",
    longitude: "-1062900"
  },
  "America/Coral_Harbour": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Cordoba": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Costa_Rica": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0095600",
    longitude: "-0840500"
  },
  "America/Creston": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Cuiaba": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0153500",
    longitude: "-0560500"
  },
  "America/Curacao": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Danmarkshavn": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0764600",
    longitude: "-0184000"
  },
  "America/Dawson": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0640400",
    longitude: "-1392500"
  },
  "America/Dawson_Creek": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0554600",
    longitude: "-1201400"
  },
  "America/Denver": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0394421",
    longitude: "-1045903"
  },
  "America/Detroit": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0421953",
    longitude: "-0830245"
  },
  "America/Dominica": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Edmonton": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0533300",
    longitude: "-1132800"
  },
  "America/Eirunepe": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0064000",
    longitude: "-0695200"
  },
  "America/El_Salvador": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0134200",
    longitude: "-0891200"
  },
  "America/Ensenada": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Fort_Nelson": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0584800",
    longitude: "-1224200"
  },
  "America/Fort_Wayne": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Fortaleza": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0034300",
    longitude: "-0383000"
  },
  "America/Glace_Bay": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0461200",
    longitude: "-0595700"
  },
  "America/Godthab": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700328T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "America/Goose_Bay": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0532000",
    longitude: "-0602500"
  },
  "America/Grand_Turk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0212800",
    longitude: "-0710800"
  },
  "America/Grenada": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Guadeloupe": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Guatemala": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0143800",
    longitude: "-0903100"
  },
  "America/Guayaquil": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0021000",
    longitude: "-0795000"
  },
  "America/Guyana": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0064800",
    longitude: "-0581000"
  },
  "America/Halifax": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0443900",
    longitude: "-0633600"
  },
  "America/Havana": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:CST\r\nDTSTART:19701101T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:CDT\r\nDTSTART:19700308T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0230800",
    longitude: "-0822200"
  },
  "America/Hermosillo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0290400",
    longitude: "-1105800"
  },
  "America/Indiana/Indianapolis": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0394606",
    longitude: "-0860929"
  },
  "America/Indiana/Knox": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0411745",
    longitude: "-0863730"
  },
  "America/Indiana/Marengo": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0382232",
    longitude: "-0862041"
  },
  "America/Indiana/Petersburg": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0382931",
    longitude: "-0871643"
  },
  "America/Indiana/Tell_City": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0375711",
    longitude: "-0864541"
  },
  "America/Indiana/Vevay": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0384452",
    longitude: "-0850402"
  },
  "America/Indiana/Vincennes": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0384038",
    longitude: "-0873143"
  },
  "America/Indiana/Winamac": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0410305",
    longitude: "-0863611"
  },
  "America/Indianapolis": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Inuvik": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0682059",
    longitude: "-1334300"
  },
  "America/Iqaluit": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0634400",
    longitude: "-0682800"
  },
  "America/Jamaica": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0175805",
    longitude: "-0764736"
  },
  "America/Jujuy": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Juneau": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0581807",
    longitude: "-1342511"
  },
  "America/Kentucky/Louisville": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0381515",
    longitude: "-0854534"
  },
  "America/Kentucky/Monticello": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0364947",
    longitude: "-0845057"
  },
  "America/Knox_IN": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Kralendijk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/La_Paz": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0163000",
    longitude: "-0680900"
  },
  "America/Lima": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0120300",
    longitude: "-0770300"
  },
  "America/Los_Angeles": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0340308",
    longitude: "-1181434"
  },
  "America/Louisville": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Lower_Princes": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Maceio": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0094000",
    longitude: "-0354300"
  },
  "America/Managua": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0120900",
    longitude: "-0861700"
  },
  "America/Manaus": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0030800",
    longitude: "-0600100"
  },
  "America/Marigot": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Martinique": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0143600",
    longitude: "-0610500"
  },
  "America/Matamoros": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0255000",
    longitude: "-0973000"
  },
  "America/Mazatlan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0231300",
    longitude: "-1062500"
  },
  "America/Mendoza": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Menominee": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0450628",
    longitude: "-0873651"
  },
  "America/Merida": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0205800",
    longitude: "-0893700"
  },
  "America/Metlakatla": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0550737",
    longitude: "-1313435"
  },
  "America/Mexico_City": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0192400",
    longitude: "-0990900"
  },
  "America/Miquelon": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0470300",
    longitude: "-0562000"
  },
  "America/Moncton": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0460600",
    longitude: "-0644700"
  },
  "America/Monterrey": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0254000",
    longitude: "-1001900"
  },
  "America/Montevideo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0345433",
    longitude: "-0561245"
  },
  "America/Montreal": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Montserrat": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Nassau": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/New_York": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0404251",
    longitude: "-0740023"
  },
  "America/Nipigon": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Nome": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0643004",
    longitude: "-1652423"
  },
  "America/Noronha": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0035100",
    longitude: "-0322500"
  },
  "America/North_Dakota/Beulah": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0471551",
    longitude: "-1014640"
  },
  "America/North_Dakota/Center": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0470659",
    longitude: "-1011757"
  },
  "America/North_Dakota/New_Salem": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0465042",
    longitude: "-1012439"
  },
  "America/Nuuk": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700328T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0641100",
    longitude: "-0514400"
  },
  "America/Ojinaga": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0293400",
    longitude: "-1042500"
  },
  "America/Panama": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0085800",
    longitude: "-0793200"
  },
  "America/Pangnirtung": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Paramaribo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0055000",
    longitude: "-0551000"
  },
  "America/Phoenix": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0332654",
    longitude: "-1120424"
  },
  "America/Port-au-Prince": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0183200",
    longitude: "-0722000"
  },
  "America/Port_of_Spain": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Porto_Acre": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Porto_Velho": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0084600",
    longitude: "-0635400"
  },
  "America/Puerto_Rico": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0182806",
    longitude: "-0660622"
  },
  "America/Punta_Arenas": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0530900",
    longitude: "-0705500"
  },
  "America/Rainy_River": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Rankin_Inlet": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0624900",
    longitude: "-0920459"
  },
  "America/Recife": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0080300",
    longitude: "-0345400"
  },
  "America/Regina": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0502400",
    longitude: "-1043900"
  },
  "America/Resolute": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0744144",
    longitude: "-0944945"
  },
  "America/Rio_Branco": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0095800",
    longitude: "-0674800"
  },
  "America/Rosario": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Santa_Isabel": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Santarem": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0022600",
    longitude: "-0545200"
  },
  "America/Santiago": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700405T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700906T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "-0332700",
    longitude: "-0704000"
  },
  "America/Santo_Domingo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0182800",
    longitude: "-0695400"
  },
  "America/Sao_Paulo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0233200",
    longitude: "-0463700"
  },
  "America/Scoresbysund": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700328T230000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT"
    ],
    latitude: "+0702900",
    longitude: "-0215800"
  },
  "America/Shiprock": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Sitka": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0571035",
    longitude: "-1351807"
  },
  "America/St_Barthelemy": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/St_Johns": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0230\r\nTZOFFSETTO:-0330\r\nTZNAME:NST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0330\r\nTZOFFSETTO:-0230\r\nTZNAME:NDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0473400",
    longitude: "-0524300"
  },
  "America/St_Kitts": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/St_Lucia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/St_Thomas": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/St_Vincent": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Swift_Current": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0501700",
    longitude: "-1075000"
  },
  "America/Tegucigalpa": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0140600",
    longitude: "-0871300"
  },
  "America/Thule": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0763400",
    longitude: "-0684700"
  },
  "America/Thunder_Bay": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "America/Tijuana": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0323200",
    longitude: "-1170100"
  },
  "America/Toronto": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0433900",
    longitude: "-0792300"
  },
  "America/Tortola": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Vancouver": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0491600",
    longitude: "-1230700"
  },
  "America/Virgin": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "America/Whitehorse": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0604300",
    longitude: "-1350300"
  },
  "America/Winnipeg": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0495300",
    longitude: "-0970900"
  },
  "America/Yakutat": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0593249",
    longitude: "-1394338"
  },
  "America/Yellowknife": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Antarctica/Casey": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0661700",
    longitude: "+1103100"
  },
  "Antarctica/Davis": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0683500",
    longitude: "+0775800"
  },
  "Antarctica/DumontDUrville": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Antarctica/Macquarie": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "-0543000",
    longitude: "+1585700"
  },
  "Antarctica/Mawson": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0673600",
    longitude: "+0625300"
  },
  "Antarctica/McMurdo": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Antarctica/Palmer": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0644800",
    longitude: "-0640600"
  },
  "Antarctica/Rothera": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0673400",
    longitude: "-0680800"
  },
  "Antarctica/South_Pole": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Antarctica/Syowa": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Antarctica/Troll": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0200\r\nTZNAME:+02\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "-0720041",
    longitude: "+0023206"
  },
  "Antarctica/Vostok": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0782400",
    longitude: "+1065400"
  },
  "Arctic/Longyearbyen": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Asia/Aden": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Almaty": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0431500",
    longitude: "+0765700"
  },
  "Asia/Amman": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0315700",
    longitude: "+0355600"
  },
  "Asia/Anadyr": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0644500",
    longitude: "+1772900"
  },
  "Asia/Aqtau": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0443100",
    longitude: "+0501600"
  },
  "Asia/Aqtobe": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0501700",
    longitude: "+0571000"
  },
  "Asia/Ashgabat": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0375700",
    longitude: "+0582300"
  },
  "Asia/Ashkhabad": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Atyrau": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0470700",
    longitude: "+0515600"
  },
  "Asia/Baghdad": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0332100",
    longitude: "+0442500"
  },
  "Asia/Bahrain": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Baku": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0402300",
    longitude: "+0495100"
  },
  "Asia/Bangkok": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0134500",
    longitude: "+1003100"
  },
  "Asia/Barnaul": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0532200",
    longitude: "+0834500"
  },
  "Asia/Beirut": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0335300",
    longitude: "+0353000"
  },
  "Asia/Bishkek": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0425400",
    longitude: "+0743600"
  },
  "Asia/Brunei": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Calcutta": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:IST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Chita": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0520300",
    longitude: "+1132800"
  },
  "Asia/Choibalsan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0480400",
    longitude: "+1143000"
  },
  "Asia/Chongqing": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Chungking": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Colombo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:+0530\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0065600",
    longitude: "+0795100"
  },
  "Asia/Dacca": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Damascus": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0333000",
    longitude: "+0361800"
  },
  "Asia/Dhaka": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0234300",
    longitude: "+0902500"
  },
  "Asia/Dili": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0083300",
    longitude: "+1253500"
  },
  "Asia/Dubai": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0251800",
    longitude: "+0551800"
  },
  "Asia/Dushanbe": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0383500",
    longitude: "+0684800"
  },
  "Asia/Famagusta": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0350700",
    longitude: "+0335700"
  },
  "Asia/Gaza": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700328T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701031T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SA\r\nEND:STANDARD"
    ],
    latitude: "+0313000",
    longitude: "+0342800"
  },
  "Asia/Harbin": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Hebron": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700328T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SA\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701031T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SA\r\nEND:STANDARD"
    ],
    latitude: "+0313200",
    longitude: "+0350542"
  },
  "Asia/Ho_Chi_Minh": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0104500",
    longitude: "+1064000"
  },
  "Asia/Hong_Kong": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:HKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0221700",
    longitude: "+1140900"
  },
  "Asia/Hovd": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0480100",
    longitude: "+0913900"
  },
  "Asia/Irkutsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0521600",
    longitude: "+1042000"
  },
  "Asia/Istanbul": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Jakarta": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:WIB\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0061000",
    longitude: "+1064800"
  },
  "Asia/Jayapura": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:WIT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0023200",
    longitude: "+1404200"
  },
  "Asia/Jerusalem": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:IDT\r\nDTSTART:19700327T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:IST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0314650",
    longitude: "+0351326"
  },
  "Asia/Kabul": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0430\r\nTZOFFSETTO:+0430\r\nTZNAME:+0430\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0343100",
    longitude: "+0691200"
  },
  "Asia/Kamchatka": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0530100",
    longitude: "+1583900"
  },
  "Asia/Karachi": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:PKT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0245200",
    longitude: "+0670300"
  },
  "Asia/Kashgar": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Kathmandu": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0545\r\nTZOFFSETTO:+0545\r\nTZNAME:+0545\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0274300",
    longitude: "+0851900"
  },
  "Asia/Katmandu": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0545\r\nTZOFFSETTO:+0545\r\nTZNAME:+0545\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Khandyga": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0623923",
    longitude: "+1353314"
  },
  "Asia/Kolkata": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0530\r\nTZOFFSETTO:+0530\r\nTZNAME:IST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0223200",
    longitude: "+0882200"
  },
  "Asia/Krasnoyarsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0560100",
    longitude: "+0925000"
  },
  "Asia/Kuala_Lumpur": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Kuching": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0013300",
    longitude: "+1102000"
  },
  "Asia/Kuwait": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Macao": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Macau": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0221150",
    longitude: "+1133230"
  },
  "Asia/Magadan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0593400",
    longitude: "+1504800"
  },
  "Asia/Makassar": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:WITA\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0050700",
    longitude: "+1192400"
  },
  "Asia/Manila": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:PST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0143500",
    longitude: "+1210000"
  },
  "Asia/Muscat": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Nicosia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0351000",
    longitude: "+0332200"
  },
  "Asia/Novokuznetsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0534500",
    longitude: "+0870700"
  },
  "Asia/Novosibirsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0550200",
    longitude: "+0825500"
  },
  "Asia/Omsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0550000",
    longitude: "+0732400"
  },
  "Asia/Oral": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0511300",
    longitude: "+0512100"
  },
  "Asia/Phnom_Penh": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Pontianak": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:WIB\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0000200",
    longitude: "+1092000"
  },
  "Asia/Pyongyang": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0390100",
    longitude: "+1254500"
  },
  "Asia/Qatar": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0251700",
    longitude: "+0513200"
  },
  "Asia/Qostanay": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0531200",
    longitude: "+0633700"
  },
  "Asia/Qyzylorda": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0444800",
    longitude: "+0652800"
  },
  "Asia/Rangoon": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Riyadh": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0243800",
    longitude: "+0464300"
  },
  "Asia/Saigon": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Sakhalin": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0465800",
    longitude: "+1424200"
  },
  "Asia/Samarkand": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0394000",
    longitude: "+0664800"
  },
  "Asia/Seoul": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:KST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0373300",
    longitude: "+1265800"
  },
  "Asia/Shanghai": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0311400",
    longitude: "+1212800"
  },
  "Asia/Singapore": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0011700",
    longitude: "+1035100"
  },
  "Asia/Srednekolymsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0672800",
    longitude: "+1534300"
  },
  "Asia/Taipei": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0250300",
    longitude: "+1213000"
  },
  "Asia/Tashkent": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0412000",
    longitude: "+0691800"
  },
  "Asia/Tbilisi": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0414300",
    longitude: "+0444900"
  },
  "Asia/Tehran": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0330\r\nTZOFFSETTO:+0330\r\nTZNAME:+0330\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0354000",
    longitude: "+0512600"
  },
  "Asia/Tel_Aviv": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:IDT\r\nDTSTART:19700327T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1FR\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:IST\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Asia/Thimbu": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Thimphu": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0272800",
    longitude: "+0893900"
  },
  "Asia/Tokyo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:JST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0353916",
    longitude: "+1394441"
  },
  "Asia/Tomsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0563000",
    longitude: "+0845800"
  },
  "Asia/Ujung_Pandang": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:WITA\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Ulaanbaatar": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0475500",
    longitude: "+1065300"
  },
  "Asia/Ulan_Bator": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:+08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Urumqi": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0434800",
    longitude: "+0873500"
  },
  "Asia/Ust-Nera": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0643337",
    longitude: "+1431336"
  },
  "Asia/Vientiane": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Asia/Vladivostok": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0431000",
    longitude: "+1315600"
  },
  "Asia/Yakutsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0620000",
    longitude: "+1294000"
  },
  "Asia/Yangon": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0164700",
    longitude: "+0961000"
  },
  "Asia/Yekaterinburg": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0565100",
    longitude: "+0603600"
  },
  "Asia/Yerevan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0401100",
    longitude: "+0443000"
  },
  "Atlantic/Azores": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:+0000\r\nTZNAME:+00\r\nDTSTART:19700329T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19701025T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0374400",
    longitude: "-0254000"
  },
  "Atlantic/Bermuda": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "+0321700",
    longitude: "-0644600"
  },
  "Atlantic/Canary": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0280600",
    longitude: "-0152400"
  },
  "Atlantic/Cape_Verde": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0100\r\nTZOFFSETTO:-0100\r\nTZNAME:-01\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0145500",
    longitude: "-0233100"
  },
  "Atlantic/Faeroe": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Atlantic/Faroe": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0620100",
    longitude: "-0064600"
  },
  "Atlantic/Jan_Mayen": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Atlantic/Madeira": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0323800",
    longitude: "-0165400"
  },
  "Atlantic/Reykjavik": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Atlantic/South_Georgia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0541600",
    longitude: "-0363200"
  },
  "Atlantic/St_Helena": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Atlantic/Stanley": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0514200",
    longitude: "-0575100"
  },
  "Australia/ACT": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Australia/Adelaide": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "-0345500",
    longitude: "+1383500"
  },
  "Australia/Brisbane": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0272800",
    longitude: "+1530200"
  },
  "Australia/Broken_Hill": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "-0315700",
    longitude: "+1412700"
  },
  "Australia/Canberra": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Australia/Currie": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Australia/Darwin": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0122800",
    longitude: "+1305000"
  },
  "Australia/Eucla": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0845\r\nTZOFFSETTO:+0845\r\nTZNAME:+0845\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0314300",
    longitude: "+1285200"
  },
  "Australia/Hobart": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "-0425300",
    longitude: "+1471900"
  },
  "Australia/LHI": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1030\r\nTZNAME:+1030\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Australia/Lindeman": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0201600",
    longitude: "+1490000"
  },
  "Australia/Lord_Howe": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1030\r\nTZNAME:+1030\r\nDTSTART:19700405T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "-0313300",
    longitude: "+1590500"
  },
  "Australia/Melbourne": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "-0374900",
    longitude: "+1445800"
  },
  "Australia/NSW": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Australia/North": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Australia/Perth": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:AWST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0315700",
    longitude: "+1155100"
  },
  "Australia/Queensland": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Australia/South": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Australia/Sydney": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "-0335200",
    longitude: "+1511300"
  },
  "Australia/Tasmania": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Australia/Victoria": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1000\r\nTZNAME:AEST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1100\r\nTZNAME:AEDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Australia/West": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0800\r\nTZOFFSETTO:+0800\r\nTZNAME:AWST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Australia/Yancowinna": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1030\r\nTZOFFSETTO:+0930\r\nTZNAME:ACST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0930\r\nTZOFFSETTO:+1030\r\nTZNAME:ACDT\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Brazil/Acre": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Brazil/DeNoronha": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0200\r\nTZOFFSETTO:-0200\r\nTZNAME:-02\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Brazil/East": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Brazil/West": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Canada/Atlantic": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:ADT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:AST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Canada/Central": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Canada/Eastern": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Canada/Mountain": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Canada/Newfoundland": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0230\r\nTZOFFSETTO:-0330\r\nTZNAME:NST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0330\r\nTZOFFSETTO:-0230\r\nTZNAME:NDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT"
    ]
  },
  "Canada/Pacific": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Canada/Saskatchewan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Canada/Yukon": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Chile/Continental": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0300\r\nTZOFFSETTO:-0400\r\nTZNAME:-04\r\nDTSTART:19700405T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0300\r\nTZNAME:-03\r\nDTSTART:19700906T000000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Chile/EasterIsland": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700404T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SA\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700905T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SA\r\nEND:DAYLIGHT"
    ]
  },
  "Europe/Amsterdam": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Andorra": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0423000",
    longitude: "+0013100"
  },
  "Europe/Astrakhan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0462100",
    longitude: "+0480300"
  },
  "Europe/Athens": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0375800",
    longitude: "+0234300"
  },
  "Europe/Belfast": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Belgrade": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0445000",
    longitude: "+0203000"
  },
  "Europe/Berlin": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0523000",
    longitude: "+0132200"
  },
  "Europe/Bratislava": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Brussels": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0505000",
    longitude: "+0042000"
  },
  "Europe/Bucharest": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0442600",
    longitude: "+0260600"
  },
  "Europe/Budapest": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0473000",
    longitude: "+0190500"
  },
  "Europe/Busingen": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Chisinau": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0470000",
    longitude: "+0285000"
  },
  "Europe/Copenhagen": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Dublin": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:IST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0532000",
    longitude: "-0061500"
  },
  "Europe/Gibraltar": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0360800",
    longitude: "-0052100"
  },
  "Europe/Guernsey": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Helsinki": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0601000",
    longitude: "+0245800"
  },
  "Europe/Isle_of_Man": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Istanbul": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0410100",
    longitude: "+0285800"
  },
  "Europe/Jersey": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Kaliningrad": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0544300",
    longitude: "+0203000"
  },
  "Europe/Kiev": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Europe/Kirov": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0583600",
    longitude: "+0493900"
  },
  "Europe/Kyiv": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0502600",
    longitude: "+0303100"
  },
  "Europe/Lisbon": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:WET\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:WEST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
    ],
    latitude: "+0384300",
    longitude: "-0090800"
  },
  "Europe/Ljubljana": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/London": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0000\r\nTZOFFSETTO:+0100\r\nTZNAME:BST\r\nDTSTART:19700329T010000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0000\r\nTZNAME:GMT\r\nDTSTART:19701025T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0513030",
    longitude: "+0000731"
  },
  "Europe/Luxembourg": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Madrid": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0402400",
    longitude: "-0034100"
  },
  "Europe/Malta": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0355400",
    longitude: "+0143100"
  },
  "Europe/Mariehamn": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Minsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:+03\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0535400",
    longitude: "+0273400"
  },
  "Europe/Monaco": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Moscow": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0554521",
    longitude: "+0373704"
  },
  "Europe/Nicosia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Europe/Oslo": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Paris": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0485200",
    longitude: "+0022000"
  },
  "Europe/Podgorica": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Prague": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0500500",
    longitude: "+0142600"
  },
  "Europe/Riga": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0565700",
    longitude: "+0240600"
  },
  "Europe/Rome": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0415400",
    longitude: "+0122900"
  },
  "Europe/Samara": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0531200",
    longitude: "+0500900"
  },
  "Europe/San_Marino": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Sarajevo": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Saratov": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0513400",
    longitude: "+0460200"
  },
  "Europe/Simferopol": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0445700",
    longitude: "+0340600"
  },
  "Europe/Skopje": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Sofia": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0424100",
    longitude: "+0231900"
  },
  "Europe/Stockholm": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Tallinn": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0592500",
    longitude: "+0244500"
  },
  "Europe/Tirane": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0412000",
    longitude: "+0195000"
  },
  "Europe/Tiraspol": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Ulyanovsk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0542000",
    longitude: "+0482400"
  },
  "Europe/Uzhgorod": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Europe/Vaduz": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Vatican": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Vienna": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0481300",
    longitude: "+0162000"
  },
  "Europe/Vilnius": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0544100",
    longitude: "+0251900"
  },
  "Europe/Volgograd": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:MSK\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0484400",
    longitude: "+0442500"
  },
  "Europe/Warsaw": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0521500",
    longitude: "+0210000"
  },
  "Europe/Zagreb": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ]
  },
  "Europe/Zaporozhye": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0200\r\nTZNAME:EET\r\nDTSTART:19701025T040000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0300\r\nTZNAME:EEST\r\nDTSTART:19700329T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT"
    ]
  },
  "Europe/Zurich": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+0100\r\nTZOFFSETTO:+0200\r\nTZNAME:CEST\r\nDTSTART:19700329T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0200\r\nTZOFFSETTO:+0100\r\nTZNAME:CET\r\nDTSTART:19701025T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r\nEND:STANDARD"
    ],
    latitude: "+0472300",
    longitude: "+0083200"
  },
  "Indian/Antananarivo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Indian/Chagos": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0600\r\nTZOFFSETTO:+0600\r\nTZNAME:+06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0072000",
    longitude: "+0722500"
  },
  "Indian/Christmas": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0700\r\nTZOFFSETTO:+0700\r\nTZNAME:+07\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Indian/Cocos": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0630\r\nTZOFFSETTO:+0630\r\nTZNAME:+0630\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Indian/Comoro": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Indian/Kerguelen": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Indian/Mahe": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Indian/Maldives": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0500\r\nTZOFFSETTO:+0500\r\nTZNAME:+05\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0041000",
    longitude: "+0733000"
  },
  "Indian/Mauritius": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0201000",
    longitude: "+0573000"
  },
  "Indian/Mayotte": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0300\r\nTZOFFSETTO:+0300\r\nTZNAME:EAT\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Indian/Reunion": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0400\r\nTZOFFSETTO:+0400\r\nTZNAME:+04\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Mexico/BajaNorte": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "Mexico/BajaSur": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Mexico/General": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Apia": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0135000",
    longitude: "-1714400"
  },
  "Pacific/Auckland": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1300\r\nTZNAME:NZDT\r\nDTSTART:19700927T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1200\r\nTZNAME:NZST\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "-0365200",
    longitude: "+1744600"
  },
  "Pacific/Bougainville": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0061300",
    longitude: "+1553400"
  },
  "Pacific/Chatham": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1245\r\nTZOFFSETTO:+1345\r\nTZNAME:+1345\r\nDTSTART:19700927T024500\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=-1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1345\r\nTZOFFSETTO:+1245\r\nTZNAME:+1245\r\nDTSTART:19700405T034500\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "-0435700",
    longitude: "-1763300"
  },
  "Pacific/Chuuk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Easter": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700404T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SA\r\nEND:STANDARD",
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:-05\r\nDTSTART:19700905T220000\r\nRRULE:FREQ=YEARLY;BYMONTH=9;BYDAY=1SA\r\nEND:DAYLIGHT"
    ],
    latitude: "-0270900",
    longitude: "-1092600"
  },
  "Pacific/Efate": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0174000",
    longitude: "+1682500"
  },
  "Pacific/Enderbury": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Fakaofo": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0092200",
    longitude: "-1711400"
  },
  "Pacific/Fiji": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0180800",
    longitude: "+1782500"
  },
  "Pacific/Funafuti": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Galapagos": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0600\r\nTZNAME:-06\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0005400",
    longitude: "-0893600"
  },
  "Pacific/Gambier": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0900\r\nTZNAME:-09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0230800",
    longitude: "-1345700"
  },
  "Pacific/Guadalcanal": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0093200",
    longitude: "+1601200"
  },
  "Pacific/Guam": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:ChST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0132800",
    longitude: "+1444500"
  },
  "Pacific/Honolulu": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0211825",
    longitude: "-1575130"
  },
  "Pacific/Johnston": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Kanton": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0024700",
    longitude: "-1714300"
  },
  "Pacific/Kiritimati": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1400\r\nTZOFFSETTO:+1400\r\nTZNAME:+14\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0015200",
    longitude: "-1572000"
  },
  "Pacific/Kosrae": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0051900",
    longitude: "+1625900"
  },
  "Pacific/Kwajalein": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0090500",
    longitude: "+1672000"
  },
  "Pacific/Majuro": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Marquesas": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0930\r\nTZOFFSETTO:-0930\r\nTZNAME:-0930\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0090000",
    longitude: "-1393000"
  },
  "Pacific/Midway": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Nauru": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0003100",
    longitude: "+1665500"
  },
  "Pacific/Niue": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:-11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0190100",
    longitude: "-1695500"
  },
  "Pacific/Norfolk": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19701004T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=1SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700405T030000\r\nRRULE:FREQ=YEARLY;BYMONTH=4;BYDAY=1SU\r\nEND:STANDARD"
    ],
    latitude: "-0290300",
    longitude: "+1675800"
  },
  "Pacific/Noumea": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0221600",
    longitude: "+1662700"
  },
  "Pacific/Pago_Pago": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0141600",
    longitude: "-1704200"
  },
  "Pacific/Palau": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+0900\r\nTZOFFSETTO:+0900\r\nTZNAME:+09\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0072000",
    longitude: "+1342900"
  },
  "Pacific/Pitcairn": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0800\r\nTZNAME:-08\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0250400",
    longitude: "-1300500"
  },
  "Pacific/Pohnpei": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Ponape": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1100\r\nTZOFFSETTO:+1100\r\nTZNAME:+11\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Port_Moresby": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0093000",
    longitude: "+1471000"
  },
  "Pacific/Rarotonga": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:-10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0211400",
    longitude: "-1594600"
  },
  "Pacific/Saipan": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:ChST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Samoa": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Tahiti": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:-10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0173200",
    longitude: "-1493400"
  },
  "Pacific/Tarawa": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "+0012500",
    longitude: "+1730000"
  },
  "Pacific/Tongatapu": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1300\r\nTZOFFSETTO:+1300\r\nTZNAME:+13\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ],
    latitude: "-0210800",
    longitude: "-1751200"
  },
  "Pacific/Truk": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Wake": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Wallis": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1200\r\nTZOFFSETTO:+1200\r\nTZNAME:+12\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "Pacific/Yap": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:+1000\r\nTZOFFSETTO:+1000\r\nTZNAME:+10\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "US/Alaska": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-0800\r\nTZNAME:AKDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0900\r\nTZNAME:AKST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/Aleutian": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-0900\r\nTZNAME:HDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0900\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/Arizona": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "US/Central": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/East-Indiana": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/Eastern": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/Hawaii": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1000\r\nTZOFFSETTO:-1000\r\nTZNAME:HST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  },
  "US/Indiana-Starke": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0500\r\nTZNAME:CDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0600\r\nTZNAME:CST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/Michigan": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0500\r\nTZOFFSETTO:-0400\r\nTZNAME:EDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0400\r\nTZOFFSETTO:-0500\r\nTZNAME:EST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/Mountain": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0600\r\nTZNAME:MDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0600\r\nTZOFFSETTO:-0700\r\nTZNAME:MST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/Pacific": {
    ics: [
      "BEGIN:DAYLIGHT\r\nTZOFFSETFROM:-0800\r\nTZOFFSETTO:-0700\r\nTZNAME:PDT\r\nDTSTART:19700308T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=2SU\r\nEND:DAYLIGHT",
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-0700\r\nTZOFFSETTO:-0800\r\nTZNAME:PST\r\nDTSTART:19701101T020000\r\nRRULE:FREQ=YEARLY;BYMONTH=11;BYDAY=1SU\r\nEND:STANDARD"
    ]
  },
  "US/Samoa": {
    ics: [
      "BEGIN:STANDARD\r\nTZOFFSETFROM:-1100\r\nTZOFFSETTO:-1100\r\nTZNAME:SST\r\nDTSTART:19700101T000000\r\nEND:STANDARD"
    ]
  }
};
const tzData = {
  version: version$1,
  aliases,
  zones
};
class TimezoneManager {
  /**
   * Map of aliases
   * Alias name => timezoneId
   */
  _aliases = /* @__PURE__ */ new Map();
  /**
   * Map of Timezones
   * timezoneId => Timezone
   */
  _timezones = /* @__PURE__ */ new Map();
  /**
   * List of aliases that were registered while their targets were missing
   * [[aliasName, timezoneId], ...]
   */
  _pendingAliases = [];
  /**
   * Gets a timezone for the given id.
   *
   * @param timezoneId - The id of the timezone
   */
  getTimezoneForId(timezoneId) {
    let level = 0;
    while (level++ < 20) {
      if (this._timezones.has(timezoneId)) {
        return this._timezones.get(timezoneId);
      }
      if (this._aliases.has(timezoneId)) {
        timezoneId = this._aliases.get(timezoneId);
      } else {
        return null;
      }
    }
    console.error("TimezoneManager.getTimezoneForIdRec() exceeds recursion limits");
    return null;
  }
  /**
   * Checks if there is a timezone for the given id stored in this manager.
   *
   * @param timezoneId - The id of the timezone
   */
  hasTimezoneForId(timezoneId) {
    return this._timezones.has(timezoneId) || this._aliases.has(timezoneId);
  }
  /**
   * Checks if the given timezone id is an alias.
   *
   * @param timezoneId - The id of the timezone
   */
  isAlias(timezoneId) {
    return !this._timezones.has(timezoneId) && this._aliases.has(timezoneId);
  }
  /**
   * Lists all timezones.
   *
   * @param includeAliases - Whether or not to include aliases
   */
  listAllTimezones(includeAliases = false) {
    const timezones = Array.from(this._timezones.keys());
    if (includeAliases) {
      return timezones.concat(Array.from(this._aliases.keys()));
    }
    return timezones;
  }
  /**
   * Registers a timezone
   *
   * @param timezone - The timezone-object to register
   */
  registerTimezone(timezone) {
    this._timezones.set(timezone.timezoneId, timezone);
    ICALmodule.TimezoneService.register(timezone.toICALTimezone(), timezone.timezoneId);
    this._pendingAliases = this._pendingAliases.filter(([aliasName, timezoneId]) => {
      if (timezoneId !== timezone.timezoneId) {
        return true;
      }
      ICALmodule.TimezoneService.register(timezone.toICALTimezone(), aliasName);
      return false;
    });
  }
  registerDefaultTimezones() {
    console.debug(`@nextcloud/calendar-js app is using version ${tzData.version} of the timezone database`);
    for (const tzid in tzData.zones) {
      const ics = [
        "BEGIN:VTIMEZONE",
        "TZID:" + tzid,
        ...tzData.zones[tzid].ics,
        "END:VTIMEZONE"
      ].join("\r\n");
      this.registerTimezoneFromICS(tzid, ics);
    }
    for (const tzid in tzData.aliases) {
      this.registerAlias(tzid, tzData.aliases[tzid].aliasTo);
    }
  }
  /**
   * Registers a timezone based on ics data.
   *
   * @param timezoneId - The id of the timezone
   * @param ics - The iCalendar timezone definition
   */
  registerTimezoneFromICS(timezoneId, ics) {
    const timezone = new Timezone2(timezoneId, ics);
    this.registerTimezone(timezone);
  }
  /**
   * Registers a new timezone-alias
   *
   * @param aliasName - The timezone-id of the alias
   * @param timezoneId - The timezone-id to resolve the alias to
   */
  registerAlias(aliasName, timezoneId) {
    this._aliases.set(aliasName, timezoneId);
    const resolvedTimezone = this.getTimezoneForId(timezoneId);
    if (!resolvedTimezone) {
      this._pendingAliases.push([aliasName, timezoneId]);
      return;
    }
    ICALmodule.TimezoneService.register(resolvedTimezone.toICALTimezone(), aliasName);
  }
  /**
   * Unregisters a timezone.
   *
   * @param timezoneId - Unregisters a timezone by Id
   */
  unregisterTimezones(timezoneId) {
    this._timezones.delete(timezoneId);
    ICALmodule.TimezoneService.remove(timezoneId);
  }
  /**
   * Unregisters a timezone-alias.
   *
   * @param aliasName - The alias to unregister
   */
  unregisterAlias(aliasName) {
    this._aliases.delete(aliasName);
    this._pendingAliases = this._pendingAliases.filter(([pendingAliasName]) => pendingAliasName !== aliasName);
    ICALmodule.TimezoneService.remove(aliasName);
  }
  /**
   * Clear all timezones
   */
  clearAllTimezones() {
    this._aliases = /* @__PURE__ */ new Map();
    this._pendingAliases = [];
    this._timezones = /* @__PURE__ */ new Map();
    ICALmodule.TimezoneService.reset();
    timezoneManager$1.registerTimezone(Timezone2.utc);
    timezoneManager$1.registerTimezone(Timezone2.floating);
    timezoneManager$1.registerAlias("GMT", Timezone2.utc.timezoneId);
    timezoneManager$1.registerAlias("Z", Timezone2.utc.timezoneId);
  }
}
const timezoneManager$1 = new TimezoneManager();
timezoneManager$1.clearAllTimezones();
function getTimezoneManager$1() {
  return timezoneManager$1;
}
register();
const timezoneManager = getTimezoneManager$1();
let initialized = false;
function getTimezoneManager() {
  if (!initialized) {
    timezoneManager.registerDefaultTimezones();
    initialized = true;
  }
  return timezoneManager;
}
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "NcTimezonePicker",
  props: /* @__PURE__ */ mergeModels({
    additionalTimezones: { default: () => [] },
    uid: { default: createElementId() }
  }, {
    "modelValue": { default: "floating" },
    "modelModifiers": {}
  }),
  emits: ["update:modelValue"],
  setup(__props) {
    const props = __props;
    const modelValue = useModel(__props, "modelValue");
    const selectedTimezone = computed({
      set(timezone) {
        modelValue.value = timezone.timezoneId;
      },
      get() {
        for (const additionalTimezone of props.additionalTimezones) {
          if (additionalTimezone.timezoneId === modelValue.value) {
            return {
              cities: [],
              ...additionalTimezone
            };
          }
        }
        return {
          label: getReadableTimezoneName(modelValue.value),
          timezoneId: modelValue.value,
          cities: []
        };
      }
    });
    const options = computed(() => {
      const timezoneManager2 = getTimezoneManager();
      const timezoneList = getSortedTimezoneList(
        timezoneManager2.listAllTimezones(),
        props.additionalTimezones,
        t("Global")
        // TRANSLATORS: This refers to global timezones in the timezone picker
      );
      const timezonesGrouped = [];
      for (const group of Object.values(timezoneList)) {
        timezonesGrouped.push(...group.regions);
      }
      return timezonesGrouped;
    });
    function isSelectable(option) {
      return !option.timezoneId.startsWith("tz-group__");
    }
    function filterBy(option, label, search) {
      const terms = search.trim().split(" ");
      if ("continent" in option) {
        return option.regions.some((region) => {
          return matchTimezoneId(region.timezoneId, terms);
        });
      }
      return matchTimezoneId(option.timezoneId, terms);
    }
    function matchTimezoneId(timezoneId, terms) {
      return terms.every((term) => timezoneId.toLowerCase().includes(term.toLowerCase()));
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(NcSelect), {
        modelValue: selectedTimezone.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => selectedTimezone.value = $event),
        "aria-label-combobox": unref(t)("Search for timezone"),
        clearable: false,
        "filter-by": filterBy,
        multiple: false,
        options: options.value,
        placeholder: unref(t)("Type to search time zone"),
        selectable: isSelectable,
        uid: _ctx.uid,
        label: "label"
      }, null, 8, ["modelValue", "aria-label-combobox", "options", "placeholder", "uid"]);
    };
  }
});
register();
const _hoisted_1$3 = { class: "vue-date-time-picker__wrapper" };
const _hoisted_2$3 = {
  ref: "target-key",
  class: "vue-date-time-picker__wrapper"
};
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "NcDateTimePicker",
  props: /* @__PURE__ */ mergeModels({
    appendToBody: { type: Boolean },
    ariaLabel: { default: t("Datepicker input") },
    ariaLabelMenu: { default: t("Datepicker menu") },
    clearable: { type: Boolean },
    confirm: { type: Boolean },
    format: { type: [String, Function], default: void 0 },
    locale: { default: getCanonicalLocale() },
    minuteStep: { default: 10 },
    modelValue: { default: null },
    placeholder: { default: void 0 },
    showTimezoneSelect: { type: Boolean },
    showWeekNumber: { type: Boolean },
    type: { default: "date" }
  }, {
    "timezoneId": { default: "UTC" },
    "timezoneIdModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:modelValue", "update:timezoneId"], ["update:timezoneId"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const timezoneId = useModel(__props, "timezoneId");
    const target = useTemplateRef("target-key");
    const picker = useTemplateRef("picker-key");
    const emit2 = __emit;
    const value = computed(() => {
      if (props.modelValue === null && props.clearable) {
        return null;
      }
      if (props.type === "week") {
        const date = props.modelValue instanceof Date ? props.modelValue : /* @__PURE__ */ new Date();
        const end = new Date(date);
        end.setUTCDate(date.getUTCDate() + 6);
        return [date, end];
      } else if (props.type === "year") {
        const date = props.modelValue instanceof Date ? props.modelValue : /* @__PURE__ */ new Date();
        return date.getUTCFullYear();
      } else if (props.type === "month") {
        const date = props.modelValue instanceof Date ? props.modelValue : /* @__PURE__ */ new Date();
        return { year: date.getUTCFullYear(), month: date.getUTCMonth() };
      } else if (props.type === "time") {
        const time = props.modelValue instanceof Date ? props.modelValue : /* @__PURE__ */ new Date();
        return {
          hours: time.getHours(),
          minutes: time.getMinutes(),
          seconds: time.getSeconds()
        };
      } else if (props.type === "time-range") {
        const time = [props.modelValue].flat();
        if (time.length !== 2) {
          const start = /* @__PURE__ */ new Date();
          const end = new Date(start);
          end.setHours(end.getHours() + 1);
          time.splice(0, 2, start, end);
        }
        return time.map((date) => ({
          hours: date.getHours(),
          minutes: date.getMinutes(),
          seconds: date.getSeconds()
        }));
      } else if (props.type.endsWith("-range")) {
        if (props.modelValue === void 0) {
          const start = /* @__PURE__ */ new Date();
          const end = new Date(start);
          end.setUTCDate(start.getUTCDate() + 7);
          return [start, end];
        }
        return props.modelValue;
      }
      return props.modelValue ?? /* @__PURE__ */ new Date();
    });
    const placeholderFallback = computed(() => {
      if (props.type === "date") {
        return t("Select date");
      } else if (props.type === "time") {
        return t("Select time");
      } else if (props.type === "datetime") {
        return t("Select date and time");
      } else if (props.type === "week") {
        return t("Select week");
      } else if (props.type === "month") {
        return t("Select month");
      } else if (props.type === "year") {
        return t("Select year");
      } else if (props.type.endsWith("-range")) {
        return t("Select time range");
      }
      return t("Select date and time");
    });
    const realFormat = computed(() => {
      if (props.format) {
        return props.format;
      } else if (props.type === "week") {
        return "RR-II";
      }
      let formatter;
      if (props.type === "date" || props.type === "date-range") {
        formatter = new Intl.DateTimeFormat(getCanonicalLocale(), { dateStyle: "medium" });
      } else if (props.type === "time" || props.type === "time-range") {
        formatter = new Intl.DateTimeFormat(getCanonicalLocale(), { timeStyle: "short" });
      } else if (props.type === "datetime" || props.type === "datetime-range") {
        formatter = new Intl.DateTimeFormat(getCanonicalLocale(), { dateStyle: "medium", timeStyle: "short" });
      } else if (props.type === "month") {
        formatter = new Intl.DateTimeFormat(getCanonicalLocale(), { year: "numeric", month: "2-digit" });
      } else if (props.type === "year") {
        formatter = new Intl.DateTimeFormat(getCanonicalLocale(), { year: "numeric" });
      }
      if (formatter) {
        return (input) => Array.isArray(input) ? formatter.formatRange(input[0], input[1]) : formatter.format(input);
      }
      return void 0;
    });
    const pickerType = computed(() => ({
      timePicker: props.type === "time" || props.type === "time-range",
      yearPicker: props.type === "year",
      monthPicker: props.type === "month",
      weekPicker: props.type === "week",
      range: props.type.endsWith("-range") && {
        // do not use partial ranges (meaning after selecting the start [Date, null] will be emitted)
        // if this is needed someday we can enable it,
        // but its not covered by our component interface (props / events) documentation so just disabled for now.
        partialRange: false
      },
      enableTimePicker: !(props.type === "date" || props.type === "date-range"),
      flow: props.type === "datetime" ? ["calendar", "time"] : void 0
    }));
    function onUpdateModelValue(value2) {
      if (value2 === null) {
        return emit2("update:modelValue", null);
      }
      if (props.type === "time") {
        emit2("update:modelValue", formatLibraryTime(value2));
      } else if (props.type === "time-range") {
        const start = formatLibraryTime(value2[0]);
        const end = formatLibraryTime(value2[1]);
        if (end.getTime() < start.getTime()) {
          end.setDate(end.getDate() + 1);
        }
        emit2("update:modelValue", [start, end]);
      } else if (props.type === "month") {
        const data = value2;
        emit2("update:modelValue", new Date(data.year, data.month, 1));
      } else if (props.type === "year") {
        emit2("update:modelValue", new Date(value2, 0));
      } else if (props.type === "week") {
        emit2("update:modelValue", value2[0]);
      } else {
        emit2("update:modelValue", value2);
      }
    }
    function formatLibraryTime(time) {
      const date = /* @__PURE__ */ new Date();
      date.setHours(time.hours);
      date.setMinutes(time.minutes);
      date.setSeconds(time.seconds);
      return date;
    }
    const dayNames = getDayNamesMin();
    const weekStart = getFirstDay();
    const weekNumName = t("W");
    const ariaLabels = computed(() => ({
      toggleOverlay: t("Toggle overlay"),
      menu: props.ariaLabelMenu,
      input: props.ariaLabel,
      openTimePicker: t("Open time picker"),
      closeTimePicker: t("Close time Picker"),
      incrementValue: (type) => {
        if (type === "hours") {
          return t("Increment hours");
        } else if (type === "minutes") {
          return t("Increment minutes");
        }
        return t("Increment seconds");
      },
      decrementValue: (type) => {
        if (type === "hours") {
          return t("Decrement hours");
        } else if (type === "minutes") {
          return t("Decrement minutes");
        }
        return t("Decrement seconds");
      },
      openTpOverlay: (type) => {
        if (type === "hours") {
          return t("Open hours overlay");
        } else if (type === "minutes") {
          return t("Open minutes overlay");
        }
        return t("Open seconds overlay");
      },
      amPmButton: t("Switch AM/PM mode"),
      openYearsOverlay: t("Open years overlay"),
      openMonthsOverlay: t("Open months overlay"),
      nextMonth: t("Next month"),
      prevMonth: t("Previous month"),
      nextYear: t("Next year"),
      prevYear: t("Previous year"),
      weekDay: (day) => getDayNames()[day],
      clearInput: t("Clear value"),
      calendarIcon: t("Calendar icon"),
      timePicker: t("Time picker"),
      monthPicker: (overlay) => overlay ? t("Month picker overlay") : t("Month picker"),
      yearPicker: (overlay) => overlay ? t("Year picker overlay") : t("Year picker")
    }));
    function selectDate() {
      picker.value.selectDate();
    }
    function cancelSelection() {
      picker.value.closeMenu();
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createVNode(unref(Qn), mergeProps({
          ref: "picker-key",
          "aria-labels": ariaLabels.value,
          "auto-apply": !_ctx.confirm,
          class: ["vue-date-time-picker", { "vue-date-time-picker--clearable": _ctx.clearable }],
          "cancel-text": unref(t)("Cancel"),
          clearable: _ctx.clearable,
          "day-names": unref(dayNames),
          placeholder: _ctx.placeholder ?? placeholderFallback.value,
          format: realFormat.value,
          locale: _ctx.locale,
          "minutes-increment": _ctx.minuteStep,
          "model-value": value.value,
          "now-button-label": unref(t)("Now"),
          "select-text": unref(t)("Pick"),
          "six-weeks": "fair",
          teleport: _ctx.appendToBody ? target.value || void 0 : false,
          "text-input": "",
          "week-num-name": unref(weekNumName),
          "week-numbers": _ctx.showWeekNumber ? { type: "iso" } : void 0,
          "week-start": unref(weekStart)
        }, pickerType.value, { "onUpdate:modelValue": onUpdateModelValue }), createSlots({
          "action-buttons": withCtx(() => [
            createVNode(unref(NcButton), {
              size: "small",
              variant: "tertiary",
              onClick: cancelSelection
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(t)("Cancel")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(NcButton), {
              size: "small",
              variant: "primary",
              onClick: selectDate
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(t)("Pick")), 1)
              ]),
              _: 1
            })
          ]),
          "clear-icon": withCtx(({ clear }) => [
            createVNode(unref(NcButton), {
              "aria-label": unref(t)("Clear value"),
              variant: "tertiary-no-background",
              onClick: clear
            }, {
              icon: withCtx(() => [
                createVNode(NcIconSvgWrapper, {
                  inline: "",
                  path: unref(mdiClose),
                  size: 20
                }, null, 8, ["path"])
              ]),
              _: 2
            }, 1032, ["aria-label", "onClick"])
          ]),
          "input-icon": withCtx(() => [
            createVNode(NcIconSvgWrapper, {
              path: unref(mdiCalendarBlank),
              size: 20
            }, null, 8, ["path"])
          ]),
          "clock-icon": withCtx(() => [
            createVNode(NcIconSvgWrapper, {
              inline: "",
              path: unref(mdiClock),
              size: 20
            }, null, 8, ["path"])
          ]),
          "arrow-left": withCtx(() => [
            createVNode(NcIconSvgWrapper, {
              inline: "",
              path: unref(mdiChevronLeft),
              size: 20
            }, null, 8, ["path"])
          ]),
          "arrow-right": withCtx(() => [
            createVNode(NcIconSvgWrapper, {
              inline: "",
              path: unref(mdiChevronRight),
              size: 20
            }, null, 8, ["path"])
          ]),
          "arrow-down": withCtx(() => [
            createVNode(NcIconSvgWrapper, {
              inline: "",
              path: unref(mdiChevronDown),
              size: 20
            }, null, 8, ["path"])
          ]),
          "arrow-up": withCtx(() => [
            createVNode(NcIconSvgWrapper, {
              inline: "",
              path: unref(mdiChevronUp),
              size: 20
            }, null, 8, ["path"])
          ]),
          _: 2
        }, [
          _ctx.showTimezoneSelect ? {
            name: "action-extra",
            fn: withCtx(() => [
              createVNode(_sfc_main$4, {
                modelValue: timezoneId.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => timezoneId.value = $event),
                class: "vue-date-time-picker__timezone",
                "append-to-body": false,
                "input-label": unref(t)("Timezone")
              }, null, 8, ["modelValue", "input-label"])
            ]),
            key: "0"
          } : void 0
        ]), 1040, ["aria-labels", "auto-apply", "class", "cancel-text", "clearable", "day-names", "placeholder", "format", "locale", "minutes-increment", "model-value", "now-button-label", "select-text", "teleport", "week-num-name", "week-numbers", "week-start"]),
        (openBlock(), createBlock(Teleport, {
          to: "body",
          disabled: !_ctx.appendToBody
        }, [
          createBaseVNode("div", _hoisted_2$3, null, 512)
        ], 8, ["disabled"]))
      ]);
    };
  }
});
const NcDateTimePicker = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-27474da0"]]);
var isWindowAvailable = typeof window !== "undefined";
isWindowAvailable && (function() {
  var lastTime = 0;
  var vendors = ["ms", "moz", "webkit", "o"];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
    window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame)
    window.requestAnimationFrame = function(callback, element) {
      var currTime = (/* @__PURE__ */ new Date()).getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  if (!window.cancelAnimationFrame)
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
})();
var emojiMart$1 = { exports: {} };
var emojiMart = emojiMart$1.exports;
var hasRequiredEmojiMart;
function requireEmojiMart() {
  if (hasRequiredEmojiMart) return emojiMart$1.exports;
  hasRequiredEmojiMart = 1;
  (function(module, exports) {
    !(function(e2, t2) {
      module.exports = t2();
    })("undefined" != typeof self ? self : emojiMart, (function() {
      return (function() {
        var e2 = { 537: function() {
          "undefined" != typeof window && (function() {
            for (var e3 = 0, t3 = ["ms", "moz", "webkit", "o"], i2 = 0; i2 < t3.length && !window.requestAnimationFrame; ++i2) window.requestAnimationFrame = window[t3[i2] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[t3[i2] + "CancelAnimationFrame"] || window[t3[i2] + "CancelRequestAnimationFrame"];
            window.requestAnimationFrame || (window.requestAnimationFrame = function(t4, i3) {
              var n2 = (/* @__PURE__ */ new Date()).getTime(), r = Math.max(0, 16 - (n2 - e3)), o = window.setTimeout((function() {
                t4(n2 + r);
              }), r);
              return e3 = n2 + r, o;
            }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(e4) {
              clearTimeout(e4);
            });
          })();
        } }, t2 = {};
        function i(n2) {
          var r = t2[n2];
          if (void 0 !== r) return r.exports;
          var o = t2[n2] = { exports: {} };
          return e2[n2](o, o.exports, i), o.exports;
        }
        i.d = function(e3, t3) {
          for (var n2 in t3) i.o(t3, n2) && !i.o(e3, n2) && Object.defineProperty(e3, n2, { enumerable: true, get: t3[n2] });
        }, i.o = function(e3, t3) {
          return Object.prototype.hasOwnProperty.call(e3, t3);
        }, i.r = function(e3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        };
        var n = {};
        return (function() {
          i.r(n), i.d(n, { Anchors: function() {
            return k;
          }, Category: function() {
            return X;
          }, Emoji: function() {
            return J;
          }, EmojiData: function() {
            return N;
          }, EmojiIndex: function() {
            return R;
          }, EmojiView: function() {
            return $;
          }, Picker: function() {
            return se;
          }, Preview: function() {
            return G;
          }, Search: function() {
            return Q;
          }, Skins: function() {
            return Z;
          }, frequently: function() {
            return w;
          }, sanitize: function() {
            return D;
          }, store: function() {
            return c;
          }, uncompress: function() {
            return v2;
          } });
          var e3, t3, r = "emoji-mart", o = JSON, s = "undefined" != typeof window && "localStorage" in window;
          function a(e4, i2) {
            if (t3) t3(e4, i2);
            else {
              if (!s) return;
              try {
                window.localStorage["".concat(r, ".").concat(e4)] = o.stringify(i2);
              } catch (e5) {
              }
            }
          }
          var c = { update: function(e4) {
            for (var t4 in e4) a(t4, e4[t4]);
          }, set: a, get: function(t4) {
            if (e3) return e3(t4);
            if (s) {
              try {
                var i2 = window.localStorage["".concat(r, ".").concat(t4)];
              } catch (e4) {
                return;
              }
              return i2 ? JSON.parse(i2) : void 0;
            }
          }, setNamespace: function(e4) {
            r = e4;
          }, setHandlers: function(i2) {
            i2 || (i2 = {}), e3 = i2.getter, t3 = i2.setter;
          } };
          function u(e4) {
            return u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, u(e4);
          }
          function l(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var i2 = 0, n2 = new Array(t4); i2 < t4; i2++) n2[i2] = e4[i2];
            return n2;
          }
          var h2 = { name: "a", unified: "b", non_qualified: "c", has_img_apple: "d", has_img_google: "e", has_img_twitter: "f", has_img_facebook: "h", keywords: "j", sheet: "k", emoticons: "l", text: "m", short_names: "n", added_in: "o" }, m = function(e4) {
            var t4 = [], i2 = function(e5, i3) {
              e5 && (Array.isArray(e5) ? e5 : [e5]).forEach((function(e6) {
                (i3 ? e6.split(/[-|_|\s]+/) : [e6]).forEach((function(e7) {
                  e7 = e7.toLowerCase(), -1 == t4.indexOf(e7) && t4.push(e7);
                }));
              }));
            };
            return i2(e4.short_names, true), i2(e4.name, true), i2(e4.keywords, false), i2(e4.emoticons, false), t4.join(",");
          };
          function d(e4) {
            var t4, i2 = (function(e5, t7) {
              var i3 = "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
              if (!i3) {
                if (Array.isArray(e5) || (i3 = (function(e6, t9) {
                  if (e6) {
                    if ("string" == typeof e6) return l(e6, t9);
                    var i4 = Object.prototype.toString.call(e6).slice(8, -1);
                    return "Object" === i4 && e6.constructor && (i4 = e6.constructor.name), "Map" === i4 || "Set" === i4 ? Array.from(e6) : "Arguments" === i4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i4) ? l(e6, t9) : void 0;
                  }
                })(e5)) || t7) {
                  i3 && (e5 = i3);
                  var n3 = 0, r3 = function() {
                  };
                  return { s: r3, n: function() {
                    return n3 >= e5.length ? { done: true } : { done: false, value: e5[n3++] };
                  }, e: function(e6) {
                    throw e6;
                  }, f: r3 };
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }
              var o2, s2 = true, a2 = false;
              return { s: function() {
                i3 = i3.call(e5);
              }, n: function() {
                var e6 = i3.next();
                return s2 = e6.done, e6;
              }, e: function(e6) {
                a2 = true, o2 = e6;
              }, f: function() {
                try {
                  s2 || null == i3.return || i3.return();
                } finally {
                  if (a2) throw o2;
                }
              } };
            })(Object.getOwnPropertyNames(e4));
            try {
              for (i2.s(); !(t4 = i2.n()).done; ) {
                var n2 = t4.value, r2 = e4[n2];
                e4[n2] = r2 && "object" === u(r2) ? d(r2) : r2;
              }
            } catch (e5) {
              i2.e(e5);
            } finally {
              i2.f();
            }
            return Object.freeze(e4);
          }
          var f, p, v2 = function(e4) {
            if (!e4.compressed) return e4;
            for (var t4 in e4.compressed = false, e4.emojis) {
              var i2 = e4.emojis[t4];
              for (var n2 in h2) i2[n2] = i2[h2[n2]], delete i2[h2[n2]];
              i2.short_names || (i2.short_names = []), i2.short_names.unshift(t4), i2.sheet_x = i2.sheet[0], i2.sheet_y = i2.sheet[1], delete i2.sheet, i2.text || (i2.text = ""), i2.added_in || (i2.added_in = 6), i2.added_in = i2.added_in.toFixed(1), i2.search = m(i2);
            }
            return d(e4);
          }, j = ["+1", "grinning", "kissing_heart", "heart_eyes", "laughing", "stuck_out_tongue_winking_eye", "sweat_smile", "joy", "scream", "disappointed", "unamused", "weary", "sob", "sunglasses", "heart", "hankey"], g = {};
          function y() {
            p = true, f = c.get("frequently");
          }
          var w = { add: function(e4) {
            p || y();
            var t4 = e4.id;
            f || (f = g), f[t4] || (f[t4] = 0), f[t4] += 1, c.set("last", t4), c.set("frequently", f);
          }, get: function(e4) {
            if (p || y(), !f) {
              g = {};
              for (var t4 = [], i2 = Math.min(e4, j.length), n2 = 0; n2 < i2; n2++) g[j[n2]] = parseInt((i2 - n2) / 4, 10) + 1, t4.push(j[n2]);
              return t4;
            }
            var r2 = e4, o2 = [];
            for (var s2 in f) f.hasOwnProperty(s2) && o2.push(s2);
            var a2 = o2.sort((function(e5, t7) {
              return f[e5] - f[t7];
            })).reverse().slice(0, r2), u2 = c.get("last");
            return u2 && -1 == a2.indexOf(u2) && (a2.pop(), a2.push(u2)), a2;
          } }, _ = { activity: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 0C5.373 0 0 5.372 0 12c0 6.627 5.373 12 12 12 6.628 0 12-5.373 12-12 0-6.628-5.372-12-12-12m9.949 11H17.05c.224-2.527 1.232-4.773 1.968-6.113A9.966 9.966 0 0 1 21.949 11M13 11V2.051a9.945 9.945 0 0 1 4.432 1.564c-.858 1.491-2.156 4.22-2.392 7.385H13zm-2 0H8.961c-.238-3.165-1.536-5.894-2.393-7.385A9.95 9.95 0 0 1 11 2.051V11zm0 2v8.949a9.937 9.937 0 0 1-4.432-1.564c.857-1.492 2.155-4.221 2.393-7.385H11zm4.04 0c.236 3.164 1.534 5.893 2.392 7.385A9.92 9.92 0 0 1 13 21.949V13h2.04zM4.982 4.887C5.718 6.227 6.726 8.473 6.951 11h-4.9a9.977 9.977 0 0 1 2.931-6.113M2.051 13h4.9c-.226 2.527-1.233 4.771-1.969 6.113A9.972 9.972 0 0 1 2.051 13m16.967 6.113c-.735-1.342-1.744-3.586-1.968-6.113h4.899a9.961 9.961 0 0 1-2.931 6.113"/></svg>', custom: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><g transform="translate(2.000000, 1.000000)"><rect id="Rectangle" x="8" y="0" width="3" height="21" rx="1.5"></rect><rect id="Rectangle" transform="translate(9.843, 10.549) rotate(60) translate(-9.843, -10.549) " x="8.343" y="0.049" width="3" height="21" rx="1.5"></rect><rect id="Rectangle" transform="translate(9.843, 10.549) rotate(-60) translate(-9.843, -10.549) " x="8.343" y="0.049" width="3" height="21" rx="1.5"></rect></g></svg>', flags: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M0 0l6.084 24H8L1.916 0zM21 5h-4l-1-4H4l3 12h3l1 4h13L21 5zM6.563 3h7.875l2 8H8.563l-2-8zm8.832 10l-2.856 1.904L12.063 13h3.332zM19 13l-1.5-6h1.938l2 8H16l3-2z"/></svg>', foods: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M17 4.978c-1.838 0-2.876.396-3.68.934.513-1.172 1.768-2.934 4.68-2.934a1 1 0 0 0 0-2c-2.921 0-4.629 1.365-5.547 2.512-.064.078-.119.162-.18.244C11.73 1.838 10.798.023 9.207.023 8.579.022 7.85.306 7 .978 5.027 2.54 5.329 3.902 6.492 4.999 3.609 5.222 0 7.352 0 12.969c0 4.582 4.961 11.009 9 11.009 1.975 0 2.371-.486 3-1 .629.514 1.025 1 3 1 4.039 0 9-6.418 9-11 0-5.953-4.055-8-7-8M8.242 2.546c.641-.508.943-.523.965-.523.426.169.975 1.405 1.357 3.055-1.527-.629-2.741-1.352-2.98-1.846.059-.112.241-.356.658-.686M15 21.978c-1.08 0-1.21-.109-1.559-.402l-.176-.146c-.367-.302-.816-.452-1.266-.452s-.898.15-1.266.452l-.176.146c-.347.292-.477.402-1.557.402-2.813 0-7-5.389-7-9.009 0-5.823 4.488-5.991 5-5.991 1.939 0 2.484.471 3.387 1.251l.323.276a1.995 1.995 0 0 0 2.58 0l.323-.276c.902-.78 1.447-1.251 3.387-1.251.512 0 5 .168 5 6 0 3.617-4.187 9-7 9"/></svg>', nature: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M15.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 15.5 8M8.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 8.5 8"/><path d="M18.933 0h-.027c-.97 0-2.138.787-3.018 1.497-1.274-.374-2.612-.51-3.887-.51-1.285 0-2.616.133-3.874.517C7.245.79 6.069 0 5.093 0h-.027C3.352 0 .07 2.67.002 7.026c-.039 2.479.276 4.238 1.04 5.013.254.258.882.677 1.295.882.191 3.177.922 5.238 2.536 6.38.897.637 2.187.949 3.2 1.102C8.04 20.6 8 20.795 8 21c0 1.773 2.35 3 4 3 1.648 0 4-1.227 4-3 0-.201-.038-.393-.072-.586 2.573-.385 5.435-1.877 5.925-7.587.396-.22.887-.568 1.104-.788.763-.774 1.079-2.534 1.04-5.013C23.929 2.67 20.646 0 18.933 0M3.223 9.135c-.237.281-.837 1.155-.884 1.238-.15-.41-.368-1.349-.337-3.291.051-3.281 2.478-4.972 3.091-5.031.256.015.731.27 1.265.646-1.11 1.171-2.275 2.915-2.352 5.125-.133.546-.398.858-.783 1.313M12 22c-.901 0-1.954-.693-2-1 0-.654.475-1.236 1-1.602V20a1 1 0 1 0 2 0v-.602c.524.365 1 .947 1 1.602-.046.307-1.099 1-2 1m3-3.48v.02a4.752 4.752 0 0 0-1.262-1.02c1.092-.516 2.239-1.334 2.239-2.217 0-1.842-1.781-2.195-3.977-2.195-2.196 0-3.978.354-3.978 2.195 0 .883 1.148 1.701 2.238 2.217A4.8 4.8 0 0 0 9 18.539v-.025c-1-.076-2.182-.281-2.973-.842-1.301-.92-1.838-3.045-1.853-6.478l.023-.041c.496-.826 1.49-1.45 1.804-3.102 0-2.047 1.357-3.631 2.362-4.522C9.37 3.178 10.555 3 11.948 3c1.447 0 2.685.192 3.733.57 1 .9 2.316 2.465 2.316 4.48.313 1.651 1.307 2.275 1.803 3.102.035.058.068.117.102.178-.059 5.967-1.949 7.01-4.902 7.19m6.628-8.202c-.037-.065-.074-.13-.113-.195a7.587 7.587 0 0 0-.739-.987c-.385-.455-.648-.768-.782-1.313-.076-2.209-1.241-3.954-2.353-5.124.531-.376 1.004-.63 1.261-.647.636.071 3.044 1.764 3.096 5.031.027 1.81-.347 3.218-.37 3.235"/></svg>', objects: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 0a9 9 0 0 0-5 16.482V21s2.035 3 5 3 5-3 5-3v-4.518A9 9 0 0 0 12 0zm0 2c3.86 0 7 3.141 7 7s-3.14 7-7 7-7-3.141-7-7 3.14-7 7-7zM9 17.477c.94.332 1.946.523 3 .523s2.06-.19 3-.523v.834c-.91.436-1.925.689-3 .689a6.924 6.924 0 0 1-3-.69v-.833zm.236 3.07A8.854 8.854 0 0 0 12 21c.965 0 1.888-.167 2.758-.451C14.155 21.173 13.153 22 12 22c-1.102 0-2.117-.789-2.764-1.453z"/><path d="M14.745 12.449h-.004c-.852-.024-1.188-.858-1.577-1.824-.421-1.061-.703-1.561-1.182-1.566h-.009c-.481 0-.783.497-1.235 1.537-.436.982-.801 1.811-1.636 1.791l-.276-.043c-.565-.171-.853-.691-1.284-1.794-.125-.313-.202-.632-.27-.913-.051-.213-.127-.53-.195-.634C7.067 9.004 7.039 9 6.99 9A1 1 0 0 1 7 7h.01c1.662.017 2.015 1.373 2.198 2.134.486-.981 1.304-2.058 2.797-2.075 1.531.018 2.28 1.153 2.731 2.141l.002-.008C14.944 8.424 15.327 7 16.979 7h.032A1 1 0 1 1 17 9h-.011c-.149.076-.256.474-.319.709a6.484 6.484 0 0 1-.311.951c-.429.973-.79 1.789-1.614 1.789"/></svg>', smileys: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10"/><path d="M8 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 8 7M16 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 16 7M15.232 15c-.693 1.195-1.87 2-3.349 2-1.477 0-2.655-.805-3.347-2H15m3-2H6a6 6 0 1 0 12 0"/></svg>', people: '<svg xmlns:svg="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 24 24"> <path id="path3814" d="m 3.3591089,21.17726 c 0.172036,0.09385 4.265994,2.29837 8.8144451,2.29837 4.927767,0 8.670894,-2.211883 8.82782,-2.306019 0.113079,-0.06785 0.182268,-0.190051 0.182267,-0.321923 0,-3.03119 -0.929494,-5.804936 -2.617196,-7.810712 -1.180603,-1.403134 -2.661918,-2.359516 -4.295699,-2.799791 4.699118,-2.236258 3.102306,-9.28617162 -2.097191,-9.28617162 -5.1994978,0 -6.7963103,7.04991362 -2.097192,9.28617162 -1.6337821,0.440275 -3.1150971,1.396798 -4.2956991,2.799791 -1.687703,2.005776 -2.617196,4.779522 -2.617196,7.810712 1.2e-6,0.137378 0.075039,0.263785 0.195641,0.329572 z M 8.0439319,5.8308783 C 8.0439309,2.151521 12.492107,0.30955811 15.093491,2.9109411 17.694874,5.5123241 15.852911,9.9605006 12.173554,9.9605 9.8938991,9.9579135 8.0465186,8.1105332 8.0439319,5.8308783 Z m -1.688782,7.6894977 c 1.524535,-1.811449 3.5906601,-2.809035 5.8184041,-2.809035 2.227744,0 4.293869,0.997586 5.818404,2.809035 1.533639,1.822571 2.395932,4.339858 2.439152,7.108301 -0.803352,0.434877 -4.141636,2.096112 -8.257556,2.096112 -3.8062921,0 -7.3910861,-1.671043 -8.2573681,-2.104981 0.04505,-2.765017 0.906968,-5.278785 2.438964,-7.099432 z" /> <path id="path3816" d="M 12.173828 0.38867188 C 9.3198513 0.38867187 7.3770988 2.3672285 6.8652344 4.6308594 C 6.4218608 6.5916015 7.1153562 8.7676117 8.9648438 10.126953 C 7.6141249 10.677376 6.3550511 11.480944 5.3496094 12.675781 C 3.5629317 14.799185 2.6015625 17.701475 2.6015625 20.847656 C 2.6015654 21.189861 2.7894276 21.508002 3.0898438 21.671875 C 3.3044068 21.788925 7.4436239 24.039062 12.173828 24.039062 C 17.269918 24.039062 21.083568 21.776786 21.291016 21.652344 C 21.57281 21.483266 21.746097 21.176282 21.746094 20.847656 C 21.746094 17.701475 20.78277 14.799185 18.996094 12.675781 C 17.990455 11.480591 16.733818 10.675362 15.382812 10.125 C 17.231132 8.7655552 17.925675 6.5910701 17.482422 4.6308594 C 16.970557 2.3672285 15.027805 0.38867188 12.173828 0.38867188 z M 12.792969 2.3007812 C 13.466253 2.4161792 14.125113 2.7383941 14.695312 3.3085938 C 15.835712 4.4489931 15.985604 5.9473549 15.46875 7.1953125 C 14.951896 8.4432701 13.786828 9.3984378 12.173828 9.3984375 C 10.197719 9.3961954 8.607711 7.806187 8.6054688 5.8300781 C 8.6054683 4.2170785 9.5606362 3.0520102 10.808594 2.5351562 C 11.432573 2.2767293 12.119685 2.1853833 12.792969 2.3007812 z M 12.173828 11.273438 C 14.233647 11.273438 16.133674 12.185084 17.5625 13.882812 C 18.93069 15.508765 19.698347 17.776969 19.808594 20.283203 C 18.807395 20.800235 15.886157 22.162109 12.173828 22.162109 C 8.7614632 22.162109 5.6245754 20.787069 4.5390625 20.265625 C 4.6525896 17.766717 5.4203315 15.504791 6.7851562 13.882812 C 8.2139827 12.185084 10.11401 11.273438 12.173828 11.273438 z " /> </svg>', places: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M6.5 12C5.122 12 4 13.121 4 14.5S5.122 17 6.5 17 9 15.879 9 14.5 7.878 12 6.5 12m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5M17.5 12c-1.378 0-2.5 1.121-2.5 2.5s1.122 2.5 2.5 2.5 2.5-1.121 2.5-2.5-1.122-2.5-2.5-2.5m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5"/><path d="M22.482 9.494l-1.039-.346L21.4 9h.6c.552 0 1-.439 1-.992 0-.006-.003-.008-.003-.008H23c0-1-.889-2-1.984-2h-.642l-.731-1.717C19.262 3.012 18.091 2 16.764 2H7.236C5.909 2 4.738 3.012 4.357 4.283L3.626 6h-.642C1.889 6 1 7 1 8h.003S1 8.002 1 8.008C1 8.561 1.448 9 2 9h.6l-.043.148-1.039.346a2.001 2.001 0 0 0-1.359 2.097l.751 7.508a1 1 0 0 0 .994.901H3v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h6v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h1.096a.999.999 0 0 0 .994-.901l.751-7.508a2.001 2.001 0 0 0-1.359-2.097M6.273 4.857C6.402 4.43 6.788 4 7.236 4h9.527c.448 0 .834.43.963.857L19.313 9H4.688l1.585-4.143zM7 21H5v-1h2v1zm12 0h-2v-1h2v1zm2.189-3H2.811l-.662-6.607L3 11h18l.852.393L21.189 18z"/></svg>', recent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M13 4h-2l-.001 7H9v2h2v2h2v-2h4v-2h-4z"/><path d="M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10"/></svg>', symbols: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M0 0h11v2H0zM4 11h3V6h4V4H0v2h4zM15.5 17c1.381 0 2.5-1.116 2.5-2.493s-1.119-2.493-2.5-2.493S13 13.13 13 14.507 14.119 17 15.5 17m0-2.986c.276 0 .5.222.5.493 0 .272-.224.493-.5.493s-.5-.221-.5-.493.224-.493.5-.493M21.5 19.014c-1.381 0-2.5 1.116-2.5 2.493S20.119 24 21.5 24s2.5-1.116 2.5-2.493-1.119-2.493-2.5-2.493m0 2.986a.497.497 0 0 1-.5-.493c0-.271.224-.493.5-.493s.5.222.5.493a.497.497 0 0 1-.5.493M22 13l-9 9 1.513 1.5 8.99-9.009zM17 11c2.209 0 4-1.119 4-2.5V2s.985-.161 1.498.949C23.01 4.055 23 6 23 6s1-1.119 1-3.135C24-.02 21 0 21 0h-2v6.347A5.853 5.853 0 0 0 17 6c-2.209 0-4 1.119-4 2.5s1.791 2.5 4 2.5M10.297 20.482l-1.475-1.585a47.54 47.54 0 0 1-1.442 1.129c-.307-.288-.989-1.016-2.045-2.183.902-.836 1.479-1.466 1.729-1.892s.376-.871.376-1.336c0-.592-.273-1.178-.818-1.759-.546-.581-1.329-.871-2.349-.871-1.008 0-1.79.293-2.344.879-.556.587-.832 1.181-.832 1.784 0 .813.419 1.748 1.256 2.805-.847.614-1.444 1.208-1.794 1.784a3.465 3.465 0 0 0-.523 1.833c0 .857.308 1.56.924 2.107.616.549 1.423.823 2.42.823 1.173 0 2.444-.379 3.813-1.137L8.235 24h2.819l-2.09-2.383 1.333-1.135zm-6.736-6.389a1.02 1.02 0 0 1 .73-.286c.31 0 .559.085.747.254a.849.849 0 0 1 .283.659c0 .518-.419 1.112-1.257 1.784-.536-.651-.805-1.231-.805-1.742a.901.901 0 0 1 .302-.669M3.74 22c-.427 0-.778-.116-1.057-.349-.279-.232-.418-.487-.418-.766 0-.594.509-1.288 1.527-2.083.968 1.134 1.717 1.946 2.248 2.438-.921.507-1.686.76-2.3.76"/></svg>' };
          function b(e4, t4, i2, n2, r2, o2, s2, a2) {
            var c2, u2 = "function" == typeof e4 ? e4.options : e4;
            if (t4 && (u2.render = t4, u2.staticRenderFns = i2, u2._compiled = true), c2) ;
            return { exports: e4, options: u2 };
          }
          var C = b({ props: { i18n: { type: Object, required: true }, color: { type: String }, categories: { type: Array, required: true }, activeCategory: { type: Object, default: function() {
            return {};
          } } }, emits: ["click"], created: function() {
            this.svgs = _;
          } }, (function() {
            var e4 = this, t4 = e4._self._c;
            return t4("div", { staticClass: "emoji-mart-anchors", attrs: { role: "tablist" } }, e4._l(e4.categories, (function(i2) {
              return t4("button", { key: i2.id, class: { "emoji-mart-anchor": true, "emoji-mart-anchor-selected": i2.id == e4.activeCategory.id }, style: { color: i2.id == e4.activeCategory.id ? e4.color : "" }, attrs: { role: "tab", type: "button", "aria-label": i2.name, "aria-selected": i2.id == e4.activeCategory.id, "data-title": e4.i18n.categories[i2.id] }, on: { click: function(t7) {
                return e4.$emit("click", i2);
              } } }, [t4("div", { attrs: { "aria-hidden": "true" }, domProps: { innerHTML: e4._s(e4.svgs[i2.id]) } }), e4._v(" "), t4("span", { staticClass: "emoji-mart-anchor-bar", style: { backgroundColor: e4.color }, attrs: { "aria-hidden": "true" } })]);
            })), 0);
          }), []), k = C.exports;
          function E(e4, t4) {
            if (!(e4 instanceof t4)) throw new TypeError("Cannot call a class as a function");
          }
          function S(e4) {
            var t4 = (function(e5, t7) {
              if ("object" != u(e5) || !e5) return e5;
              var i2 = e5[Symbol.toPrimitive];
              if (void 0 !== i2) {
                var n2 = i2.call(e5, "string");
                if ("object" != u(n2)) return n2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(e5);
            })(e4);
            return "symbol" == u(t4) ? t4 : t4 + "";
          }
          function x(e4, t4) {
            for (var i2 = 0; i2 < t4.length; i2++) {
              var n2 = t4[i2];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e4, S(n2.key), n2);
            }
          }
          function O(e4, t4, i2) {
            return t4 && x(e4.prototype, t4), Object.defineProperty(e4, "prototype", { writable: false }), e4;
          }
          var P = String.fromCodePoint || function() {
            var e4, t4, i2 = [], n2 = -1, r2 = arguments.length;
            if (!r2) return "";
            for (var o2 = ""; ++n2 < r2; ) {
              var s2 = Number(arguments[n2]);
              if (!isFinite(s2) || s2 < 0 || s2 > 1114111 || Math.floor(s2) != s2) throw RangeError("Invalid code point: " + s2);
              s2 <= 65535 ? i2.push(s2) : (e4 = 55296 + ((s2 -= 65536) >> 10), t4 = s2 % 1024 + 56320, i2.push(e4, t4)), (n2 + 1 === r2 || i2.length > 16384) && (o2 += String.fromCharCode.apply(null, i2), i2.length = 0);
            }
            return o2;
          };
          function A(e4) {
            var t4 = e4.split("-").map((function(e5) {
              return "0x".concat(e5);
            }));
            return P.apply(null, t4);
          }
          function M(e4) {
            return e4.reduce((function(e5, t4) {
              return -1 === e5.indexOf(t4) && e5.push(t4), e5;
            }), []);
          }
          function I(e4, t4) {
            var i2 = M(e4), n2 = M(t4);
            return i2.filter((function(e5) {
              return n2.indexOf(e5) >= 0;
            }));
          }
          function F(e4, t4) {
            var i2 = {};
            for (var n2 in e4) {
              var r2 = e4[n2], o2 = r2;
              Object.prototype.hasOwnProperty.call(t4, n2) && (o2 = t4[n2]), "object" === u(o2) && (o2 = F(r2, o2)), i2[n2] = o2;
            }
            return i2;
          }
          function z(e4, t4) {
            var i2 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (!i2) {
              if (Array.isArray(e4) || (i2 = (function(e5, t7) {
                if (e5) {
                  if ("string" == typeof e5) return L(e5, t7);
                  var i3 = Object.prototype.toString.call(e5).slice(8, -1);
                  return "Object" === i3 && e5.constructor && (i3 = e5.constructor.name), "Map" === i3 || "Set" === i3 ? Array.from(e5) : "Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3) ? L(e5, t7) : void 0;
                }
              })(e4)) || t4) {
                i2 && (e4 = i2);
                var n2 = 0, r2 = function() {
                };
                return { s: r2, n: function() {
                  return n2 >= e4.length ? { done: true } : { done: false, value: e4[n2++] };
                }, e: function(e5) {
                  throw e5;
                }, f: r2 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var o2, s2 = true, a2 = false;
            return { s: function() {
              i2 = i2.call(e4);
            }, n: function() {
              var e5 = i2.next();
              return s2 = e5.done, e5;
            }, e: function(e5) {
              a2 = true, o2 = e5;
            }, f: function() {
              try {
                s2 || null == i2.return || i2.return();
              } finally {
                if (a2) throw o2;
              }
            } };
          }
          function L(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var i2 = 0, n2 = new Array(t4); i2 < t4; i2++) n2[i2] = e4[i2];
            return n2;
          }
          var T = /^(?:\:([^\:]+)\:)(?:\:skin-tone-(\d)\:)?$/, q = ["1F3FA", "1F3FB", "1F3FC", "1F3FD", "1F3FE", "1F3FF"], R = (function() {
            return O((function e4(t4) {
              var i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n2 = i2.emojisToShowFilter, r2 = i2.include, o2 = i2.exclude, s2 = i2.custom, a2 = i2.recent, c2 = i2.recentLength, u2 = void 0 === c2 ? 20 : c2;
              E(this, e4), this._data = v2(t4), this._emojisFilter = n2 || null, this._include = r2 || null, this._exclude = o2 || null, this._custom = s2 || [], this._recent = a2 || w.get(u2), this._emojis = {}, this._nativeEmojis = {}, this._emoticons = {}, this._categories = [], this._recentCategory = { id: "recent", name: "Recent", emojis: [] }, this._customCategory = { id: "custom", name: "Custom", emojis: [] }, this._searchIndex = {}, this.buildIndex(), Object.freeze(this);
            }), [{ key: "buildIndex", value: function() {
              var e4 = this, t4 = this._data.categories;
              if (this._include && (t4 = (t4 = t4.filter((function(t7) {
                return e4._include.includes(t7.id);
              }))).sort((function(t7, i3) {
                var n3 = e4._include.indexOf(t7.id), r3 = e4._include.indexOf(i3.id);
                return n3 < r3 ? -1 : n3 > r3 ? 1 : 0;
              }))), t4.forEach((function(t7) {
                if (e4.isCategoryNeeded(t7.id)) {
                  var i3 = { id: t7.id, name: t7.name, emojis: [] };
                  t7.emojis.forEach((function(t9) {
                    var n3 = e4.addEmoji(t9);
                    n3 && i3.emojis.push(n3);
                  })), i3.emojis.length && e4._categories.push(i3);
                }
              })), this.isCategoryNeeded("custom")) {
                if (this._custom.length > 0) {
                  var i2, n2 = z(this._custom);
                  try {
                    for (n2.s(); !(i2 = n2.n()).done; ) {
                      var r2 = i2.value;
                      this.addCustomEmoji(r2);
                    }
                  } catch (e5) {
                    n2.e(e5);
                  } finally {
                    n2.f();
                  }
                }
                this._customCategory.emojis.length && this._categories.push(this._customCategory);
              }
              this.isCategoryNeeded("recent") && (this._recent.length && this._recent.map((function(t7) {
                var i3, n3 = z(e4._customCategory.emojis);
                try {
                  for (n3.s(); !(i3 = n3.n()).done; ) {
                    var r3 = i3.value;
                    if (r3.id === t7) return void e4._recentCategory.emojis.push(r3);
                  }
                } catch (e5) {
                  n3.e(e5);
                } finally {
                  n3.f();
                }
                e4.hasEmoji(t7) && e4._recentCategory.emojis.push(e4.emoji(t7));
              })), this._recentCategory.emojis.length && this._categories.unshift(this._recentCategory));
            } }, { key: "findEmoji", value: function(e4, t4) {
              var i2 = e4.match(T);
              if (i2 && (e4 = i2[1], i2[2] && (t4 = parseInt(i2[2], 10))), this._data.aliases.hasOwnProperty(e4) && (e4 = this._data.aliases[e4]), this._emojis.hasOwnProperty(e4)) {
                var n2 = this._emojis[e4];
                return t4 ? n2.getSkin(t4) : n2;
              }
              return this._nativeEmojis.hasOwnProperty(e4) ? this._nativeEmojis[e4] : null;
            } }, { key: "categories", value: function() {
              return this._categories;
            } }, { key: "emoji", value: function(e4) {
              this._data.aliases.hasOwnProperty(e4) && (e4 = this._data.aliases[e4]);
              var t4 = this._emojis[e4];
              if (!t4) throw new Error("Can not find emoji by id: " + e4);
              return t4;
            } }, { key: "firstEmoji", value: function() {
              var e4 = this._emojis[Object.keys(this._emojis)[0]];
              if (!e4) throw new Error("Can not get first emoji");
              return e4;
            } }, { key: "hasEmoji", value: function(e4) {
              return this._data.aliases.hasOwnProperty(e4) && (e4 = this._data.aliases[e4]), !!this._emojis[e4];
            } }, { key: "nativeEmoji", value: function(e4) {
              return this._nativeEmojis.hasOwnProperty(e4) ? this._nativeEmojis[e4] : null;
            } }, { key: "search", value: function(e4, t4) {
              var i2 = this;
              if (t4 || (t4 = 75), !e4.length) return null;
              if ("-" == e4 || "-1" == e4) return [this.emoji("-1")];
              var n2, r2 = e4.toLowerCase().split(/[\s|,|\-|_]+/);
              r2.length > 2 && (r2 = [r2[0], r2[1]]), n2 = r2.map((function(e5) {
                for (var t7 = i2._emojis, n3 = i2._searchIndex, r3 = 0, o3 = function() {
                  var i3 = e5[s2];
                  if (r3++, n3[i3] || (n3[i3] = {}), !(n3 = n3[i3]).results) {
                    var o4 = {};
                    for (var a2 in n3.results = [], n3.emojis = {}, t7) {
                      var c2 = t7[a2], u2 = c2._data.search, l2 = e5.substr(0, r3), h3 = u2.indexOf(l2);
                      if (-1 != h3) {
                        var m2 = h3 + 1;
                        l2 == a2 && (m2 = 0), n3.results.push(c2), n3.emojis[a2] = c2, o4[a2] = m2;
                      }
                    }
                    n3.results.sort((function(e6, t9) {
                      return o4[e6.id] - o4[t9.id];
                    }));
                  }
                  t7 = n3.emojis;
                }, s2 = 0; s2 < e5.length; s2++) o3();
                return n3.results;
              })).filter((function(e5) {
                return e5;
              }));
              var o2 = null;
              return (o2 = n2.length > 1 ? I.apply(null, n2) : n2.length ? n2[0] : []) && o2.length > t4 && (o2 = o2.slice(0, t4)), o2;
            } }, { key: "addCustomEmoji", value: function(e4) {
              var t4 = Object.assign({}, e4, { id: e4.short_names[0], custom: true });
              t4.search || (t4.search = m(t4));
              var i2 = new N(t4);
              return this._emojis[i2.id] = i2, this._customCategory.emojis.push(i2), i2;
            } }, { key: "addEmoji", value: function(e4) {
              var t4 = this, i2 = this._data.emojis[e4];
              if (!this.isEmojiNeeded(i2)) return false;
              var n2 = new N(i2);
              if (this._emojis[e4] = n2, n2.native && (this._nativeEmojis[n2.native] = n2), n2._skins) for (var r2 in n2._skins) {
                var o2 = n2._skins[r2];
                o2.native && (this._nativeEmojis[o2.native] = o2);
              }
              return n2.emoticons && n2.emoticons.forEach((function(i3) {
                t4._emoticons[i3] || (t4._emoticons[i3] = e4);
              })), n2;
            } }, { key: "isCategoryNeeded", value: function(e4) {
              var t4 = !this._include || !this._include.length || this._include.indexOf(e4) > -1, i2 = !(!this._exclude || !this._exclude.length) && this._exclude.indexOf(e4) > -1;
              return !(!t4 || i2);
            } }, { key: "isEmojiNeeded", value: function(e4) {
              return !this._emojisFilter || this._emojisFilter(e4);
            } }]);
          })(), N = (function() {
            return O((function e4(t4) {
              if (E(this, e4), this._data = Object.assign({}, t4), this._skins = null, this._data.skin_variations) for (var i2 in this._skins = [], q) {
                var n2 = q[i2], r2 = this._data.skin_variations[n2], o2 = Object.assign({}, t4);
                for (var s2 in r2) o2[s2] = r2[s2];
                delete o2.skin_variations, o2.skin_tone = parseInt(i2) + 1, this._skins.push(new e4(o2));
              }
              for (var a2 in this._sanitized = D(this._data), this._sanitized) this[a2] = this._sanitized[a2];
              this.short_names = this._data.short_names, this.short_name = this._data.short_names[0], Object.freeze(this);
            }), [{ key: "getSkin", value: function(e4) {
              return e4 && "native" != e4 && this._skins ? this._skins[e4 - 1] : this;
            } }, { key: "getPosition", value: function() {
              var e4 = +(100 / 60 * this._data.sheet_x).toFixed(2), t4 = +(100 / 60 * this._data.sheet_y).toFixed(2);
              return "".concat(e4, "% ").concat(t4, "%");
            } }, { key: "ariaLabel", value: function() {
              return [this.native].concat(this.short_names).filter(Boolean).join(", ");
            } }]);
          })(), $ = (function() {
            return O((function e4(t4, i2, n2, r2, o2, s2, a2) {
              E(this, e4), this._emoji = t4, this._native = r2, this._skin = i2, this._set = n2, this._fallback = o2, this.canRender = this._canRender(), this.cssClass = this._cssClass(), this.cssStyle = this._cssStyle(a2), this.content = this._content(), this.title = true === s2 ? t4.short_name : null, this.ariaLabel = t4.ariaLabel(), Object.freeze(this);
            }), [{ key: "getEmoji", value: function() {
              return this._emoji.getSkin(this._skin);
            } }, { key: "_canRender", value: function() {
              return this._isCustom() || this._isNative() || this._hasEmoji() || this._fallback;
            } }, { key: "_cssClass", value: function() {
              return ["emoji-set-" + this._set, "emoji-type-" + this._emojiType()];
            } }, { key: "_cssStyle", value: function(e4) {
              var t4 = {};
              return this._isCustom() ? t4 = { backgroundImage: "url(" + this.getEmoji()._data.imageUrl + ")", backgroundSize: "100%", width: e4 + "px", height: e4 + "px" } : this._hasEmoji() && !this._isNative() && (t4 = { backgroundPosition: this.getEmoji().getPosition() }), e4 && (t4 = this._isNative() ? Object.assign(t4, { fontSize: Math.round(0.95 * e4 * 10) / 10 + "px" }) : Object.assign(t4, { width: e4 + "px", height: e4 + "px" })), t4;
            } }, { key: "_content", value: function() {
              return this._isCustom() ? "" : this._isNative() ? this.getEmoji().native : this._hasEmoji() ? "" : this._fallback ? this._fallback(this.getEmoji()) : null;
            } }, { key: "_isNative", value: function() {
              return this._native;
            } }, { key: "_isCustom", value: function() {
              return this.getEmoji().custom;
            } }, { key: "_hasEmoji", value: function() {
              if (!this.getEmoji()._data) return false;
              var e4 = this.getEmoji()._data["has_img_" + this._set];
              return void 0 === e4 || e4;
            } }, { key: "_emojiType", value: function() {
              return this._isCustom() ? "custom" : this._isNative() ? "native" : this._hasEmoji() ? "image" : "fallback";
            } }]);
          })();
          function D(e4) {
            var t4 = e4.name, i2 = e4.short_names, n2 = e4.skin_tone, r2 = e4.skin_variations, o2 = e4.emoticons, s2 = e4.unified, a2 = e4.custom, c2 = e4.imageUrl, u2 = e4.id || i2[0], l2 = ":".concat(u2, ":");
            return a2 ? { id: u2, name: t4, colons: l2, emoticons: o2, custom: a2, imageUrl: c2 } : (n2 && (l2 += ":skin-tone-".concat(n2, ":")), { id: u2, name: t4, colons: l2, emoticons: o2, unified: s2.toLowerCase(), skin: n2 || (r2 ? 1 : null), native: A(s2) });
          }
          function B(e4, t4, i2) {
            return (t4 = S(t4)) in e4 ? Object.defineProperty(e4, t4, { value: i2, enumerable: true, configurable: true, writable: true }) : e4[t4] = i2, e4;
          }
          var H = { native: { type: Boolean, default: false }, tooltip: { type: Boolean, default: false }, fallback: { type: Function }, skin: { type: Number, default: 1 }, set: { type: String, default: "apple" }, emoji: { type: [String, Object], required: true }, size: { type: Number, default: null }, tag: { type: String, default: "span" } }, U = { perLine: { type: Number, default: 9 }, maxSearchResults: { type: Number, default: 75 }, emojiSize: { type: Number, default: 24 }, title: { type: String, default: "Emoji Mart™" }, emoji: { type: String, default: "department_store" }, color: { type: String, default: "#ae65c5" }, set: { type: String, default: "apple" }, skin: { type: Number, default: null }, defaultSkin: { type: Number, default: 1 }, native: { type: Boolean, default: false }, emojiTooltip: { type: Boolean, default: false }, autoFocus: { type: Boolean, default: false }, i18n: { type: Object, default: function() {
            return {};
          } }, showPreview: { type: Boolean, default: true }, showSearch: { type: Boolean, default: true }, showCategories: { type: Boolean, default: true }, showSkinTones: { type: Boolean, default: true }, infiniteScroll: { type: Boolean, default: true }, pickerStyles: { type: Object, default: function() {
            return {};
          } } };
          function V(e4, t4) {
            var i2 = Object.keys(e4);
            if (Object.getOwnPropertySymbols) {
              var n2 = Object.getOwnPropertySymbols(e4);
              t4 && (n2 = n2.filter((function(t7) {
                return Object.getOwnPropertyDescriptor(e4, t7).enumerable;
              }))), i2.push.apply(i2, n2);
            }
            return i2;
          }
          function W(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var i2 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? V(Object(i2), true).forEach((function(t7) {
                B(e4, t7, i2[t7]);
              })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i2)) : V(Object(i2)).forEach((function(t7) {
                Object.defineProperty(e4, t7, Object.getOwnPropertyDescriptor(i2, t7));
              }));
            }
            return e4;
          }
          var J = b({ props: W(W({}, H), {}, { data: { type: Object, required: true } }), emits: ["click", "mouseenter", "mouseleave"], computed: { view: function() {
            return new $(this.emojiObject, this.skin, this.set, this.native, this.fallback, this.tooltip, this.size);
          }, sanitizedData: function() {
            return this.emojiObject._sanitized;
          }, title: function() {
            return this.tooltip ? this.emojiObject.short_name : null;
          }, emojiObject: function() {
            return "string" == typeof this.emoji ? this.data.findEmoji(this.emoji) : this.emoji;
          } }, created: function() {
          }, methods: { onClick: function() {
            this.$emit("click", this.emojiObject);
          }, onMouseEnter: function() {
            this.$emit("mouseenter", this.emojiObject);
          }, onMouseLeave: function() {
            this.$emit("mouseleave", this.emojiObject);
          } } }, (function() {
            var e4 = this, t4 = e4._self._c;
            return e4.view.canRender ? t4(e4.tag, { tag: "component", staticClass: "emoji-mart-emoji", attrs: { title: e4.view.title, "aria-label": e4.view.ariaLabel, "data-title": e4.title }, on: { mouseenter: e4.onMouseEnter, mouseleave: e4.onMouseLeave, click: e4.onClick } }, [t4("span", { class: e4.view.cssClass, style: e4.view.cssStyle }, [e4._v(e4._s(e4.view.content))])]) : e4._e();
          }), []).exports, X = b({ props: { data: { type: Object, required: true }, i18n: { type: Object, required: true }, id: { type: String, required: true }, name: { type: String, required: true }, emojis: { type: Array }, emojiProps: { type: Object, required: true } }, methods: { activeClass: function(e4) {
            return this.emojiProps.selectedEmoji && this.emojiProps.selectedEmojiCategory && this.emojiProps.selectedEmoji.id == e4.id && this.emojiProps.selectedEmojiCategory.id == this.id ? "emoji-mart-emoji-selected" : "";
          } }, computed: { isVisible: function() {
            return !!this.emojis;
          }, isSearch: function() {
            return "Search" == this.name;
          }, hasResults: function() {
            return this.emojis.length > 0;
          }, emojiObjects: function() {
            var e4 = this;
            return this.emojis.map((function(t4) {
              return { emojiObject: t4, emojiView: new $(t4, e4.emojiProps.skin, e4.emojiProps.set, e4.emojiProps.native, e4.emojiProps.fallback, e4.emojiProps.emojiTooltip, e4.emojiProps.emojiSize) };
            }));
          } }, components: { Emoji: J } }, (function() {
            var e4 = this, t4 = e4._self._c;
            return e4.isVisible && (e4.isSearch || e4.hasResults) ? t4("section", { class: { "emoji-mart-category": true, "emoji-mart-no-results": !e4.hasResults }, attrs: { "aria-label": e4.i18n.categories[e4.id] } }, [t4("div", { staticClass: "emoji-mart-category-label" }, [t4("h3", { staticClass: "emoji-mart-category-label" }, [e4._v(e4._s(e4.i18n.categories[e4.id]))])]), e4._v(" "), e4._l(e4.emojiObjects, (function(i2) {
              var n2 = i2.emojiObject, r2 = i2.emojiView;
              return [r2.canRender ? t4("button", { key: n2.id, staticClass: "emoji-mart-emoji", class: e4.activeClass(n2), attrs: { "aria-label": r2.ariaLabel, role: "option", "aria-selected": "false", "aria-posinset": "1", "aria-setsize": "1812", type: "button", "data-title": n2.short_name, title: r2.title }, on: { mouseenter: function(t7) {
                e4.emojiProps.onEnter(r2.getEmoji());
              }, mouseleave: function(t7) {
                e4.emojiProps.onLeave(r2.getEmoji());
              }, click: function(t7) {
                e4.emojiProps.onClick(r2.getEmoji());
              } } }, [t4("span", { class: r2.cssClass, style: r2.cssStyle }, [e4._v(e4._s(r2.content))])]) : e4._e()];
            })), e4._v(" "), e4.hasResults ? e4._e() : t4("div", [t4("emoji", { attrs: { data: e4.data, emoji: "sleuth_or_spy", native: e4.emojiProps.native, skin: e4.emojiProps.skin, set: e4.emojiProps.set } }), e4._v(" "), t4("div", { staticClass: "emoji-mart-no-results-label" }, [e4._v(e4._s(e4.i18n.notfound))])], 1)], 2) : e4._e();
          }), []).exports, Z = b({ props: { skin: { type: Number, required: true } }, emits: ["change"], data: function() {
            return { opened: false };
          }, methods: { onClick: function(e4) {
            this.opened && e4 != this.skin && this.$emit("change", e4), this.opened = !this.opened;
          } } }, (function() {
            var e4 = this, t4 = e4._self._c;
            return t4("div", { class: { "emoji-mart-skin-swatches": true, "emoji-mart-skin-swatches-opened": e4.opened } }, e4._l(6, (function(i2) {
              return t4("span", { key: i2, class: { "emoji-mart-skin-swatch": true, "emoji-mart-skin-swatch-selected": e4.skin == i2 } }, [t4("span", { class: "emoji-mart-skin emoji-mart-skin-tone-" + i2, on: { click: function(t7) {
                return e4.onClick(i2);
              } } })]);
            })), 0);
          }), []).exports, G = b({ props: { data: { type: Object, required: true }, title: { type: String, required: true }, emoji: { type: [String, Object] }, idleEmoji: { type: [String, Object], required: true }, showSkinTones: { type: Boolean, default: true }, emojiProps: { type: Object, required: true }, skinProps: { type: Object, required: true }, onSkinChange: { type: Function, required: true } }, computed: { emojiData: function() {
            return this.emoji ? this.emoji : {};
          }, emojiShortNames: function() {
            return this.emojiData.short_names;
          }, emojiEmoticons: function() {
            return this.emojiData.emoticons;
          } }, components: { Emoji: J, Skins: Z } }, (function() {
            var e4 = this, t4 = e4._self._c;
            return t4("div", { staticClass: "emoji-mart-preview" }, [e4.emoji ? [t4("div", { staticClass: "emoji-mart-preview-emoji" }, [t4("emoji", { attrs: { data: e4.data, emoji: e4.emoji, native: e4.emojiProps.native, skin: e4.emojiProps.skin, set: e4.emojiProps.set } })], 1), e4._v(" "), t4("div", { staticClass: "emoji-mart-preview-data" }, [t4("div", { staticClass: "emoji-mart-preview-name" }, [e4._v(e4._s(e4.emoji.name))]), e4._v(" "), t4("div", { staticClass: "emoji-mart-preview-shortnames" }, e4._l(e4.emojiShortNames, (function(i2) {
              return t4("span", { key: i2, staticClass: "emoji-mart-preview-shortname" }, [e4._v(":" + e4._s(i2) + ":")]);
            })), 0), e4._v(" "), t4("div", { staticClass: "emoji-mart-preview-emoticons" }, e4._l(e4.emojiEmoticons, (function(i2) {
              return t4("span", { key: i2, staticClass: "emoji-mart-preview-emoticon" }, [e4._v(e4._s(i2))]);
            })), 0)])] : [t4("div", { staticClass: "emoji-mart-preview-emoji" }, [t4("emoji", { attrs: { data: e4.data, emoji: e4.idleEmoji, native: e4.emojiProps.native, skin: e4.emojiProps.skin, set: e4.emojiProps.set } })], 1), e4._v(" "), t4("div", { staticClass: "emoji-mart-preview-data" }, [t4("span", { staticClass: "emoji-mart-title-label" }, [e4._v(e4._s(e4.title))])]), e4._v(" "), e4.showSkinTones ? t4("div", { staticClass: "emoji-mart-preview-skins" }, [t4("skins", { attrs: { skin: e4.skinProps.skin }, on: { change: function(t7) {
              return e4.onSkinChange(t7);
            } } })], 1) : e4._e()]], 2);
          }), []).exports, K2 = b({ props: { data: { type: Object, required: true }, i18n: { type: Object, required: true }, autoFocus: { type: Boolean, default: false }, onSearch: { type: Function, required: true }, onArrowLeft: { type: Function, required: false }, onArrowRight: { type: Function, required: false }, onArrowDown: { type: Function, required: false }, onArrowUp: { type: Function, required: false }, onEnter: { type: Function, required: false } }, emits: ["search", "enter", "arrowUp", "arrowDown", "arrowRight", "arrowLeft"], data: function() {
            return { value: "" };
          }, computed: { emojiIndex: function() {
            return this.data;
          } }, watch: { value: function() {
            this.$emit("search", this.value);
          } }, methods: { clear: function() {
            this.value = "";
          } }, mounted: function() {
            var e4 = this.$el.querySelector("input");
            this.autoFocus && e4.focus();
          } }, (function() {
            var e4 = this, t4 = e4._self._c;
            return t4("div", { staticClass: "emoji-mart-search" }, [t4("input", { directives: [{ name: "model", rawName: "v-model", value: e4.value, expression: "value" }], attrs: { type: "text", placeholder: e4.i18n.search, role: "textbox", "aria-autocomplete": "list", "aria-owns": "emoji-mart-list", "aria-label": "Search for an emoji", "aria-describedby": "emoji-mart-search-description" }, domProps: { value: e4.value }, on: { keydown: [function(t7) {
              return !t7.type.indexOf("key") && e4._k(t7.keyCode, "left", 37, t7.key, ["Left", "ArrowLeft"]) || "button" in t7 && 0 !== t7.button ? null : function(t9) {
                return e4.$emit("arrowLeft", t9);
              }.apply(null, arguments);
            }, function(t7) {
              return !t7.type.indexOf("key") && e4._k(t7.keyCode, "right", 39, t7.key, ["Right", "ArrowRight"]) || "button" in t7 && 2 !== t7.button ? null : function() {
                return e4.$emit("arrowRight");
              }.apply(null, arguments);
            }, function(t7) {
              return !t7.type.indexOf("key") && e4._k(t7.keyCode, "down", 40, t7.key, ["Down", "ArrowDown"]) ? null : function() {
                return e4.$emit("arrowDown");
              }.apply(null, arguments);
            }, function(t7) {
              return !t7.type.indexOf("key") && e4._k(t7.keyCode, "up", 38, t7.key, ["Up", "ArrowUp"]) ? null : function(t9) {
                return e4.$emit("arrowUp", t9);
              }.apply(null, arguments);
            }, function(t7) {
              return !t7.type.indexOf("key") && e4._k(t7.keyCode, "enter", 13, t7.key, "Enter") ? null : function() {
                return e4.$emit("enter");
              }.apply(null, arguments);
            }], input: function(t7) {
              t7.target.composing || (e4.value = t7.target.value);
            } } }), e4._v(" "), t4("span", { staticClass: "hidden", attrs: { id: "emoji-picker-search-description" } }, [e4._v("Use the left, right, up and down arrow keys to navigate the emoji search\n    results.")])]);
          }), []), Q = K2.exports;
          function Y(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var i2 = 0, n2 = new Array(t4); i2 < t4; i2++) n2[i2] = e4[i2];
            return n2;
          }
          i(537);
          var ee = (function() {
            return O((function e4(t4) {
              var i2, n2;
              E(this, e4), this._vm = t4, this._data = t4.data, this._perLine = t4.perLine, this._categories = [], (i2 = this._categories).push.apply(i2, (function(e5) {
                if (Array.isArray(e5)) return Y(e5);
              })(n2 = this._data.categories()) || (function(e5) {
                if ("undefined" != typeof Symbol && null != e5[Symbol.iterator] || null != e5["@@iterator"]) return Array.from(e5);
              })(n2) || (function(e5, t7) {
                if (e5) {
                  if ("string" == typeof e5) return Y(e5, t7);
                  var i3 = Object.prototype.toString.call(e5).slice(8, -1);
                  return "Object" === i3 && e5.constructor && (i3 = e5.constructor.name), "Map" === i3 || "Set" === i3 ? Array.from(e5) : "Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3) ? Y(e5, t7) : void 0;
                }
              })(n2) || (function() {
                throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              })()), this._categories = this._categories.filter((function(e5) {
                return e5.emojis.length > 0;
              })), this._categories[0].first = true, Object.freeze(this._categories), this.activeCategory = this._categories[0], this.searchEmojis = null, this.previewEmoji = null, this.previewEmojiCategoryIdx = 0, this.previewEmojiIdx = -1;
            }), [{ key: "onScroll", value: function() {
              for (var e4 = this._vm.$refs.scroll.scrollTop, t4 = this.filteredCategories[0], i2 = 0, n2 = this.filteredCategories.length; i2 < n2; i2++) {
                var r2 = this.filteredCategories[i2], o2 = this._vm.getCategoryComponent(i2);
                if (o2 && o2.$el.offsetTop - 50 > e4) break;
                t4 = r2;
              }
              this.activeCategory = t4;
            } }, { key: "allCategories", get: function() {
              return this._categories;
            } }, { key: "filteredCategories", get: function() {
              return this.searchEmojis ? [{ id: "search", name: "Search", emojis: this.searchEmojis }] : this._categories.filter((function(e4) {
                return e4.emojis.length > 0;
              }));
            } }, { key: "previewEmojiCategory", get: function() {
              return this.previewEmojiCategoryIdx >= 0 ? this.filteredCategories[this.previewEmojiCategoryIdx] : null;
            } }, { key: "onAnchorClick", value: function(e4) {
              var t4 = this;
              if (!this.searchEmojis) {
                var i2 = this.filteredCategories.indexOf(e4), n2 = this._vm.getCategoryComponent(i2);
                this._vm.infiniteScroll ? (function() {
                  if (n2) {
                    var i3 = n2.$el.offsetTop;
                    e4.first && (i3 = 0), t4._vm.$refs.scroll.scrollTop = i3;
                  }
                })() : this.activeCategory = this.filteredCategories[i2];
              }
            } }, { key: "onSearch", value: function(e4) {
              var t4 = this._data.search(e4, this.maxSearchResults);
              this.searchEmojis = t4, this.previewEmojiCategoryIdx = 0, this.previewEmojiIdx = 0, this.updatePreviewEmoji();
            } }, { key: "onEmojiEnter", value: function(e4) {
              this.previewEmoji = e4, this.previewEmojiIdx = -1, this.previewEmojiCategoryIdx = -1;
            } }, { key: "onEmojiLeave", value: function(e4) {
              this.previewEmoji = null;
            } }, { key: "onArrowLeft", value: function() {
              this.previewEmojiIdx > 0 ? this.previewEmojiIdx -= 1 : (this.previewEmojiCategoryIdx -= 1, this.previewEmojiCategoryIdx < 0 ? this.previewEmojiCategoryIdx = 0 : this.previewEmojiIdx = this.filteredCategories[this.previewEmojiCategoryIdx].emojis.length - 1), this.updatePreviewEmoji();
            } }, { key: "onArrowRight", value: function() {
              this.previewEmojiIdx < this.emojisLength(this.previewEmojiCategoryIdx) - 1 ? this.previewEmojiIdx += 1 : (this.previewEmojiCategoryIdx += 1, this.previewEmojiCategoryIdx >= this.filteredCategories.length ? this.previewEmojiCategoryIdx = this.filteredCategories.length - 1 : this.previewEmojiIdx = 0), this.updatePreviewEmoji();
            } }, { key: "onArrowDown", value: function() {
              if (-1 == this.previewEmojiIdx) return this.onArrowRight();
              var e4 = this.filteredCategories[this.previewEmojiCategoryIdx].emojis.length, t4 = this._perLine;
              this.previewEmojiIdx + t4 > e4 && (t4 = e4 % this._perLine);
              for (var i2 = 0; i2 < t4; i2++) this.onArrowRight();
              this.updatePreviewEmoji();
            } }, { key: "onArrowUp", value: function() {
              var e4 = this._perLine;
              this.previewEmojiIdx - e4 < 0 && (e4 = this.previewEmojiCategoryIdx > 0 ? this.filteredCategories[this.previewEmojiCategoryIdx - 1].emojis.length % this._perLine : 0);
              for (var t4 = 0; t4 < e4; t4++) this.onArrowLeft();
              this.updatePreviewEmoji();
            } }, { key: "updatePreviewEmoji", value: function() {
              var e4 = this;
              this.previewEmoji = this.filteredCategories[this.previewEmojiCategoryIdx].emojis[this.previewEmojiIdx], this._vm.$nextTick((function() {
                var t4 = e4._vm.$refs.scroll, i2 = t4.querySelector(".emoji-mart-emoji-selected"), n2 = t4.offsetTop - t4.offsetHeight;
                i2 && i2.offsetTop + i2.offsetHeight > n2 + t4.scrollTop && (t4.scrollTop += i2.offsetHeight), i2 && i2.offsetTop < t4.scrollTop && (t4.scrollTop -= i2.offsetHeight);
              }));
            } }, { key: "emojisLength", value: function(e4) {
              return -1 == e4 ? 0 : this.filteredCategories[e4].emojis.length;
            } }]);
          })();
          function te(e4, t4) {
            var i2 = Object.keys(e4);
            if (Object.getOwnPropertySymbols) {
              var n2 = Object.getOwnPropertySymbols(e4);
              t4 && (n2 = n2.filter((function(t7) {
                return Object.getOwnPropertyDescriptor(e4, t7).enumerable;
              }))), i2.push.apply(i2, n2);
            }
            return i2;
          }
          function ie(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var i2 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? te(Object(i2), true).forEach((function(t7) {
                B(e4, t7, i2[t7]);
              })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(i2)) : te(Object(i2)).forEach((function(t7) {
                Object.defineProperty(e4, t7, Object.getOwnPropertyDescriptor(i2, t7));
              }));
            }
            return e4;
          }
          var ne = { search: "Search", notfound: "No Emoji Found", categories: { search: "Search Results", recent: "Frequently Used", smileys: "Smileys & Emotion", people: "People & Body", nature: "Animals & Nature", foods: "Food & Drink", activity: "Activity", places: "Travel & Places", objects: "Objects", symbols: "Symbols", flags: "Flags", custom: "Custom" } }, re = { props: ie(ie({}, U), {}, { data: { type: Object, required: true } }), emits: ["select", "skin-change"], data: function() {
            return { activeSkin: this.skin || c.get("skin") || this.defaultSkin, view: new ee(this) };
          }, computed: { customStyles: function() {
            return ie({ width: this.calculateWidth + "px" }, this.pickerStyles);
          }, emojiProps: function() {
            return { native: this.native, skin: this.activeSkin, set: this.set, emojiTooltip: this.emojiTooltip, emojiSize: this.emojiSize, selectedEmoji: this.view.previewEmoji, selectedEmojiCategory: this.view.previewEmojiCategory, onEnter: this.onEmojiEnter.bind(this), onLeave: this.onEmojiLeave.bind(this), onClick: this.onEmojiClick.bind(this) };
          }, skinProps: function() {
            return { skin: this.activeSkin };
          }, calculateWidth: function() {
            return this.perLine * (this.emojiSize + 12) + 12 + 2 + (function() {
              if ("undefined" == typeof document) return 0;
              var e4 = document.createElement("div");
              e4.style.width = "100px", e4.style.height = "100px", e4.style.overflow = "scroll", e4.style.position = "absolute", e4.style.top = "-9999px", document.body.appendChild(e4);
              var t4 = e4.offsetWidth - e4.clientWidth;
              return document.body.removeChild(e4), t4;
            })();
          }, filteredCategories: function() {
            return this.view.filteredCategories;
          }, mergedI18n: function() {
            return Object.freeze(F(ne, this.i18n));
          }, idleEmoji: function() {
            try {
              return this.data.emoji(this.emoji);
            } catch (e4) {
              return console.error("Default preview emoji `" + this.emoji + "` is not available, check the Picker `emoji` property"), console.error(e4), this.data.firstEmoji();
            }
          }, isSearching: function() {
            return null != this.view.searchEmojis;
          } }, watch: { skin: function() {
            this.onSkinChange(this.skin);
          } }, methods: { onScroll: function() {
            this.infiniteScroll && !this.waitingForPaint && (this.waitingForPaint = true, window.requestAnimationFrame(this.onScrollPaint.bind(this)));
          }, onScrollPaint: function() {
            this.waitingForPaint = false, this.view.onScroll();
          }, onAnchorClick: function(e4) {
            this.view.onAnchorClick(e4);
          }, onSearch: function(e4) {
            this.view.onSearch(e4);
          }, onEmojiEnter: function(e4) {
            this.view.onEmojiEnter(e4);
          }, onEmojiLeave: function(e4) {
            this.view.onEmojiLeave(e4);
          }, onArrowLeft: function(e4) {
            var t4 = this.view.previewEmojiIdx;
            this.view.onArrowLeft(), e4 && this.view.previewEmojiIdx !== t4 && e4.preventDefault();
          }, onArrowRight: function() {
            this.view.onArrowRight();
          }, onArrowDown: function() {
            this.view.onArrowDown();
          }, onArrowUp: function(e4) {
            this.view.onArrowUp(), e4.preventDefault();
          }, onEnter: function() {
            this.view.previewEmoji && (this.$emit("select", this.view.previewEmoji), w.add(this.view.previewEmoji));
          }, onEmojiClick: function(e4) {
            this.$emit("select", e4), w.add(e4);
          }, onTextSelect: function(e4) {
            e4.stopPropagation();
          }, onSkinChange: function(e4) {
            this.activeSkin = e4, c.update({ skin: e4 }), this.$emit("skin-change", e4);
          }, getCategoryComponent: function(e4) {
            var t4 = this.$refs["categories_" + e4];
            return t4 && "0" in t4 ? t4[0] : t4;
          } }, components: { Anchors: k, Category: X, Preview: G, Search: Q } }, oe = b(re, (function() {
            var e4 = this, t4 = e4._self._c;
            return t4("section", { staticClass: "emoji-mart emoji-mart-static", style: e4.customStyles }, [e4.showCategories ? t4("div", { staticClass: "emoji-mart-bar emoji-mart-bar-anchors" }, [t4("anchors", { attrs: { data: e4.data, i18n: e4.mergedI18n, color: e4.color, categories: e4.view.allCategories, "active-category": e4.view.activeCategory }, on: { click: e4.onAnchorClick } })], 1) : e4._e(), e4._v(" "), e4._t("searchTemplate", (function() {
              return [e4.showSearch ? t4("search", { ref: "search", attrs: { data: e4.data, i18n: e4.mergedI18n, "auto-focus": e4.autoFocus, "on-search": e4.onSearch }, on: { search: e4.onSearch, arrowLeft: e4.onArrowLeft, arrowRight: e4.onArrowRight, arrowDown: e4.onArrowDown, arrowUp: e4.onArrowUp, enter: e4.onEnter, select: e4.onTextSelect } }) : e4._e()];
            }), { data: e4.data, i18n: e4.i18n, autoFocus: e4.autoFocus, onSearch: e4.onSearch }), e4._v(" "), t4("div", { ref: "scroll", staticClass: "emoji-mart-scroll", attrs: { role: "tabpanel" }, on: { scroll: e4.onScroll } }, [t4("div", { ref: "scrollContent", attrs: { id: "emoji-mart-list", role: "listbox", "aria-expanded": "true" } }, [e4._t("customCategory"), e4._v(" "), e4._l(e4.view.filteredCategories, (function(i2, n2) {
              return t4("category", { directives: [{ name: "show", rawName: "v-show", value: e4.infiniteScroll || i2 == e4.view.activeCategory || e4.isSearching, expression: "infiniteScroll || category == view.activeCategory || isSearching" }], key: i2.id, ref: "categories_" + n2, refInFor: true, attrs: { data: e4.data, i18n: e4.mergedI18n, id: i2.id, name: i2.name, emojis: i2.emojis, "emoji-props": e4.emojiProps } });
            }))], 2)]), e4._v(" "), e4._t("previewTemplate", (function() {
              return [e4.showPreview ? t4("div", { staticClass: "emoji-mart-bar emoji-mart-bar-preview" }, [t4("preview", { attrs: { data: e4.data, title: e4.title, emoji: e4.view.previewEmoji, "idle-emoji": e4.idleEmoji, "show-skin-tones": e4.showSkinTones, "emoji-props": e4.emojiProps, "skin-props": e4.skinProps, "on-skin-change": e4.onSkinChange } })], 1) : e4._e()];
            }), { data: e4.data, title: e4.title, emoji: e4.view.previewEmoji, idleEmoji: e4.idleEmoji, showSkinTones: e4.showSkinTones, emojiProps: e4.emojiProps, skinProps: e4.skinProps, onSkinChange: e4.onSkinChange })], 2);
          }), []), se = oe.exports;
        })(), n;
      })();
    }));
  })(emojiMart$1);
  return emojiMart$1.exports;
}
requireEmojiMart();
distExports.getBuilder("nextcloud-vue").persist(true).build();
register(t5, t15, t35, t40);
({
  search: t("Search emoji"),
  notfound: t("No emoji found"),
  categories: {
    search: t("Search results"),
    recent: t("Frequently used"),
    smileys: t("Smileys & Emotion"),
    people: t("People & Body"),
    nature: t("Animals & Nature"),
    foods: t("Food & Drink"),
    activity: t("Activities"),
    places: t("Travel & Places"),
    objects: t("Objects"),
    symbols: t("Symbols"),
    flags: t("Flags"),
    custom: t("Custom")
  }
});
[
  new Color(255, 222, 52, t("Neutral skin color")),
  new Color(228, 205, 166, t("Light skin tone")),
  new Color(250, 221, 192, t("Medium light skin tone")),
  new Color(174, 129, 87, t("Medium skin tone")),
  new Color(158, 113, 88, t("Medium dark skin tone")),
  new Color(96, 79, 69, t("Dark skin tone"))
];
({
  props: {
    /**
     * The fallback text in the preview section
     */
    previewFallbackName: {
      default: t("Pick an emoji")
    }
  }
});
Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--default-grid-baseline"));
Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--default-clickable-area"));
Number.parseInt(window.getComputedStyle(document.body).getPropertyValue("--clickable-area-small"));
register(t39);
e()?.circles?.teamResourceProviders ?? [];
register(t36);
register(t8);
({
  props: {
    /**
     * Make the header name dynamic
     */
    header: {
      default: t("Related resources")
    },
    description: {
      default: t("Anything shared with the same group of people will show up here")
    }
  }
});
if (!Array.prototype.find) {
  Array.prototype.find = function(predicate) {
    if (this === null) {
      throw new TypeError("Array.prototype.find called on null or undefined");
    }
    if (typeof predicate !== "function") {
      throw new TypeError("predicate must be a function");
    }
    var list = Object(this);
    var length = list.length >>> 0;
    var thisArg = arguments[1];
    var value;
    for (var i = 0; i < length; i++) {
      value = list[i];
      if (predicate.call(thisArg, value, i, list)) {
        return value;
      }
    }
    return void 0;
  };
}
if (window && typeof window.CustomEvent !== "function") {
  let CustomEvent$1 = function(event, params) {
    params = params || {
      bubbles: false,
      cancelable: false,
      detail: void 0
    };
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
    return evt;
  };
  if (typeof window.Event !== "undefined") {
    CustomEvent$1.prototype = window.Event.prototype;
  }
  window.CustomEvent = CustomEvent$1;
}
register(t32, t35);
({
  props: {
    placeholder: {
      default: t("Write a message …")
    }
  }
});
register(t0);
({
  props: {
    // Add NcSelect prop defaults and populate $props
    ...NcSelect.props,
    /**
     * Placeholder text
     *
     * @see https://vue-select.org/api/props.html#placeholder
     */
    placeholder: {
      default: t("Select a tag")
    }
  }
});
register(t45);
const _sfc_main$1 = {
  name: "HelpCircleIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
const _hoisted_1$1 = ["aria-hidden", "aria-label"];
const _hoisted_2$1 = ["fill", "width", "height"];
const _hoisted_3$1 = { d: "M15.07,11.25L14.17,12.17C13.45,12.89 13,13.5 13,15H11V14.5C11,13.39 11.45,12.39 12.17,11.67L13.41,10.41C13.78,10.05 14,9.55 14,9C14,7.89 13.1,7 12,7A2,2 0 0,0 10,9H8A4,4 0 0,1 12,5A4,4 0 0,1 16,9C16,9.88 15.64,10.67 15.07,11.25M13,19H11V17H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12C22,6.47 17.5,2 12,2Z" };
const _hoisted_4$1 = { key: 0 };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", mergeProps(_ctx.$attrs, {
    "aria-hidden": $props.title ? null : "true",
    "aria-label": $props.title,
    class: "material-design-icon help-circle-icon",
    role: "img",
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click", $event))
  }), [
    (openBlock(), createElementBlock("svg", {
      fill: $props.fillColor,
      class: "material-design-icon__svg",
      width: $props.size,
      height: $props.size,
      viewBox: "0 0 24 24"
    }, [
      createBaseVNode("path", _hoisted_3$1, [
        $props.title ? (openBlock(), createElementBlock("title", _hoisted_4$1, toDisplayString($props.title), 1)) : createCommentVNode("", true)
      ])
    ], 8, _hoisted_2$1))
  ], 16, _hoisted_1$1);
}
const HelpCircle = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
register();
const _hoisted_1$2 = { class: "settings-section" };
const _hoisted_2$2 = { class: "settings-section__name" };
const _hoisted_3$2 = ["aria-label", "href", "title"];
const _hoisted_4 = {
  key: 0,
  class: "settings-section__desc"
};
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "NcSettingsSection",
  props: {
    name: {},
    description: { default: "" },
    docUrl: { default: "" }
  },
  setup(__props) {
    const ariaLabel = t("External documentation");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$2, [
        createBaseVNode("h2", _hoisted_2$2, [
          createTextVNode(toDisplayString(_ctx.name) + " ", 1),
          _ctx.docUrl ? (openBlock(), createElementBlock("a", {
            key: 0,
            "aria-label": unref(ariaLabel),
            class: "settings-section__info",
            href: _ctx.docUrl,
            rel: "noreferrer nofollow",
            target: "_blank",
            title: unref(ariaLabel)
          }, [
            createVNode(HelpCircle, { size: 20 })
          ], 8, _hoisted_3$2)) : createCommentVNode("", true)
        ]),
        _ctx.description ? (openBlock(), createElementBlock("p", _hoisted_4, toDisplayString(_ctx.description), 1)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ]);
    };
  }
});
const NcSettingsSection = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-dbbb3fd7"]]);
register(t46);
({
  methods: {
    /**
     * Debounce the group search (reduce API calls)
     */
    onSearch: debounce(function(query) {
      this.loadGroup(query);
    }, 200)
  }
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "InputDiv",
  props: /* @__PURE__ */ mergeModels({
    signalingClass: { type: String, required: false, default: "" },
    placeholder: { type: String, required: false, default: "" },
    type: { type: String, required: false, default: "text" },
    inputmode: { type: String, required: false },
    useNumModifiers: { type: Boolean, required: false, default: false },
    modifierStepValue: { type: Number, required: false, default: 1 },
    numMax: { type: Number, required: false },
    numMin: { type: Number, required: false },
    numWrap: { type: Boolean, required: false, default: false },
    focus: { type: Boolean, required: false, default: false },
    submit: { type: Boolean, required: false, default: false },
    helperText: { type: String, required: false, default: null },
    label: { type: String, required: false, default: null },
    useNumericVariant: { type: Boolean, required: false, default: false },
    disabled: { type: Boolean, required: false, default: false }
  }, {
    "modelValue": { type: [String, Number], ...{ required: true } },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["input", "change", "submit"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    __expose();
    const model = useModel(__props, "modelValue");
    const vInputFocus = {
      mounted: (el) => {
        if (__props.focus) {
          el.focus();
        }
      }
    };
    const emit2 = __emit;
    const numericModelValue = computed(
      () => typeof model.value === "number" ? model.value : parseInt(model.value)
    );
    const computedSignalingClass = computed(() => {
      if (__props.signalingClass === "valid") {
        return "success";
      }
      if (__props.signalingClass === "invalid") {
        return "error";
      }
      return __props.signalingClass;
    });
    const checking = computed(() => !__props.useNumModifiers && computedSignalingClass.value === "checking");
    const error = computed(
      () => !checking.value && !__props.useNumModifiers && computedSignalingClass.value === "error"
    );
    const success = computed(
      () => !checking.value && !__props.useNumModifiers && computedSignalingClass.value === "success" && !__props.submit
    );
    const showSubmit = computed(
      () => !checking.value && !__props.useNumModifiers && __props.submit && computedSignalingClass.value !== "error"
    );
    function assertBoundaries() {
      if (__props.numMin && __props.numMax && __props.numMin >= __props.numMax) {
        Logger.warn("numMin is greater or equal than numMax. Validation will be skipped.");
        return false;
      }
      return true;
    }
    function numCheckBoundaries(value) {
      if (__props.numMax && value > __props.numMax) {
        if (__props.numWrap && __props.numMin && assertBoundaries() && numericModelValue.value === __props.numMax) {
          value = __props.numMin;
        } else {
          value = __props.numMax;
        }
      }
      if (__props.numMin && value < __props.numMin) {
        if (__props.numWrap && __props.numMax && assertBoundaries() && numericModelValue.value === __props.numMin) {
          value = __props.numMax;
        } else {
          value = __props.numMin;
        }
      }
      return value;
    }
    function add2() {
      const nextValue = numCheckBoundaries(numericModelValue.value + __props.modifierStepValue);
      if (model.value !== nextValue) {
        model.value = nextValue;
        emit2("change");
      }
    }
    function subtract() {
      const nextValue = numCheckBoundaries(numericModelValue.value - __props.modifierStepValue);
      if (model.value !== nextValue) {
        model.value = nextValue;
        emit2("change");
      }
    }
    onMounted(() => {
      assertBoundaries();
    });
    const __returned__ = { model, vInputFocus, emit: emit2, numericModelValue, computedSignalingClass, checking, error, success, showSubmit, assertBoundaries, numCheckBoundaries, add: add2, subtract, PlusIcon, MinusIcon, ArrowRightIcon, CheckIcon, AlertIcon, ChevronLeftIcon, ChevronRightIcon, get Spinner() {
      return Spinner;
    }, get NcButton() {
      return NcButton;
    }, get t() {
      return translate;
    } };
    Object.defineProperty(__returned__, "__isScriptSetup", { enumerable: false, value: true });
    return __returned__;
  }
});
const _hoisted_1 = { key: 0 };
const _hoisted_2 = { class: "input-wrapper" };
const _hoisted_3 = ["disabled", "type", "inputmode", "placeholder"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    {
      class: normalizeClass(["input-div", { numeric: $props.useNumModifiers || $props.inputmode === "numeric" }])
    },
    [
      $props.label ? (openBlock(), createElementBlock(
        "label",
        _hoisted_1,
        toDisplayString($props.label),
        1
        /* TEXT */
      )) : createCommentVNode("v-if", true),
      createBaseVNode("div", _hoisted_2, [
        $props.useNumModifiers && !$props.useNumericVariant ? (openBlock(), createBlock($setup["NcButton"], {
          key: 0,
          class: "date-add-button",
          title: $setup.t("agora", "minus"),
          variant: "tertiary-no-background",
          onClick: $setup.subtract
        }, {
          icon: withCtx(() => [
            createVNode($setup["ChevronLeftIcon"])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["title"])) : createCommentVNode("v-if", true),
        withDirectives(createBaseVNode("input", {
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $setup.model = $event),
          disabled: $props.disabled,
          type: $props.type,
          inputmode: $props.inputmode,
          placeholder: $props.placeholder,
          class: normalizeClass([
            {
              "has-modifier": $props.useNumModifiers && $props.useNumericVariant,
              "has-submit": $props.submit
            },
            $setup.computedSignalingClass
          ]),
          onInput: _cache[1] || (_cache[1] = ($event) => $setup.emit("input")),
          onChange: _cache[2] || (_cache[2] = ($event) => $setup.emit("change")),
          onKeyup: _cache[3] || (_cache[3] = withKeys(($event) => $setup.emit("submit"), ["enter"]))
        }, null, 42, _hoisted_3), [
          [vModelDynamic, $setup.model],
          [$setup["vInputFocus"]]
        ]),
        $setup.checking ? (openBlock(), createBlock($setup["Spinner"], {
          key: 1,
          class: "signaling-icon spinner"
        })) : $setup.error ? (openBlock(), createBlock($setup["AlertIcon"], {
          key: 2,
          class: "signaling-icon error"
        })) : $setup.success ? (openBlock(), createBlock($setup["CheckIcon"], {
          key: 3,
          class: "signaling-icon success"
        })) : $setup.showSubmit ? (openBlock(), createBlock($setup["ArrowRightIcon"], {
          key: 4,
          class: "signaling-icon submit",
          onClick: _cache[4] || (_cache[4] = ($event) => $setup.emit("submit"))
        })) : createCommentVNode("v-if", true),
        $props.useNumModifiers && !$props.useNumericVariant ? (openBlock(), createBlock($setup["NcButton"], {
          key: 5,
          title: $setup.t("agora", "plus"),
          variant: "tertiary-no-background",
          onClick: $setup.add
        }, {
          icon: withCtx(() => [
            createVNode($setup["ChevronRightIcon"])
          ]),
          _: 1
          /* STABLE */
        }, 8, ["title"])) : createCommentVNode("v-if", true),
        $props.useNumModifiers && $props.useNumericVariant ? (openBlock(), createBlock($setup["MinusIcon"], {
          key: 6,
          class: "modifier subtract",
          onClick: _cache[5] || (_cache[5] = ($event) => $setup.subtract())
        })) : createCommentVNode("v-if", true),
        $props.useNumModifiers && $props.useNumericVariant ? (openBlock(), createBlock($setup["PlusIcon"], {
          key: 7,
          class: "modifier add",
          onClick: _cache[6] || (_cache[6] = ($event) => $setup.add())
        })) : createCommentVNode("v-if", true)
      ]),
      $props.helperText !== null ? (openBlock(), createElementBlock(
        "div",
        {
          key: 1,
          class: normalizeClass(["helper", $setup.computedSignalingClass])
        },
        toDisplayString($props.helperText),
        3
        /* TEXT, CLASS */
      )) : createCommentVNode("v-if", true)
    ],
    2
    /* CLASS */
  );
}
const InputDiv = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-920e1d5d"], ["__file", "/var/www/nextcloud/apps/agora/src/components/Base/modules/InputDiv.vue"]]);
var browser = {};
var canPromise;
var hasRequiredCanPromise;
function requireCanPromise() {
  if (hasRequiredCanPromise) return canPromise;
  hasRequiredCanPromise = 1;
  canPromise = function() {
    return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
  };
  return canPromise;
}
var qrcode = {};
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  let toSJISFunction;
  const CODEWORDS_COUNT = [
    0,
    // Not used
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
  ];
  utils$1.getSymbolSize = function getSymbolSize(version2) {
    if (!version2) throw new Error('"version" cannot be null or undefined');
    if (version2 < 1 || version2 > 40) throw new Error('"version" should be in range from 1 to 40');
    return version2 * 4 + 17;
  };
  utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
    return CODEWORDS_COUNT[version2];
  };
  utils$1.getBCHDigit = function(data) {
    let digit = 0;
    while (data !== 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  };
  utils$1.setToSJISFunction = function setToSJISFunction(f) {
    if (typeof f !== "function") {
      throw new Error('"toSJISFunc" is not a valid function.');
    }
    toSJISFunction = f;
  };
  utils$1.isKanjiModeEnabled = function() {
    return typeof toSJISFunction !== "undefined";
  };
  utils$1.toSJIS = function toSJIS(kanji) {
    return toSJISFunction(kanji);
  };
  return utils$1;
}
var errorCorrectionLevel = {};
var hasRequiredErrorCorrectionLevel;
function requireErrorCorrectionLevel() {
  if (hasRequiredErrorCorrectionLevel) return errorCorrectionLevel;
  hasRequiredErrorCorrectionLevel = 1;
  (function(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid2(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  })(errorCorrectionLevel);
  return errorCorrectionLevel;
}
var bitBuffer;
var hasRequiredBitBuffer;
function requireBitBuffer() {
  if (hasRequiredBitBuffer) return bitBuffer;
  hasRequiredBitBuffer = 1;
  function BitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  BitBuffer.prototype = {
    get: function(index2) {
      const bufIndex = Math.floor(index2 / 8);
      return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
    },
    put: function(num, length) {
      for (let i = 0; i < length; i++) {
        this.putBit((num >>> length - i - 1 & 1) === 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      const bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  bitBuffer = BitBuffer;
  return bitBuffer;
}
var bitMatrix;
var hasRequiredBitMatrix;
function requireBitMatrix() {
  if (hasRequiredBitMatrix) return bitMatrix;
  hasRequiredBitMatrix = 1;
  function BitMatrix(size) {
    if (!size || size < 1) {
      throw new Error("BitMatrix size must be defined and greater than 0");
    }
    this.size = size;
    this.data = new Uint8Array(size * size);
    this.reservedBit = new Uint8Array(size * size);
  }
  BitMatrix.prototype.set = function(row, col, value, reserved) {
    const index2 = row * this.size + col;
    this.data[index2] = value;
    if (reserved) this.reservedBit[index2] = true;
  };
  BitMatrix.prototype.get = function(row, col) {
    return this.data[row * this.size + col];
  };
  BitMatrix.prototype.xor = function(row, col, value) {
    this.data[row * this.size + col] ^= value;
  };
  BitMatrix.prototype.isReserved = function(row, col) {
    return this.reservedBit[row * this.size + col];
  };
  bitMatrix = BitMatrix;
  return bitMatrix;
}
var alignmentPattern = {};
var hasRequiredAlignmentPattern;
function requireAlignmentPattern() {
  if (hasRequiredAlignmentPattern) return alignmentPattern;
  hasRequiredAlignmentPattern = 1;
  (function(exports) {
    const getSymbolSize = requireUtils$1().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version2) {
      if (version2 === 1) return [];
      const posCount = Math.floor(version2 / 7) + 2;
      const size = getSymbolSize(version2);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version2) {
      const coords = [];
      const pos = exports.getRowColCoords(version2);
      const posLength = pos.length;
      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          if (i === 0 && j === 0 || // top-left
          i === 0 && j === posLength - 1 || // bottom-left
          i === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i], pos[j]]);
        }
      }
      return coords;
    };
  })(alignmentPattern);
  return alignmentPattern;
}
var finderPattern = {};
var hasRequiredFinderPattern;
function requireFinderPattern() {
  if (hasRequiredFinderPattern) return finderPattern;
  hasRequiredFinderPattern = 1;
  const getSymbolSize = requireUtils$1().getSymbolSize;
  const FINDER_PATTERN_SIZE = 7;
  finderPattern.getPositions = function getPositions(version2) {
    const size = getSymbolSize(version2);
    return [
      // top-left
      [0, 0],
      // top-right
      [size - FINDER_PATTERN_SIZE, 0],
      // bottom-left
      [0, size - FINDER_PATTERN_SIZE]
    ];
  };
  return finderPattern;
}
var maskPattern = {};
var hasRequiredMaskPattern;
function requireMaskPattern() {
  if (hasRequiredMaskPattern) return maskPattern;
  hasRequiredMaskPattern = 1;
  (function(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    const PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid2(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module = data.get(row, col);
          if (module === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module;
            sameCountCol = 1;
          }
          module = data.get(col, row);
          if (module === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern2, i, j) {
      switch (maskPattern2) {
        case exports.Patterns.PATTERN000:
          return (i + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern2);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  })(maskPattern);
  return maskPattern;
}
var errorCorrectionCode = {};
var hasRequiredErrorCorrectionCode;
function requireErrorCorrectionCode() {
  if (hasRequiredErrorCorrectionCode) return errorCorrectionCode;
  hasRequiredErrorCorrectionCode = 1;
  const ECLevel = requireErrorCorrectionLevel();
  const EC_BLOCKS_TABLE = [
    // L  M  Q  H
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    1,
    2,
    2,
    4,
    1,
    2,
    4,
    4,
    2,
    4,
    4,
    4,
    2,
    4,
    6,
    5,
    2,
    4,
    6,
    6,
    2,
    5,
    8,
    8,
    4,
    5,
    8,
    8,
    4,
    5,
    8,
    11,
    4,
    8,
    10,
    11,
    4,
    9,
    12,
    16,
    4,
    9,
    16,
    16,
    6,
    10,
    12,
    18,
    6,
    10,
    17,
    16,
    6,
    11,
    16,
    19,
    6,
    13,
    18,
    21,
    7,
    14,
    21,
    25,
    8,
    16,
    20,
    25,
    8,
    17,
    23,
    25,
    9,
    17,
    23,
    34,
    9,
    18,
    25,
    30,
    10,
    20,
    27,
    32,
    12,
    21,
    29,
    35,
    12,
    23,
    34,
    37,
    12,
    25,
    34,
    40,
    13,
    26,
    35,
    42,
    14,
    28,
    38,
    45,
    15,
    29,
    40,
    48,
    16,
    31,
    43,
    51,
    17,
    33,
    45,
    54,
    18,
    35,
    48,
    57,
    19,
    37,
    51,
    60,
    19,
    38,
    53,
    63,
    20,
    40,
    56,
    66,
    21,
    43,
    59,
    70,
    22,
    45,
    62,
    74,
    24,
    47,
    65,
    77,
    25,
    49,
    68,
    81
  ];
  const EC_CODEWORDS_TABLE = [
    // L  M  Q  H
    7,
    10,
    13,
    17,
    10,
    16,
    22,
    28,
    15,
    26,
    36,
    44,
    20,
    36,
    52,
    64,
    26,
    48,
    72,
    88,
    36,
    64,
    96,
    112,
    40,
    72,
    108,
    130,
    48,
    88,
    132,
    156,
    60,
    110,
    160,
    192,
    72,
    130,
    192,
    224,
    80,
    150,
    224,
    264,
    96,
    176,
    260,
    308,
    104,
    198,
    288,
    352,
    120,
    216,
    320,
    384,
    132,
    240,
    360,
    432,
    144,
    280,
    408,
    480,
    168,
    308,
    448,
    532,
    180,
    338,
    504,
    588,
    196,
    364,
    546,
    650,
    224,
    416,
    600,
    700,
    224,
    442,
    644,
    750,
    252,
    476,
    690,
    816,
    270,
    504,
    750,
    900,
    300,
    560,
    810,
    960,
    312,
    588,
    870,
    1050,
    336,
    644,
    952,
    1110,
    360,
    700,
    1020,
    1200,
    390,
    728,
    1050,
    1260,
    420,
    784,
    1140,
    1350,
    450,
    812,
    1200,
    1440,
    480,
    868,
    1290,
    1530,
    510,
    924,
    1350,
    1620,
    540,
    980,
    1440,
    1710,
    570,
    1036,
    1530,
    1800,
    570,
    1064,
    1590,
    1890,
    600,
    1120,
    1680,
    1980,
    630,
    1204,
    1770,
    2100,
    660,
    1260,
    1860,
    2220,
    720,
    1316,
    1950,
    2310,
    750,
    1372,
    2040,
    2430
  ];
  errorCorrectionCode.getBlocksCount = function getBlocksCount(version2, errorCorrectionLevel2) {
    switch (errorCorrectionLevel2) {
      case ECLevel.L:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0];
      case ECLevel.M:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2];
      case ECLevel.H:
        return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version2, errorCorrectionLevel2) {
    switch (errorCorrectionLevel2) {
      case ECLevel.L:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0];
      case ECLevel.M:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2];
      case ECLevel.H:
        return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3];
      default:
        return void 0;
    }
  };
  return errorCorrectionCode;
}
var polynomial = {};
var galoisField = {};
var hasRequiredGaloisField;
function requireGaloisField() {
  if (hasRequiredGaloisField) return galoisField;
  hasRequiredGaloisField = 1;
  const EXP_TABLE = new Uint8Array(512);
  const LOG_TABLE = new Uint8Array(256);
  (function initTables() {
    let x = 1;
    for (let i = 0; i < 255; i++) {
      EXP_TABLE[i] = x;
      LOG_TABLE[x] = i;
      x <<= 1;
      if (x & 256) {
        x ^= 285;
      }
    }
    for (let i = 255; i < 512; i++) {
      EXP_TABLE[i] = EXP_TABLE[i - 255];
    }
  })();
  galoisField.log = function log(n) {
    if (n < 1) throw new Error("log(" + n + ")");
    return LOG_TABLE[n];
  };
  galoisField.exp = function exp(n) {
    return EXP_TABLE[n];
  };
  galoisField.mul = function mul(x, y) {
    if (x === 0 || y === 0) return 0;
    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
  };
  return galoisField;
}
var hasRequiredPolynomial;
function requirePolynomial() {
  if (hasRequiredPolynomial) return polynomial;
  hasRequiredPolynomial = 1;
  (function(exports) {
    const GF = requireGaloisField();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i = 0; i < degree; i++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
      }
      return poly;
    };
  })(polynomial);
  return polynomial;
}
var reedSolomonEncoder;
var hasRequiredReedSolomonEncoder;
function requireReedSolomonEncoder() {
  if (hasRequiredReedSolomonEncoder) return reedSolomonEncoder;
  hasRequiredReedSolomonEncoder = 1;
  const Polynomial = requirePolynomial();
  function ReedSolomonEncoder(degree) {
    this.genPoly = void 0;
    this.degree = degree;
    if (this.degree) this.initialize(this.degree);
  }
  ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
    this.degree = degree;
    this.genPoly = Polynomial.generateECPolynomial(this.degree);
  };
  ReedSolomonEncoder.prototype.encode = function encode(data) {
    if (!this.genPoly) {
      throw new Error("Encoder not initialized");
    }
    const paddedData = new Uint8Array(data.length + this.degree);
    paddedData.set(data);
    const remainder = Polynomial.mod(paddedData, this.genPoly);
    const start = this.degree - remainder.length;
    if (start > 0) {
      const buff = new Uint8Array(this.degree);
      buff.set(remainder, start);
      return buff;
    }
    return remainder;
  };
  reedSolomonEncoder = ReedSolomonEncoder;
  return reedSolomonEncoder;
}
var version = {};
var mode = {};
var versionCheck = {};
var hasRequiredVersionCheck;
function requireVersionCheck() {
  if (hasRequiredVersionCheck) return versionCheck;
  hasRequiredVersionCheck = 1;
  versionCheck.isValid = function isValid2(version2) {
    return !isNaN(version2) && version2 >= 1 && version2 <= 40;
  };
  return versionCheck;
}
var regex = {};
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  const numeric2 = "[0-9]+";
  const alphanumeric2 = "[A-Z $%*+\\-./:]+";
  let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  kanji = kanji.replace(/u/g, "\\u");
  const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
  regex.KANJI = new RegExp(kanji, "g");
  regex.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
  regex.BYTE = new RegExp(byte, "g");
  regex.NUMERIC = new RegExp(numeric2, "g");
  regex.ALPHANUMERIC = new RegExp(alphanumeric2, "g");
  const TEST_KANJI = new RegExp("^" + kanji + "$");
  const TEST_NUMERIC = new RegExp("^" + numeric2 + "$");
  const TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  regex.testKanji = function testKanji(str) {
    return TEST_KANJI.test(str);
  };
  regex.testNumeric = function testNumeric(str) {
    return TEST_NUMERIC.test(str);
  };
  regex.testAlphanumeric = function testAlphanumeric(str) {
    return TEST_ALPHANUMERIC.test(str);
  };
  return regex;
}
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  (function(exports) {
    const VersionCheck = requireVersionCheck();
    const Regex = requireRegex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode2, version2) {
      if (!mode2.ccBits) throw new Error("Invalid mode: " + mode2);
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid version: " + version2);
      }
      if (version2 >= 1 && version2 < 10) return mode2.ccBits[0];
      else if (version2 < 27) return mode2.ccBits[1];
      return mode2.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString(mode2) {
      if (mode2 && mode2.id) return mode2.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid2(mode2) {
      return mode2 && mode2.bit && mode2.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  })(mode);
  return mode;
}
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version;
  hasRequiredVersion = 1;
  (function(exports) {
    const Utils = requireUtils$1();
    const ECCode = requireErrorCorrectionCode();
    const ECLevel = requireErrorCorrectionLevel();
    const Mode = requireMode();
    const VersionCheck = requireVersionCheck();
    const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    const G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode2, version2) {
      return Mode.getCharCountIndicator(mode2, version2) + 4;
    }
    function getTotalBitsFromDataArray(segments2, version2) {
      let totalBits = 0;
      segments2.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version2);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments2, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version2, errorCorrectionLevel2, mode2) {
      if (!VersionCheck.isValid(version2)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode2 === "undefined") mode2 = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version2);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode2 === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode2, version2);
      switch (mode2) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel2) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel2, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version2) {
      if (!VersionCheck.isValid(version2) || version2 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version2 << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version2 << 12 | d;
    };
  })(version);
  return version;
}
var formatInfo = {};
var hasRequiredFormatInfo;
function requireFormatInfo() {
  if (hasRequiredFormatInfo) return formatInfo;
  hasRequiredFormatInfo = 1;
  const Utils = requireUtils$1();
  const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
  const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
  const G15_BCH = Utils.getBCHDigit(G15);
  formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel2, mask) {
    const data = errorCorrectionLevel2.bit << 3 | mask;
    let d = data << 10;
    while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
      d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
    }
    return (data << 10 | d) ^ G15_MASK;
  };
  return formatInfo;
}
var segments = {};
var numericData;
var hasRequiredNumericData;
function requireNumericData() {
  if (hasRequiredNumericData) return numericData;
  hasRequiredNumericData = 1;
  const Mode = requireMode();
  function NumericData(data) {
    this.mode = Mode.NUMERIC;
    this.data = data.toString();
  }
  NumericData.getBitsLength = function getBitsLength(length) {
    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
  };
  NumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  NumericData.prototype.getBitsLength = function getBitsLength() {
    return NumericData.getBitsLength(this.data.length);
  };
  NumericData.prototype.write = function write(bitBuffer2) {
    let i, group, value;
    for (i = 0; i + 3 <= this.data.length; i += 3) {
      group = this.data.substr(i, 3);
      value = parseInt(group, 10);
      bitBuffer2.put(value, 10);
    }
    const remainingNum = this.data.length - i;
    if (remainingNum > 0) {
      group = this.data.substr(i);
      value = parseInt(group, 10);
      bitBuffer2.put(value, remainingNum * 3 + 1);
    }
  };
  numericData = NumericData;
  return numericData;
}
var alphanumericData;
var hasRequiredAlphanumericData;
function requireAlphanumericData() {
  if (hasRequiredAlphanumericData) return alphanumericData;
  hasRequiredAlphanumericData = 1;
  const Mode = requireMode();
  const ALPHA_NUM_CHARS = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":"
  ];
  function AlphanumericData(data) {
    this.mode = Mode.ALPHANUMERIC;
    this.data = data;
  }
  AlphanumericData.getBitsLength = function getBitsLength(length) {
    return 11 * Math.floor(length / 2) + 6 * (length % 2);
  };
  AlphanumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  AlphanumericData.prototype.getBitsLength = function getBitsLength() {
    return AlphanumericData.getBitsLength(this.data.length);
  };
  AlphanumericData.prototype.write = function write(bitBuffer2) {
    let i;
    for (i = 0; i + 2 <= this.data.length; i += 2) {
      let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
      value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
      bitBuffer2.put(value, 11);
    }
    if (this.data.length % 2) {
      bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
    }
  };
  alphanumericData = AlphanumericData;
  return alphanumericData;
}
var byteData;
var hasRequiredByteData;
function requireByteData() {
  if (hasRequiredByteData) return byteData;
  hasRequiredByteData = 1;
  const Mode = requireMode();
  function ByteData(data) {
    this.mode = Mode.BYTE;
    if (typeof data === "string") {
      this.data = new TextEncoder().encode(data);
    } else {
      this.data = new Uint8Array(data);
    }
  }
  ByteData.getBitsLength = function getBitsLength(length) {
    return length * 8;
  };
  ByteData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  ByteData.prototype.getBitsLength = function getBitsLength() {
    return ByteData.getBitsLength(this.data.length);
  };
  ByteData.prototype.write = function(bitBuffer2) {
    for (let i = 0, l = this.data.length; i < l; i++) {
      bitBuffer2.put(this.data[i], 8);
    }
  };
  byteData = ByteData;
  return byteData;
}
var kanjiData;
var hasRequiredKanjiData;
function requireKanjiData() {
  if (hasRequiredKanjiData) return kanjiData;
  hasRequiredKanjiData = 1;
  const Mode = requireMode();
  const Utils = requireUtils$1();
  function KanjiData(data) {
    this.mode = Mode.KANJI;
    this.data = data;
  }
  KanjiData.getBitsLength = function getBitsLength(length) {
    return length * 13;
  };
  KanjiData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  KanjiData.prototype.getBitsLength = function getBitsLength() {
    return KanjiData.getBitsLength(this.data.length);
  };
  KanjiData.prototype.write = function(bitBuffer2) {
    let i;
    for (i = 0; i < this.data.length; i++) {
      let value = Utils.toSJIS(this.data[i]);
      if (value >= 33088 && value <= 40956) {
        value -= 33088;
      } else if (value >= 57408 && value <= 60351) {
        value -= 49472;
      } else {
        throw new Error(
          "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
        );
      }
      value = (value >>> 8 & 255) * 192 + (value & 255);
      bitBuffer2.put(value, 13);
    }
  };
  kanjiData = KanjiData;
  return kanjiData;
}
var dijkstra = { exports: {} };
var hasRequiredDijkstra;
function requireDijkstra() {
  if (hasRequiredDijkstra) return dijkstra.exports;
  hasRequiredDijkstra = 1;
  (function(module) {
    var dijkstra2 = {
      single_source_shortest_paths: function(graph, s, d) {
        var predecessors = {};
        var costs = {};
        costs[s] = 0;
        var open = dijkstra2.PriorityQueue.make();
        open.push(s, 0);
        var closest, u, v2, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u] || {};
          for (v2 in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v2)) {
              cost_of_e = adjacent_nodes[v2];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v2];
              first_visit = typeof costs[v2] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v2] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v2, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v2] = u;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        while (u) {
          nodes.push(u);
          predecessors[u];
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s, d) {
        var predecessors = dijkstra2.single_source_shortest_paths(graph, s, d);
        return dijkstra2.extract_shortest_path_from_predecessor_list(
          predecessors,
          d
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T = dijkstra2.PriorityQueue, t2 = {}, key;
          opts = opts || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t2[key] = T[key];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T.default_sorter;
          return t2;
        },
        default_sorter: function(a, b) {
          return a.cost - b.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    {
      module.exports = dijkstra2;
    }
  })(dijkstra);
  return dijkstra.exports;
}
var hasRequiredSegments;
function requireSegments() {
  if (hasRequiredSegments) return segments;
  hasRequiredSegments = 1;
  (function(exports) {
    const Mode = requireMode();
    const NumericData = requireNumericData();
    const AlphanumericData = requireAlphanumericData();
    const ByteData = requireByteData();
    const KanjiData = requireKanjiData();
    const Regex = requireRegex();
    const Utils = requireUtils$1();
    const dijkstra2 = requireDijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex2, mode2, str) {
      const segments2 = [];
      let result;
      while ((result = regex2.exec(str)) !== null) {
        segments2.push({
          data: result[0],
          index: result.index,
          mode: mode2,
          length: result[0].length
        });
      }
      return segments2;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode2) {
      switch (mode2) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version2) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = "" + i + j;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version2);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode2;
      const bestMode = Mode.getBestModeForData(data);
      mode2 = Mode.from(modesHint, bestMode);
      if (mode2 !== Mode.BYTE && mode2.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode2) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode2 === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode2 = Mode.BYTE;
      }
      switch (mode2) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version2) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version2);
      const path = dijkstra2.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  })(segments);
  return segments;
}
var hasRequiredQrcode;
function requireQrcode() {
  if (hasRequiredQrcode) return qrcode;
  hasRequiredQrcode = 1;
  const Utils = requireUtils$1();
  const ECLevel = requireErrorCorrectionLevel();
  const BitBuffer = requireBitBuffer();
  const BitMatrix = requireBitMatrix();
  const AlignmentPattern = requireAlignmentPattern();
  const FinderPattern = requireFinderPattern();
  const MaskPattern = requireMaskPattern();
  const ECCode = requireErrorCorrectionCode();
  const ReedSolomonEncoder = requireReedSolomonEncoder();
  const Version = requireVersion();
  const FormatInfo = requireFormatInfo();
  const Mode = requireMode();
  const Segments = requireSegments();
  function setupFinderPattern(matrix, version2) {
    const size = matrix.size;
    const pos = FinderPattern.getPositions(version2);
    for (let i = 0; i < pos.length; i++) {
      const row = pos[i][0];
      const col = pos[i][1];
      for (let r = -1; r <= 7; r++) {
        if (row + r <= -1 || size <= row + r) continue;
        for (let c = -1; c <= 7; c++) {
          if (col + c <= -1 || size <= col + c) continue;
          if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  function setupTimingPattern(matrix) {
    const size = matrix.size;
    for (let r = 8; r < size - 8; r++) {
      const value = r % 2 === 0;
      matrix.set(r, 6, value, true);
      matrix.set(6, r, value, true);
    }
  }
  function setupAlignmentPattern(matrix, version2) {
    const pos = AlignmentPattern.getPositions(version2);
    for (let i = 0; i < pos.length; i++) {
      const row = pos[i][0];
      const col = pos[i][1];
      for (let r = -2; r <= 2; r++) {
        for (let c = -2; c <= 2; c++) {
          if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  function setupVersionInfo(matrix, version2) {
    const size = matrix.size;
    const bits = Version.getEncodedBits(version2);
    let row, col, mod;
    for (let i = 0; i < 18; i++) {
      row = Math.floor(i / 3);
      col = i % 3 + size - 8 - 3;
      mod = (bits >> i & 1) === 1;
      matrix.set(row, col, mod, true);
      matrix.set(col, row, mod, true);
    }
  }
  function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
    const size = matrix.size;
    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2);
    let i, mod;
    for (i = 0; i < 15; i++) {
      mod = (bits >> i & 1) === 1;
      if (i < 6) {
        matrix.set(i, 8, mod, true);
      } else if (i < 8) {
        matrix.set(i + 1, 8, mod, true);
      } else {
        matrix.set(size - 15 + i, 8, mod, true);
      }
      if (i < 8) {
        matrix.set(8, size - i - 1, mod, true);
      } else if (i < 9) {
        matrix.set(8, 15 - i - 1 + 1, mod, true);
      } else {
        matrix.set(8, 15 - i - 1, mod, true);
      }
    }
    matrix.set(size - 8, 8, 1, true);
  }
  function setupData(matrix, data) {
    const size = matrix.size;
    let inc = -1;
    let row = size - 1;
    let bitIndex = 7;
    let byteIndex = 0;
    for (let col = size - 1; col > 0; col -= 2) {
      if (col === 6) col--;
      while (true) {
        for (let c = 0; c < 2; c++) {
          if (!matrix.isReserved(row, col - c)) {
            let dark = false;
            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) === 1;
            }
            matrix.set(row, col - c, dark);
            bitIndex--;
            if (bitIndex === -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || size <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  }
  function createData(version2, errorCorrectionLevel2, segments2) {
    const buffer = new BitBuffer();
    segments2.forEach(function(data) {
      buffer.put(data.mode.bit, 4);
      buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version2));
      data.write(buffer);
    });
    const totalCodewords = Utils.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
      buffer.put(0, 4);
    }
    while (buffer.getLengthInBits() % 8 !== 0) {
      buffer.putBit(0);
    }
    const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
    for (let i = 0; i < remainingByte; i++) {
      buffer.put(i % 2 ? 17 : 236, 8);
    }
    return createCodewords(buffer, version2, errorCorrectionLevel2);
  }
  function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
    const totalCodewords = Utils.getSymbolTotalCodewords(version2);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version2, errorCorrectionLevel2);
    const dataTotalCodewords = totalCodewords - ecTotalCodewords;
    const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2);
    const blocksInGroup2 = totalCodewords % ecTotalBlocks;
    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
    const rs = new ReedSolomonEncoder(ecCount);
    let offset = 0;
    const dcData = new Array(ecTotalBlocks);
    const ecData = new Array(ecTotalBlocks);
    let maxDataSize = 0;
    const buffer = new Uint8Array(bitBuffer2.buffer);
    for (let b = 0; b < ecTotalBlocks; b++) {
      const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
      dcData[b] = buffer.slice(offset, offset + dataSize);
      ecData[b] = rs.encode(dcData[b]);
      offset += dataSize;
      maxDataSize = Math.max(maxDataSize, dataSize);
    }
    const data = new Uint8Array(totalCodewords);
    let index2 = 0;
    let i, r;
    for (i = 0; i < maxDataSize; i++) {
      for (r = 0; r < ecTotalBlocks; r++) {
        if (i < dcData[r].length) {
          data[index2++] = dcData[r][i];
        }
      }
    }
    for (i = 0; i < ecCount; i++) {
      for (r = 0; r < ecTotalBlocks; r++) {
        data[index2++] = ecData[r][i];
      }
    }
    return data;
  }
  function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
    let segments2;
    if (Array.isArray(data)) {
      segments2 = Segments.fromArray(data);
    } else if (typeof data === "string") {
      let estimatedVersion = version2;
      if (!estimatedVersion) {
        const rawSegments = Segments.rawSplit(data);
        estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel2);
      }
      segments2 = Segments.fromString(data, estimatedVersion || 40);
    } else {
      throw new Error("Invalid data");
    }
    const bestVersion = Version.getBestVersionForData(segments2, errorCorrectionLevel2);
    if (!bestVersion) {
      throw new Error("The amount of data is too big to be stored in a QR Code");
    }
    if (!version2) {
      version2 = bestVersion;
    } else if (version2 < bestVersion) {
      throw new Error(
        "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
      );
    }
    const dataBits = createData(version2, errorCorrectionLevel2, segments2);
    const moduleCount = Utils.getSymbolSize(version2);
    const modules = new BitMatrix(moduleCount);
    setupFinderPattern(modules, version2);
    setupTimingPattern(modules);
    setupAlignmentPattern(modules, version2);
    setupFormatInfo(modules, errorCorrectionLevel2, 0);
    if (version2 >= 7) {
      setupVersionInfo(modules, version2);
    }
    setupData(modules, dataBits);
    if (isNaN(maskPattern2)) {
      maskPattern2 = MaskPattern.getBestMask(
        modules,
        setupFormatInfo.bind(null, modules, errorCorrectionLevel2)
      );
    }
    MaskPattern.applyMask(maskPattern2, modules);
    setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2);
    return {
      modules,
      version: version2,
      errorCorrectionLevel: errorCorrectionLevel2,
      maskPattern: maskPattern2,
      segments: segments2
    };
  }
  qrcode.create = function create(data, options) {
    if (typeof data === "undefined" || data === "") {
      throw new Error("No input text");
    }
    let errorCorrectionLevel2 = ECLevel.M;
    let version2;
    let mask;
    if (typeof options !== "undefined") {
      errorCorrectionLevel2 = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
      version2 = Version.from(options.version);
      mask = MaskPattern.from(options.maskPattern);
      if (options.toSJISFunc) {
        Utils.setToSJISFunction(options.toSJISFunc);
      }
    }
    return createSymbol(data, version2, errorCorrectionLevel2, mask);
  };
  return qrcode;
}
var canvas = {};
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr2, opts) {
      const size = qr2.modules.size;
      const data = qr2.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  })(utils);
  return utils;
}
var hasRequiredCanvas;
function requireCanvas() {
  if (hasRequiredCanvas) return canvas;
  hasRequiredCanvas = 1;
  (function(exports) {
    const Utils = requireUtils();
    function clearCanvas(ctx, canvas2, size) {
      ctx.clearRect(0, 0, canvas2.width, canvas2.height);
      if (!canvas2.style) canvas2.style = {};
      canvas2.height = size;
      canvas2.width = size;
      canvas2.style.height = size + "px";
      canvas2.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e2) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render2(qrData, canvas2, options) {
      let opts = options;
      let canvasEl = canvas2;
      if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
        opts = canvas2;
        canvas2 = void 0;
      }
      if (!canvas2) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas2 || !canvas2.getContext)) {
        opts = canvas2;
        canvas2 = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas2, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  })(canvas);
  return canvas;
}
var svgTag = {};
var hasRequiredSvgTag;
function requireSvgTag() {
  if (hasRequiredSvgTag) return svgTag;
  hasRequiredSvgTag = 1;
  const Utils = requireUtils();
  function getColorAttrib(color, attrib) {
    const alpha2 = color.a / 255;
    const str = attrib + '="' + color.hex + '"';
    return alpha2 < 1 ? str + " " + attrib + '-opacity="' + alpha2.toFixed(2).slice(1) + '"' : str;
  }
  function svgCmd(cmd, x, y) {
    let str = cmd + x;
    if (typeof y !== "undefined") str += " " + y;
    return str;
  }
  function qrToPath(data, size, margin) {
    let path = "";
    let moveBy = 0;
    let newRow = false;
    let lineLength = 0;
    for (let i = 0; i < data.length; i++) {
      const col = Math.floor(i % size);
      const row = Math.floor(i / size);
      if (!col && !newRow) newRow = true;
      if (data[i]) {
        lineLength++;
        if (!(i > 0 && col > 0 && data[i - 1])) {
          path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
          moveBy = 0;
          newRow = false;
        }
        if (!(col + 1 < size && data[i + 1])) {
          path += svgCmd("h", lineLength);
          lineLength = 0;
        }
      } else {
        moveBy++;
      }
    }
    return path;
  }
  svgTag.render = function render2(qrData, options, cb) {
    const opts = Utils.getOptions(options);
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    const qrcodesize = size + opts.margin * 2;
    const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
    const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
    const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
    const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
    const svgTag2 = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
    if (typeof cb === "function") {
      cb(null, svgTag2);
    }
    return svgTag2;
  };
  return svgTag;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  const canPromise2 = requireCanPromise();
  const QRCode2 = requireQrcode();
  const CanvasRenderer = requireCanvas();
  const SvgRenderer = requireSvgTag();
  function renderCanvas(renderFunc, canvas2, text, opts, cb) {
    const args = [].slice.call(arguments, 1);
    const argsNum = args.length;
    const isLastArgCb = typeof args[argsNum - 1] === "function";
    if (!isLastArgCb && !canPromise2()) {
      throw new Error("Callback required as last argument");
    }
    if (isLastArgCb) {
      if (argsNum < 2) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 2) {
        cb = text;
        text = canvas2;
        canvas2 = opts = void 0;
      } else if (argsNum === 3) {
        if (canvas2.getContext && typeof cb === "undefined") {
          cb = opts;
          opts = void 0;
        } else {
          cb = opts;
          opts = text;
          text = canvas2;
          canvas2 = void 0;
        }
      }
    } else {
      if (argsNum < 1) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 1) {
        text = canvas2;
        canvas2 = opts = void 0;
      } else if (argsNum === 2 && !canvas2.getContext) {
        opts = text;
        text = canvas2;
        canvas2 = void 0;
      }
      return new Promise(function(resolve, reject) {
        try {
          const data = QRCode2.create(text, opts);
          resolve(renderFunc(data, canvas2, opts));
        } catch (e2) {
          reject(e2);
        }
      });
    }
    try {
      const data = QRCode2.create(text, opts);
      cb(null, renderFunc(data, canvas2, opts));
    } catch (e2) {
      cb(e2);
    }
  }
  browser.create = QRCode2.create;
  browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
  browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
  browser.toString = renderCanvas.bind(null, function(data, _, opts) {
    return SvgRenderer.render(data, opts);
  });
  return browser;
}
var browserExports = requireBrowser();
const QRCode = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
const index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: NcSelect
}, Symbol.toStringTag, { value: "Module" }));
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: NcColorPicker
}, Symbol.toStringTag, { value: "Module" }));
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: NcDateTimePicker
}, Symbol.toStringTag, { value: "Module" }));
export {
  CheckIcon as C,
  InputDiv as I,
  NcSettingsSection as N,
  Options as O,
  PlusIcon as P,
  QRCode as Q,
  Spinner as S,
  NcAppNavigationItem as a,
  NcDialog as b,
  NcAppNavigation as c,
  NcAppContent as d,
  NcActionButtonGroup as e,
  NcActionInput as f,
  find as g,
  reset as h,
  NcAppSidebar as i,
  NcAppSettingsDialog as j,
  NcContent as k,
  registerCustomProtocol as r,
  tokenize as t
};
//# sourceMappingURL=index-CZ70RVFy.chunk.mjs.map
